{
  "/build-apps/add-time-picker-guide": [
    {
      "image": "https://developer.newrelic.com/static/7f679da4c4ffce5fa547a04b27ac700d/0086b/add-timepicker.png",
      "url": "https://developer.newrelic.com/build-apps/add-time-picker-guide/embed/",
      "sections": [
        "Add a time picker",
        "Before you begin",
        "Important",
        "Prepare the time picker sample code",
        "Import the PlatformStateContext component",
        "Add the time to the queries",
        "Summary"
      ],
      "published_at": "2021-04-12T01:54:52Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "852014728d86d0fcfc4345d6402f7533d9ca5e2e",
      "popularity": 1,
      "body": "This guide steps you through the process of adding access to our time picker in the sample transaction overview application. The sample application provides an overview of the telemetry data showing your account's transactions by application, average response time, HTTP response codes, and transaction errors. When you enable the time picker, users can specify the time range of data to view. We also have a 12 minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1–4 of the CLI quick start. In step 1, be sure to make a copy of the number preceding your account name. This is your accound ID, and you’ll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the time picker sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 7 If you haven't already done so, clone the example applications from our how-to GitHub repo. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 7 Change to the directory nr1-howto-add-time-picker-nerdlet: bash Copy $ cd nr1-how-to/add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet Step 3 of 7 In your preferred text editor, open index.js. Step 4 of 7 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 7 Change to the add-time-picker directory: bash Copy $ cd /nr1-how-to/add-time-picker Step 6 of 7 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 7 of 7 Once the sample application is successfully served, go to the local version of New Relic One (https://one.newrelic.com/?nerdpacks=local) click Apps, and click Add Time Picker. After launching the Add Time Picker application, you see a dashboard that gives an overview of the transactions in your New Relic account: By default, the application shows your data within the last 60 minutes. If you toggle the time picker, it doesn't update the charts because the transaction overview application isn't connected to the New Relic One platform. It has no access to the data from the time picker. In the following sections, you'll add the time picker to the example application and add the time to the queries. Import the PlatformStateContext component The first step in adding the time picker is to import the PlatformStateContext component. Important If you need more details about the PlatformStateContext example that follows, see the APIs and components page Here's what the PlatformStateContext component does: Wraps all of the code within the return statement of the render method Makes a function call passing in the New Relic platform state Returns all of the code within our current return statement Complete these steps: Step 1 of 5 In a text editor, open /add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet/index.js. Step 2 of 5 Add the PlatformStateContext component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, PlatformStateContext, } from 'nr1'; Copy Step 3 of 5 Just below the current return insert this code for the PlatformStateContext component: <PlatformStateContext.Consumer> {(platformState) => { return ( // ADD THE CURRENT RETURN CODE HERE ) }} </PlatformStateContext.Consumer> Copy Step 4 of 5 Move the current application code so it is under the return of the PlatformState function call. The return statement should now look like this: return ( <PlatformStateContext.Consumer> {(PlatformState) => { return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); Copy Step 5 of 5 Add a console.log statement to make sure you are seeing appropriate data. Insert the following code inside the PlatformState return statement just before the opening tag for the <Grid> component: /* Taking a peek at the PlatformState */ console.log(PlatformState); Copy After you complete these steps, your browser console displays something like this: Add the time to the queries In your console, you should see some data from the New Relic platform state. Now you're ready to add timeRange data to update the charts in the transaction overview application. This step requires you to import the timeRangeToNrql utility method from the New Relic One community library. Important You can get more details on the New Relic One community library from our GitHub repo. This helper method takes your PlatformState.timeRange duration data, formats it from milliseconds, and returns a formatted SINCE statement to add to your NRQL. Step 1 of 4 Import the timeRangeToNrql method by inserting this line of code below the other import sections: Important You don't need to include the AccountDropdown from the community import example. import { timeRangeToNrql } from '@newrelic/nr1-community'; Copy Step 2 of 4 Pass the PlatformState to the timeRangeToNrql helper, and save its output as a since statement for later use: const since = timeRangeToNrql(PlatformState); Copy Step 3 of 4 After creating the since variable, go through the code in the PlatformStateContext return statement and concatenate the since variable in each of the existing chart component queries. Here's a TableChart example: <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} />; Copy Step 4 of 4 After you update all of the chart components, confirm that the final index.js file looks similar to this: Important This completed sample code is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, } from 'nr1'; import { timeRangeToNrql } from '@newrelic/nr1-community'; export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props) { super(props); this.accountId = 1; } render() { const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <PlatformStateContext.Consumer> {(PlatformState) => { /* Taking a peek at the PlatformState */ console.log(PlatformState); const since = timeRangeToNrql(PlatformState); console.log(since); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount + since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); } } Copy Summary When you completed all the steps in this example, you successfully implemented the time picker in your application by importing the PlatformStateContext component and accessing its timePicker data object.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 249.06761,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add a <em>time</em> <em>picker</em>",
        "body": ", you&#x27;ll add the <em>time</em> <em>picker</em> to the example application and add the <em>time</em> to the queries. Import the <em>PlatformStateContext</em> component The first step in adding the <em>time</em> <em>picker</em> is to import the <em>PlatformStateContext</em> component. Important If you need more details about the <em>PlatformStateContext</em> example"
      },
      "id": "6063d5f464441fcf580c8bbd"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/embed/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:16Z",
      "type": "",
      "external_id": "58de68bd963cdd2062e88db55cb90ad124055eb6",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to take use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy PlatformStateContext.Consumer provides access to the platform's URL state. This state contains two important values for you to use in this context: accountId timeRange Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your nerdlet, you can use accountId from the platform URL state. Step 3 of 10 Use platformState.accountId in your NrqlQuery: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Next, notice that your query uses a SINCE clause, which identifies the historical timeframe your query should fetch data from. Step 4 of 10 Utilize platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. Tip While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery is now using the account ID, which it got from platform state. It's also using the platform state's time range, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.70062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>PlatformStateContext</em> to your Nerdlet",
        "body": " component&#x27;s render() <em>method</em>: import React from &#x27;react&#x27;; import { HeadingText, LineChart, NrqlQuery, <em>PlatformStateContext</em>, } from &#x27;nr1&#x27;; const ACCOUNT_ID = 123456 &#x2F;&#x2F; &lt;YOUR NEW RELIC ACCOUNT ID&gt; export default class NewsletterSignups extends React.Component { render() { return &lt;div&gt; &lt;HeadingText className"
      },
      "id": "6073000164441f84ce9d853d"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course"
      ],
      "published_at": "2021-04-11T14:00:18Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to lookup the application user's account ID and the time range they selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your nerdlet. You can also use navigation for other nerdlets and launchers. Step 1 of 10 Change to the add-navigation directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now openApmEntity() knows that entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you've created a button and configured it to call .openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row but the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application: Click App performance: Now you see the stacked entity! Congratulations! You're finished writing all the code you'll write for you New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo application that is running an A/B test. You've created several charts, buttons, and other UI elements. You've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and out of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to deploy and subscribe to your New Relic application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.16847,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to your nerdlet, before starting this one. In the last lesson, you used <em>PlatformStateContext</em> from the New Relic One SDK to lookup the application user&#x27;s account ID and the <em>time</em> range they selected from the <em>app</em>&#x27;s <em>time</em> <em>picker</em>. Now, you&#x27;ll learn about another component that interacts with the New Relic"
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.77246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ": <em>PlatformStateContext</em>: provides read access to the platform URL state variables. Example: <em>time</em>Range in the <em>time</em> <em>picker</em>. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state."
      },
      "id": "60652884196a67886047e800"
    },
    {
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/embed/",
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "f6dba06ee883ff39a13eb7090bf3c91f9395d6e2",
      "popularity": 1,
      "body": "Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application. Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component. Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows. As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells. The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.301636,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add tables to your New Relic One <em>application</em>",
        "body": " Nr1HowtoAdd<em>TimePicker</em> extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application. Change the directory back to nr1-how-to&#x2F;create-a-table. Before you can load the demo application, you need to update its unique id"
      },
      "id": "6063d633196a6796a1c6f441"
    }
  ],
  "/automate-workflows/5-mins-tag-resources": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/embed/",
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps"
      ],
      "published_at": "2021-04-13T01:54:27Z",
      "title": "",
      "updated_at": "2021-04-04T01:53:18Z",
      "type": "",
      "external_id": "ddf0ca28ab311ff372e8955f2ef022de99716131",
      "popularity": 1,
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.23077,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " application. You should copy it or write it down. Step 6 of 10 Add a simple <em>tag</em> to your application. Now that you have the GUID, you can point the <em>New</em> <em>Relic</em> <em>CLI</em> directly at your application. Adding a <em>tag</em> is the simplest way to try out the <em>CLI</em> capabilities (don&#x27;t worry, <em>tags</em> can be deleted by using"
      },
      "id": "60691c0ee7b9d2f79094463b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/embed/",
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-04-02T01:54:45Z",
      "type": "",
      "external_id": "c42a52759fcbe676670d61e60c9aa5e269edcccd",
      "popularity": 1,
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.20187,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": "<em>Tags</em> help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the <em>New</em> <em>Relic</em> <em>CLI</em> is a good candidate for automation. In this 5-minute guide, you use the <em>New</em> <em>Relic</em> <em>CLI</em> to add multiple <em>tags</em> to one"
      },
      "id": "60667965196a67a9c347e810"
    },
    {
      "image": "https://developer.newrelic.com/static/futurestack-registration-86e612c0605fb3c49cfd28f35977135d.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Futurestack: Master Observability",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-04-13T01:37:02Z",
      "title": "New Relic Developers",
      "updated_at": "2021-04-06T01:39:15Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Data Nerds, get ready to hack the future. Level Up your observability game at Futurestack 2021. Rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 28 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.20461,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/32r7lf1gmda1w/promo-image.1608575562.png",
      "url": "https://learn.newrelic.com/go-deeper-advanced-alerting-nrql-alerts",
      "sections": [
        "Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you’ll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance s",
        "About this workshop",
        "Go Deeper: Advanced Alerting & NRQL Alerts"
      ],
      "published_at": "2021-04-13T01:38:27Z",
      "title": "[Webinar] Go Deeper: Advanced Alerting & NRQL Alerts",
      "updated_at": "2021-04-13T01:38:26Z",
      "type": "",
      "external_id": "a44bc2bed49a8b258b97a438df3e7a0bbcf7095a",
      "popularity": 1,
      "body": "Sign In [Webinar] Go Deeper: Advanced Alerting & NRQL Alerts Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you’ll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios. Register | FREE Already registered? Sign In About this workshop You’ve mastered Alerting Fundamentals and want to know more about alerting? Join this highly practical and engaging session where we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.   With scenario based labs, you’ll create specific policies and conditions for typical use cases across the full stack, use tags to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.  The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements.  Agenda and Labs Effective Alerting strategies  SLO’s, SLA’s and Thresholds Use Cases and labs:  Alerting on SLA’s Alerting on variable performance -Dynamic Baseline Alerting Using tags to dynamically target Entities NRQL Alerts; Outlier detection, and other use cases Lab: Alert on Multiple issues (Static),  Lab: Alert on Synthetic performance (Dynamic),  Lab: Alert on Outlier behaviour (Outlier - Facets) Notifying the right team: Channels, Test Channels and Webhooks  Lab: Webhook Challenge Alerts and Dashboarding  Lab: Charting alerts Managing Alerts and Conditions REST API and Muting Rules Go Deeper: Advanced Alerting & NRQL Alerts Event Date Spaces left Go Deeper: Advanced Alerting & NRQL Alerts April 22, 2021, 10 a.m. - April 22, 2021, noon BST 127 Go Deeper: Advanced Alerting & NRQL Alerts April 27, 2021, 10 a.m. - April 27, 2021, noon PDT 128 About this workshop You’ve mastered Alerting Fundamentals and want to know more about alerting? Join this highly practical and engaging session where we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.   With scenario based labs, you’ll create specific policies and conditions for typical use cases across the full stack, use tags to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.  The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements.  Agenda and Labs Effective Alerting strategies  SLO’s, SLA’s and Thresholds Use Cases and labs:  Alerting on SLA’s Alerting on variable performance -Dynamic Baseline Alerting Using tags to dynamically target Entities NRQL Alerts; Outlier detection, and other use cases Lab: Alert on Multiple issues (Static),  Lab: Alert on Synthetic performance (Dynamic),  Lab: Alert on Outlier behaviour (Outlier - Facets) Notifying the right team: Channels, Test Channels and Webhooks  Lab: Webhook Challenge Alerts and Dashboarding  Lab: Charting alerts Managing Alerts and Conditions REST API and Muting Rules Live events Go Deeper: Advanced Alerting & NRQL Alerts Event Date Spaces left Go Deeper: Advanced Alerting & NRQL Alerts April 22, 2021, 10 a.m. - April 22, 2021, noon BST 127 Go Deeper: Advanced Alerting & NRQL Alerts April 27, 2021, 10 a.m. - April 27, 2021, noon PDT 128 © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.94656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " stack, use <em>tags</em> to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.  The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your"
      },
      "id": "600789b728ccbc0c0a3f6fa8"
    },
    {
      "sections": [
        "Report Zipkin-format traces via Trace API",
        "Zipkin version requirements",
        "Overview of using the Trace API",
        "Send sample Zipkin trace payload",
        "Send Zipkin-format payload",
        "Send data from existing Zipkin instrumentation",
        "Transformation of Zipkin data",
        "Add other tags/attributes"
      ],
      "title": "Report Zipkin-format traces via Trace API",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Trace API"
      ],
      "external_id": "dba8334d1f068236c741ff04c13ecc2be2c184fc",
      "image": "https://docs.newrelic.com/static/96e69137f0dd86b313ec72d5f0c1ad83/119c7/Screen-Shot-2020-08-13-at-1.26.17-PM.png",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/trace-api/report-zipkin-format-traces-trace-api/",
      "published_at": "2021-04-12T11:45:27Z",
      "updated_at": "2021-04-10T16:18:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to create your own tracing implementation, you can use our Trace API. This doc explains how to send Zipkin-format trace data to our Trace API. (For our general data format, see New Relic format.) Zipkin version requirements The Trace API supports data from Zipkin JSON v2 (or higher) without any modification. For details on this version, see Zipkin v2 release details and the Zipkin v2 schema. Overview of using the Trace API Using our Trace API is as simple as: Sending trace data in the expected format (in this case, zipkin format). Sending that data to the appropriate endpoint Our send-data instructions have options for enabling Infinite Tracing. To learn more about this, see Intro to Infinite Tracing and Sampling considerations. To get started using the Trace API, choose an option: Send a sample trace: This shows a curl example of sending a trace to New Relic. This is useful for understanding how the Trace API works, and to verify you're seeing data in New Relic. Report data from existing Zipkin instrumentation: if you have an existing Zipkin implementation, you can simply change the endpoint of where your data gets sent. Send sample Zipkin trace payload This section describes how to send a simple Zipkin-format trace to our Trace API via curl request. You might choose to do this in order to learn how our API works and to verify that data is showing up in New Relic before doing in-depth instrumentation. To get started sending a sample payload: (Optional, to enable Infinite Tracing) First, you must set up a trace observer. That procedure includes instructions for sending a sample trace using our general new-relic format. When you get to that step, return here to instead learn how to send a Zipkin-format trace. Send a Zipkin-format payload following the instructions below. Send Zipkin-format payload To send a sample Zipkin-format trace: Get an Insights insert key: Go to the API keys UI and select Insights insert keys. If you don't already have a key, create a new one by selecting Insert keys +. You'll be executing a curl request, below. Notes on this: Replace the insert key placeholder with your insert key. If you're using Infinite Tracing, use the YOUR_TRACE_OBSERVER_URL value in place of the standard endpoint. If you want to send more than one post, change the trace ID to a different value. Sending the same payload or span id multiple times for the same traceId may result in fragmented traces in the UI. curl -i -H 'Content-Type: application/json' \\ -H 'Api-Key: $NEW_RELIC_INSERT_KEY' \\ -H 'Data-Format: zipkin' \\ -H 'Data-Format-Version: 2' \\ -X POST \\ -d '[ { \"traceId\": \"test-zipkin-trace-id-1\", \"id\": \"3e0f5885710776cd\", \"kind\": \"CLIENT\", \"name\": \"post\", \"duration\": 508068, \"localEndpoint\": { \"serviceName\": \"service-1\", \"ipv4\": \"127.0.0.1\", \"port\": 8080 }, \"tags\": { } }, { \"traceId\": \"test-zipkin-trace-id-1\", \"parentId\": \"3e0f5885710776cd\", \"id\": \"asdf9asdn123lkasdf\", \"kind\": \"CLIENT\", \"name\": \"service 2 span\", \"duration\": 2019, \"localEndpoint\": { \"serviceName\": \"service-2\", \"ipv4\": \"127.0.0.1\", \"port\": 8080 }, \"tags\": { \"error.message\": \"Invalid credentials\" } } ]' 'https://trace-api.newrelic.com/trace/v1' Copy Within a minute, the trace should be available in the our distributed tracing UI. To find it, run a query for the trace.id. In this example, it was test-zipkin-trace-id-1. Note that you search by the transformed attribute of trace.id (not traceId). To learn more: Learn where Trace API data shows up in the UI. Send data from an existing Zipkin instrumentation. Learn how to decorate spans by adding tags. This helps you customize how traces are displayed in our UI for a richer, more helpful experience. Learn about general endpoint information (data limits, required metadata, and response validation). Learn about how Zipkin data is transformed and stored in our format. If you don't see your trace data, see Troubleshooting. Send data from existing Zipkin instrumentation Preliminary notes: If you want to enable Infinite Tracing, you first must set up a trace observer. It can be helpful to first send a sample payload to verify things are working properly. To report data from an existing Zipkin instrumentation, you'll point the Zipkin tracer at the appropriate Trace API endpoint with some required request metadata. You can send the required metadata as headers or query parameters (some Zipkin tracer versions don't allow specifying HTTP headers). Here's an example of what it might look like to create a Zipkin OkHttpSender in Java configured for the Trace API: OkHttpSender.create(\"https://trace-api.newrelic.com/trace/v1?Api-Key=NEW_RELIC_INSERT_API_KEY&Data-Format=zipkin&Data-Format-Version=2\"); Copy Note that if you were using Infinite Tracing, or had an EU-region New Relic account, the endpoint would be different. For an explanation of Api-Key and the other metadata, see Request metadata. Transformation of Zipkin data To create a consistent search/query experience, some Zipkin data will be transformed to match New Relic attribute naming. For more on how we store and structure trace data, see How distributed tracing works. Zipkin tag Stored in New Relic as... Details traceId trace.id Unique identifier for a trace. id id Unique identifier for a span. parentId parent.id Identifier of the upstream span that called the service. kind kind Either Client or Server. name name Name of span. duration duration.ms Zipkin v2 spans must have durations specified in microseconds, and will be converted to milliseconds. localEndpoint: serviceName service.name We use the Zipkin v2 service name to identify the entity that created this span. localEndpoint: port localEndpoint.port All values in the localEndpoint object will be flattened to a span attribute called localEndpoint.key tags reported as attributes Key:value pairs in the tags object in Zipkin v2 will be written as span attributes. annotations not supported We do not currently support annotations in the Trace API. Spans will not be rejected if they contain annotations, but the annotations data will not be written. Add other tags/attributes You can add any tags you want to the tags block, with the exception of the restricted tags. For example, you might want to add attributes like customer.id or user.id to help you analyze your trace data. Tags will be converted to New Relic attributes. To learn how to control how spans appear in New Relic (for example, adding errors or setting a span as a datastore span), see Decorate spans.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.57472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add other <em>tags</em>&#x2F;attributes",
        "body": " How distributed tracing works. Zipkin <em>tag</em> Stored in <em>New</em> <em>Relic</em> as... Details traceId trace.id Unique identifier for a trace. id id Unique identifier for a span. parentId parent.id Identifier of the upstream span that called the service. kind kind Either Client or Server. name name Name of span"
      },
      "id": "6071cfc864441fa88f9d8530"
    }
  ],
  "/terms": [
    {
      "image": "https://newrelic.com/sites/default/files/styles/800w/public/2021-01/FS_Speakers_Image1.jpg?itok=fLI9yK12",
      "url": "https://newrelic.com/futurestack/call-for-speakers",
      "sections": [
        "Call for Speakers is Now Closed",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-11T12:14:16Z",
      "title": "FutureStack | Call for Speakers | New Relic",
      "updated_at": "2021-04-11T12:14:16Z",
      "type": "",
      "external_id": "8c8aefb9f7d82163734f7672956f3572fead5ec3",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Call for Speakers is Now Closed For questions please contact SpeakersFS21@streamlinevents.com {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 515.51434,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "600c401c64441fad17396fc8"
    },
    {
      "image": "https://newrelic.com/themes/custom/curio/assets/images/metadata/NROG_Image.png",
      "url": "https://newrelic.com/futurestack/terms-and-conditions-giveaway",
      "sections": [
        "Terms and Conditions: FUTURESTACK 2021 Registration Giveaway"
      ],
      "published_at": "2021-04-11T15:06:08Z",
      "title": "Terms and Conditions: FUTURESTACK 2021 Registration Giveaway | New Relic",
      "updated_at": "2021-04-11T15:06:08Z",
      "type": "",
      "external_id": "151e37ce3627c69dbf642a68dcca384056f657e2",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Terms and Conditions: FUTURESTACK 2021 Registration Giveaway New Relic, Inc. (“New Relic”) invites all eligible participants to enter the FutureStack 2021 Registration Giveaway (the “Giveaway”) which will be held from Thursday, April 1, 2021 at 8:00am PDT through Friday, April 30, 2021 at 5:00pm PDT (the “Giveaway Period”). The first one thousand five hundred (1,500) participants who have successfully completed the registration process for the FutureStack 2021: Level Up virtual event may be eligible to win the prize detailed below. Supplies are limited. Entries are limited to one event registration per participant. A participant’s entry into the Giveaway constitutes acceptance of these Terms & Conditions. NO PURCHASE OR PAYMENT IS NECESSARY TO ENTER THIS GIVEAWAY. Prizes: The first one thousand five hundred (1,500) participants who have successfully registered to attend the FutureStack 2021: Level Up virtual event via https://newrelic.com/futurestack will receive one (1) New Relic Swag Pack, with an approximate value of $40 USD. Prizes are non-transferable. Winners will be contacted via the email address associated with their FutureStack 2021: Level Up event registration by Monday, May 3, 2021. Winners shall have seventy-two (72) hours after receiving the email notification to claim their prize or else it will be forfeited. Who Can Enter: The Giveaway is strictly limited to legal residents of the United States and Washington, D.C. who are at least eighteen (18) years of age. Participants are solely responsible for ensuring their participation in the Giveaway is lawful. New Relic employees are not eligible to participate in the Giveaway. New Relic reserves the right, at its sole discretion, to disqualify participants for any reason, including if it is determined that one’s participation in the Giveaway is not lawful. Release: ALL PARTICIPANTS IN THE GIVEAWAY RELEASE NEW RELIC, INC. AND ITS RESPECTIVE EMPLOYEES, OFFICERS, DIRECTORS, AND SHAREHOLDERS (“RELEASED PARTIES”) FROM AND AGAINST ALL LIABILITY, CLAIMS, AND DAMAGES ARISING IN CONNECTION WITH THEIR PARTICIPATION OR INABILITY TO PARTICIPATE, ENTRY IN THE GIVEAWAY AND/OR ACCEPTANCE, RECEIPT, OWNERSHIP OR USE OF THE PRIZE AWARDED IN THE GIVEAWAY, INCLUDING BUT NOT LIMITED TO PERSONAL INJURY, DEATH, DAMAGE TO PROPERTY OR LOSS OF PROPERTY. Limitation of Liability: RELEASED PARTIES ARE NOT RESPONSIBLE FOR ANY CLAIMS, DAMAGES, EXPENSES, COSTS OR LOSSES TO ANY PERSON OR PROPERTY OF ANY KIND ARISING FROM OR IN CONNECTION WITH (1) TYPOGRAPHICAL OR OTHER ERRORS IN THE PRINTING OF THESE OFFICIAL RULES; (2) TECHNICAL FAILURES OF ANY KIND, INCLUDING BUT NOT LIMITED TO MALFUNCTIONS, INTERRUPTIONS OR DISCONNECTIONS OR DISCONNECTIONS IN PHONE LINES, HARDWARE, SOFTWARE OR FAILURE OF ANY EMAIL OR ENTRIES TO BE RECEIVED BY NEW RELIC DUE TO TECHNICAL PROBLEMS, HUMAN ERROR OR TRAFFIC CONGESTION, UNAVAILABLE NETWORK CONNECTIONS ON THE INTERNET OR ANY WEBSITE; (3) UNAUTHORIZED THIRD PARTY TAMPERING WITH THE GIVEAWAY; (4) TECHNICAL OR HUMAN ERROR IN THE ADMINISTRATION OF THE PRIZE; OR (5) LATE, LOST, UNDELIVERABLE, DAMAGED OR STOLEN MAIL. General: Any entries generated by a script, computer program, robotic or other automatic means will be disqualified. The Giveaway is governed by and will be construed in accordance with the laws of the State of California and the forum and venue for any dispute shall be San Francisco, California. Participants acknowledge that any contact information collected during the Giveaway Period will be used for marketing and other internal purposes. New Relic reserves the right to terminate this Giveaway for any or no reason and at any time without further notice. New Relic, Inc. 188 Spear Street, Suite 1000 San Francisco, CA 94105 Register Now Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 479.64297,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Terms</em> <em>and</em> <em>Conditions</em>: FUTURESTACK 2021 Registration Giveaway | New Relic",
        "sections": "<em>Terms</em> <em>and</em> <em>Conditions</em>: FUTURESTACK 2021 Registration Giveaway",
        "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item <em>Terms</em> and <em>Conditions</em>: FUTURESTACK 2021 Registration Giveaway New Relic, Inc. (“New Relic”) invites all eligible"
      },
      "id": "6073106028ccbca5ef51c129"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-04/Yopes_Thomas_Headshot.jpg?h=0f3f3a77&itok=x4unEit0",
      "url": "https://newrelic.com/futurestack/speakers/thomas-yopes",
      "sections": [
        "Thomas Yopes",
        "Sessions with Thomas Yopes",
        "New Relic: Startup Observability No-brainer and Stepping Stone To Cloud Unit Costs",
        "Meet Our Speakers",
        "Daniel Kim",
        "Eugene Kovshilovsky",
        "Peter Espe",
        "Jonan Scheffler",
        "Mason Jones",
        "Joanna Leidy",
        "Scot Gorman",
        "Samer Rashdan",
        "Andy Baio",
        "Gwen Hurd",
        "Paras Wadehra",
        "Phil Weber",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-11T15:11:36Z",
      "title": "Thomas Yopes | New Relic",
      "updated_at": "2021-04-11T15:11:36Z",
      "type": "",
      "external_id": "a35f4e0695700f830c2076e4459c25559edd931d",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Thomas Yopes Co-Founder, cloudthread Sessions with Thomas Yopes 10:35 am - 10:55 am PT | Thursday, May 27 | Snackable New Relic: Startup Observability No-brainer and Stepping Stone To Cloud Unit Costs Meet Our Speakers Daniel Kim Senior Developer Relations Engineer New Relic Learn more Eugene Kovshilovsky Senior Vice President of Software Engineering CarParts.com Learn more Peter Espe Infrastructure Engineer Credit Karma Learn more Jonan Scheffler Director, Developer Relations New Relic Learn more Mason Jones Senior Staff Site Reliability Engineer Credit Karma Learn more Joanna Leidy Lead UI Engineer New Relic Learn more Scot Gorman Site Reliability Engineering Manager Chegg Learn more Samer Rashdan Enabling Customer Success Through Creative Problem Solving Pearson Education Learn more Andy Baio Creator Skittish Learn more Gwen Hurd Senior Solutions Engineer New Relic Learn more Paras Wadehra Solutions Architect New Relic Learn more Phil Weber Senior Technical Training Specialist New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 453.1772,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "New Relic: Startup Observability No-brainer <em>and</em> Stepping Stone To Cloud Unit Costs",
        "body": " All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "607311a8e7b9d24171a5c681"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/FutureStack_FS_2021_Mario_flower_dark.png?h=655eccb1&itok=8oM4fyBm",
      "url": "https://newrelic.com/futurestack/speakers/peter-espe",
      "sections": [
        "Peter Espe",
        "Sessions with Peter Espe",
        "Migrating Credit Karma's Telegraf Metrics to New Relic",
        "Meet Our Speakers",
        "Justin Eveland",
        "Sam Aaron",
        "Sandeep Parmar",
        "Michael Caron",
        "Liam Hurrell",
        "Joanna Leidy",
        "Aaron Judy",
        "Gwen Hurd",
        "Henry Jewkes",
        "Paras Wadehra",
        "Lew Cirne",
        "Daniel Kim",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-11T15:11:36Z",
      "title": "Peter Espe | New Relic",
      "updated_at": "2021-04-11T15:11:36Z",
      "type": "",
      "external_id": "82484358c55bfb03d9b2062265ba7312e293fd51",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Peter Espe Infrastructure Engineer, Credit Karma Sessions with Peter Espe 11:15 am - 12:15 am PT | Thursday, May 27 | Hands-on Workshop Migrating Credit Karma's Telegraf Metrics to New Relic Learn how Credit Karma migrated its large, Telegraf-based metrics monitoring solution to New Relic without interruption, shifting hundreds of developers using hundreds of microservices.  (Join this session for live chat OR watch on-demand immediately after) Meet Our Speakers Justin Eveland Software Engineer New Relic Learn more Sam Aaron Creator Sonic Pi Learn more Sandeep Parmar Pre-Sales Solutions Architect New Relic Learn more Michael Caron Senior Technical Training Specialist New Relic Learn more Liam Hurrell Senior Technical Training Specialist New Relic Learn more Joanna Leidy Lead UI Engineer New Relic Learn more Aaron Judy Chief of Innovation and AI Maricopa County Clerk of the Superior Court Learn more Gwen Hurd Senior Solutions Engineer New Relic Learn more Henry Jewkes Experimentation Advisor Split.io Learn more Paras Wadehra Solutions Architect New Relic Learn more Lew Cirne CEO and Founder New Relic Learn more Daniel Kim Senior Developer Relations Engineer New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 453.1772,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "6042d19764441f1625378ef7"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-04/Packard_Daniele_Headshot.jpg?h=44650d79&itok=wFQUDbZp",
      "url": "https://newrelic.com/futurestack/speakers/daniele-packard",
      "sections": [
        "Daniele Packard",
        "Sessions with Daniele Packard",
        "New Relic: Startup Observability No-brainer and Stepping Stone To Cloud Unit Costs",
        "Meet Our Speakers",
        "Naveen Chittoor",
        "Alec Isaacson",
        "Justin Eveland",
        "Jonan Scheffler",
        "Sagar Thirumala",
        "Dan Rufener",
        "Danny Roessner",
        "Jonathan Karon",
        "Anthony Pounds-Cornish",
        "Samer Rashdan",
        "Daniel Kim",
        "JD Weiner",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-11T15:11:36Z",
      "title": "Daniele Packard | New Relic",
      "updated_at": "2021-04-11T15:11:36Z",
      "type": "",
      "external_id": "766d88ffae7bdcc2fe38b1c5d8a0bbd72641bef7",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Daniele Packard Co-Founder, cloudthread Sessions with Daniele Packard 10:35 am - 10:55 am PT | Thursday, May 27 | Snackable New Relic: Startup Observability No-brainer and Stepping Stone To Cloud Unit Costs Meet Our Speakers Naveen Chittoor Application Support Engineer Cox Communications Inc Learn more Alec Isaacson Pre-Sales Solutions Architect New Relic Learn more Justin Eveland Software Engineer New Relic Learn more Jonan Scheffler Director, Developer Relations New Relic Learn more Sagar Thirumala Administrator Cox Communications Inc Learn more Dan Rufener Director of New Venture Development New Relic Learn more Danny Roessner Director, Engineering WellSky Learn more Jonathan Karon Director of Venture Development New Relic Learn more Anthony Pounds-Cornish Consultant Cognitran Learn more Samer Rashdan Enabling Customer Success Through Creative Problem Solving Pearson Education Learn more Daniel Kim Senior Developer Relations Engineer New Relic Learn more JD Weiner Manager of Operations Forbes Media LLC Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 453.1772,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "New Relic: Startup Observability No-brainer <em>and</em> Stepping Stone To Cloud Unit Costs",
        "body": " Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "607311a828ccbc462651c172"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "image": "https://developer.newrelic.com/static/2dd8a32b57677b2e8d2497147d8ebc26/2663f/custom-attribute-query.png",
      "url": "https://developer.newrelic.com/collect-data/custom-attributes/embed/",
      "sections": [
        "Add custom attributes to your New Relic data",
        "Create a custom attribute"
      ],
      "published_at": "2021-04-12T01:54:52Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "cedc1038d9905e78e3cb8a2c8103984059a0a18c",
      "popularity": 1,
      "body": "There are countless filters and pivots you might want to apply to your data. By adding custom attributes to your data, you can see beyond your code and analyze your business in-depth. A common pattern when using custom attributes is to capture user information, such as name, ID, email, and more. This allows you to 'link' your operational data with your business data. For example, if you have the user information, you tie together your service desk and CRM data with the operational data in New Relic. Create a custom attribute Step 1 of 2 Use the open source Java APM agent's API to add a userid custom attribute to your APM-reported data, Transaction and TransactionError events. NewRelic.addCustomParameter(\"userid\", userId); Copy Step 2 of 2 After you add the userid custom attribute, run a NRQL query that uses it. As the query shows, the userid attribute enables you to filter and facet your NRQL queries. -- Get a count of errors experienced by a single filtered userid faceted by date and error message SELECT count(*) FROM TransactionError WHERE userid = '1401961100' FACET dateOf(timestamp), `error.message` SINCE 1 week ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.44978,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em> to your New Relic data",
        "body": "There are countless filters and pivots you might want to apply to your data. By adding <em>custom</em> <em>attributes</em> to your data, you can see beyond your code and analyze your business in-depth. A common pattern when using <em>custom</em> <em>attributes</em> is to capture user information, such as name, ID, email, and more"
      },
      "id": "6063d5f364441f975c0c8beb"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Important",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9a5edf6068acc3b7187d217bd7932f0478e5467c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-04-12T01:06:07Z",
      "updated_at": "2021-03-30T06:37:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.87711,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> events and <em>attributes</em>",
        "sections": "APM: Report <em>custom</em> events and <em>attributes</em>",
        "tags": "<em>Custom</em> events",
        "body": ". For restrictions on event type names, see our documentation about limits and restricted characters and <em>NRQL</em> reserved words. You can then add <em>custom</em> <em>attributes</em> for your .NET app. You can turn off <em>custom</em> events entirely by setting <em>custom</em>Events.enabled to false in newrelic.config. Node.js <em>Custom</em> event"
      },
      "id": "603ecece28ccbcc865eba7a0"
    },
    {
      "sections": [
        "Simulate SQL JOIN functions in Insights",
        "Important",
        "Simulate SQL JOIN in Insights"
      ],
      "title": "Simulate SQL JOIN functions in Insights",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Explore data"
      ],
      "external_id": "7a865cf0687b3b99d9a59d7616c03ef8266e71e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/simulate-sql-join-functions-insights/",
      "published_at": "2021-04-11T15:46:15Z",
      "updated_at": "2021-03-29T16:26:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. When you use Insights to make queries, NRQL does not have an equivalent SQL-like JOIN function for subqueries. Recommendation: Make the transition from Insights to New Relic One so that you can take advantage of nested queries. Simulate SQL JOIN in Insights If you are using Insights to gain more in-depth data, you can add custom attributes to some data types. With Insights, you can simulate a JOIN by using custom attributes in a query's WHERE or FACET clause. Example: You want to know which browser types are experiencing the highest web duration for a specific product purchase. You could add a custom attribute named Product to your application's purchase transaction method. Then you could run this NRQL query: SELECT max(duration), average(duration), max(backendDuration), average(backendDuration) FROM PageView WHERE Product = 'Hat' FACET userAgentName SINCE 7 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.47069,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Insights to gain more in-depth data, you can add <em>custom</em> <em>attributes</em> to some data types. With Insights, you can simulate a JOIN by using <em>custom</em> <em>attributes</em> in a query&#x27;s WHERE or FACET clause. Example: You want to know which browser types are experiencing the highest web duration for a specific product"
      },
      "id": "6043ff1764441fe197378f17"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/Rabiela_Sergio_Headshot_0.jpg?h=0e4e36f5&itok=WRvHEC-i",
      "url": "https://newrelic.com/futurestack/speakers/sergio-rabiela",
      "sections": [
        "Sergio Rabiela",
        "Sessions with Sergio Rabiela",
        "Custom Attributes and Events for Business Health",
        "Meet Our Speakers",
        "Matt Shandera",
        "Naveen Chittoor",
        "Ev Haus",
        "Rohit Kaul",
        "Maggie Calegari",
        "Paras Wadehra",
        "Thomas Yopes",
        "Kelsey Hightower",
        "Mason Jones",
        "Dave Soloway",
        "Andy Baio",
        "Jonathan Karon",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-11T15:06:59Z",
      "title": "Sergio Rabiela | New Relic",
      "updated_at": "2021-04-11T15:06:59Z",
      "type": "",
      "external_id": "7e17badde1356bebb9a7b345bd326e66912aaf65",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Sergio Rabiela Vice President of Technology, Beyond Finance, Inc on LinkedIn Sessions with Sergio Rabiela 10:15 am - 11:15 am PT | Wednesday, May 26 | Hands-on Workshop Custom Attributes and Events for Business Health Custom Attributes and Events let you push metrics that inform business KPIs in real-time. We'll run through how to use custom attributes and events to allow a broader set of people to monitor business functions and troubleshoot issues in your apps. (Join this session for live chat OR watch on-demand immediately after) Meet Our Speakers Matt Shandera Program Manager for Nonprofit Success New Relic Learn more Naveen Chittoor Application Support Engineer Cox Communications Inc Learn more Ev Haus Head Of Technology at ZenHub ZenHub Learn more Rohit Kaul Senior Partner Solutions Consultant New Relic Learn more Maggie Calegari Founder and Creator Mindful Movement with Maggie Learn more Paras Wadehra Solutions Architect New Relic Learn more Thomas Yopes Co-Founder cloudthread Learn more Kelsey Hightower Principal Engineer Google Learn more Mason Jones Senior Staff Site Reliability Engineer Credit Karma Learn more Dave Soloway Manager, Engineering Blackhawk Network Learn more Andy Baio Creator Skittish Learn more Jonathan Karon Director of Venture Development New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.89949,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Custom</em> <em>Attributes</em> and Events for Business Health",
        "body": ":15 am PT | Wednesday, May 26 | Hands-on Workshop <em>Custom</em> <em>Attributes</em> and Events for Business Health <em>Custom</em> <em>Attributes</em> and Events let you push metrics that inform business KPIs in real-time. We&#x27;ll run through how to use <em>custom</em> <em>attributes</em> and events to allow a broader set of people to monitor business"
      },
      "id": "6042d15c28ccbce4462c6079"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/NRBlog_20181107_S7_AWS-EC2-tagging-integration.png",
      "url": "https://newrelic.com/blog/how-to-relic/new-relic-infrastructure-getting-started-best-practices",
      "sections": [
        "Getting organized and getting started",
        "Create a naming convention",
        "Implement a tagging structure",
        "Create a filter set",
        "Understanding your UI",
        "Apply a filter",
        "Making data actionable",
        "Using New Relic Insights queries",
        "Set up New Relic Alerts",
        "Monitor your apps, and their hosts, in one place",
        "Ready to learn more?",
        "Related Topics"
      ],
      "published_at": "2021-04-14T00:02:29Z",
      "title": "Getting Started with New Relic Infrastructure: Best Practices That Set You up for Success",
      "updated_at": "2021-04-14T00:02:29Z",
      "type": "",
      "external_id": "78d3925eba18b334c1df9469f34071151e6d3b82",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Infrastructure Monitoring Getting Started with New Relic Infrastructure: Best Practices That Set You up for Success Nov 8, 2018 • 7 min read By New Relic Community Team The following is adapted from a series of best practice guides that reflect the New Relic Community Team’s work with thousands of customers—identifying challenges and coming up with actionable solutions for organizations getting started with New Relic Infrastructure. Also, check out our guides to getting started with New Relic APM, New Relic Mobile, New Relic Insights, New Relic Browser, and New Relic Synthetics; and discover the New Relic Community Team’s latest Best Practice Guide offerings. Improving application performance involves more than just your company’s software. It also demands visibility into your application infrastructure: the servers and hosts, and the supporting network and storage resources, that power your applications and make them available to users. New Relic Infrastructure offers a powerful set of solutions to your organization’s infrastructure visibility challenges. Infrastructure lets you look into host resource usage—locally or in the cloud—and also lets you monitor events on your hosts, inventory metrics, and network or storage availability.  Infrastructure makes it easy to track all of these resources, and to correlate any changes to potential impacts on your host and application performance. In this post, we will show you how to set up New Relic Infrastructure to make the most of this added visibility into your environment. (After reviewing these best practices—and, when possible, actually working with them in your organization's own environment—you’ll be ready to demonstrate your new skills by taking our Infrastructure Best Practices Quiz): Let’s dive into our list of best practices, organized based on the Infrastructure capabilities and tasks they address. Getting organized and getting started Create a naming convention Let’s begin with two of the most important tips for New Relic Infrastructure users: Decide upon an appropriate naming scheme and use it consistently. First, a simple naming scheme for all of the elements in your account can greatly reduce the amount of time you spend looking for pertinent information. When you devise a naming scheme and apply it consistently within a specific New Relic account—for example, <env (Prod/Staging)>-<Service Name>-<AWS Region>—the host name can supply the information you need to locate a problem and to identify the right person to fix it.  Learn more about applying a naming scheme to your New Relic Infrastructure environment in our docs: Updating display names in your Infrastructure configuration file. Implement a tagging structure Tags are integral to organizing the hosts within your environment. They allow you to spot problems more easily by sorting and filtering groups of hosts; for example, you can add the same attribute to a number of hosts to identify them later, using the Infrastructure UI or NRQL queries. If your hosts are in Amazon Web Services (AWS), then New Relic Infrastructure’s Amazon EC2 integration makes the process of implementing tagging remarkably simple. Any EC2 tags you add to your hosts within AWS will carry over to New Relic, allowing you to group your hosts without extra configuration. New Relic Infrastructure's Amazon EC2 integration is one of more than 50 cloud and on-host integrations that make tasks such as tagging simpler—yet also more powerful. If you’re not using AWS EC2, New Relic Infrastructure supports more than 50 other cloud and on-host integrations, in addition to offering custom attributes that you can tailor to meet your organization’s needs. Learn more about implementing tagging using either AWS EC2 integration or custom attributes in our documentation: AWS EC2 Monitoring Integration Configure the Infrastructure Agent: Custom Attributes Create a filter set Filter sets let you target any number of hosts based on a variety of attributes, including tags, hostNames, etc. You can then target filter sets with alert conditions, which saves you the time required to apply a condition to multiple hosts manually. You can also alter the charts in the Infrastructure UI to focus in on a specific filter set—letting you concentrate on the hosts that matter most to you. Learn more about using Infrastructure Filter Sets in our docs: Filter Sets: Organize Your Hosts. Understanding your UI Apply a filter By default, the New Relic Infrastructure UI shows you data for all reporting hosts. Depending on the number of hosts that you’re monitoring, applying a filter set to the UI can make your monitoring data much easier to assess and interpret. You can create filter sets that apply to hostnames, or EC2 tags, or any other attributes that matter to you. When you apply them, the UI will focus only on matching hostnames. When you apply a filter set, it carries through to all parts of the Infrastructure UI—keeping you informed only on the hosts you need to know about. Learn more about using New Relic Infrastructure filter sets in New Relic University: Using Filter Sets and Groups in New Relic Infrastructure. New Relic Infrastructure makes it easy to configure filter sets based on a wide range of attributes, and to target filter sets by alert conditions. Making data actionable Using New Relic Insights queries New Relic Insights gives you a powerful way to ask questions of your data—and that’s especially true for New Relic Infrastructure users. We work hard, for example, to ensure that Infrastructure data is tracked as event-based data that you can query quickly and easily, and that any chart created within Infrastructure is also available within Insights at the click of a button. In addition, when you set up Infrastructure integrations, the setup process automatically creates a number of Insights dashboards—helping to make these integrations more valuable, more quickly, for you. Learn more about the shared data and views within New Relic Infrastructure and Insights in our documentation: Share Infrastructure data and view in Insights. New Relic Insights gives users a powerful yet easy to use set of tools for querying data generated while working with New Relic Infrastructure. Set up New Relic Alerts Alerts are critical factor to the monitoring process: What’s the point of monitoring if you don’t know when your applications or infrastructure is having problems are misbehaving?  New Relic Alerts allows you to configure notifications using a variety of popular messaging and communication platforms (Slack, OpsGenie, PagerDuty, etc.), as well as a generic webhook to which you can send notifications. When you get started with Infrastructure Alerts, one of the first conditions we recommend is a “Host Not Reporting” condition. Learn more about alerting best practices, including tips on setting up a “Host Not Reporting” condition with these resources: Guide to Effective Alerting in Practice Intro to APM Alerting Create Infrastructure ‘Host Not Reporting’ condition New Relic supports quick and easy configuration of alert notifications using a variety of messaging programs. Monitor your apps, and their hosts, in one place Health maps provide a high-level view of your host and application health in relation to one another, prioritized by health status. As long as you have both an APM and Infrastructure subscription, you can use health maps to gain dashboard-style visibility into potential problems—making it easier to find, diagnose, and fix them quickly. Learn more about New Relic health maps in the video demo below, or in the New Relic docs: Introduction to health maps. Ready to learn more? Looking for more Infrastructure best practices and tips? Check out the Infrastructure Level Up page in the New Relic Explorers Hub for a wealth of community-generated resources on these and related topics. And when you feel you’re ready, test your new Infrastructure skills by taking our Infrastructure Best Practices Quiz and earning your proficiency badge! Related Topics Infrastructure Monitoring By New Relic Community Team Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.23839,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", New Relic Infrastructure supports more than 50 other cloud and on-host integrations, in addition to offering <em>custom</em> <em>attributes</em> that you can tailor to meet your organization’s needs. Learn more about implementing tagging using either AWS EC2 integration or <em>custom</em> <em>attributes</em> in our documentation: AWS"
      },
      "id": "6076311528ccbc61fd51c159"
    }
  ],
  "/terraform/terraform-modules": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-14T00:08:56Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.56415,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Linking a <em>notification</em> <em>channel</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "70555c1d24e8e54b46763d57010901e206ef2ccb",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.50517,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6066782e64441f3610617ac3"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-04-12T02:18:23Z",
      "updated_at": "2021-04-06T07:43:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirements: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.03162,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-13T01:55:31Z",
      "title": "",
      "updated_at": "2021-04-01T01:51:55Z",
      "type": "",
      "external_id": "5e43fb43faa36807fc9f1eb660748303373fa8dd",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.11371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6065273be7b9d2336c944613"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/markdown-summary-for-syslog-facilities.png",
      "url": "https://newrelic.com/blog/how-to-relic/how-to-create-syslog-dashboard-using-new-relic-terraform",
      "sections": [
        "Understanding the Syslog format",
        "Step 1: Create your Terraform project",
        "Step 2: Create the Syslog dashboard",
        "Widget 1: Billboard counters by severity",
        "Widget 2: Billboard for log throughput",
        "Widget 3: Line chart to view problem-related trends over time",
        "Widget 4: Bar charts by application and node",
        "Widget 5: Line charts to view log counters by severity and facility over time",
        "Widget 6: Event table to display the top 100 logs",
        "Widget 7: Markdown summary for Syslog facilities",
        "Step 3: Apply your code",
        "Step 4: Add alerts for real-time notification",
        "Ready to create a Syslog dashboard?"
      ],
      "published_at": "2021-04-13T23:18:13Z",
      "title": "Dashboards as Code: How to Create a Syslog Dashboard Using New Relic and Terraform",
      "updated_at": "2021-04-13T23:16:12Z",
      "type": "",
      "external_id": "5372ca6e0d29c3dced938e55d3c17f22b01bbec4",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Dashboards as Code: How to Create a Syslog Dashboard Using New Relic and Terraform Mar 16, 2021 • 11 min read By Edmo Vamerlatti Dashboards are important tools that help you visualize your entire stack's performance to understand context and resolve issues quickly. They also help you answer questions such as, \"When did the problem start?\" and \"What's the impact of this issue?\" However, manually maintaining dashboards can be error prone and is sub-optimal in terms of efficiency and security. Manual updates to dashboards also do not provide any modification history, rollback mechanisms, peer reviews, or any of the benefits we normally expect in CI/CD pipelines. That’s why engineers are beginning to treat them like any other important resource: by creating dashboards as code. For example, using Terraform and the new, built-in log parser rule for Syslog RFC-5424 within New Relic One, you can implement observability as code with a dashboard that organizes Syslog RFC-5424 unstructured messages into attribute/value pairs and lets you drive alerts based on subsets of log data. With the new agentless option for onboarding syslog data, you have a variety of options for data ingest, so long as you properly parse the data when ingesting or directly from the New Relic UI. This blog post guides you through how to create a Syslog RFC-5424 dashboard as code. Understanding the Syslog format To build the dashboard, you first need to understand how log severities are defined in the Syslog RFC-5424 format. The PRI part of a syslog, which is a calculated priority value, is used to represent both the facility and severity of the log or event message. PRI calculates the value by first multiplying the facility number by 8 and then adding the numerical value of the severity. For example, a security/authorization (facility = 4) with a critical severity (severity = 2) would have a PRI value of 34 ((4 * 8) + 2). Based on this understanding, you can extract the log severity from the PRI log attribute using the following formula: (pri - ((floor(pri)/8) * 8)). Step 1: Create your Terraform project As an infrastructure-as-code tool that you can use to provision all kinds of infrastructure and services, Terraform uses a configuration language known as HCL. Its main purpose is to describe resources that are used to represent infrastructure objects. The resources are processed by specific plugins called providers. New Relic has an official Terraform provider. It allows you to manage different types of resources such as dashboards, alert channels, and alert policies. For more information about the Terraform provider, see the provider documentation and the quick-tip video shown here. Start by creating your project folder. Because Terraform is quite flexible and can be adapted depending on the requirements of your project (including multiple environments, multiple accounts, and so on), there are different ways of organizing a Terraform workspace. For simplicity’s sake, we’ll adopt a flat structure for this example. 1. Create a directory for your project. mkdir newrelic-syslog-monitoring 2. Create a file named versions.tf in your working directory. Terraform uses this file to configure the Terraform client and specify all required providers for the current module, in this case, the newrelic provider. terraform { required_version = \">= 0.13\" required_providers { newrelic = { source  = \"newrelic/newrelic\" version = \">= 2.12.0\" } } } 3. Provide input variables. The New Relic Terraform provider requires an Account ID, Personal Key, and Region (US or EU) to integrate with your account and manage resources. It supports two methods of configuration: using environment variables or a provider block. This simple example uses the provider block, and all required information is received through input variables. Create a file named variables.tf: variable \"NEWRELIC_ACCOUNT_ID\" { type    = number } variable \"NEWRELIC_API_KEY\" { type    = string } variable \"NEWRELIC_REGION\" { type    = string } 4. Create a file named main.tf to be the primary entry point for Terraform. The New Relic Terraform provider is also configured in this file using the input variables previously declared in the variables.tf file: provider \"newrelic\" { account_id = var.NEWRELIC_ACCOUNT_ID api_key    = var.NEWRELIC_API_KEY region     = var.NEWRELIC_REGION } Step 2: Create the Syslog dashboard All the dashboard data is retrieved from the Log data type using the NRQL query language. To simplify the queries and avoid repetition, use Terraform locals to represent the Syslog severity formula and the logType filter value. 1. Create a file named dashboards.tf. This file is used to describe the dashboard resource and its widgets/visualizations: locals { syslog   = \"syslog-rfc5424\" severity = \"(numeric(pri) - (floor(numeric(pri)/8) * 8))\" } resource \"newrelic_dashboard\" \"syslog_dashboard\" { title             = \"Syslog Dashboard\" grid_column_count = 12 } 2. Add widgets and visualizations. The first step in designing your dashboard is to define what you want to achieve and which visualizations will be most important to enable that. For this example, the dashboard gives an overview of application health. Note: All widget code goes inside the \"syslog_dashboard\" {...} block. Widget 1: Billboard counters by severity The log's severity is one of the most important fields available in the Syslog format and is widely used on this dashboard's visualizations. Billboard charts show the log counters by severity, coloring them yellow or red depending on the threshold_yellow and threshold_red values. The charts make it easy to see what's happening with your applications and catch your attention if any problematic log arrives. Because these billboard charts share nearly identical code, you can take advantage of Terrafrom's dynamic blocks and reuse the code to iterate through a severity_billboards map to configure every widget. To accomplish this, add a severity_billboards map inside the locals{...} block with the following content: locals { syslog   = \"syslog-rfc5424\" severity = \"(numeric(pri) - (floor(numeric(pri)/8) * 8))\" severity_billboards = tomap({ \"emergency\"     = { severity =  0, row = 1, column = 1, threshold_red = 1 }, \"alert\"         = { severity =  1, row = 2, column = 1, threshold_red = 1 }, \"critical\"      = { severity =  2, row = 1, column = 2, threshold_red = 1 }, \"error\"         = { severity =  3, row = 2, column = 2, threshold_yellow = 1 }, \"warning\"       = { severity =  4, row = 1, column = 3 }, \"notice\"        = { severity =  5, row = 2, column = 3 }, \"informational\" = { severity =  6, row = 1, column = 4 }, \"debug\"         = { severity =  7, row = 2, column = 4 } }) } Then add generic code for the widget inside the syslog_dashboard\" {...} block: dynamic \"widget\" { for_each = local.severity_billboards content { title            = \"\" nrql             = <<-EOF SELECT count(*) as '${title(widget.key)} (${widget.value.severity})' FROM Log WHERE logType = '${local.syslog}' AND ${local.severity} = ${widget.value.severity} EOF visualization    = \"billboard\" width            = 1 height           = 1 row              = widget.value.row column           = widget.value.column threshold_yellow = try(widget.value.threshold_yellow, null) threshold_red    = try(widget.value.threshold_red, null) } } Your final result should look similar to this:   Widget 2: Billboard for log throughput This chart shows the total number of logs and the rate per minute your applications are sending them. widget { title         = \"Throughput\" nrql          = <<-EOF SELECT rate(count(*), 1 minute) as 'Logs /min', count(*) as 'Total' FROM Log WHERE logType = '${local.syslog}' SINCE 1 hour ago EOF visualization = \"attribute_sheet\" width         = 2 height        = 2 row           = 1 column        = 5 } Your final result should look like this:   Widget 3: Line chart to view problem-related trends over time This chart counts all logs with severity equal to Error(3), Critical(2), Alert(1) or Emergency(0) and displays the result over time. Spikes on this graph show that you might have problems with your applications that require actions to be taken to resolve them. widget { title         = \"Logs (Emergency + Alert + Critical + Error)\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' AND ${local.severity} < 4 TIMESERIES AUTO EOF visualization = \"line_chart\" width         = 6 height        = 3 row           = 3 column        = 1 } Your final result should look something like this:   Widget 4: Bar charts by application and node These charts show the number of logs by application and hostname. They can also be configured to filter the current dashboard just by clicking on the application/hostname bars. widget { title         = \"Top Applications\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET app.name EOF visualization = \"facet_bar_chart\" width         = 2 height        = 5 row           = 1 column        = 7 } widget { title         = \"Top Nodes\" nrql          = <<-EOF SELECT count(*) as 'Logs' FROM Log WHERE logType = '${local.syslog}' FACET hostname EOF visualization = \"facet_bar_chart\" width         = 2 height        = 5 row           = 1 column        = 9 } Your final result should look similar to this:   Widget 5: Line charts to view log counters by severity and facility over time The idea behind these charts is to display the number of logs by severity and facility your applications are sending over time. This way you can easily detect spikes of any severity or facility and identify when they started and stopped. widget { title         = \"Logs by Severity\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET string(${local.severity}) as 'Severity' TIMESERIES AUTO EOF visualization = \"faceted_line_chart\" width         = 3 height        = 3 row           = 6 column        = 1 } widget { title         = \"Logs by Facility\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET floor(numeric(pri)/8) as 'Facility' TIMESERIES AUTO EOF visualization = \"faceted_line_chart\" width         = 3 height        = 3 row           = 6 column        = 4 } Your final result should look similar to this:   Widget 6: Event table to display the top 100 logs This chart displays the 100 most important logs prioritized by severity. widget { title         = \"Top 100 Logs\" nrql          = <<-EOF SELECT ${local.severity} as 'Severity', app.name as 'Application', message FROM Log WHERE logType = '${local.syslog}' LIMIT 100 EOF column        = 7 row           = 6 visualization = \"event_table\" width         = 6 height        = 3 } Your final result should look like this:   Widget 7: Markdown summary for Syslog facilities This chart lists the names of the syslog facilities on your dashboard for easy reference. widget { title         = \"\" width         = 2 height        = 5 row           = 1 column        = 11 source        = <<-EOF ### Facilities 1. kernel messages 2. user-level messages 3. mail system 4. system daemons 5. security/authorization messages (note 1) 6. messages generated internally by syslogd 7. line printer subsystem 8. network news subsystem 9. UUCP subsystem 10. clock daemon (note 2) 11. security/authorization messages (note 1) 12. FTP daemon 13. NTP subsystem 14. log audit (note 1) 15. log alert (note 1) 16. clock daemon (note 2) to 23. local uses 0 to 7 (local n) EOF visualization = \"markdown\" } Your final dashboard should look similar to this: markdown summary for syslog facilities example   Step 3: Apply your code You can install the Terraform client either by downloading the binary from www.terraform.io/downloads.html or using your operating system's package manager. More instructions on how to install Terraform in different environments can be found here. After you install the Terraform client, run the following command in your working directory: terraform plan -var NEWRELIC_ACCOUNT_ID=<YOUR-ACCOUNT-ID> -var NEWRELIC_API_KEY=<YOUR-API-KEY> \\ -var NEWRELIC_REGION=<US or EU> The terraform plan command creates an execution plan and then determines which actions are necessary to achieve the desired state specified in the configuration files. In this case, your dashboard resource is added. Finally, run the following command to apply all pending actions and create the resources in the New Relic One platform: terraform apply -var NEWRELIC_ACCOUNT_ID=<YOUR-ACCOUNT-ID> -var NEWRELIC_API_KEY=<YOUR-API-KEY> \\ -var NEWRELIC_REGION=<US or EU> Terraform uses states to map your local resources to the real world. When you have a declared resource such as resource \"newrelic_dashboard\" in your files, Terraform uses the map to know that the New Relic Dashboard ID 1234 is represented by that resource. That said, if you apply this project in different machines without sharing the state, Terraform will recreate all resources instead of updating them. Setting up a remote state would prevent this situation. HashiCorp offers a Terraform Cloud solution that automates Terraform workflow out of the box. It's also possible to use Atlantis, which is a tool that automates Terraform through pull requests, taking your observability as code to the next level. Step 4: Add alerts for real-time notification Although dashboards are essential tools for detecting and troubleshooting problems, unless you’re watching them 24 hours a day, you can miss important logs. Setting up alerts gives you instant notification whenever an important metric hits a threshold. New Relic alerts help you solve your application issues faster and with less noise before they turn into critical incidents. New Relic’s third-party integrations, such as PagerDuty and Slack, make the notification process very efficient and adaptable to your team’s needs. The New Relic Terraform provider supports all required alerting resources to monitor your syslog applications. You can, for example, create different alert channels per team, responsibility, node, or application, notifying different people in various ways when applications are reporting errors. For the example, you can reuse the dashboard queries and define the following NRQL alert conditions: A static threshold alarm for critical severities Error(3), Critical(2), Alert(1) and Emergency(0). Baseline alarm in upper direction for log counters with severity < 4 to detect abnormal unhealthy spikes. Additional alerts depending on your environment and system characteristics, such as a static alert for logs with severity < 4 and facility equal to security/authorization messages(4), which would appropriately send a notification message to the #security-team Slack channel, for example, and not the whole company. (For more information about New Relic alerts with Terraform, see this blog post.) Ready to create a Syslog dashboard? All the code used in the example can be found in this GitHub repository. If you don't want to use Terraform but would like to try out the dashboard, you can import it by copying this JSON file content, replacing the <YOUR_ACCOUNT_ID> placeholder with your Account ID, and importing it into New Relic using the UI (Dashboard > Import dashboard option). If you’re new to New Relic and want to try out the New Relic Terraform provider, sign up for a new account with 100 GB/month of free ingest. By Edmo Vamerlatti Edmo is a Software Engineer at New Relic, where he works on the Logging team. His professional interests include distributed systems, high scalability, observability, and programming languages. In his spare time, he enjoys reading, eating out in restaurants, and skateboarding. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.38972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dashboards as Code: How to Create a Syslog Dashboard Using New Relic and <em>Terraform</em>",
        "sections": "Step 4: Add <em>alerts</em> for real-time <em>notification</em>",
        "body": " and facility equal to security&#x2F;authorization messages(4), which would appropriately send a <em>notification</em> message to the #security-team Slack <em>channel</em>, for example, and not the whole company. (For more information about New Relic <em>alerts</em> with <em>Terraform</em>, see this blog post.) Ready to create a Syslog dashboard"
      },
      "id": "6076263d28ccbcffe951c16a"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/embed/",
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps"
      ],
      "published_at": "2021-04-13T01:54:27Z",
      "title": "",
      "updated_at": "2021-04-04T01:53:18Z",
      "type": "",
      "external_id": "ddf0ca28ab311ff372e8955f2ef022de99716131",
      "popularity": 1,
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.98834,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": "Access the <em>New</em> <em>Relic</em> platform from the comfort of your terminal. You can use the <em>New</em> <em>Relic</em> <em>CLI</em> to manage <em>entity</em> <em>tags</em>, define workloads, record <em>deployment</em> <em>markers</em>, and much more. In short, you can use the <em>CLI</em> to automate common tasks in your DevOps workflow. This guide walks you through"
      },
      "id": "60691c0ee7b9d2f79094463b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/embed/",
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-04-02T01:54:45Z",
      "type": "",
      "external_id": "c42a52759fcbe676670d61e60c9aa5e269edcccd",
      "popularity": 1,
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.33983,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " of your entities. Before you begin For this guide you need a <em>New</em> <em>Relic</em> user <em>key</em>: You can view and create them in the <em>API</em> keys UI. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including"
      },
      "id": "60667965196a67a9c347e810"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:51Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.37125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Most Popular <em>New</em> <em>Relic</em> One Applications (Round up #3)",
        "sections": "<em>Deployment</em> Analyzer",
        "body": " as related access to <em>New</em> <em>Relic</em> One. What are you waiting for? <em>Deploy</em> these apps now! To <em>deploy</em> any of these apps you need: Access to <em>New</em> <em>Relic</em> One (Requires a paid <em>New</em> <em>Relic</em> account and use of a supported browser) The <em>New</em> <em>Relic</em> One <em>CLI</em> A personal <em>New</em> <em>Relic</em> <em>API</em> <em>key</em>  Node v10 or higher A GitHub account  Once"
      },
      "id": "60762e1f196a673d0a64a782"
    },
    {
      "image": "https://developer.newrelic.com/static/futurestack-registration-86e612c0605fb3c49cfd28f35977135d.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Futurestack: Master Observability",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-04-13T01:37:02Z",
      "title": "New Relic Developers",
      "updated_at": "2021-04-06T01:39:15Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Data Nerds, get ready to hack the future. Level Up your observability game at Futurestack 2021. Rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 28 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 206.91617,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Report Zipkin-format traces via Trace API",
        "Zipkin version requirements",
        "Overview of using the Trace API",
        "Send sample Zipkin trace payload",
        "Send Zipkin-format payload",
        "Send data from existing Zipkin instrumentation",
        "Transformation of Zipkin data",
        "Add other tags/attributes"
      ],
      "title": "Report Zipkin-format traces via Trace API",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Trace API"
      ],
      "external_id": "dba8334d1f068236c741ff04c13ecc2be2c184fc",
      "image": "https://docs.newrelic.com/static/96e69137f0dd86b313ec72d5f0c1ad83/119c7/Screen-Shot-2020-08-13-at-1.26.17-PM.png",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/trace-api/report-zipkin-format-traces-trace-api/",
      "published_at": "2021-04-12T11:45:27Z",
      "updated_at": "2021-04-10T16:18:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to create your own tracing implementation, you can use our Trace API. This doc explains how to send Zipkin-format trace data to our Trace API. (For our general data format, see New Relic format.) Zipkin version requirements The Trace API supports data from Zipkin JSON v2 (or higher) without any modification. For details on this version, see Zipkin v2 release details and the Zipkin v2 schema. Overview of using the Trace API Using our Trace API is as simple as: Sending trace data in the expected format (in this case, zipkin format). Sending that data to the appropriate endpoint Our send-data instructions have options for enabling Infinite Tracing. To learn more about this, see Intro to Infinite Tracing and Sampling considerations. To get started using the Trace API, choose an option: Send a sample trace: This shows a curl example of sending a trace to New Relic. This is useful for understanding how the Trace API works, and to verify you're seeing data in New Relic. Report data from existing Zipkin instrumentation: if you have an existing Zipkin implementation, you can simply change the endpoint of where your data gets sent. Send sample Zipkin trace payload This section describes how to send a simple Zipkin-format trace to our Trace API via curl request. You might choose to do this in order to learn how our API works and to verify that data is showing up in New Relic before doing in-depth instrumentation. To get started sending a sample payload: (Optional, to enable Infinite Tracing) First, you must set up a trace observer. That procedure includes instructions for sending a sample trace using our general new-relic format. When you get to that step, return here to instead learn how to send a Zipkin-format trace. Send a Zipkin-format payload following the instructions below. Send Zipkin-format payload To send a sample Zipkin-format trace: Get an Insights insert key: Go to the API keys UI and select Insights insert keys. If you don't already have a key, create a new one by selecting Insert keys +. You'll be executing a curl request, below. Notes on this: Replace the insert key placeholder with your insert key. If you're using Infinite Tracing, use the YOUR_TRACE_OBSERVER_URL value in place of the standard endpoint. If you want to send more than one post, change the trace ID to a different value. Sending the same payload or span id multiple times for the same traceId may result in fragmented traces in the UI. curl -i -H 'Content-Type: application/json' \\ -H 'Api-Key: $NEW_RELIC_INSERT_KEY' \\ -H 'Data-Format: zipkin' \\ -H 'Data-Format-Version: 2' \\ -X POST \\ -d '[ { \"traceId\": \"test-zipkin-trace-id-1\", \"id\": \"3e0f5885710776cd\", \"kind\": \"CLIENT\", \"name\": \"post\", \"duration\": 508068, \"localEndpoint\": { \"serviceName\": \"service-1\", \"ipv4\": \"127.0.0.1\", \"port\": 8080 }, \"tags\": { } }, { \"traceId\": \"test-zipkin-trace-id-1\", \"parentId\": \"3e0f5885710776cd\", \"id\": \"asdf9asdn123lkasdf\", \"kind\": \"CLIENT\", \"name\": \"service 2 span\", \"duration\": 2019, \"localEndpoint\": { \"serviceName\": \"service-2\", \"ipv4\": \"127.0.0.1\", \"port\": 8080 }, \"tags\": { \"error.message\": \"Invalid credentials\" } } ]' 'https://trace-api.newrelic.com/trace/v1' Copy Within a minute, the trace should be available in the our distributed tracing UI. To find it, run a query for the trace.id. In this example, it was test-zipkin-trace-id-1. Note that you search by the transformed attribute of trace.id (not traceId). To learn more: Learn where Trace API data shows up in the UI. Send data from an existing Zipkin instrumentation. Learn how to decorate spans by adding tags. This helps you customize how traces are displayed in our UI for a richer, more helpful experience. Learn about general endpoint information (data limits, required metadata, and response validation). Learn about how Zipkin data is transformed and stored in our format. If you don't see your trace data, see Troubleshooting. Send data from existing Zipkin instrumentation Preliminary notes: If you want to enable Infinite Tracing, you first must set up a trace observer. It can be helpful to first send a sample payload to verify things are working properly. To report data from an existing Zipkin instrumentation, you'll point the Zipkin tracer at the appropriate Trace API endpoint with some required request metadata. You can send the required metadata as headers or query parameters (some Zipkin tracer versions don't allow specifying HTTP headers). Here's an example of what it might look like to create a Zipkin OkHttpSender in Java configured for the Trace API: OkHttpSender.create(\"https://trace-api.newrelic.com/trace/v1?Api-Key=NEW_RELIC_INSERT_API_KEY&Data-Format=zipkin&Data-Format-Version=2\"); Copy Note that if you were using Infinite Tracing, or had an EU-region New Relic account, the endpoint would be different. For an explanation of Api-Key and the other metadata, see Request metadata. Transformation of Zipkin data To create a consistent search/query experience, some Zipkin data will be transformed to match New Relic attribute naming. For more on how we store and structure trace data, see How distributed tracing works. Zipkin tag Stored in New Relic as... Details traceId trace.id Unique identifier for a trace. id id Unique identifier for a span. parentId parent.id Identifier of the upstream span that called the service. kind kind Either Client or Server. name name Name of span. duration duration.ms Zipkin v2 spans must have durations specified in microseconds, and will be converted to milliseconds. localEndpoint: serviceName service.name We use the Zipkin v2 service name to identify the entity that created this span. localEndpoint: port localEndpoint.port All values in the localEndpoint object will be flattened to a span attribute called localEndpoint.key tags reported as attributes Key:value pairs in the tags object in Zipkin v2 will be written as span attributes. annotations not supported We do not currently support annotations in the Trace API. Spans will not be rejected if they contain annotations, but the annotations data will not be written. Add other tags/attributes You can add any tags you want to the tags block, with the exception of the restricted tags. For example, you might want to add attributes like customer.id or user.id to help you analyze your trace data. Tags will be converted to New Relic attributes. To learn how to control how spans appear in New Relic (for example, adding errors or setting a span as a datastore span), see Decorate spans.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.22272,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report Zipkin-format traces via Trace <em>API</em>",
        "sections": "Add other <em>tags</em>&#x2F;attributes",
        "tags": "Trace <em>API</em>",
        "body": " for the same traceId may result in fragmented traces in the UI. curl -i -H &#x27;Content-Type: application&#x2F;json&#x27; \\ -H &#x27;<em>Api</em>-<em>Key</em>: $<em>NEW_RELIC_INSERT_KEY</em>&#x27; \\ -H &#x27;Data-Format: zipkin&#x27; \\ -H &#x27;Data-Format-Version: 2&#x27; \\ -X POST \\ -d &#x27;[ { &quot;traceId&quot;: &quot;test-zipkin-trace-id-1&quot;, &quot;id&quot;: &quot;3e0f5885710776cd&quot;, &quot;kind&quot;: &quot;CLIENT"
      },
      "id": "6071cfc864441fa88f9d8530"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/NRBlog_20181107_S7_AWS-EC2-tagging-integration.png",
      "url": "https://newrelic.com/blog/how-to-relic/new-relic-infrastructure-getting-started-best-practices",
      "sections": [
        "Getting organized and getting started",
        "Create a naming convention",
        "Implement a tagging structure",
        "Create a filter set",
        "Understanding your UI",
        "Apply a filter",
        "Making data actionable",
        "Using New Relic Insights queries",
        "Set up New Relic Alerts",
        "Monitor your apps, and their hosts, in one place",
        "Ready to learn more?",
        "Related Topics"
      ],
      "published_at": "2021-04-14T00:02:29Z",
      "title": "Getting Started with New Relic Infrastructure: Best Practices That Set You up for Success",
      "updated_at": "2021-04-14T00:02:29Z",
      "type": "",
      "external_id": "78d3925eba18b334c1df9469f34071151e6d3b82",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Infrastructure Monitoring Getting Started with New Relic Infrastructure: Best Practices That Set You up for Success Nov 8, 2018 • 7 min read By New Relic Community Team The following is adapted from a series of best practice guides that reflect the New Relic Community Team’s work with thousands of customers—identifying challenges and coming up with actionable solutions for organizations getting started with New Relic Infrastructure. Also, check out our guides to getting started with New Relic APM, New Relic Mobile, New Relic Insights, New Relic Browser, and New Relic Synthetics; and discover the New Relic Community Team’s latest Best Practice Guide offerings. Improving application performance involves more than just your company’s software. It also demands visibility into your application infrastructure: the servers and hosts, and the supporting network and storage resources, that power your applications and make them available to users. New Relic Infrastructure offers a powerful set of solutions to your organization’s infrastructure visibility challenges. Infrastructure lets you look into host resource usage—locally or in the cloud—and also lets you monitor events on your hosts, inventory metrics, and network or storage availability.  Infrastructure makes it easy to track all of these resources, and to correlate any changes to potential impacts on your host and application performance. In this post, we will show you how to set up New Relic Infrastructure to make the most of this added visibility into your environment. (After reviewing these best practices—and, when possible, actually working with them in your organization's own environment—you’ll be ready to demonstrate your new skills by taking our Infrastructure Best Practices Quiz): Let’s dive into our list of best practices, organized based on the Infrastructure capabilities and tasks they address. Getting organized and getting started Create a naming convention Let’s begin with two of the most important tips for New Relic Infrastructure users: Decide upon an appropriate naming scheme and use it consistently. First, a simple naming scheme for all of the elements in your account can greatly reduce the amount of time you spend looking for pertinent information. When you devise a naming scheme and apply it consistently within a specific New Relic account—for example, <env (Prod/Staging)>-<Service Name>-<AWS Region>—the host name can supply the information you need to locate a problem and to identify the right person to fix it.  Learn more about applying a naming scheme to your New Relic Infrastructure environment in our docs: Updating display names in your Infrastructure configuration file. Implement a tagging structure Tags are integral to organizing the hosts within your environment. They allow you to spot problems more easily by sorting and filtering groups of hosts; for example, you can add the same attribute to a number of hosts to identify them later, using the Infrastructure UI or NRQL queries. If your hosts are in Amazon Web Services (AWS), then New Relic Infrastructure’s Amazon EC2 integration makes the process of implementing tagging remarkably simple. Any EC2 tags you add to your hosts within AWS will carry over to New Relic, allowing you to group your hosts without extra configuration. New Relic Infrastructure's Amazon EC2 integration is one of more than 50 cloud and on-host integrations that make tasks such as tagging simpler—yet also more powerful. If you’re not using AWS EC2, New Relic Infrastructure supports more than 50 other cloud and on-host integrations, in addition to offering custom attributes that you can tailor to meet your organization’s needs. Learn more about implementing tagging using either AWS EC2 integration or custom attributes in our documentation: AWS EC2 Monitoring Integration Configure the Infrastructure Agent: Custom Attributes Create a filter set Filter sets let you target any number of hosts based on a variety of attributes, including tags, hostNames, etc. You can then target filter sets with alert conditions, which saves you the time required to apply a condition to multiple hosts manually. You can also alter the charts in the Infrastructure UI to focus in on a specific filter set—letting you concentrate on the hosts that matter most to you. Learn more about using Infrastructure Filter Sets in our docs: Filter Sets: Organize Your Hosts. Understanding your UI Apply a filter By default, the New Relic Infrastructure UI shows you data for all reporting hosts. Depending on the number of hosts that you’re monitoring, applying a filter set to the UI can make your monitoring data much easier to assess and interpret. You can create filter sets that apply to hostnames, or EC2 tags, or any other attributes that matter to you. When you apply them, the UI will focus only on matching hostnames. When you apply a filter set, it carries through to all parts of the Infrastructure UI—keeping you informed only on the hosts you need to know about. Learn more about using New Relic Infrastructure filter sets in New Relic University: Using Filter Sets and Groups in New Relic Infrastructure. New Relic Infrastructure makes it easy to configure filter sets based on a wide range of attributes, and to target filter sets by alert conditions. Making data actionable Using New Relic Insights queries New Relic Insights gives you a powerful way to ask questions of your data—and that’s especially true for New Relic Infrastructure users. We work hard, for example, to ensure that Infrastructure data is tracked as event-based data that you can query quickly and easily, and that any chart created within Infrastructure is also available within Insights at the click of a button. In addition, when you set up Infrastructure integrations, the setup process automatically creates a number of Insights dashboards—helping to make these integrations more valuable, more quickly, for you. Learn more about the shared data and views within New Relic Infrastructure and Insights in our documentation: Share Infrastructure data and view in Insights. New Relic Insights gives users a powerful yet easy to use set of tools for querying data generated while working with New Relic Infrastructure. Set up New Relic Alerts Alerts are critical factor to the monitoring process: What’s the point of monitoring if you don’t know when your applications or infrastructure is having problems are misbehaving?  New Relic Alerts allows you to configure notifications using a variety of popular messaging and communication platforms (Slack, OpsGenie, PagerDuty, etc.), as well as a generic webhook to which you can send notifications. When you get started with Infrastructure Alerts, one of the first conditions we recommend is a “Host Not Reporting” condition. Learn more about alerting best practices, including tips on setting up a “Host Not Reporting” condition with these resources: Guide to Effective Alerting in Practice Intro to APM Alerting Create Infrastructure ‘Host Not Reporting’ condition New Relic supports quick and easy configuration of alert notifications using a variety of messaging programs. Monitor your apps, and their hosts, in one place Health maps provide a high-level view of your host and application health in relation to one another, prioritized by health status. As long as you have both an APM and Infrastructure subscription, you can use health maps to gain dashboard-style visibility into potential problems—making it easier to find, diagnose, and fix them quickly. Learn more about New Relic health maps in the video demo below, or in the New Relic docs: Introduction to health maps. Ready to learn more? Looking for more Infrastructure best practices and tips? Check out the Infrastructure Level Up page in the New Relic Explorers Hub for a wealth of community-generated resources on these and related topics. And when you feel you’re ready, test your new Infrastructure skills by taking our Infrastructure Best Practices Quiz and earning your proficiency badge! Related Topics Infrastructure Monitoring By New Relic Community Team Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.4523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Implement a <em>tagging</em> structure",
        "body": " environment in our docs: Updating display names in <em>your</em> Infrastructure configuration file. Implement a <em>tagging</em> structure Tags are integral to organizing the hosts within <em>your</em> environment. They allow you to spot problems more easily by sorting and filtering groups of hosts; for example, you can add the same"
      },
      "id": "6076311528ccbc61fd51c159"
    },
    {
      "sections": [
        "NerdGraph tagging API tutorial",
        "Read tags for an entity",
        "Add tags for an entity",
        "Remove a tag from an entity",
        "Delete specific tag values for an entity",
        "Replace all tag values for an entity"
      ],
      "title": "NerdGraph tagging API tutorial",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "b62313b6fa10ab235c031feae23d6fe52163b703",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial/",
      "published_at": "2021-04-12T04:28:59Z",
      "updated_at": "2021-03-16T07:06:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can add tags to your data to help improve data organization and findability. Learn more about tagging at New Relic. This doc explains how to use our NerdGraph API to add and manage tags. For a guide to automating tags using our CLI tool, see our developer site. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to find the entity and then fetch its tags. Use NerdGraph's tag API to read the existing tags and their values. In this example, our entity is a browser app called Cookie Checkout: { actor { entitySearch (query: \"name like 'Cookie Checkout'\") { results { entities { tags { key values } } } } } } Copy The actual values vary depending on your data. Use the New Relic GraphiQL explorer to experiment with queries. Add tags for an entity To add new tags for an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity you want to tag. Use the taggingAddTagsToEntity mutation to add a tag with a value to the entity. In this example, we have a browser application called Cookie Checkout owned by a UI team. We want to add a team tag with a ui value to this instance. Once the tag is added, we can filter by the tag team:ui and find the Cookie Checkout app in the New Relic One UI. mutation { taggingAddTagsToEntity ( guid: \"ENTITY_GUID\", tags: { key: \"team\", values: [\"ui\"]}) { errors { message } } } Copy Remove a tag from an entity To delete a tag and all of its associated values from an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagFromEntity mutation. The following example mutation removes the team tag from an entity: mutation { taggingDeleteTagFromEntity ( guid: \"ENTITY_GUID\", tagKeys: [\"team\"]) { errors { message } } } Copy Delete specific tag values for an entity Instead of deleting an entire tag and all of its values, you can delete a single tag value. Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagValuesFromEntity mutation. The following example mutation deletes the ui value from the tag key: mutation { taggingDeleteTagValuesFromEntity ( guid: \"ENTITY_GUID\", tagValues : [{key: \"team\" value: \"ui\"}]) { errors { message } } } Copy Because tagValues is an array, you can delete multiple specific values from a single entity in one mutation. Replace all tag values for an entity To replace the entity’s entire set of tags with the provided tag set: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingReplaceTagsOnEntity mutation. In this example, the Cookie Checkout browser application was transferred from the ui team to the cookie-dev team. You can replace the tag values for team with the following mutation: mutation { taggingReplaceTagsOnEntity ( guid: \"ENTITY_GUID\", tags: {key: \"team\" values: [\"cookie-dev\"]}) { errors { message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.87831,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph <em>tagging</em> API tutorial",
        "sections": "NerdGraph <em>tagging</em> API tutorial",
        "body": " the <em>taggingDeleteTag</em>FromEntity mutation. The following example mutation removes the team <em>tag</em> from an entity: mutation { <em>taggingDeleteTag</em>FromEntity ( guid: &quot;ENTITY_GUID&quot;, <em>tag</em>Keys: [&quot;team&quot;]) { errors { message } } } Copy Delete specific <em>tag</em> values for an entity Instead of deleting an <em>entire</em> <em>tag</em> and all of its values, you can"
      },
      "id": "603ec1c6196a67eeada83d9a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Roundup1.png",
      "url": "https://newrelic.com/blog/nerdlog/feature-updates-browser-synthetics-mobile-2020",
      "sections": [
        "Enable or disable cookie collection in New Relic Browser",
        "Drop noisy or sensitive data from your New Relic Browser agent",
        "Deploy synthetic monitors from your Kubernetes environments",
        "More global locations to monitor uptime and performance",
        "Optimize React Native application performance",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:34:08Z",
      "title": "Roundup: Recent Improvements to Digital Experience Monitoring Solutions",
      "updated_at": "2021-04-13T23:34:08Z",
      "type": "",
      "external_id": "81e2d0692ad6246491654e626dd04cff94352188",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Digital Experience Monitoring Roundup: Recent Improvements to Digital Experience Monitoring Solutions Jun 2, 2020 • 7 min read By Mat Ball The software engineering teams using New Relic to measure websites, mobile apps, and critical user endpoints are passionate about efficiency, optimization, and performance. As a result, we receive a lot of customer feedback and feature requests. In today’s rapidly-changing environments, you want seamless integrations for the technologies and processes you’re already using. Some of your requests have reflected your needs to comply with regional regulations for collecting end-user data, such as General Data Protection Regulation (GDPR)  and the need to more easily monitor uptime and performance of critical endpoints within your existing technological ecosystems, such as Kubernetes clusters and React Native applications. We’ve heard you. And as a result, we have some exciting updates to share about new ways to handle your user data, endpoint monitoring, and mobile applications. Enable or disable cookie collection in New Relic Browser If you’re based in  Europe—or any area that requires compliance for tracking end-user data online—New Relic Browser now gives you the ability to enable or disable the use of cookies and cookie collection. Because cookies track user actions, they’re subject to regulation in some regions. Europe’s Privacy and Electronic Communications Regulation (PECR) and GDPR require sites to detail what cookies do, and ask consent from users before placing cookies. In the United States, the California Consumer Privacy Act (CCPA) doesn’t require businesses to gain consent, but it does necessitate disclosure of what companies do with collected data. New Relic Browser users can now toggle on or off a switch allowing them to determine if they collect cookies by default. This ensures compliance for Browser users when collecting user data. To learn more, visit our docs page, “New Relic cookies used by Browser.” Drop noisy or sensitive data from your New Relic Browser agent Data dropping enables you to drop data at ingest so that it’s not stored in the New Relic Database (NRDB). You have the ability to drop entire data types or subsets and to drop attributes from data types. By dropping data you can: More effectively manage cost, choosing to drop data deemed to be low value Better handle sensitive data, such as credit card information, social security numbers, or other personally identifiable information (PII) For more, check out our blog post, \"How to Drop Data in New Relic.\" Deploy synthetic monitors from your Kubernetes environments If you missed it, you can now automatically deploy synthetic private locations from Kubernetes environments. This removes the manual process for deploying synthetic tests and helps you easily monitor uptime and performance of employee-facing applications, services, APIs, as well as any critical endpoint existing behind your firewall. As you’re using Kubernetes to build and scale faster, you can easily and automatically combine synthetic tests to ensure coverage as you continuously deliver improvements. Previously, we launched containerized private minions to help you easily incorporate uptime monitoring into the build process as you tested employee-facing applications behind your firewall. New Relic users can now add private minions into their Kubernetes environments. With our latest update, New Relic Synthetics is meeting you where you are—within the systems you’re using—to automate and manage your build and deployment processes. You now have an easier way to automate and ensure that your critical endpoints are available and performant as you rapidly change and scale your systems. Read this blog post to get started. More global locations to monitor uptime and performance New Relic Synthetics is also giving you more locations to choose to measure uptime and performance of your critical endpoints. Previously, we added: Stockholm, Sweden; Hong Kong, China; and Manama, Bahrain. Today we’re excited to announce the availability of Cape Town, South Africa, and Milan, Italy. With these new additions, you can proactively simulate user traffic to measure uptime and performance from locations closer to your end-users and customers. New Relic Synthetics easily tracks uptime and SLAs for your services, URLs, and API endpoints, and provides performance data on how fast your pages, their resources, and your third-party components take to load. Optimize React Native application performance As a reminder, React Native developers can use our open beta React Native agent to monitor their pre-production applications to optimize their performance for stable, fast, and reliable React Native apps. Previously, React Native developers have been unable to use New Relic Mobile APM because our current agent is built for native frameworks (iOS and Android). As of March 2020, React Native developers can use our open beta React Native agent to monitor their pre-production applications to optimize their performance for stable, fast, and reliable React Native apps. We’ve received an amazing response for this beta, and don’t want you to miss out. Read more about the open beta, and sign up now.  Related Topics Digital Experience Monitoring By Mat Ball Mat Ball is a product marketing manager at New Relic focused on the impact of frontend web applications to business and customer experience outcomes. Previously, Mat worked for SOASTA, where he marketed their data science product. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.79872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Drop noisy or sensitive data from <em>your</em> New Relic Browser agent",
        "body": " or sensitive data from <em>your</em> New Relic Browser agent Data dropping enables you to drop data at ingest so that it’s not stored in the New Relic Database (NRDB). You have the ability to drop <em>entire</em> data types or subsets and to drop attributes from data types. By dropping data you can: More effectively manage"
      },
      "id": "60762a70196a6705ee64a7b3"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/SynthKub1.png",
      "url": "https://newrelic.com/blog/how-to-relic/deploy-synthetics-from-kubernetes-environments",
      "sections": [
        "Benefits of connecting New Relic Synthetics and Kubernetes",
        "How to get started with New Relic Synthetics and Kubernetes",
        "To monitor the CPM using the Kubernetes cluster explorer",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:54:48Z",
      "title": "Deploy Synthetics from Kubernetes Environments to Monitor Employee-Facing Applications",
      "updated_at": "2021-04-13T23:54:47Z",
      "type": "",
      "external_id": "fe7c715c1417af64bd4c5ffc1871739a673484f8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring Deploy Synthetics from Kubernetes Environments to Monitor Employee-Facing Applications May 13, 2020 • 7 min read By Mat Ball Kubernetes helps increase the velocity of deployments, improve infrastructure durability, and automate the building, running, and maintaining of applications throughout your production environments. To optimize performance, New Relic released the Kubernetes cluster explorer so you can quickly understand the health of your rapidly-scaling environments of pods, containers, and applications. Synthetic testing and monitoring allows you to proactively test the availability and performance of your critical endpoints.  We launched containerized private minions to help you easily incorporate uptime monitoring into the build process as you tested employee facing applications behind the firewall. For these reasons, we’re excited to announce that New Relic users can now add private minions into their Kubernetes environments. This new feature offers our customers the ability to automatically deploy synthetic private locations and run monitors alongside them as part of a Kubernetes deployment. In short, New Relic Synthetics is meeting you where you are—within the systems you’re using—to automate and manage your build and deployment processes. You now have an easier way to automate and ensure that your critical endpoints are available and performant as you rapidly change and scale your systems. Benefits of connecting New Relic Synthetics and Kubernetes We’ve made Synthetics compatible with your Kubernetes orchestration software, enabling you to use Kubernetes to monitor availability and performance from Synthetic’s private locations, such as those behind a firewall or not exposed to the public. Leveraging Kubernetes to automate and manage these private locations helps developers save time and reduce manual efforts. Use the private minion Helm charts to easily include a private location in your next Kubernetes deployment. Once the location is created, add it to your existing Synthetics monitors, and you’ll be up and running in minutes. Leave the scaling and reliability concerns to Kubernetes. We have designed our private minion so that Kubernetes has full control over the resources and containers. The Helm charts allow you to use our recommended default resources or provide you with the ability to define the resource allocation per synthetics check. This helps you focus more on remediating latency and improving reliability, and less on configuration and instrumentation. Even more, we offer additional visibility of the Kubernetes host itself. Using the New Relic Kubernetes cluster explorer you can quickly see the health and status of your private location, alongside the other containers running in your Kubernetes environment. You can also easily view stats and errors about your private location, and understand how widespread issues might be across other applications running on the same cluster. This way, New Relic customers leveraging Kubernetes can simultaneously deploy a new version of their application alongside APM and Synthetics. The feature makes it easy by leveraging Helm charts on Kubernetes, which automatically provide reference configurations, steps for deployment, and resource requirements. If an application experiences issues and is re-deployed per the Kubernetes automated deployment process, Synthetics is also redeployed with no additional configuration needed. How to get started with New Relic Synthetics and Kubernetes Confirm you meet the Kubernetes container orchestration system environment requirements. Locate your private location key.  Go to synthetics.newrelic.com > Private locations.In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Set up a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com/charts If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Install the CPM using the Helm charts: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY To update an existing CPM installation: helm update YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YO Next, connect into New Relic’s Kubernetes cluster explorer. To monitor the CPM using the Kubernetes cluster explorer Locate your license key. Find your cluster name: kubectl config current-context Confirm you have kube-state-metrics installed: kubectl get deployment --all-namespaces | grep kube-state-metrics Select the cluster for the agent installation: kubectl config set-cluster DESIRED_CLUSTER Add the Helm charts: helm repo add stable https://kubernetes-charts.storage.googleapis.com/ Install the Kubernetes integration using the Helm charts, depending on whether you're using Helm 2 or Helm 3 Look up the Synthetics minion in your Kubernetes cluster explorer. For employee-facing applications, or any application not exposed to the public or behind the firewall, availability, and performance is critical to efficiency. Kubernetes orchestration software allows teams to quickly automate change and more easily manage the build and deploy process. Incorporating synthetic monitoring into Kubernetes software gives software engineers the ability to easily detect, isolate, and communicate problems of availability and performance for critical application endpoints. To learn more about how you can enable teams to proactively detect and resolve incidents faster by finding problems before they impact customers, check out New Relic Synthetics. Related Topics Kubernetes Monitoring By Mat Ball Mat Ball is a product marketing manager at New Relic focused on the impact of frontend web applications to business and customer experience outcomes. Previously, Mat worked for SOASTA, where he marketed their data science product. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.301346,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Benefits <em>of</em> connecting New Relic Synthetics and Kubernetes",
        "body": ", improve infrastructure durability, and <em>automate</em> the building, running, and maintaining of applications throughout <em>your</em> production environments. To optimize performance, New Relic released the Kubernetes cluster explorer so you can quickly understand the health of <em>your</em> rapidly-scaling environments of pods"
      },
      "id": "60762f4864441f45329d854f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/magnifying-glass-1-150x150.jpg",
      "url": "https://newrelic.com/blog/best-practices/site-reliability-engineer-sre-habits",
      "sections": [
        "Habit 1: You analyze every change in the context of the (much) bigger picture",
        "Habit 2: You’re pragmatic and forward-thinking about that analysis",
        "Habit 3: You are willing to move on when something isn’t actually helping",
        "Habit 4: You embrace every opportunity to automate",
        "Habit 5: You can persuade organizations to do what needs to be done",
        "Habit 6: You expand your existing skill set to include new tools and approaches",
        "Habit 7: You trust the process",
        "Related Topics"
      ],
      "published_at": "2021-04-14T00:12:34Z",
      "title": "7 Habits of Highly Successful Site Reliability Engineers",
      "updated_at": "2021-04-14T00:12:33Z",
      "type": "",
      "external_id": "de2da5d9b583508593d6c100d90bdd01f0ca0131",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit DevOps 7 Habits of Highly Successful Site Reliability Engineers Nov 13, 2017 • 7 min read By Kevin Casey In a recent post, we examined the rise of the Site Reliability Engineer in modern software organizations. But it’s one thing just to be called a SRE; we also wanted to know what it takes to become a great one. So we decided to look at some of the characteristics and habits common to highly successful SREs. As in most development and operations roles, first-class technical chops are obviously critical. For SREs, those specific skills might depend on how a particular organization defines or approaches the role: the Google approach to Site Reliability Engineering might require more software engineering and coding experience, whereas another organization might place a higher value on ops or QA skills. But as we found when we looked at what makes dev and ops practitioners successful, what sets the “great” apart from the “good enough” is often a combination of habits and traits that complement technical expertise. The seven habits outlined below were derived from extensive interviews with New Relic Software Engineer Beth Long and Site Reliability Engineer Jason Qualman. Let’s dive in: Habit 1: You analyze every change in the context of the (much) bigger picture Successful software developers understand how their code helps drive the overall business. SREs have their own version of this trait. “You’re looking for someone who is really thinking about the bigger picture outside of the day-to-day,” Jason says. “A successful SRE is someone who can understand and interpret things at a higher level than that.” At New Relic, we describe it internally as “someone who is constantly analyzing every change for its risk and what its impact could be down the road, not just today. And what does that mean for the larger infrastructure?” Habit 2: You’re pragmatic and forward-thinking about that analysis The best SREs take a pragmatic approach and consider how their work is going to affect the rest of a particular system or team. There’s little upside in a siloed approach that throws a change over the wall with no concern for how it might affect the person sitting on the other side. “We are making decisions very low in the stack,” Jason says of the SRE’s role. “Sometimes that can affect people all the way up. You need someone who can understand how their solution to a particular issue is going to affect someone else way down the road.” Habit 3: You are willing to move on when something isn’t actually helping For an SRE, part of being pragmatic means being willing to dump processes and procedures that may be well intentioned but don’t turn out to actually be productive. Beth recalls an internal example of this when New Relic was evolving its reliability practices. “A few years ago we were going through a phase of rapid growth, and to deal with any associated instability we implemented a ‘Change Acceptance Board’ (CAB) process. It was intended to help us evaluate releases before they went into production in order to prevent breaking changes from causing further incidents. The irony was that by slowing down our release cycle, we began to accumulate bigger and bigger changes, which had the exact opposite of the intended effect. These larger changes actually increased the risk associated with each release.” Eventually, the CAB process was scrapped in favor of more frequent but smaller releases, which yielded far better results. Habit 4: You embrace every opportunity to automate Top-notch SREs successfully cope with a key challenge: how to increase the reliability of everything they touch without slowing the company’s ability to ship software quickly. The solution is almost always automation. Great SREs are proactive about finding ways to address painful manual tasks, bugs, and so forth with new ways to automate that process or fix. “A lot of this role is thinking about inefficient and time-consuming things people are doing and putting a stop to them as soon as possible,” Jason explains. “Instead of kicking a can down the road on manual work, you’re saying, ‘I’m going to take the time to automate this right now and stop anyone else from having to do this painful thing.’” This obsessive focus on automation isn’t unique to New Relic—The DevOps Handbook has a chapter that discusses the counterintuitive effects of manual acceptance processes, for example. And “automation” and its variants seem to appear more often than any other word in SRE job descriptions. A recent opening at Procore Technologies in Los Angeles, which makes construction-management software, lists this as the second bullet point in its SRE job description: “Automate, automate, automate and then ... automate!” Habit 5: You can persuade organizations to do what needs to be done The confidence to advocate for a particular automation task or SRE initiative is another attribute that sets apart A-team SREs. You need to be willing to go to bat for why it’s critical to automate a particular process or other piece of work. And that can be problematic, because it can appear to clash with the culture and pace of many traditional software organizations. Great SREs live their own engineering-centric version of the self-help classic How to Win Friends and Influence People. Part of the job, simply put, involves convincing other people to do things they initially might not want to do; for example, working with a software engineer more focused on product features than, say, problems that might occur as the product scales over the next several years. Great SREs have to be effective salespeople, able to sell their colleagues on the long-term benefits of automating a particular process or project, even if that might appear to involve some near-term pain. Bottom line? “You need to be able to dig in and say ‘stop’ and ‘no, we really need to to do this thing now,’ which can be difficult to do in some engineering organizations,” Beth explains. Habit 6: You expand your existing skill set to include new tools and approaches Since the SRE concept is still new-ish, many SREs have worked in other jobs prior to assuming the role. Some SREs might have a developer background, while others may come from a traditional operations background. Jason and Beth note that, in general, hiring managers are best served by not pigeonholing the SRE role to one particular background. A traditional QA engineer might have a good makeup for the SRE position, for example. No matter your background, there’s a decent chance the SRE role will challenge you to move out of your comfort zone and develop new skills. An ops practitioner might benefit from learning a programming language or three, for instance; someone with a dev background will need to be willing and able to think much more deeply about operational processes and challenges than they probably did in the past. The best SREs embrace that kind of learning and skill development. Habit 7: You trust the process If there’s a guiding philosophy for the highly successful SRE, it might be expressed this way: you’re not actually chasing a holy grail of preventing anything from ever breaking. That seldom works. Instead, you work tirelessly to see the big picture, incorporate automation, encourage healthy patterns, learn new skills and tools, and improve reliability in everything that you do. Perfection can never be attained, but constantly striving to do things better is the way to get as close as possible. DON'T MISS: The Rise of the Site Reliability Engineer   Related Topics DevOps By Kevin Casey Kevin Casey writes about technology and business for a wide variety of publications and companies. He won an Azbee Award, given by the American Society of Business Publication Editors, for his InformationWeek story, “Are You Too Old for IT?” He’s also a former community choice honoree in the Small Business Influencer Awards. Follow the author Kevin Casey on Twitter Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.18295,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "7 Habits <em>of</em> Highly Successful Site Reliability Engineers",
        "sections": "Habit 4: You embrace every opportunity to <em>automate</em>",
        "body": "Skip to main content We&#x27;re leveling up Future<em>Stack</em> registration with swag, only until 4&#x2F;30. Terms &amp; conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-<em>Stack</em> Observability Applied Intelligence"
      },
      "id": "60763372196a67127764a7aa"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/collect-data-from-any-source/embed/",
      "sections": [
        "Collect data from any source",
        "Agent APIs",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API",
        "Log API"
      ],
      "published_at": "2021-04-11T13:57:08Z",
      "title": "",
      "updated_at": "2021-03-31T01:51:31Z",
      "type": "",
      "external_id": "8e707490926e30080cc8b28594f32c1bc40ef393",
      "popularity": 1,
      "body": "New Relic products report a lot of data “out of the box.” When you use products like APM, Browser, Mobile, Infrastructure monitoring, or an integration, by default you receive performance data. But you may want to bring data into New Relic that isn't collected by default. Maybe you want an API-based solution that doesn't require install of an agent. Maybe you want to bring telemetry data from another analysis service into New Relic. This page describes several ways to get data into New Relic. Step 1 of 6 Agent APIs If you use our APM, Browser, or Mobile agents to report data, you can use their associated APIs to report custom data. For example, if you monitor your application with the our APM Python agent, you can use the Python agent API to set up custom instrumentation. See the agent APIs. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language wrappers for our Trace API and Metric API (and eventually our Log API and Event API). These SDKs let you easily send metrics and trace data to New Relic without needing to install an agent. For customers, we offer open-source exporters and integrations that use the Telemetry SDKs to send metrics and trace data: Istio adaptor Prometheus OpenMetrics (for Docker | for Kubernetes) OpenCensus exporter (for Go | for Python) DropWizard exporter Micrometer exporter Want to build your own solution? See our Telemetry SDK docs. Step 3 of 6 Trace API Our Trace API lets you send distributed tracing data to New Relic and consolidate tracing data from multiple sources in one place. We accept trace data in two formats: Zipkin format New Relic format (if you don’t have Zipkin-format data, you’d use this) bash Copy $ curl -i -X POST https://trace-api.newrelic.com/trace/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -H 'Data-Format: newrelic' \\ > -H 'Data-Format-Version: 1' \\ > -d '[ $ { $ \"common\": { $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host123.test.com\" $ } $ }, $ \"spans\": [ $ { $ \"trace.id\": \"123456\", $ \"id\": \"ABC\", $ \"attributes\": { $ \"duration.ms\": 12.53, $ \"name\": \"/home\" $ } $ }, $ { $ \"trace.id\": \"123456\", $ \"id\": \"DEF\", $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host456.test.com\", $ \"duration.ms\": 2.97, $ \"name\": \"/auth\", $ \"parent.id\": \"ABC\" $ } $ } $ ] $ } $ ]' Step 4 of 6 Metric API You can use our Metric API to send metric data to New Relic from any source. bash Copy $ curl -i -X POST https://metric-api.newrelic.com/metric/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"metrics\": [ $ { $ \"name\": \"memory.heap\", $ \"type\": \"gauge\", $ \"value\": 2.3, $ \"timestamp\": 1531414060739, $ \"attributes\": { $ \"host.name\": \"dev.server.com\" $ } $ } $ ] $ } $ ]' Step 5 of 6 Event API For sending arbitrary events to New Relic, you can use our Event API. We save these events as a new event type, which can then be queried via NRQL. (Eventually, the Telemetry SDKs will support the Event API.) bash Copy $ curl -i -X POST https://insights-collector.newrelic.com/v1/accounts/$ACCOUNT_ID/events \\ > -H \"Content-Type: application/json\" \\ > -H \"x-insert-key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"eventType\": \"LoginEvent\", $ \"service\": \"login-service\", $ \"customerId\": \"xyz\" $ } $ ]' Step 6 of 6 Log API If our existing logging integrations don’t meet your needs, you can use our Log API to send any arbitrary log data to New Relic. (Eventually, the Telemetry SDKs will support the Log API.) bash Copy $ curl -i -X POST https://log-api.newrelic.com/log/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ \"logs\": [ $ { $ \"timestamp\": 1593538496000, $ \"message\": \"User xyz logged in\", $ \"service\": \"login-service\", $ \"hostname\": \"login.example.com\" $ } $ ] $ ]'",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.45139,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> <em>APIs</em>",
        "body": " their associated APIs to report custom data. For example, if you monitor your application with the our APM Python <em>agent</em>, you can use the Python <em>agent</em> <em>API</em> to set up custom instrumentation. See the <em>agent</em> APIs. Step 2 of 6 <em>Telemetry</em> <em>SDK</em> Our <em>Telemetry</em> SDKs are language wrappers for our <em>Trace</em> <em>API</em> and <em>Metric</em>"
      },
      "id": "6063d5a3e7b9d297a1703743"
    },
    {
      "sections": [
        "FedRAMP-compliant endpoints",
        "Customer FedRAMP obligations",
        "Overview of data sources",
        "Agents",
        "APM agents",
        "Mobile agents",
        "Infrastructure monitoring",
        "Infrastructure agent versions below 1.15.0",
        "Browser agent",
        "Data-ingest APIs",
        "Metric API",
        "Telemetry integrations",
        "Telemetry SDKs",
        "Event API",
        "Log API",
        "Log forwarders",
        "Trace API"
      ],
      "title": "FedRAMP-compliant endpoints",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Compliance"
      ],
      "external_id": "ffce8ad6f802717392aca80e0965c9f3fe77ffdf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/compliance/fedramp-compliant-endpoints/",
      "published_at": "2021-04-12T10:50:08Z",
      "updated_at": "2021-04-05T21:48:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides information on FedRAMP-compliant endpoints in New Relic. For more information about our security accreditation for the Federal Risk and Authorization Management Program (FedRAMP), see our data encryption documentation. Customer FedRAMP obligations New Relic customers must meet all of the following requirements for New Relic’s FedRAMP environment: New Relic-approved customers: New Relic’s FedRAMP-Moderate authorized environment is only available to New Relic-approved customers. For more information, contact your New Relic account representative. Order form: Customer’s order form with New Relic must include customer’s eligibility for FedRAMP. Subscription level: Customer must have a current and valid subscription to New Relic Full-Stack Observability Enterprise or New Relic-approved subscription. Authorized New Relic endpoints: Customer must send its data only to New Relic’s FedRAMP-designated endpoints. Authorized services and features: Customer must use only FedRAMP audited and authorized New Relic services and features (see below). Overview of data sources There are multiple ways to get data into New Relic. This doc has two sections: Agent settings: for our APM agents, infrastructure agent, browser agent, and mobile agent. Data-ingest APIs: for our Metric API, Event API, Trace API, and Log API, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents, and browser agent. Setting these agents to send FedRAMP-compliant data involves setting a configuration setting to use the relevant FedRAMP endpoint. APM agents To ensure FedRAMP compliance, all APM agent configurations must report to gov-collector.newrelic.com rather than the default. Depending on the agent, you can either use code-based configuration or an environment variable. Here are details on enabling this: Language Code or environment variable C SDK In code: strcpy(_newrelic_app_config_t->redirect_collector, \"gov-collector.newrelic.com\"); Copy Environment variable: none Go In code: app, err = newrelic.NewApplication( newrelic.ConfigAppName(\"App Name\"), newrelic.ConfigLicense(os.Getenv(\"NEW_RELIC_LICENSE_KEY\")), func(cfg *newrelic.Config) { cfg.Host = \"gov-collector.newrelic.com\" }, ) Copy Environment variable: NEW_RELIC_HOST Java In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Or set a system property of: newrelic.config.host Copy Environment variable: NEW_RELIC_HOST .NET In your XML config next to the license key: <service licenseKey=\"YOUR_LICENSE_KEY\" host=\"gov-collector.newrelic.com\"/> Copy Environment variable: NEW_RELIC_HOST Node.js In newrelic.js: host: 'gov-collector.newrelic.com' Copy Environment variable: NEW_RELIC_HOST PHP In newrelic.ini: newrelic.daemon.collector_host = gov-collector.newrelic.com Copy Environment variable: none Python In newrelic.ini: [newrelic] host = gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Ruby In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Elixir (open source agent) In config.exs: config :new_relic_agent, host: \"gov-collector.newrelic.com\" Copy Environment variable: NEW_RELIC_HOST For more on configuring APM agents, see APM configuration. Mobile agents To ensure FedRAMP compliance when using our mobile monitoring agents, all agent configurations must report to gov-mobile-collector.newrelic.com rather than the default. You must use code-based configuration. Environment variables are not available. Framework-specific configurations: Agent Code or environment variable Android In code: NewRelic.withApplicationToken({APP_TOKEN}) .usingCollectorAddress(\"gov-mobile-collector.newrelic.com\") .usingCrashCollectorAddress(\"gov-mobile-crash.newrelic.com\") .start(this.getApplication()); Copy Environment variable: none iOS In code: [NewRelic startWithApplicationToken:@\"{APP_TOKEN}\" andCollectorAddress:@\"gov-mobile-collector.newrelic.com\" andCrashCollectorAddress:@\"gov-mobile-crash.newrelic.com\"]; Copy Environment variable: none Infrastructure monitoring If you have infrastructure agent version 1.15.0 or higher, simply enable the FedRAMP configuration option. If you have an older agent version, use the following values to edit your YAML configuration: Infrastructure agent versions below 1.15.0 If you have an infrastructure agent version below 1.15.0, you must change three of the endpoints used for reporting. To set these endpoints, you can change your YAML configuration or use environment variables. YAML config field Endpoint URL collector_url https://gov-infra-api.newrelic.com Copy identity_url https://gov-identity-api.newrelic.com Copy command_channel_url https://gov-infrastructure-command-api.newrelic.com Copy To edit environment variables, use these values: Environment variable Endpoint URL NRIA_COLLECTOR_URL https://gov-infra-api.newrelic.com Copy NRIA_IDENTITY_URL https://gov-identity-api.newrelic.com Copy NRIA_COMMAND_CHANNEL_URL https://gov-infrastructure-command-api.newrelic.com Copy Browser agent To configure the browser agent to use a FedRAMP-compliant endpoint, you must use the copy-paste method method (other browser agent install methods are not supported) and edit the browser code’s script element tag so that the domain is gov-bam.nr-data.net for both beacon and error_beacon, like this: window.NREUM||(NREUM={});NREUM.info={\"beacon\":\"gov-bam.nr-data.net\",\"errorBeacon\":\"gov-bam.nr-data.net\"... Copy Data-ingest APIs Below are details about the FedRAMP endpoint for our ingest APIs: Metric API, the Event API, the Log API, and the Trace API. Metric API To ensure FedRAMP compliance when using the Metric API, instead of sending metric data to the default Metric API endpoint of https://metric-api.newrelic.com/metric/v1, it must be sent to https://gov-metric-api.newrelic.com/metric/v1. The Metric API can be used directly but it's mainly used by various New Relic tools. Below are instructions showing where to edit the configuration for setting the FedRAMP endpoint. Telemetry integrations Here are instructions for our open source telemetry integrations that report metric data: Dropwizard: use the overrideUri configuration. Kamon: use the metric-ingest-url configuration. See Override endpoints. Micrometer: override the public String uri() method on your NewRelicRegistryConfig to return the new endpoint. See an example. Prometheus: Prometheus OpenMetrics: if you are using our nri-prometheus helm chart, you can change the endpoint in your values.yml file, like in this example. If you're using the nri-bundle chart, you need to nest this value under the nri-prometheus key to propagate it to the sub-chart. Remote write integration: not available. Telemetry SDKs Here are instructions for our Telemetry SDKs that report metric data: Go: use the MetricsURLOverride configuration. Java: in the MetricBatchSender section, configure the endpoint. See an example. .NET: use the MetricUrlOverride configuration. Node.js: edit the METRIC_HOST = 'metric-api.newrelic.com' configuration. Python: edit the HOST = \"metric-api.newrelic.com\" configuration. Event API To ensure FedRAMP compliance for the Event API, all traffic reporting to insights-collector.newrelic.com must instead report to gov-insights-collector.newrelic.com. The Event API endpoint is configurable for the following Telemetry SDKs. The Telemetry SDKs are used by our open-source telemetry integrations. Language Solution Java Telemetry SDK In code: SenderConfiguration configuration = SenderConfiguration .builder( \"gov-insights-collector.newrelic.com\", EventBatchSender.EVENTS_PATH) .build(); EventBatchSender eventBatchSender = EventBatchSender.create(configuration); Copy Python Telemetry SDK In code: event_client = EventClient(host=\"gov-insights-collector.newrelic.com\") Copy For more information, see our Telemetry API documentation in GitHub. Log API To ensure FedRAMP compliance for data sent via the Log API, the solution for almost all our logging tools is to replace the https://log-api.newrelic.com/log/v1 endpoint with https://gov-log-api.newrelic.com/log/v1. Here are details for various tools: Log forwarders Here are details on changing the endpoint for our log forwarders: AWS Firelens: Add the endpoint property to the options field of the logConfiguration, similar to to the EU account endpoint change shown in these Firelens endpoint configuration instructions. Fluentbit: Use our Fluentbit endpoint configuration. Fluentd: Use our Fluentd endpoint instructions. Infrastructure agent: See FedRAMP for infrastructure. Kubernetes: Our Kubernetes integration logs are based on fluentbit’s output plugin. Use these endpoint instructions. Logstash: Use our Logstash endpoint configuration. Syslog: For configuring syslog clients, see TCP endpoint configuration. S3: Not available. Vector: Not available. To use the Log API directly, you'd edit the Log API endpoint configuration. Trace API FedRAMP is not yet available for the Trace API itself, but note that some of our agents report trace data and you can enable FedRAMP for some of those agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.626,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Metric</em> <em>API</em>",
        "body": " APM agents, infrastructure <em>agent</em>, browser <em>agent</em>, and mobile <em>agent</em>. Data-ingest APIs: for our <em>Metric</em> <em>API</em>, <em>Event</em> <em>API</em>, <em>Trace</em> <em>API</em>, and Log <em>API</em>, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents"
      },
      "id": "603e945164441f64384e8872"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Tip",
        "Requirements and compatibility",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "4cc9878a6fd53a3602eedd978303457aab82ac4e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-manage-data/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-04-12T11:18:58Z",
      "updated_at": "2021-03-16T15:37:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Tip To use our Telemetry SDKs and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Requirements and compatibility To build with the Telemetry SDKs, you will need an Insights insert key. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.13713,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "sections": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "tags": "<em>Telemetry</em> Data Platform",
        "body": "Our <em>Telemetry</em> SDKs are an open source set of <em>API</em> client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the <em>Metric</em> <em>API</em>, <em>Trace</em> <em>API</em>, Log <em>API</em>, and <em>Event</em> <em>API</em>. We offer open-source integrations for <em>telemetry</em> tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Report custom event data",
        "Important",
        "Value from custom events and attributes",
        "Avoid rate limits",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "title": "Report custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9c787cb83d5d7d1722bcbec25f4eb8698f5be6e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-custom-event-data/",
      "published_at": "2021-04-11T15:39:24Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. New Relic products report a variety of default event data to your account. This document explains how to report your own custom events and attributes. Value from custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. By reporting custom events, you can create more useful and customized queries and charts of your data. This is a key part of optimizing how New Relic works for you. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.86758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>event</em> data",
        "sections": "Report custom <em>event</em> data",
        "tags": "<em>Event</em> data sources",
        "body": " of custom data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em> <em>API</em> Extend data retention To learn how to extend how long events are retained in your account, see our documentation about <em>event</em> data retention."
      },
      "id": "6043f0b1196a67451d960f86"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/ranna_unthank-300x300.jpg?h=6c83441f&itok=4Mgvu_0J",
      "url": "https://newrelic.com/blog/nerdlog/open-instrumentation",
      "sections": [
        "New Relic Metrics",
        "New Relic Traces",
        "Availability and pricing",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:51:22Z",
      "title": "New Relic Open Instrumentation: APIs for New Relic One, the First Observability Platform",
      "updated_at": "2021-04-13T23:51:22Z",
      "type": "",
      "external_id": "0285a344a3eb748444ebc5848ca388ddbc53565d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Observability New Relic Open Instrumentation: APIs for New Relic One, the First Observability Platform Sep 19, 2019 • 8 min read By Ranna Unthank Jan. 27, 2020, update: We've extended our list of open source integrations built on the Telemetry SDK to include Node/TypeScript and .NET. Metrics, events, logs, and traces are the core telemetry data types that enable observability within the modern software stack. The continual maturation of DevOps and open source tooling has put developers in the driver’s seat with observability-driven instrumentation. In fact, more data than ever is available from sources within business-critical applications and infrastructure, and methods for correlating and visualizing that data in meaningful ways are just as numerous. OpenTelemetry, part of the Cloud Native Computing Foundation (CNCF), is poised to become the one standard for open source instrumentation and telemetry collection, and W3C Trace Context will become the standard for propagating trace context across process boundaries. Both of these projects are building for a future in which instrumentation and tracing becomes easier for everybody. And pre-existing projects like OpenCensus, Zipkin, Prometheus, and statsd (just to name a few) are also well established in the open source community. As software teams orient their practices around these open source APIs and standards, they need the flexibility to send metrics and trace data from a number of sources as well as from custom solutions. But this has led to a proliferation of tools from which teams are unable to achieve a single source of truth about the entities that define their systems. These issues pose real barriers to achieving true observability. At New Relic, we’re more excited than ever to say that we’re all in on the future of observability, and we believe this future holds huge promise for New Relic customers. It’s our goal to provide modern software teams a single observability platform in which they can combine log data, agent-based APM and Infrastructure data, and third-party telemetry data to create an entity-centric system of record that illuminates their entire stack. Aggregating data from disparate sources and storing it in one place provides customers with the ability to analyze, visualize, and troubleshoot their systems from a single platform. To that end, we’ve added two new APIs to support open instrumentation in the New Relic One observability platform: New Relic Metrics and New Relic Traces. Both APIs can be used directly via their HTTP endpoints or via the new Telemetry SDK, which facilitates sending telemetry data to those APIs. With these capabilities, you’ll: Deliver more complete observability. Collect metric and trace data from any number of open source, vendor-agnostic tools; and display that information alongside data gathered from New Relic instrumentation. Reduce the cost of observability. By sending your business-critical observability data to our SaaS platform, you’ll reduce the cost and operational burden of maintaining different systems for storing, querying, and viewing that data. Avoid vendor lock-in from instrumentation. Instrumentation based on open standards is more portable than vendor-specific instrumentation, so DevOps teams can focus on the value of their full observability platform—not on the value of the instrumentation alone. Embrace simplicity and transparency. Open and transparent protocols, formats, and APIs for ingesting data from any source, such as OpenTelemetry, Envoy, and Prometheus, enhance New Relic’s ability to work with data from popular open source tools. Let’s look at how this will work in New Relic: New Relic Metrics A metric is an aggregation of values collected over time, and they’re extremely useful when you know what you want to collect from a large body of data. With the New Relic Metrics API, you’ll use open source data exporters and scrapers built by New Relic, or contributed by third-party developers, to collect data already available through standard metric emitters. You can also build exporters and scrapers using our open source Telemetry SDK, which provides a language-specific, client-side interface for accepting and transforming metric data, so that it can be batched and sent to New Relic via the Metrics API. Today, we’re providing the following open source integrations built on the Telemetry SDK: Prometheus OpenMetrics integration OpenCensus exporter (Python and Go) Micrometer exporter DropWizard exporter Istio exporter The Metrics API is a simple HTTP endpoint that accepts JSON-formatted data for ingest and storage in New Relic's platform. Metrics data is stored as dimensional metric data consisting of a measurement and its associated key:value pairs. In fact, when integration with the Telemetry SDK isn’t a good option—for example, if you want more control over how the data is packaged or sent—you can send well-formed data directly to the Metrics API via HTTP. You can access this data with the New Relic One chart builder (and with the New Relic Query Language (NRQL)) to create New Relic One dashboards; or use the data in New Relic One applications. You’ll also be able to set fine-grained alerts on these metrics, with the ability to focus in on any condition defined in a NRQL alert. Note: At this time, for New Relic Metrics, the Telemetry SDK supports only Java, Go, and Python. For more specifics on the New Relic Metrics API, including details on rate limits, JSON payload format, and metrics types, see our documentation.  New Relic Traces Distributed tracing helps you find the sources of latency and errors in a distributed system by stitching together operations across all services involved in a single request. New Relic agents automatically instrument your services to time and collect information about operations and create the “spans” that make up a distributed trace. There are many tools available for instrumenting and creating tracing data. The New Relic Trace API is a new HTTP endpoint that accepts tracing data in the Zipkin JSON v2 format or the New Relic-specific format. If you’ve instrumented parts of your system with Zipkin, you can now send that tracing data to New Relic with no changes to your instrumentation. And you’ll no longer need to manage the complex, high-availability storage systems necessary for storing trace data because we do that for you! If you’re using OpenCensus or Istio, you can now use the New Relic OpenCensus exporters and Istio adapter to send tracing data created by those tools as well. And like with the Metrics API, you can also use the Telemetry SDK’s language-specific client-side interface to accept and transform trace data, so that it can be batched and sent to the New Relic Trace API. Once you’ve sent distributed tracing data to New Relic, you’ll be able to take advantage of New Relic’s powerful trace visualizations, querying capabilities, anomaly detection and analytics tools to understand and troubleshoot systems in context with the rest of their New Relic instrumented ecosystem. For more information on the New Relic Trace API, including details on the Zipkin- and New Relic-format, see our documentation. Note: At this time, for New Relic Traces, the Telemetry SDK supports only Go, Python, and Java. Availability and pricing Modern software developers widely embrace open source frameworks and tools that include built-in telemetry, and we know that. But we also know that you need one primary place where you can analyze that data. The New Relic One observability platform provides the curated and customized visualizations you need to understand your telemetry data—and the entities from which it comes—in the context of your entire business or enterprise, and it does so without requiring you to operate any additional software. New Relic Metrics and New Relic Traces provide efficient and easy integrations for getting your telemetry data into New Relic. These APIs are available to all customers on New Relic Pro or equivalent subscription plans—visit newrelic.com to find out more. Related Topics Observability By Ranna Unthank Ranna Unthank is a Principal Product Marketing Manager at New Relic. She has over 10 years of experience in product marketing and sales enablement. Her technology experience and knowledge spans from storage to server and desktop virtualization to cloud computing and modern architecture technologies. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.3959,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Open Instrumentation: <em>APIs</em> for New Relic One, the First Observability Platform",
        "sections": "New Relic <em>Metrics</em>",
        "body": " source <em>Telemetry</em> <em>SDK</em>, which provides a language-specific, client-side interface for accepting and transforming <em>metric</em> data, so that it can be batched and sent to New Relic via the Metrics <em>API</em>. Today, we’re providing the following open source integrations built on the <em>Telemetry</em> <em>SDK</em>: Prometheus"
      },
      "id": "60762e7a28ccbcdd3751c168"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:50Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.63194,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #6)",
        "sections": "<em>Subscribe</em> to <em>apps</em> in the New Relic One Catalog",
        "body": " to your New Relic account using the following commands: nr1 nerdpack:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;nr1-attributory.git cd nr1-attributory nr1 nerdpack:<em>publish</em> nr1 nerdpack:<em>deploy</em> -c STABLE nr1 nerdpack:<em>subscribe</em> -c STABLE Then go to the homepage of one.newrelic.com and select the <em>app’s</em> launcher"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/Natalie_Serrino%20FS21.jpg?h=2e0f227d&itok=xI5aRyVf",
      "url": "https://newrelic.com/futurestack/speakers/natalie-serrino",
      "sections": [
        "Natalie Serrino",
        "Sessions with Natalie Serrino",
        "Kubernetes-Native Observability Without Instrumentation",
        "Meet Our Speakers",
        "Matt Shandera",
        "Colin MacNaughton",
        "Joanna Leidy",
        "Naveen Chittoor",
        "Jonathan Karon",
        "Paras Wadehra",
        "Nicole van der Hoeven",
        "Sergio Rabiela",
        "Nočnica Fee",
        "Ari Zilka",
        "Scot Gorman",
        "Justin Eveland",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-11T14:37:12Z",
      "title": "Natalie Serrino | New Relic",
      "updated_at": "2021-04-11T14:37:12Z",
      "type": "",
      "external_id": "b07751ac88fb8968451d9e1aed356d4ff8b4e0e6",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Natalie Serrino Principal Software Engineer, New Relic Sessions with Natalie Serrino 10:15 am - 11:15 am PT | Wednesday, May 26 | Hands-on Workshop Kubernetes-Native Observability Without Instrumentation Learn how to get visibility into your Kubernetes cluster and apps with no-instrumentation data collection, allowing you to debug in minutes. No need to update, recompile, or deploy your apps - it just works. (Join this session for live chat OR watch on-demand immediately after) Meet Our Speakers Matt Shandera Program Manager for Nonprofit Success New Relic Learn more Colin MacNaughton Staff Engineer New Relic Learn more Joanna Leidy Lead UI Engineer New Relic Learn more Naveen Chittoor Application Support Engineer Cox Communications Inc Learn more Jonathan Karon Director of Venture Development New Relic Learn more Paras Wadehra Solutions Architect New Relic Learn more Nicole van der Hoeven Developer Advocate k6.io Learn more Sergio Rabiela Vice President of Technology Beyond Finance, Inc Learn more Nočnica Fee Developer Advocate New Relic Learn more Ari Zilka Head of the Product Incubator New Relic Learn more Scot Gorman Site Reliability Engineering Manager Chegg Learn more Justin Eveland Software Engineer New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 53.99849,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", May 26 | Hands-on Workshop Kubernetes-Native Observability Without Instrumentation Learn how to get visibility into your Kubernetes cluster and <em>apps</em> with no-instrumentation data collection, allowing you to debug in minutes. No need to update, recompile, or <em>deploy</em> your <em>apps</em> - it just works. (Join"
      },
      "id": "6042d15ce7b9d2c6cc579a0e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Figure8-e1570028252480.png",
      "url": "https://newrelic.com/blog/best-practices/what-is-serverless-architecture",
      "sections": [
        "What is serverless architecture?",
        "What are the advantages of using serverless architecture?",
        "Decomposing drives better observability",
        "Serverless is event-based",
        "Faster deployments, greater flexibility, and accelerated innovation",
        "Reducing architecture costs",
        "Focusing more on UX",
        "What are the limitations of using serverless architecture?",
        "Long-running application inefficiencies",
        "Third-party dependency",
        "Cold starts",
        "Is serverless architecture for you?",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:36:03Z",
      "title": "What Is Serverless Architecture? Key Benefits and Limitations",
      "updated_at": "2021-04-13T23:36:03Z",
      "type": "",
      "external_id": "e2071d6d8b01e362ac308565b88598fce2d04ac3",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Cloud What Is Serverless Architecture? Key Benefits and Limitations Aug 28, 2020 • 6 min read By Nočnica Fee As organizations and their technology ecosystems mature, they often find that managing architecture is a challenge. Rather than becoming professionals at managing a platform, software teams would rather devote their time and resources to applications and development. The new alternative is serverless architecture. But what is serverless architecture? And is it the right move for you? What is serverless architecture? Serverless architecture describes a way for companies to build and run applications but not have to manage infrastructure. It provides a way to remove architecture responsibilities from your workload, including provisioning, scaling, and maintenance. Scaling can be automatic, and you only pay for what you use. Since the development of this new technology, we’ve seen substantial growth through Amazon Web Services (AWS). A recent O’Reilly survey found that 40 percent of organizations adopted serverless architecture. The main reasons behind the adoption include reduced costs, scalability, developer productivity, and more, per the chart below. Image courtesy of OReilly.com. Not everyone is ready to go all-in with serverless. The study found concerns around security, fear of the unknown, and not having the right staff. That last concern deserves to be highlighted: even though serverless should be “easier,” it still takes team expertise to be competent in a new tool. Let’s look specifically at the benefits and limitations of serverless architecture. What are the advantages of using serverless architecture? The leading advantage is that your developers can focus their attention on product development. They no longer have to account for managing and operating servers. Components like network configuration or the physical security of your servers are handled by the vendor rather than your team. Many other benefits come from serverless architecture as well. Decomposing drives better observability With serverless, you break down applications into smaller and smaller pieces, known as decomposition. By doing so, you’ll gain better observability across the application. With smaller pieces, the knowledge necessary to make changes or create fixes is smaller. Serverless is event-based Serverless uses an event-based system versus stream-based. With event-based architecture, each subpart of the application is independent. Events trigger one another. In stream-based, there are connections to each service. If there is a failure, it just impacts that event, not the entire log. Faster deployments, greater flexibility, and accelerated innovation Speed is often a contributing factor in choosing to use a serverless architecture. You can rapidly deploy apps in hours because there’s no infrastructure construction to weigh you down. With faster deployments also comes ease in scalability. By using such an agile architecture, you can be very flexible in your releases. Because it’s a quicker process, you can accelerate innovation. This flexibility is especially valuable in situations where pivoting is urgent. These types of scenarios are playing out all over the world in response to the pandemic. Organizations have to change their focus to meet emerging needs. This could be internal with a move to remote work. Another example is the adoption of customer-facing applications like those of retailers and restaurants. Reducing architecture costs Being serverless, an organization is essentially outsourcing server and database management. You are no longer responsible for the huge investments required for internal architecture administration. Ultimately your use case will define how much you can save. Focusing more on UX If your applications have end users, which they probably do, they have high expectations around digital experiences. If architecture is no longer a concern, it leaves more time to work on the user experience (UX). You can’t afford to not invest in the user interface, so serverless can provide you with a way to reallocate resources. What are the limitations of using serverless architecture? Serverless architecture isn’t perfect. It’s still an evolving architecture, leaving some not ready to adopt. Long-running application inefficiencies Running workloads, which are long-running, could be more costly on serverless. Using a dedicated server is often more efficient. Third-party dependency Serverless architecture requires you to be reliant on your provider. You don’t have full control, and changes may impact you without notice. The platform’s availability is subject to its terms. Cold starts A “cold start” occurs when a platform must initiate internal resources. It may take some time for your serverless architecture to handle that first function request. You can avoid a “cold start” by ensuring the function remains in an active state. You do this by sending requests to it periodically. Is serverless architecture for you? Serverless architecture is just one more option for deploying applications. Being able to monitor and troubleshoot serverless is also critical. Explore how we make this possible with New Relic Serverless for AWS Lambda. Get a serverless overview and a free trial. Related Topics Cloud By Nočnica Fee Nočnica Fee is a Dev Advocate for New Relic specializing in serverless. She's a frequent contributor to The New Stack and Dev.to. In her downtime, she enjoys drum machines and woodworking. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 50.96924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Faster <em>deployments</em>, greater flexibility, and accelerated innovation",
        "body": ", not the entire log. Faster deployments, greater flexibility, and accelerated innovation Speed is often a contributing factor in choosing to use a serverless architecture. You can rapidly <em>deploy</em> <em>apps</em> in hours because there’s no infrastructure construction to weigh you down. With faster deployments also"
      },
      "id": "60762ae3196a675ccd64a76a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 43.303017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #5)",
        "sections": "<em>Subscribe</em> to <em>applications</em> with the New Relic One Catalog",
        "body": " Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to <em>subscribe</em> applications to accounts and subaccounts. Click <em>Add</em> the <em>app</em> to <em>add</em> the application to the account you wish to grant access. If your team changes, and you need"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Event-Stream-Screenshot.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-applications-4",
      "sections": [
        "Event Stream",
        "Specific requirements for this app",
        "Neon",
        "Network Telemetry",
        "SLO/R",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:52Z",
      "title": "The Most Popular New Relic One Applications (Roundup #4)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "0ac60d545488f3c1904bdd6e0d552af5c307ee5a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #4) Jan 9, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs different types and combinations of insights into how their apps and systems are performing. That’s why New Relic One is programmable—you can build and deploy custom apps that give you the specific insights and information your company needs. To show you what’s possible—and to inspire you to create apps—we worked with members of the New Relic community to build a handful of open source applications, and the number of newly-developed apps continues to grow. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Event Stream Neon Network Telemetry SLO/R Event Stream During a launch or incident, you need the absolute latest data from your application. Event Stream is like Unix tail for APM data—it pulls in your Transaction and TransactionError data in a live stream, so you can find out exactly what's happening with your app right at that moment. You can also filter and facet the data to show the exact data you need. New Relic One Application Event Stream Fork or deploy the Event Stream app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agent. Neon Need to create a single dashboard to track the health of entire business units or regions? Neon lets you create a status board based on New Relic alerts or the values from New Relic events. Fork or deploy the Neon app from GitHub. Specific requirements for this app To view the status of New Relic alerts, you’ll need to set up a webhook notification channel for the alert policies. See the New Relic documentation to learn more about managing notification channels. Network Telemetry Network Telemetry Screenshot The Network Telemetry app visualizes data collected through the Network Telemetry Infrastructure integration. The integration collects data from network devices that export Sflow or IPFIX network samples, and the app creates visualizations to help you examine the sources and destinations of communication within a network, as well as the volume of traffic between devices. Fork or deploy Network Telemetry from GitHub. Specific requirements for this app Install the New Relic Infrastructure agent, and ensure you have the related access to New Relic One. Install the New Relic Network Telemetry On-host integration.  SLO/R SLO/R Screenshot The SLO/R app calculates service-level objective (SLO) attainment for an application service. It allows you to quickly define SLOs for error, availability, capacity, and latency conditions. By measuring SLO attainment across your service estate, you'll be able to determine what signals are most important for a given service or set of services, developed and supported by a team, organization, or group. Using New Relic as a consistent basis to define and measure your SLOs offers better insight into comparative SLO attainment in your service delivery organization. Note: SLO/R is intended to work with services reporting to New Relic via an APM agent. The service provides an entity upon which to define SLOs. Error budget SLOs are defined directly from APM Transaction events; the other SLO types are defined using New Relic alerts. See \"Creating a webhook to forward Alert incidents to Insights\" for more details. Fork or deploy the SLO/R app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agents. Create a New Relic alerts webhook to forward alert events to a SLOR_ALERTS New Relic database table. See \"Creating a webhook to forward Alert incidents to Insights\" for details. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Event Stream—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Event Stream to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream   nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications. If you can imagine it, you can build it: developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 43.303017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #4)",
        "sections": "Specific requirements for this <em>app</em>",
        "body": " the following commands: nr1 nerdpack:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;nr1-event-stream.git cd nr1-event-stream   nr1 nerdpack:<em>publish</em> nr1 nerdpack:<em>deploy</em> -c STABLE nr1 nerdpack:<em>subscribe</em> -c STABLE Then go to the homepage of one.newrelic.com and select the <em>app’s</em> launcher. Check out these other"
      },
      "id": "60762e2028ccbcaf8651c17c"
    }
  ],
  "/collect-data/custom-events": [
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "Important",
        "General requirements",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "ee49e0ca9bf17447e8349123bfb470ff9964c4fe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-04-11T15:38:28Z",
      "updated_at": "2021-03-30T06:37:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.29697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "sections": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " <em>Event</em> <em>API</em> (There are additional requirements when using the <em>Event</em> <em>API</em>.) Browser monitoring <em>agent</em> <em>APIs</em> (There are additional requirements with the <em>custom</em> PageAction <em>event</em>.) Mobile monitoring SDK General requirements When reporting <em>custom</em> <em>events</em> and attributes, follow these general requirements"
      },
      "id": "6043ef69e7b9d2da1f5799f8"
    },
    {
      "sections": [
        "Report custom event data",
        "Important",
        "Value from custom events and attributes",
        "Avoid rate limits",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "title": "Report custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9c787cb83d5d7d1722bcbec25f4eb8698f5be6e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-custom-event-data/",
      "published_at": "2021-04-11T15:39:24Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. New Relic products report a variety of default event data to your account. This document explains how to report your own custom events and attributes. Value from custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. By reporting custom events, you can create more useful and customized queries and charts of your data. This is a key part of optimizing how New Relic works for you. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.77939,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>custom</em> <em>event</em> data",
        "sections": "Value from <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " policy. Send <em>custom</em> <em>events</em> and attributes Methods for sending <em>custom</em> <em>events</em> and attributes include: Source How to send <em>custom</em> data APM <em>agent</em> Use APM <em>agent</em> <em>APIs</em> to report <em>custom</em> <em>events</em> and <em>custom</em> attributes. Browser monitoring <em>agent</em> Add <em>custom</em> attributes to the PageView <em>event</em> via the Browser <em>API</em> call"
      },
      "id": "6043f0b1196a67451d960f86"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Important",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9a5edf6068acc3b7187d217bd7932f0478e5467c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-04-12T01:06:07Z",
      "updated_at": "2021-03-30T06:37:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.43364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " using the <em>Event</em> <em>API</em> (without need for APM). However, be aware that <em>custom</em> <em>events</em> sent with the <em>agent</em> <em>APIs</em> are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding <em>custom</em> data with the APM <em>agent</em> <em>API</em>. Or, go directly to the full online course"
      },
      "id": "603ecece28ccbcc865eba7a0"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Important",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations",
        "Deprecated methods"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "dba656da4a2978b01b6647a4a0011d08e6b9c4a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-04-11T15:39:24Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default Mobile events using the New Relic Mobile SDK. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple Mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the Mobile crash event trail. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default Mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations. Deprecated methods As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create custom events. The recordEvent methods for Android and iOS are deprecated. The deprecated recordEvent events do not have their own event type; they are recorded as a Mobile event type with a category attribute value of custom. recordCustomEvent creates an event with an eventType you can assign. But the eventType should only be used for one or two high-level event types, not for naming events. For example, you might have one event type Gestures, with many different names under that one type. For more context on this, see the recordCustomEvent query example.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.91934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " and MobileHandledException <em>events</em>. These <em>events</em> are available for querying and also displayed in the Mobile crash <em>event</em> trail. For more on creating <em>custom</em> attributes and <em>custom</em> <em>events</em>, see: Android SDK <em>API</em> guide iOS SDK <em>API</em> guide NRQL query examples MobileRequestError examples MobileRequest examples Limits"
      },
      "id": "6043ee0de7b9d21975579a25"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Important",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute Browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "cabf27e5367fcf6473d105983c030b653e3bd9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-04-11T15:50:26Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the Browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Subscription level This feature requires a Browser Pro subscription. The instrumentation level setting for an application does not affect the availability of JavaScript API functions. Agent version Your New Relic Browser agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 60 events per 30-second harvest cycle, per browser. After the 60-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the Browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default Browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute Browser API call To add a custom attribute to the PageView event via the Browser agent, use the setCustomAttribute Browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual Browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.91934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " add to the PageView <em>event</em> are also automatically added to the PageAction <em>event</em>. There are two ways to add <em>custom</em> attributes to the PageView <em>event</em>: Use set<em>Custom</em>Attribute Browser <em>API</em> call To add a <em>custom</em> attribute to the PageView <em>event</em> via the Browser <em>agent</em>, use the set<em>Custom</em>Attribute Browser <em>API</em>"
      },
      "id": "6043ebbee7b9d227105799b2"
    }
  ],
  "/try-our-apis": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/graphql_aws_services-1024x593.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/graphql-api",
      "sections": [
        "Using GraphQL in New Relic",
        "Example 1: Querying Infrastructure cloud integrations with NerdGraph",
        "Example 2: Modifying integration configurations with NerdGraph",
        "Transfering NerdGraph data to the terminal",
        "New Relic and GraphQL—easing the path for developers"
      ],
      "published_at": "2021-04-14T00:03:24Z",
      "title": "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "381e6b1a3bca81ebc8b6efc8199d2b75983befca",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read By Mark Weitzel As you build observability into your workflows and processes, you need the ability to quickly retrieve, sort, and process all kinds of telemetry through APIs. With New Relic, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous API operations. With the NerdGraph API explorer—built on GraphQL—you can more easily query the data you need, without over-or under-fetching, and reduce manual toil in your data analysis workflows. More specifically, in New Relic you can use NerdGraph to: Query all the entities associated with your account Query, create, and update the workloads associated with your account Create, manage, and add tags to entities Query distributed tracing data Fetch data when building a New Relic One application Understand upstream and downstream relationships with your services Configure your New Relic Infrastructure cloud integrations Query event data and custom event data with NRQL In this post, I’ll walk through two examples using NerdGraph to query information about New Relic Infrastructure cloud integrations and update their configuration values. But first a bit of history. Using GraphQL in New Relic Unlike typical REST APIs that often require loading from multiple endpoints, GraphQL provides a single endpoint that can manage complex queries so developers can get all the data their app needs from many services in one request. GraphQL is strongly typed, which allows developers to explicitly declare what information is available via queries to the GraphQL service. This declaration is done via a GraphQL schema. Schemas give developers the flexibility they need to express information about the data they return. For example, each field has a description, which developers can use to indicate the proper usage of the data. Schemas also provide the API blueprint developers need to build tools for properly constructing queries and guiding proper usage of any returned data. For example, developers can use the schema to indicate if a field has been deprecated so tools like IDEs can surface this fact and discourage use of that data. And “schema stitching”—creating a single schema from several underlying GraphQL APIs—allows developers to deliver a unified access experience across all of their APIs, as we’ve done at New Relic: The New Relic GraphQL implementation includes several underlying GraphQL APIs—including accounts, Infrastructure, and the New Relic database (for constructing NRQL queries). For more information on GraphQL, the following examples of querying cloud integration configuration data use GraphQL queries and mutations: Queries: GraphQL requests that only fetch data Mutations: GraphQL requests that modify and fetch data NerdGraph has a single endpoint: https://api.newrelic.com/graphiql. This launches (after authenticating the user) the NerdGraph API interface—an interactive, browser-based IDE for running GraphQL requests. In the NerdGraph API explorer, you build and run your query on the left, and the result is returned on the right. You can click into fields to drill into their definitions. For example, if you drill into actor, you’ll see it contains fields for user and accounts: { actor { user { name email } accounts { id name } } } The fields under actor expose data from different downstream services that are unified in the GrahQL schema delivered by the GraphQL server. When you issue a query, the GraphQL server pulls apart the query and invokes a resolver for each of the services. When the queries complete (or time out or encounter errors), the GraphQL server assembles the result and returns it to you. In the example above, we get information about the user and all the accounts that they have access to. Let’s walk through our examples to show the full power of GraphQL’s data collection capabilities. Example 1: Querying Infrastructure cloud integrations with NerdGraph In my first example, I’ll use NerdGraph to query for various data about the AWS integrations that are running in my New Relic account. I’ll use the data I gather in this example to update some specific settings in the next section. Tip: If you’re planning on following along, make sure you generate an API key that you can use with New Relic’s GraphQL API. In fact, you can generate one directly from NerdGraph. Let's start with a list of the AWS integrations I have available in New Relic Infrastructure: AWS integrations installed in New Relic Infrastructure. Next, let's retrieve some information about these AWS services via a GraphQL query. I’m going to query for the cloud provider (in this case, AWS) that’s linked to my account and the set of integrations from AWS that I’ve installed. To do this, I need to pass the ID of the account I want to query—this is the account(id: MY ACCOUNT ID) part of the query. Notice that I’m “nesting” requests to get information about the cloud provider and the integrations I’m using. If I were using a REST API, this would require multiple calls, but with the GraphQL API, I can gather this information with just one query.   { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { id name slug } integrations { id name service { id slug name createdAt updatedAt provider { name id } } } } } } } } When the query completes, the GraphQL server assembles the results about the AWS integrations I’ve installed, as shown below (note that I’ve truncated the example): { \"data\": { \"actor\": { \"account\": { \"cloud\": { \"linkedAccounts\": [ { \"authLabel\": \"arn:aws:iam::8xxxxxxx7:role/NewRelicInfrastructure-Integrations-Origami\", \"externalId\": \"8xxxxxxx7\", \"id\": 3542, \"integrations\": [ { \"id\": 75540, \"name\": \"RDS\", \"service\": { \"createdAt\": 1470991744, \"id\": 3, \"name\": \"RDS\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"rds\", \"updatedAt\": 1534242454 } }, { \"id\": 14233, \"name\": \"S3\", \"service\": { \"createdAt\": 1470991745, \"id\": 4, \"name\": \"S3\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"s3\", \"updatedAt\": 1534242454 } }, { \"id\": 12223, \"name\": \"Lambda\", \"service\": { \"createdAt\": 1477910055, \"id\": 14, \"name\": \"Lambda\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"lambda\", \"updatedAt\": 1534242454 } }, { \"id\": 172534, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 } }, } } ] } } } } } But what if I want more specific information about one of the integrations? Specifically, I want to see what tags (user-defined metadata) I’ve applied to a particular integration as well as its metrics polling interval (how often New Relic polls the integration for data), and when these settings were last updated. To do this, I’ll need to use one of the more nuanced features of GraphQL—interfaces, an abstract type that represents a collection of common fields that other object types can implement. So in my original query, I’ll add two new clauses: ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } Now, if my query hits a result that is of type CloudDynamodbIntegration or CloudReshiftIntegration, it also return the fields metricsPollingInterval, tagKey, tagValue, and updatedAt. Here's what my (truncated) query will like now: { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { ... } integrations { id name service { ... } } ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } } } } } } In the result, notice that the DynamoDb and Redshift configuration information contain the extra fields that I specified in the query using their interfaces. { \"id\": 173397, \"metricsPollingInterval\": 900, \"name\": \"Redshift\", \"service\": { \"createdAt\": 1497364366, \"id\": 21, \"name\": \"Redshift\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"redshift\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1544435410 }, { \"id\": 112183, \"metricsPollingInterval\": 900, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1549499902 }, OK! I’ve successfully queried information about my AWS integrations in New Relic Infrastructure, and I’ve used an interface to get additional information about a specific integration. Now, I’ll use the GraphQL API to update the metrics data polling intervals in one of these integrations. Example 2: Modifying integration configurations with NerdGraph In GraphQL, when you modify data with a write operation, it’s called a mutation. In this example, I’ll build a mutation to update the polling intervals of an AWS integration. First, though, I’ll set a polling interval so that we'll notice when I change it with NerdGraph. Here are the configuration options for my AWS DynamoDB integration: DynamoDB integration configuration options in New Relic Infrastructure. As you can see, I’ve set the metrics data and inventory data polling intervals to every 5 minutes, and I’ve also toggled Collect tags to ON. Now I’ll build the mutation query. First, I'll start with the keyword mutation, and like any GraphQL API request, enclose it in a pair of curly braces,{ }. Next, I want to specify that I’m configuring a cloud integration; so I’ll add cloudConfigureIntegration, which takes two arguments: accountId and integrations. For accountId, I’ll use the same account id from the first example to get information about the Infrastructure-linked accounts. The second argument is the integrations that I want to update. Again, integrations are specified by cloud provider, so here I want to include aws. So far my mutation looks like this: mutation{ cloudConfigureIntegration( accountId:MY ACCOUNT ID integrations:{aws I want to specify that I’m updating the configuration for DynamoDB, so I’ll pass in an object with dynamodb as the key and an array that contains objects with the values I want to to set. Remember, for our mutation, we want to update the metricsPollingInterval (valid values are 300, 900, 1800, and 3600 seconds) and add a tagKey (metadata about the function of the integration). The final part of the mutation adds a set of fields to return if my request is successful and a set of fields to return if there are any errors. Here's the full query: mutation{ cloudConfigureIntegration( accountId:630060 integrations:{aws:{ dynamodb:[ { linkedAccountId:4912 metricsPollingInterval:1800 tagKey:\"mdw-test\" }] } } ) { integrations{ id name updatedAt ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } errors{ linkedAccountId message integrationSlug } } } And here’s the result, which shows no errors and indicates DynamoDB’s configuration was successfully updated: { \"data\": { \"cloudConfigureIntegration\": { \"errors\": [], \"integrations\": [ { \"id\": 177184, \"metricsPollingInterval\": 1800, \"name\": \"DynamoDB\", \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1551139957 } ] } } } I can now return to New Relic Infrastructure and refresh the DynamoDB configuration page: Refreshing the DynamoDB configuration in New Relic Infrastructure. Our mutation changed the metric polling interval from 300 seconds (5 minutes) to 1800 seconds (30 minutes), and entered tag key value of mdw-test. That's it! I've successfully updated the configuration of a New Relic Infrastructure integration using NerdGraph. Transfering NerdGraph data to the terminal So, now you know how to explore the New Relic data available to you in NerdGraph, and you know how to create queries and mutations, but how do you transfer this data to your code? To capture code-ready queries and mutations, select the Tools drop down in the NerdGraph explorer. To copy a curl statement with the in-scope query to your clipboard, select Copy as CURL. Paste this code snippet into your terminal, or use it to populate an HTTP request in your code. If you’re working with the New Relic CLI, select Copy as New Relic CLI from the drop down to generate a command-line ready query or mutation. New Relic and GraphQL—easing the path for developers As these examples show, GraphQL is extremely flexible and lightweight, and dramatically reduces the overhead of working with your New Relic data. If you want to challenge yourself even more, create some more complex queries in the Query Builder. For example, can you create a query to grab the count of all of your reporting entities? Hint: check out NerdGraph’s entity search field. We’re passionate about making life for developers as easy as possible. Check out the resources available at developer.newrelic.com, and engage in the discussion with fellow developers on the Explorer’s Hub. By Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 682.6259,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Started With <em>NerdGraph</em>—The <em>New</em> <em>Relic</em> <em>GraphQL</em> <em>API</em> Explorer",
        "sections": "Using <em>GraphQL</em> in <em>New</em> <em>Relic</em>",
        "body": " to quickly retrieve, sort, and process all kinds of <em>telemetry</em> through <em>APIs</em>. With <em>New</em> <em>Relic</em>, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous <em>API</em> operations. With the <em>NerdGraph</em> <em>API</em> explorer—built on <em>GraphQL</em>"
      },
      "id": "6076314c64441f483e9d8576"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/16x9_600w/public/2021-04/iStock-842120096-2-min_6.jpg?h=77039d24&itok=FcAtK923",
      "url": "https://newrelic.com/blog/authors/mark-weitzel",
      "sections": [
        "Mark Weitzel",
        "All Posts From Author",
        "New Capabilities to Extend Development On New Relic One",
        "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
        "New Relic One: The First Programmable Observability Platform"
      ],
      "published_at": "2021-04-13T23:49:50Z",
      "title": "Mark Weitzel | New Relic",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "af07ee0bdcb27ea325c9c5262f7f935b4865f7cd",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. All Posts From Author Extend New Relic New Capabilities to Extend Development On New Relic One Mar 30, 2020 • 4 min read Read the article How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read Read the article Extend New Relic New Relic One: The First Programmable Observability Platform Sep 19, 2019 • 9 min read Read the article Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 572.1596,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mark Weitzel | <em>New</em> <em>Relic</em>",
        "sections": "Getting Started With <em>NerdGraph</em>—The <em>New</em> <em>Relic</em> <em>GraphQL</em> <em>API</em> Explorer",
        "body": " the article How to <em>Relic</em> Getting Started With <em>NerdGraph</em>—The <em>New</em> <em>Relic</em> <em>GraphQL</em> <em>API</em> Explorer Jun 11, 2020 • 12 min read Read the article Extend <em>New</em> <em>Relic</em> <em>New</em> <em>Relic</em> One: The First Programmable Observability <em>Platform</em> Sep 19, 2019 • 9 min read Read the article Company Careers and Culture Partner Program Investor"
      },
      "id": "60762e1e64441fc25b9d854d"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/muting_alerts4-1024x788.png",
      "url": "https://newrelic.com/blog/nerdlog/muting-rule-new-relic-alerts",
      "sections": [
        "What is a muting rule?",
        "How muting rules work",
        "How to set up a muting rule",
        "Creating complex rule filters",
        "Creating and managing muting rules with NerdGraph",
        "Try it now!"
      ],
      "published_at": "2021-04-13T23:56:45Z",
      "title": "Muting Rules Now Available in New Relic Alerts",
      "updated_at": "2021-04-13T23:56:45Z",
      "type": "",
      "external_id": "dbbcbffafdf0cbc54b4bd8b29149919115187a5f",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog Muting Rules Now Available in New Relic Alerts Jun 8, 2020 • 7 min read By Brian Goleno During times of planned system disruptions, a steady stream of noisy, unnecessary alerts can be a major distraction. You need to find a balance that allows you to filter out the noise yet still maintain observability and alerting on the rest of your system. With muting rules in New Relic Alerts, you can silence notifications during planned disruptions like maintenance windows, deployments, and testing. By applying muting rules, you’ll minimize the risks of overmuting by creating rules that identify violations using all of the contextual metadata we know about the entity and signal, which provides more depth than merely enabling or disabling alert conditions. This way, you can target your system’s specific subsets that are being affected by planned disruptions. Additionally, by keeping alert conditions running but silent during these periods, you can continue to observe when entities have recovered from maintenance and have returned to a healthy state. You create and manage muting rules using either New Relic Alerts UI or the NerdGraph API explorer. What is a muting rule? A muting rule overrides alert policies and conditions you’ve defined in New Relic, so you can suppress notifications during times of known system disruptions. A muting rule contains a set of conditions that match a large number of attributes and tags present in a violation event, including: Alert policy and condition names Application and service names Host names AWS tags Kubernetes tags Any other tags associated with your entities or open telemetry How muting rules work Muting rules tell New Relic how to identify individual violations after they are created, but before an incident is opened. They override the default life cycle of an alert to indicate that it should not send notifications. With muting rules, your normal alert incident life cycle is maintained; the only change is whether or not an incident triggers a notification. Violations and incidents are still opened, and health indicators show the current state of your entities as you progress through your maintenance window. When the conditions defined in a muting rule match a violation event, the violation is marked as “muted.” When a violation is muted, the incident life cycle is modified in the following ways: When a muted violation opens an incident, an “open incident” notification will not be sent. If any other violation that is not muted is associated with that incident, then an “open incident” notification will be sent. If an incident sends an “open incident” notification, then all subsequent events will trigger notifications. If an incident never sent an “open incident” notification, then subsequent events will not trigger notifications. (Tip: You can find a detailed workflow chart in the docs.) Enterprise-scale issue detection and incident management require flexibility and automation. Muting notifications is the first in a series of life cycle override actions that we will be releasing this year, including allowing you to schedule muting. All of these controls will be manageable through our API and UI. How to set up a muting rule Muting rules are available to everyone using New Relic. To set up a muting rule: Navigate to  New Relic One > Applied Intelligence. From the left-hand navigation, select Muting rules. The Muting rules page in New Relic One. Note: Since New Relic One is a cross-account experience, the Muting rules page lists all muting rules that exist across all of the accounts to which you have access. However, a muting rule currently only operates in one account at a time. Set up your rule: Click Add a Rule. Choose a name and description, and select the appropriate account. Build a violation filter to set conditions that describe the criteria used to match the attributes of a violation object. Enable the rule when you are ready for it to be active. Set up your muting rule and enable it when you are ready for it to be active   You can view violations and incidents that have been muted in New Relic Alerts. Creating complex rule filters Use complex rule filters for greater precision when muting alerts. For example, if your maintenance only touches specific hosts within a cluster, a subset of services on a host, or if you’re making updates to a data center or availability zone that affects a large number of separately monitored services, complex rule filters can help ensure you only mute the relevant alerts. Create complex rule filters by combining sets of matching conditions. Filters can either use operators like or or and to combine conditions, and most attribute evaluations can accept an array of possible values. Creating a complex filter for a muting rule. Creating and managing muting rules with NerdGraph NerdGraph is an interactive, browser-based IDE for running GraphQL requests. With NerdGraph, you can create and manage muting rules, and perform the same advanced functions available in the UI, including creating muting rules for specific hosts or products and fetching rules for a specific account. Find multiple NerdGraph API examples in the documentation. Try it now! The ability to mute notifications is one way we give you more control over your monitoring and help reduce alert fatigue. If you’re ready to give it a try, sign up for a trial and get started for free. By Brian Goleno Brian Goleno is a Sr. Product Manager in the Applied Intelligence group at New Relic. Brian has been a product manager in the SaaS-based monitoring and observability space for over five years, and has been with New Relic for the past two years. Brian is currently focused on accelerating New Relic’s issue detection capabilities and supporting the New Relic One platform. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 564.52747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting Rules Now Available in <em>New</em> <em>Relic</em> Alerts",
        "sections": "Creating and managing muting rules with <em>NerdGraph</em>",
        "body": " either <em>New</em> <em>Relic</em> Alerts UI or the <em>NerdGraph</em> <em>API</em> explorer. What is a muting rule? A muting rule overrides alert policies and conditions you’ve defined in <em>New</em> <em>Relic</em>, so you can suppress notifications during times of known system disruptions. A muting rule contains a set of conditions that match a large"
      },
      "id": "60762fbd196a6709bb64a784"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/docs_code1.png",
      "url": "https://newrelic.com/blog/how-to-relic/docs-as-code-docs-in-code",
      "sections": [
        "When words in code are forgotten",
        "How the Product Language team contributes to docs in code",
        "Help us do docs in code"
      ],
      "published_at": "2021-04-14T00:08:56Z",
      "title": "Docs As the Code, Docs In the Code At New Relic",
      "updated_at": "2021-04-14T00:08:55Z",
      "type": "",
      "external_id": "b02a91dc068f658f050710d3a7b63284fa9e8f2b",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Docs As the Code, Docs In the Code At New Relic Aug 25, 2020 • 6 min read By Fabrizio Ferri-Benedetti func (c *Command) Run() (string, error) { // set the locale BLAAARGH — An old comment in our source code   Software is made of words. Some words, such as UI text or command-line messages, are for human-computer interaction; some, like API calls and error codes, target other software; and some form the documentation—README files, user guides, online help, and more. The vast majority of words in software, though, are its source code: those words that make it run. Code, too, contains human-readable text. Consider any piece of software: Whatever the programming language (except maybe Malbolge and its esoteric companions), chances are that you'll find plenty of meaningful and useful words in the source: Embedded reference docs, which can be used to build docs automatically (for example, GoDoc, Javadoc, GraphQL, and OpenAPI) String literals, from log messages to errors to input prompts Examples and comments in configuration files Names of CLI commands, variables, functions, and methods Comments in the source code (like the one I quoted above) Now that we’ve made our software open source, the idea of docs in our code has even greater importance to us. When words in code are forgotten If code isn't documented, it doesn't exist. In many cases, code may lack embedded documentation, making it hard for developers to understand how it works or is intended to be used. But that's not the only thing that can go wrong: Undocumented API schemas result in poor user experiences when loaded into API explorers; configuration files without comments are hard to tweak, and badly-written errors can make troubleshooting needlessly difficult. Plenty can go wrong when software lacks embedded documentation. At the end of the day, our software is also measured by the quality of its words, the way it speaks to users, and how well it’s documented. Great docs unlock a great developer experience. If we expect our dev community to pull our code and enrich it, we should ensure it’s well commented and documented. How the Product Language team contributes to docs in code It’d be a long blog post if I detailed every bit of our work, so here are a few recent examples of docs-in-code work that the Product Language team has accomplished: In preparation for the open source release of the Infrastructure agent, we reviewed the entire code base for typos, formatting issues, forbidden words, and sensitive information in code comments. At the same time, we fixed capitalization issues and grammar in the CLI and debug messages, and edited the README. We regularly edit NerdGraph GraphQL schemas for embedded documentation. Docs in schemas are key to good GraphQL experiences; see, for example, the screenshot below: All fields have basic reference documentation. The same applies to OpenAPI specifications for REST APIs. We also write and edit comments in sample configuration files that help users install our agents and integrations faster. The sample configuration file for the Windows services integration, for instance, provides a brief explanation that builds on the existing documentation, so that users in a hurry can still get some guidance even if they skip our docs. # To include services, create a list of filters to be applied to the service names. # Services that find a match with any of the matching lists are included. By default, # no service is included. # # Currently, only windowsService.name metadata is supported for filtering. # Prepend \"regex\" to indicate that the pattern is a regular expression. # include_matching_entities: windowsService.name: # - regex \"^*$\" # - \"ServiceNameToBeIncluded\" Help us do docs in code We’re dedicated to bringing clear, concise, and thoughtful documentation to our open source projects—from our agents to New Relic One applications to our open source and developer sites. If you have any questions or needs concerning the docs you encounter in our code, don't hesitate to reach out to us in the appropriate repo with a comment or pull request. Happy docs-as-coding! By Fabrizio Ferri-Benedetti Fabrizio Ferri-Benedetti is a Senior Product Language Writer based in Barcelona, Spain. He loves writing and technology. A cognitive psychologist by training, he jokingly refers to himself as “computer shrink.” Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 556.47363,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Docs As the Code, Docs In the Code At <em>New</em> <em>Relic</em>",
        "body": " in the CLI and debug messages, and edited the README. We regularly edit <em>NerdGraph</em> <em>GraphQL</em> schemas for embedded documentation. Docs in schemas are key to good <em>GraphQL</em> experiences; see, for example, the screenshot below: All fields have basic reference documentation. The same applies to Open<em>API</em>"
      },
      "id": "60763298196a67968464a7ba"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:50Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 552.8711,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular <em>New</em> <em>Relic</em> One Applications (Roundup #6)",
        "sections": "Subscribe to apps in the <em>New</em> <em>Relic</em> One Catalog",
        "body": " GitHub. Specific requirements for this app Flex Manager requires <em>New</em> <em>Relic</em> Infrastructure and the Flex integration. Graphi<em>QL</em> Notebook Graphi<em>QL</em> Notebook allows you to explore and learn about the <em>NerdGraph</em>—the <em>New</em> <em>Relic</em> <em>GraphQL</em> <em>API</em>—using a Jupyter Notebook style interface. Notebooks intermix <em>GraphQL</em>"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/embed/",
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "f17736ed026e1bf9fd253b8b716db26f1f13cc58",
      "popularity": 1,
      "body": "To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 662.85767,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> One <em>CLI</em> reference",
        "body": "To build a <em>New</em> <em>Relic</em> One app, you must install the <em>New</em> <em>Relic</em> One <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> One <em>CLI</em> (command line interface). This page explains how to use <em>CLI</em> commands to: Generate"
      },
      "id": "6063d63364441f61c30c8be9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/embed/",
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "6475f68b17fa018b4557ec6d4699b8b3ed06c460",
      "popularity": 1,
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic decode - Use the decode url command to print out information encrypted within the URL newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 657.4518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> commands Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> command docs in GitHub. Options bash Copy"
      },
      "id": "6063d5f364441ff6590c8ba1"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/embed/",
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps"
      ],
      "published_at": "2021-04-13T01:54:27Z",
      "title": "",
      "updated_at": "2021-04-04T01:53:18Z",
      "type": "",
      "external_id": "ddf0ca28ab311ff372e8955f2ef022de99716131",
      "popularity": 1,
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.6207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": "Access the <em>New</em> <em>Relic</em> platform from the comfort of your terminal. You can use the <em>New</em> <em>Relic</em> <em>CLI</em> to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the <em>CLI</em> to automate common tasks in your DevOps workflow. This guide walks you through"
      },
      "id": "60691c0ee7b9d2f79094463b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/embed/",
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-04-02T01:54:45Z",
      "type": "",
      "external_id": "c42a52759fcbe676670d61e60c9aa5e269edcccd",
      "popularity": 1,
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 631.931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the <em>New</em> <em>Relic</em> <em>CLI</em> is a good candidate for automation. In this 5-minute guide, you use the <em>New</em> <em>Relic</em> <em>CLI</em> to add multiple tags to one"
      },
      "id": "60667965196a67a9c347e810"
    },
    {
      "image": "https://developer.newrelic.com/static/555c6dd44f2ffbceff682f7fbc78e01c/ba3ac/demo-service.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/demo-setup/embed/",
      "sections": [
        "Spin up your demo services",
        "Course",
        "Important"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "ec4e6154accdaf3768fc5b029e77e94337973ed8",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Before you build your New Relic One application, you need to spin up your demo services. This coursework depends on two important services: A web service that shows a newsletter signup form. The form's heading text alternates between two versions because you're performing an A/B test to determine which text leads to more high-quality subscriptions. A simulator service that sends steady traffic to the website so that you don't have to manually generate data To spin up your demo services, you first need to install Docker and Docker compose. Spin up your demo services Step 1 of 5 Clone the coursework repository from GitHub: bash Copy $ git clone https://github.com/newrelic-experimental/nru-programmability-course This repository contains code for creating NodeJS New Relic automations. It also contains a an app code directory for each lesson in the course. You'll use these directories to follow along with the course content. Step 2 of 5 Change to the demo directory, called ab-test-app: bash Copy $ cd nru-programmability-course/ab-test-app This directory contains configuration files and READMEs for using the demo. Step 3 of 5 Build and run the web service and simulator containers, using docker-compose: bash Copy $ NEW_RELIC_LICENSE_KEY=<your New Relic license key> docker-compose up -d Important Make sure you replace <your New Relic license key> with your actual license key. Once it's finished, view the website at localhost:3001: Step 4 of 5 Visit New Relic, and navigate to APM in the top navigation menu. Select Newsletter from the list of instrumented services: You may have to wait a minute or two for New Relic to recieve data from your demo services. Once it's ready, you'll see transaction data, such as performance, throughput, and an Apdex score: Step 5 of 5 To spin down your demo services, run docker-compose down from your ab-test-app directory: bash Copy $ docker-compose down Now you're ready to build your New Relic One application! The first step is to install and configure the New Relic One CLI. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Install and configure the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 543.0772,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to build your <em>New</em> <em>Relic</em> One application! The first step is to install and configure the <em>New</em> <em>Relic</em> One <em>CLI</em>. Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> One application from the ground up. Continue on to the next lesson: Install and configure the <em>New</em> <em>Relic</em> One <em>CLI</em>."
      },
      "id": "6072ff1928ccbc111f51c16a"
    }
  ],
  "/terraform/terragrunt-configuration": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-14T00:08:56Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.56415,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Linking a <em>notification</em> <em>channel</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "70555c1d24e8e54b46763d57010901e206ef2ccb",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.50517,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6066782e64441f3610617ac3"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-04-12T02:18:23Z",
      "updated_at": "2021-04-06T07:43:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirements: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.03162,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-13T01:55:31Z",
      "title": "",
      "updated_at": "2021-04-01T01:51:55Z",
      "type": "",
      "external_id": "5e43fb43faa36807fc9f1eb660748303373fa8dd",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.11371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6065273be7b9d2336c944613"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/markdown-summary-for-syslog-facilities.png",
      "url": "https://newrelic.com/blog/how-to-relic/how-to-create-syslog-dashboard-using-new-relic-terraform",
      "sections": [
        "Understanding the Syslog format",
        "Step 1: Create your Terraform project",
        "Step 2: Create the Syslog dashboard",
        "Widget 1: Billboard counters by severity",
        "Widget 2: Billboard for log throughput",
        "Widget 3: Line chart to view problem-related trends over time",
        "Widget 4: Bar charts by application and node",
        "Widget 5: Line charts to view log counters by severity and facility over time",
        "Widget 6: Event table to display the top 100 logs",
        "Widget 7: Markdown summary for Syslog facilities",
        "Step 3: Apply your code",
        "Step 4: Add alerts for real-time notification",
        "Ready to create a Syslog dashboard?"
      ],
      "published_at": "2021-04-13T23:18:13Z",
      "title": "Dashboards as Code: How to Create a Syslog Dashboard Using New Relic and Terraform",
      "updated_at": "2021-04-13T23:16:12Z",
      "type": "",
      "external_id": "5372ca6e0d29c3dced938e55d3c17f22b01bbec4",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Dashboards as Code: How to Create a Syslog Dashboard Using New Relic and Terraform Mar 16, 2021 • 11 min read By Edmo Vamerlatti Dashboards are important tools that help you visualize your entire stack's performance to understand context and resolve issues quickly. They also help you answer questions such as, \"When did the problem start?\" and \"What's the impact of this issue?\" However, manually maintaining dashboards can be error prone and is sub-optimal in terms of efficiency and security. Manual updates to dashboards also do not provide any modification history, rollback mechanisms, peer reviews, or any of the benefits we normally expect in CI/CD pipelines. That’s why engineers are beginning to treat them like any other important resource: by creating dashboards as code. For example, using Terraform and the new, built-in log parser rule for Syslog RFC-5424 within New Relic One, you can implement observability as code with a dashboard that organizes Syslog RFC-5424 unstructured messages into attribute/value pairs and lets you drive alerts based on subsets of log data. With the new agentless option for onboarding syslog data, you have a variety of options for data ingest, so long as you properly parse the data when ingesting or directly from the New Relic UI. This blog post guides you through how to create a Syslog RFC-5424 dashboard as code. Understanding the Syslog format To build the dashboard, you first need to understand how log severities are defined in the Syslog RFC-5424 format. The PRI part of a syslog, which is a calculated priority value, is used to represent both the facility and severity of the log or event message. PRI calculates the value by first multiplying the facility number by 8 and then adding the numerical value of the severity. For example, a security/authorization (facility = 4) with a critical severity (severity = 2) would have a PRI value of 34 ((4 * 8) + 2). Based on this understanding, you can extract the log severity from the PRI log attribute using the following formula: (pri - ((floor(pri)/8) * 8)). Step 1: Create your Terraform project As an infrastructure-as-code tool that you can use to provision all kinds of infrastructure and services, Terraform uses a configuration language known as HCL. Its main purpose is to describe resources that are used to represent infrastructure objects. The resources are processed by specific plugins called providers. New Relic has an official Terraform provider. It allows you to manage different types of resources such as dashboards, alert channels, and alert policies. For more information about the Terraform provider, see the provider documentation and the quick-tip video shown here. Start by creating your project folder. Because Terraform is quite flexible and can be adapted depending on the requirements of your project (including multiple environments, multiple accounts, and so on), there are different ways of organizing a Terraform workspace. For simplicity’s sake, we’ll adopt a flat structure for this example. 1. Create a directory for your project. mkdir newrelic-syslog-monitoring 2. Create a file named versions.tf in your working directory. Terraform uses this file to configure the Terraform client and specify all required providers for the current module, in this case, the newrelic provider. terraform { required_version = \">= 0.13\" required_providers { newrelic = { source  = \"newrelic/newrelic\" version = \">= 2.12.0\" } } } 3. Provide input variables. The New Relic Terraform provider requires an Account ID, Personal Key, and Region (US or EU) to integrate with your account and manage resources. It supports two methods of configuration: using environment variables or a provider block. This simple example uses the provider block, and all required information is received through input variables. Create a file named variables.tf: variable \"NEWRELIC_ACCOUNT_ID\" { type    = number } variable \"NEWRELIC_API_KEY\" { type    = string } variable \"NEWRELIC_REGION\" { type    = string } 4. Create a file named main.tf to be the primary entry point for Terraform. The New Relic Terraform provider is also configured in this file using the input variables previously declared in the variables.tf file: provider \"newrelic\" { account_id = var.NEWRELIC_ACCOUNT_ID api_key    = var.NEWRELIC_API_KEY region     = var.NEWRELIC_REGION } Step 2: Create the Syslog dashboard All the dashboard data is retrieved from the Log data type using the NRQL query language. To simplify the queries and avoid repetition, use Terraform locals to represent the Syslog severity formula and the logType filter value. 1. Create a file named dashboards.tf. This file is used to describe the dashboard resource and its widgets/visualizations: locals { syslog   = \"syslog-rfc5424\" severity = \"(numeric(pri) - (floor(numeric(pri)/8) * 8))\" } resource \"newrelic_dashboard\" \"syslog_dashboard\" { title             = \"Syslog Dashboard\" grid_column_count = 12 } 2. Add widgets and visualizations. The first step in designing your dashboard is to define what you want to achieve and which visualizations will be most important to enable that. For this example, the dashboard gives an overview of application health. Note: All widget code goes inside the \"syslog_dashboard\" {...} block. Widget 1: Billboard counters by severity The log's severity is one of the most important fields available in the Syslog format and is widely used on this dashboard's visualizations. Billboard charts show the log counters by severity, coloring them yellow or red depending on the threshold_yellow and threshold_red values. The charts make it easy to see what's happening with your applications and catch your attention if any problematic log arrives. Because these billboard charts share nearly identical code, you can take advantage of Terrafrom's dynamic blocks and reuse the code to iterate through a severity_billboards map to configure every widget. To accomplish this, add a severity_billboards map inside the locals{...} block with the following content: locals { syslog   = \"syslog-rfc5424\" severity = \"(numeric(pri) - (floor(numeric(pri)/8) * 8))\" severity_billboards = tomap({ \"emergency\"     = { severity =  0, row = 1, column = 1, threshold_red = 1 }, \"alert\"         = { severity =  1, row = 2, column = 1, threshold_red = 1 }, \"critical\"      = { severity =  2, row = 1, column = 2, threshold_red = 1 }, \"error\"         = { severity =  3, row = 2, column = 2, threshold_yellow = 1 }, \"warning\"       = { severity =  4, row = 1, column = 3 }, \"notice\"        = { severity =  5, row = 2, column = 3 }, \"informational\" = { severity =  6, row = 1, column = 4 }, \"debug\"         = { severity =  7, row = 2, column = 4 } }) } Then add generic code for the widget inside the syslog_dashboard\" {...} block: dynamic \"widget\" { for_each = local.severity_billboards content { title            = \"\" nrql             = <<-EOF SELECT count(*) as '${title(widget.key)} (${widget.value.severity})' FROM Log WHERE logType = '${local.syslog}' AND ${local.severity} = ${widget.value.severity} EOF visualization    = \"billboard\" width            = 1 height           = 1 row              = widget.value.row column           = widget.value.column threshold_yellow = try(widget.value.threshold_yellow, null) threshold_red    = try(widget.value.threshold_red, null) } } Your final result should look similar to this:   Widget 2: Billboard for log throughput This chart shows the total number of logs and the rate per minute your applications are sending them. widget { title         = \"Throughput\" nrql          = <<-EOF SELECT rate(count(*), 1 minute) as 'Logs /min', count(*) as 'Total' FROM Log WHERE logType = '${local.syslog}' SINCE 1 hour ago EOF visualization = \"attribute_sheet\" width         = 2 height        = 2 row           = 1 column        = 5 } Your final result should look like this:   Widget 3: Line chart to view problem-related trends over time This chart counts all logs with severity equal to Error(3), Critical(2), Alert(1) or Emergency(0) and displays the result over time. Spikes on this graph show that you might have problems with your applications that require actions to be taken to resolve them. widget { title         = \"Logs (Emergency + Alert + Critical + Error)\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' AND ${local.severity} < 4 TIMESERIES AUTO EOF visualization = \"line_chart\" width         = 6 height        = 3 row           = 3 column        = 1 } Your final result should look something like this:   Widget 4: Bar charts by application and node These charts show the number of logs by application and hostname. They can also be configured to filter the current dashboard just by clicking on the application/hostname bars. widget { title         = \"Top Applications\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET app.name EOF visualization = \"facet_bar_chart\" width         = 2 height        = 5 row           = 1 column        = 7 } widget { title         = \"Top Nodes\" nrql          = <<-EOF SELECT count(*) as 'Logs' FROM Log WHERE logType = '${local.syslog}' FACET hostname EOF visualization = \"facet_bar_chart\" width         = 2 height        = 5 row           = 1 column        = 9 } Your final result should look similar to this:   Widget 5: Line charts to view log counters by severity and facility over time The idea behind these charts is to display the number of logs by severity and facility your applications are sending over time. This way you can easily detect spikes of any severity or facility and identify when they started and stopped. widget { title         = \"Logs by Severity\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET string(${local.severity}) as 'Severity' TIMESERIES AUTO EOF visualization = \"faceted_line_chart\" width         = 3 height        = 3 row           = 6 column        = 1 } widget { title         = \"Logs by Facility\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET floor(numeric(pri)/8) as 'Facility' TIMESERIES AUTO EOF visualization = \"faceted_line_chart\" width         = 3 height        = 3 row           = 6 column        = 4 } Your final result should look similar to this:   Widget 6: Event table to display the top 100 logs This chart displays the 100 most important logs prioritized by severity. widget { title         = \"Top 100 Logs\" nrql          = <<-EOF SELECT ${local.severity} as 'Severity', app.name as 'Application', message FROM Log WHERE logType = '${local.syslog}' LIMIT 100 EOF column        = 7 row           = 6 visualization = \"event_table\" width         = 6 height        = 3 } Your final result should look like this:   Widget 7: Markdown summary for Syslog facilities This chart lists the names of the syslog facilities on your dashboard for easy reference. widget { title         = \"\" width         = 2 height        = 5 row           = 1 column        = 11 source        = <<-EOF ### Facilities 1. kernel messages 2. user-level messages 3. mail system 4. system daemons 5. security/authorization messages (note 1) 6. messages generated internally by syslogd 7. line printer subsystem 8. network news subsystem 9. UUCP subsystem 10. clock daemon (note 2) 11. security/authorization messages (note 1) 12. FTP daemon 13. NTP subsystem 14. log audit (note 1) 15. log alert (note 1) 16. clock daemon (note 2) to 23. local uses 0 to 7 (local n) EOF visualization = \"markdown\" } Your final dashboard should look similar to this: markdown summary for syslog facilities example   Step 3: Apply your code You can install the Terraform client either by downloading the binary from www.terraform.io/downloads.html or using your operating system's package manager. More instructions on how to install Terraform in different environments can be found here. After you install the Terraform client, run the following command in your working directory: terraform plan -var NEWRELIC_ACCOUNT_ID=<YOUR-ACCOUNT-ID> -var NEWRELIC_API_KEY=<YOUR-API-KEY> \\ -var NEWRELIC_REGION=<US or EU> The terraform plan command creates an execution plan and then determines which actions are necessary to achieve the desired state specified in the configuration files. In this case, your dashboard resource is added. Finally, run the following command to apply all pending actions and create the resources in the New Relic One platform: terraform apply -var NEWRELIC_ACCOUNT_ID=<YOUR-ACCOUNT-ID> -var NEWRELIC_API_KEY=<YOUR-API-KEY> \\ -var NEWRELIC_REGION=<US or EU> Terraform uses states to map your local resources to the real world. When you have a declared resource such as resource \"newrelic_dashboard\" in your files, Terraform uses the map to know that the New Relic Dashboard ID 1234 is represented by that resource. That said, if you apply this project in different machines without sharing the state, Terraform will recreate all resources instead of updating them. Setting up a remote state would prevent this situation. HashiCorp offers a Terraform Cloud solution that automates Terraform workflow out of the box. It's also possible to use Atlantis, which is a tool that automates Terraform through pull requests, taking your observability as code to the next level. Step 4: Add alerts for real-time notification Although dashboards are essential tools for detecting and troubleshooting problems, unless you’re watching them 24 hours a day, you can miss important logs. Setting up alerts gives you instant notification whenever an important metric hits a threshold. New Relic alerts help you solve your application issues faster and with less noise before they turn into critical incidents. New Relic’s third-party integrations, such as PagerDuty and Slack, make the notification process very efficient and adaptable to your team’s needs. The New Relic Terraform provider supports all required alerting resources to monitor your syslog applications. You can, for example, create different alert channels per team, responsibility, node, or application, notifying different people in various ways when applications are reporting errors. For the example, you can reuse the dashboard queries and define the following NRQL alert conditions: A static threshold alarm for critical severities Error(3), Critical(2), Alert(1) and Emergency(0). Baseline alarm in upper direction for log counters with severity < 4 to detect abnormal unhealthy spikes. Additional alerts depending on your environment and system characteristics, such as a static alert for logs with severity < 4 and facility equal to security/authorization messages(4), which would appropriately send a notification message to the #security-team Slack channel, for example, and not the whole company. (For more information about New Relic alerts with Terraform, see this blog post.) Ready to create a Syslog dashboard? All the code used in the example can be found in this GitHub repository. If you don't want to use Terraform but would like to try out the dashboard, you can import it by copying this JSON file content, replacing the <YOUR_ACCOUNT_ID> placeholder with your Account ID, and importing it into New Relic using the UI (Dashboard > Import dashboard option). If you’re new to New Relic and want to try out the New Relic Terraform provider, sign up for a new account with 100 GB/month of free ingest. By Edmo Vamerlatti Edmo is a Software Engineer at New Relic, where he works on the Logging team. His professional interests include distributed systems, high scalability, observability, and programming languages. In his spare time, he enjoys reading, eating out in restaurants, and skateboarding. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.38972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dashboards as Code: How to Create a Syslog Dashboard Using New Relic and <em>Terraform</em>",
        "sections": "Step 4: Add <em>alerts</em> for real-time <em>notification</em>",
        "body": " and facility equal to security&#x2F;authorization messages(4), which would appropriately send a <em>notification</em> message to the #security-team Slack <em>channel</em>, for example, and not the whole company. (For more information about New Relic <em>alerts</em> with <em>Terraform</em>, see this blog post.) Ready to create a Syslog dashboard"
      },
      "id": "6076263d28ccbcffe951c16a"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/embed/",
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "f6dba06ee883ff39a13eb7090bf3c91f9395d6e2",
      "popularity": 1,
      "body": "Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application. Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component. Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows. As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells. The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1136.0496,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>tables</em> to your New <em>Relic</em> One <em>application</em>",
        "body": " the following components to the import statement at the top of the file so that it looks like the example: <em>Table</em> <em>TableHeader</em> <em>TableHeaderCell</em> <em>TableRow</em> <em>TableRowCell</em> import { <em>Table</em>, <em>TableHeader</em>, <em>TableHeaderCell</em>, <em>TableRow</em>, <em>TableRowCell</em>, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart"
      },
      "id": "6063d633196a6796a1c6f441"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Course",
        "Extra credit"
      ],
      "published_at": "2021-04-11T14:01:09Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add pie charts, before starting this one. In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a chart group.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 398.61234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>tables</em>",
        "body": " your first <em>Table</em>Chart and some mock data: import React from &#x27;react&#x27;; import { <em>Table</em>Chart } from &#x27;nr1&#x27;; export default class VersionTotals extends React.<em>Component</em> { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version"
      },
      "id": "60725692196a67b68c64a778"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/embed/",
      "sections": [
        "Customize NRQL data",
        "Course",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T14:01:47Z",
      "type": "",
      "external_id": "f51f9d86d3b873b24e967c687d5408eb9918a33f",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add NrqlQuery components to your nerdlet, before starting this one. In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your nerdpack served locally, view your application to see your charts serving real data: In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorage from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 357.27667,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Experiment with data <em>in</em> the Data explorer",
        "body": "&#x27;s totals.js file, implement constructor() and the React lifecycle method <em>component</em>DidMount() in VersionTotals: import React from &#x27;react&#x27;; import { HeadingText, NrqlQuery, <em>Table</em>Chart, } from &#x27;nr1&#x27;; export default class VersionTotals extends React.<em>Component</em> { constructor() { super(...arguments); this.state"
      },
      "id": "6073014b28ccbc70b651c134"
    },
    {
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/embed/",
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "published_at": "2021-04-11T13:57:11Z",
      "title": "",
      "updated_at": "2021-03-31T01:51:31Z",
      "type": "",
      "external_id": "f86a155c76fd8aed2a2db00917f0bbfac21ec0cf",
      "popularity": 1,
      "body": "New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: bash Copy $ nr1 create --type nerdpack --name pageviews-app ✔ Component created successfully! nerdpack pageviews-app is available at \"./pageviews-app\" Serve the project up to New Relic: bash Copy $ cd pageviews-app && nr1 nerdpack:serve Found and loaded 2 nr1.json files on PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) Nerdpack. Nerdpack: ✔ PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) nr1.json Launchers: ✔ pageviews-app-launcher launchers/pageviews-app-launcher/nr1.json Nerdlets: ✔ pageviews-app-nerdlet nerdlets/pageviews-app-nerdlet/nr1.json 🛠 Built artifact files for: ⁎ 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ✔ ✔ Nerdpack built successfully! ★ Starting as orchestrator... ✔ Server ready! Test it at: https://staging-one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! 🛠 Built artifact files for: ⁎ 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ✔ ✔ Nerdpack built successfully! Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 3 const accountId = 0; // Replace with your account ID 4 5 export default class PageViewApp extends React.Component { 6 render() { 7 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 8 } 9 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 9 } 10 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line with this export code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <div className=\"row\"> 12 <TextField 13 placeholder=\"US\" 14 onChange={(event) => { 15 this.setState({ countryCode: event.target.value }); 16 }} 17 /> 18 </div> 19 <TableChart 20 accountId={accountId} 21 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 22 fullWidth 23 className=\"chart\" 24 /> 25 </div> 26 </div> 27 ); 28 } 29 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 return ( 16 <div className=\"container\"> 17 <div className=\"row\"> 18 <div className=\"row\"> 19 <TextField 20 placeholder=\"US\" 21 onChange={(event) => { 22 this.setState({ countryCode: event.target.value }); 23 }} 24 /> 25 </div> 26 <TableChart 27 accountId={accountId} 28 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 29 fullWidth 30 className=\"chart\" 31 /> 32 </div> 33 </div> 34 ); 35 } 36 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Above return, add: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 31 fullWidth 32 className=\"chart\" 33 /> 34 </div> 35 </div> 36 ); 37 } 38 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Now add countryCode to your table chart query. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: bash Copy $ npm install --save leaflet react-leaflet In your nerdlets styles.scss file, import the Leaflet CSS: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy While you're in styles.scss, fix the width and height of your map: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 4 5 const accountId = 0; // Replace with your account ID 6 7 export default class PageViewApp extends React.Component { 8 constructor(props) { 9 super(props); 10 this.state = { 11 countryCode: null, 12 }; 13 } 14 15 render() { 16 const { countryCode } = this.state; 17 18 return ( 19 <div className=\"container\"> 20 <div className=\"row\"> 21 <div className=\"row\"> 22 <TextField 23 placeholder=\"US\" 24 onChange={(event) => { 25 this.setState({ countryCode: event.target.value }); 26 }} 27 /> 28 </div> 29 <TableChart 30 accountId={accountId} 31 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 32 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 33 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 34 fullWidth 35 className=\"chart\" 36 /> 37 </div> 38 </div> 39 ); 40 } 41 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 render() { 23 const { countryCode } = this.state; 24 25 return ( 26 <div className=\"container\"> 27 <div className=\"row\"> 28 <div className=\"row\"> 29 <TextField 30 placeholder=\"US\" 31 onChange={(event) => { 32 this.setState({ countryCode: event.target.value }); 33 }} 34 /> 35 </div> 36 <TableChart 37 accountId={accountId} 38 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 39 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 40 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 41 fullWidth 42 className=\"chart\" 43 /> 44 </div> 45 </div> 46 ); 47 } 48 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 mapData() { 23 const { countryCode } = this.state; 24 const query = `{ 25 actor { 26 account(id: 1606862) { 27 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 28 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 29 } LIMIT 1000 \") { 30 results 31 nrql 32 } 33 } 34 } 35 }`; 36 37 return query; 38 } 39 40 render() { 41 const { countryCode } = this.state; 42 43 return ( 44 <div className=\"container\"> 45 <div className=\"row\"> 46 <div className=\"row\"> 47 <TextField 48 placeholder=\"US\" 49 onChange={(event) => { 50 this.setState({ countryCode: event.target.value }); 51 }} 52 /> 53 </div> 54 <TableChart 55 accountId={accountId} 56 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 57 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 58 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 59 fullWidth 60 className=\"chart\" 61 /> 62 </div> 63 </div> 64 ); 65 } 66 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 53 return ( 54 <div className=\"container\"> 55 <div className=\"row\"> 56 <div className=\"row\"> 57 <TextField 58 placeholder=\"US\" 59 onChange={(event) => { 60 this.setState({ countryCode: event.target.value }); 61 }} 62 /> 63 </div> 64 <TableChart 65 accountId={accountId} 66 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 67 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 68 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 69 fullWidth 70 className=\"chart\" 71 /> 72 </div> 73 </div> 74 ); 75 } 76 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <TableChart 66 accountId={accountId} 67 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 68 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 69 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 70 fullWidth 71 className=\"chart\" 72 /> 73 </div> 74 </div> 75 ); 76 } 77 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 return 'Hello'; 77 }} 78 </NerdGraphQuery> 79 </div> 80 <TableChart 81 accountId={accountId} 82 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 83 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 84 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 85 fullWidth 86 className=\"chart\" 87 /> 88 </div> 89 </div> 90 ); 91 } 92 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: index.js styles.scss .extended-webpackrc.js import React from 'react'; import { TableChart, TextField, NerdGraphQuery, Spinner, Button, BlockText, } from 'nr1'; import { Map, CircleMarker, TileLayer } from 'react-leaflet'; const accountId = 0; // Replace with your account ID export default class PageViewApp extends React.Component { constructor(props) { super(props); this.state = { countryCode: null, }; } getMarkerColor(measure, apdexTarget = 1.7) { if (measure <= apdexTarget) { return '#11A600'; } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { return '#FFD966'; } else { return '#BF0016'; } } mapData() { const { countryCode } = this.state; const query = `{ actor { account(id: 1606862) { mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' } LIMIT 1000 \") { results nrql } } } }`; return query; } render() { const { countryCode } = this.state; const defaultMapCenter = [10.5731, -7.5898]; return ( <div className=\"container\"> <div className=\"row\"> <div className=\"row\"> <TextField placeholder=\"US\" onChange={(event) => { this.setState({ countryCode: event.target.value }); }} /> </div> <div className=\"row\"> <NerdGraphQuery query={this.mapData()}> {({ loading, error, data }) => { if (loading) { return <Spinner fillContainer />; } if (error) { return 'Error'; } const { results } = data.actor.account.mapData; console.debug(results); return ( <Map className=\"containerMap\" center={defaultMapCenter} zoom={2} zoomControl > <TileLayer attribution='&copy OpenStreetMap contributors' url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" /> {results.map((pt, i) => { const center = [pt.lat, pt.lng]; return ( <CircleMarker key={`circle-${i}`} center={center} color={this.getMarkerColor(pt.y)} radius={Math.log(pt.x) * 3} onClick={() => { alert(JSON.stringify(pt)); }} /> ); })} </Map> ); }} </NerdGraphQuery> </div> <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" /> </div> </div> ); } } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.4146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Import the <em>TableChart</em> <em>component</em>",
        "body": " PageView<em>App</em> extends React.<em>Component</em> { 7 render() { 8 return ( 9 &lt;div className=&quot;container&quot;&gt; 10 &lt;div className=&quot;<em>row</em>&quot;&gt;&lt;&#x2F;div&gt; 11 &lt;&#x2F;div&gt; 12 ); 13 } 14 } pageview-<em>app</em>-nerdlet&#x2F;index.js Copy 1 pageview-<em>app</em>-nerdlet&#x2F;styles.scss Copy 1 .extended-webpackrc.js Copy Step 7 of 8 Customize the look of your <em>table</em>"
      },
      "id": "6063d5a4196a677f86c6f477"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings",
        "Course"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a grid, before starting this one. Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add version descriptions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 298.6396,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ": 9 }, ], } return &lt;div&gt; &lt;HeadingText className=&quot;chart<em>Header</em>&quot;&gt; Version {this.props.version.toUpperCase()} - Page views &lt;&#x2F;HeadingText&gt; &lt;LineChart data={[versionPageViews]} fullWidth &#x2F;&gt; &lt;&#x2F;div&gt; } } nerdlets&#x2F;ab-test-nerdlet&#x2F;page-views.js Copy import React from &#x27;react&#x27;; import { HeadingText, <em>Table</em>"
      },
      "id": "6072ff1928ccbc140b51c16e"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/SynthKub1.png",
      "url": "https://newrelic.com/blog/how-to-relic/deploy-synthetics-from-kubernetes-environments",
      "sections": [
        "Benefits of connecting New Relic Synthetics and Kubernetes",
        "How to get started with New Relic Synthetics and Kubernetes",
        "To monitor the CPM using the Kubernetes cluster explorer",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:54:48Z",
      "title": "Deploy Synthetics from Kubernetes Environments to Monitor Employee-Facing Applications",
      "updated_at": "2021-04-13T23:54:47Z",
      "type": "",
      "external_id": "fe7c715c1417af64bd4c5ffc1871739a673484f8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring Deploy Synthetics from Kubernetes Environments to Monitor Employee-Facing Applications May 13, 2020 • 7 min read By Mat Ball Kubernetes helps increase the velocity of deployments, improve infrastructure durability, and automate the building, running, and maintaining of applications throughout your production environments. To optimize performance, New Relic released the Kubernetes cluster explorer so you can quickly understand the health of your rapidly-scaling environments of pods, containers, and applications. Synthetic testing and monitoring allows you to proactively test the availability and performance of your critical endpoints.  We launched containerized private minions to help you easily incorporate uptime monitoring into the build process as you tested employee facing applications behind the firewall. For these reasons, we’re excited to announce that New Relic users can now add private minions into their Kubernetes environments. This new feature offers our customers the ability to automatically deploy synthetic private locations and run monitors alongside them as part of a Kubernetes deployment. In short, New Relic Synthetics is meeting you where you are—within the systems you’re using—to automate and manage your build and deployment processes. You now have an easier way to automate and ensure that your critical endpoints are available and performant as you rapidly change and scale your systems. Benefits of connecting New Relic Synthetics and Kubernetes We’ve made Synthetics compatible with your Kubernetes orchestration software, enabling you to use Kubernetes to monitor availability and performance from Synthetic’s private locations, such as those behind a firewall or not exposed to the public. Leveraging Kubernetes to automate and manage these private locations helps developers save time and reduce manual efforts. Use the private minion Helm charts to easily include a private location in your next Kubernetes deployment. Once the location is created, add it to your existing Synthetics monitors, and you’ll be up and running in minutes. Leave the scaling and reliability concerns to Kubernetes. We have designed our private minion so that Kubernetes has full control over the resources and containers. The Helm charts allow you to use our recommended default resources or provide you with the ability to define the resource allocation per synthetics check. This helps you focus more on remediating latency and improving reliability, and less on configuration and instrumentation. Even more, we offer additional visibility of the Kubernetes host itself. Using the New Relic Kubernetes cluster explorer you can quickly see the health and status of your private location, alongside the other containers running in your Kubernetes environment. You can also easily view stats and errors about your private location, and understand how widespread issues might be across other applications running on the same cluster. This way, New Relic customers leveraging Kubernetes can simultaneously deploy a new version of their application alongside APM and Synthetics. The feature makes it easy by leveraging Helm charts on Kubernetes, which automatically provide reference configurations, steps for deployment, and resource requirements. If an application experiences issues and is re-deployed per the Kubernetes automated deployment process, Synthetics is also redeployed with no additional configuration needed. How to get started with New Relic Synthetics and Kubernetes Confirm you meet the Kubernetes container orchestration system environment requirements. Locate your private location key.  Go to synthetics.newrelic.com > Private locations.In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Set up a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com/charts If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Install the CPM using the Helm charts: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY To update an existing CPM installation: helm update YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YO Next, connect into New Relic’s Kubernetes cluster explorer. To monitor the CPM using the Kubernetes cluster explorer Locate your license key. Find your cluster name: kubectl config current-context Confirm you have kube-state-metrics installed: kubectl get deployment --all-namespaces | grep kube-state-metrics Select the cluster for the agent installation: kubectl config set-cluster DESIRED_CLUSTER Add the Helm charts: helm repo add stable https://kubernetes-charts.storage.googleapis.com/ Install the Kubernetes integration using the Helm charts, depending on whether you're using Helm 2 or Helm 3 Look up the Synthetics minion in your Kubernetes cluster explorer. For employee-facing applications, or any application not exposed to the public or behind the firewall, availability, and performance is critical to efficiency. Kubernetes orchestration software allows teams to quickly automate change and more easily manage the build and deploy process. Incorporating synthetic monitoring into Kubernetes software gives software engineers the ability to easily detect, isolate, and communicate problems of availability and performance for critical application endpoints. To learn more about how you can enable teams to proactively detect and resolve incidents faster by finding problems before they impact customers, check out New Relic Synthetics. Related Topics Kubernetes Monitoring By Mat Ball Mat Ball is a product marketing manager at New Relic focused on the impact of frontend web applications to business and customer experience outcomes. Previously, Mat worked for SOASTA, where he marketed their data science product. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 298.10022,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Benefits of connecting <em>New</em> <em>Relic</em> Synthetics and Kubernetes",
        "body": " the key associated with the private location with the key icon. <em>Set</em> <em>up</em> a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the <em>Helm</em> <em>charts</em> from the <em>New</em> <em>Relic</em> <em>Helm</em> repo. If you are copying the <em>charts</em> for the first time: <em>helm</em> repo add YOUR_REPO_NAME https:&#x2F;&#x2F;<em>helm</em>"
      },
      "id": "60762f4864441f45329d854f"
    },
    {
      "image": "https://developer.newrelic.com/static/12d81f6bc920b8e4d1f3fdff919ce7e2/209c2/k8s-cluster-explorer.png",
      "url": "https://developer.newrelic.com/automate-workflows/kubernetes-helm-deployment/embed/",
      "sections": [
        "Set up New Relic using Helm charts",
        "Before you begin",
        "Adding the New Relic Helm repository",
        "Install the New Relic Helm chart",
        "Use the New Relic Kubernetes cluster explorer",
        "Try it out now",
        "Some tips to use the on-line tutorial window:",
        "Important",
        "What’s next?"
      ],
      "published_at": "2021-04-13T01:55:31Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "98352926cd24eeccfd7abe49dc20e8b6ed6ad039",
      "popularity": 1,
      "body": "Helm is like a package manager for Kubernetes. Helm charts help define, install and upgrade your Kubernetes applications. In this guide you'll learn how to set up New Relic with the official New Relic Helm charts. The Helm charts will deploy everything you need to get full observability of your Kubernetes environment. Before you begin This walk through assumes you’ve already deployed a Kubernetes cluster. Or you can simply use our test environment, by following the interactive tutorial at the bottom of this page. To use this guide, you should have some basic knowledge of both New Relic and Kubernetes. To complete the full exercise, you’ll need to: Get your New Relic license key Install Helm 3 Step 1 of 3 Adding the New Relic Helm repository First, add the official New Relic Helm repository bash Copy $ helm repo add newrelic https://helm-charts.newrelic.com You should see something similar to the following: bash Copy \"newrelic\" has been added to your repositories Step 2 of 3 Install the New Relic Helm chart Follow the instructions to get your New Relic license key Replace YOUR_NEW_RELIC_LICENSE_KEY and CLUSTER_NAME before running the following command: bash Copy $ helm install newrelic-bundle newrelic/nri-bundle \\ > --set global.licenseKey=YOUR_NEW_RELIC_LICENSE_KEY \\ > --set global.cluster=CLUSTER_NAME \\ > --namespace=default \\ > --set newrelic-infrastructure.privileged=true \\ > --set ksm.enabled=true \\ > --set prometheus.enabled=true \\ > --set kubeEvents.enabled=true \\ > --set logging.enabled=true You should see something similar to the following: bash Copy NAME: newrelic-bundle LAST DEPLOYED: Wed Aug 19 09:04:52 2020 NAMESPACE: default STATUS: deployed REVISION: 1 TEST SUITE: None Check if the New Relic agents have been deployed: bash Copy $ kubectl get daemonsets,pods This should look similar to: bash Copy NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/newrelic-bundle-newrelic-infrastructure 1 1 1 1 1 <none> 2m53s daemonset.apps/newrelic-bundle-newrelic-logging 1 1 1 1 1 <none> 2m53s NAME READY STATUS RESTARTS AGE pod/newrelic-bundle-kube-state-metrics-69ff8cfb74-rgjc5 1/1 Running 0 2m53s pod/newrelic-bundle-newrelic-infrastructure-z8ddb 1/1 Running 0 2m53s pod/newrelic-bundle-newrelic-logging-wp22p 1/1 Running 0 2m53s pod/newrelic-bundle-nri-kube-events-f9d5bb944-kcxxf 2/2 Running 0 2m53s pod/newrelic-bundle-nri-metadata-injection-66d76c868b-xrcq8 1/1 Running 0 2m53s pod/newrelic-bundle-nri-metadata-injection-job-rszw5 0/1 Completed 0 2m53s pod/newrelic-bundle-nri-prometheus-569689b7cb-pnddg 1/1 Running 0 2m53s Step 3 of 3 Use the New Relic Kubernetes cluster explorer Open the Kubernetes cluster explorer in New Relic One You should see something like: Want to know more? Learn how to navigate the Kubernetes cluster explorer Try it out now We can have a Kubernetes test cluster ready for you in a few minutes. By following this on-line tutorial, you will learn how to deploy the New Relic Helm charts. Some tips to use the on-line tutorial window: Accept the cookies, so you can see the menu bar. Click anywhere in the tutorial window to start. It will take a few minutes for your environment to be ready. Press CTRL-l or type clear to clear the terminal window Click on the finish flag icon in the bottom menu to hide or show the instructions Good luck! Important Some browsers automatically disable the use of iframes. If the module isn't loading please check your browser settings. Your browser does not support iframes. What’s next? Nice work — now you can easily deploy New Relic with the official New Relic Helm charts and you can start using the Kubernetes cluster explorer. The Kubernetes cluster explorer brings full observability to your k8s environment, so you can troubleshoot faster by correlating logs, metrics, events and traces all within the same user experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.65967,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>",
        "body": "<em>Helm</em> is like a package manager for Kubernetes. <em>Helm</em> <em>charts</em> help define, install and upgrade your Kubernetes applications. In this guide you&#x27;ll learn how to <em>set</em> <em>up</em> <em>New</em> <em>Relic</em> with the official <em>New</em> <em>Relic</em> <em>Helm</em> <em>charts</em>. The <em>Helm</em> <em>charts</em> will deploy everything you need to get full observability of your"
      },
      "id": "6063d633196a676102c6f465"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/openshift5.png",
      "url": "https://newrelic.com/blog/how-to-relic/what-is-kubernetes",
      "sections": [
        "OK, but why all the buzz? Why is Kubernetes so popular?",
        "So, how does Kubernetes work?",
        "The Kubernetes master",
        "Nodes",
        "Deployments and replicas",
        "Namespaces",
        "Labels",
        "Stateful sets and persistent storage volumes",
        "Other useful components",
        "Kubernetes DNS",
        "Cluster-level logs",
        "Helm: managing Kubernetes applications",
        "Kubernetes and Istio: a popular pairing",
        "Challenges to Kubernetes adoption",
        "New Relic can support your Kubernetes journey",
        "Related Topics"
      ],
      "published_at": "2021-04-14T00:02:30Z",
      "title": "What Is Kubernetes? An Introduction to the Wildly Popular Container Orchestration Platform",
      "updated_at": "2021-04-14T00:02:30Z",
      "type": "",
      "external_id": "1e800a620cd7bce03e30dd9a74ee244fc2e5ad6a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring What Is Kubernetes? An Introduction to the Wildly Popular Container Orchestration Platform Aug 15, 2019 • 14 min read By Ali Gerrard This is an update of a post originally published in July, 2018. Container-based microservices architectures have profoundly changed the way development and operations teams test and deploy modern software. Containers help companies modernize by making it easier to scale and deploy applications, but containers have also introduced new challenges and more complexity by creating an entirely new infrastructure ecosystem. Large and small software companies alike are now deploying thousands of container instances daily, and that’s a complexity of scale they have to manage. So how do they do it? Enter the age of Kubernetes. Originally developed by Google, Kubernetes is an open-source container orchestration platform designed to automate the deployment, scaling, and management of containerized applications. In fact, Kubernetes has established itself as the defacto standard for container orchestration and is the flagship project of the Cloud Native Computing Foundation (CNCF), backed by key players like Google, AWS, Microsoft, IBM, Intel, Cisco, and Red Hat. Kubernetes makes it easy to deploy and operate applications in a microservice architecture. It does so by creating an abstraction layer on top of a group of hosts, so that development teams can deploy their applications and let Kubernetes manage: Controlling resource consumption by application or team Evenly spreading application load across a host infrastructure Automatically load balancing requests across the different instances of an application Monitoring resource consumption and resource limits to automatically stop applications from consuming too many resources and restarting the applications again Moving an application instance from one host to another if there is a shortage of resources in a host, or if the host dies Automatically leveraging additional resources made available when a new host is added to the cluster Easily performing canary deployments and rollbacks See also: Docker vs. Kubernetes: It’s Not About One or the Other OK, but why all the buzz? Why is Kubernetes so popular? As more and more organizations move to microservice and cloud native architectures that make use of containers, they’re looking for strong, proven platforms. Practitioners are moving to Kubernetes for four main reasons: 1. Kubernetes helps you move faster. Indeed, Kubernetes allows you to deliver a self-service Platform-as-a-Service (PaaS) that creates a hardware layer abstraction for development teams. Your development teams can quickly and efficiently request the resources they need. If they need more resources to handle additional load, they can get those just as quickly, since resources all come from an infrastructure shared across all your teams. No more filling out forms to request new machines to run your application. Just provision and go, and take advantage of the tooling developed around Kubernetes for automating packaging, deployment, and testing, such as Helm (more below). 2. Kubernetes is cost efficient. Kubernetes and containers allow for much better resource utilization than hypervisors and VMs do; because containers are so light weight, they require less CPU and memory resources to run. 3. Kubernetes is cloud agnostic. Kubernetes runs on Amazon Web Services (AWS), Microsoft Azure, and the Google Cloud Platform (GCP), and you can also run it on-premise. You can move workloads without having to redesign your applications or completely rethink your infrastructure—which lets you to standardize on a platform and avoid vendor lock-in. In fact, companies like Kublr, Cloud Foundry, and Rancher provide tooling to help you deploy and manage your Kubernetes cluster on-premise or on whatever cloud provider you want. 4. Cloud providers will manage Kubernetes for you. As noted earlier, Kubernetes is currently the clear standard for container orchestration tools. It should come as no surprise, then, that major cloud providers are offering plenty of Kubernetes-as-a-Service-offerings. Amazon EKS, Google Cloud Kubernetes Engine, Azure Kubernetes Service (AKS), Red Hat Openshift, and IBM Cloud Kubernetes Service all provide a full Kubernetes platform management, so you can focus on what matters most to you—shipping applications that delight your users. So, how does Kubernetes work? The central component of Kubernetes is the cluster. A cluster is made up of many virtual or physical machines that each serve a specialized function either as a master or as a node. Each node hosts groups of one or more containers (which contain your applications), and the master communicates with nodes about when to create or destroy containers. At the same time, it tells nodes how to re-route traffic based on new container alignments. The following diagram depicts a general outline of a Kubernetes cluster: The Kubernetes master The Kubernetes master is the access point (or the control plane) from which administrators and other users interact with the cluster to manage the scheduling and deployment of containers. A cluster will always have at least one master, but may have more depending on the cluster’s replication pattern. The master stores the state and configuration data for the entire cluster in ectd, a persistent and distributed key-value data store. Each node has access to ectd and through it, nodes learn how to maintain the configurations of the containers they’re running. You can run etcd on the Kubernetes master, or in standalone configurations. Masters communicate with the rest of the cluster through the kube-apiserver, the main access point to the control plane. For example, the kube-apiserver makes sure that configurations in etcd match with configurations of containers deployed in the cluster. The kube-controller-manager handles control loops that manage the state of the cluster via the Kubernetes API server. Deployments, replicas, and nodes have controls handled by this service. For example, the node controller is responsible for registering a node and monitoring its health throughout its lifecycle. Node workloads in the cluster are tracked and managed by the kube-scheduler. This service keeps track of the capacity and resources of nodes and assigns work to nodes based on their availability. The cloud-controller-manager is a service running in Kubernetes that helps keep it “cloud-agnostic.” The cloud-controller-manager serves as an abstraction layer between the APIs and tools of a cloud provider (for example, storage volumes or load balancers) and their representational counterparts in Kubernetes. Nodes All nodes in a Kubernetes cluster must be configured with a container runtime, which is typically Docker. The container runtime starts and manages the containers as they’re deployed to nodes in the cluster by Kubernetes. Your applications (web servers, databases, API servers, etc.) run inside the containers. Each Kubernetes node runs an agent process called a kubelet that is responsible for managing the state of the node: starting, stopping, and maintaining application containers based on instructions from the control plane. The kubelet collects performance and health information from the node, pods and containers it runs and shares that information with the control plane to help it make scheduling decisions. The kube-proxy is a network proxy that runs on nodes in the cluster. It also works as a load balancer for services running on a node. The basic scheduling unit is a pod, which consists of one or more containers guaranteed to be co-located on the host machine and can share resources. Each pod is assigned a unique IP address within the cluster, allowing the application to use ports without conflict. You describe the desired state of the containers in a pod through a YAML or JSON object called a Pod Spec. These objects are passed to the kubelet through the API server. A pod can define one or more volumes, such as a local disk or network disk, and expose them to the containers in the pod, which allows different containers to share storage space. For example, volumes can be used when one container downloads content and another container uploads that content somewhere else. Since containers inside pods are often ephemeral, Kubernetes offers a type of load balancer, called a service, to simplify sending requests to a group of pods. A service targets a logical set of pods selected based on labels (explained below). By default, services can be accessed only from within the cluster, but you can enable public access to them as well if you want them to receive requests from outside the cluster. Deployments and replicas A deployment is a YAML object that defines the pods and the number of container instances, called replicas, for each pod. You define the number of replicas you want to have running in the cluster via a ReplicaSet, which is part of the deployment object. So, for example, if a node running a pod dies, the replica set will ensure that another pod is scheduled on another available node. A DaemonSet deploys and runs a specific daemon (in a pod) on nodes you specify. They’re most often used to provide services or maintenance to pods. A daemon set, for example, is how New Relic Infrastructure gets the Infrastructure agent deployed across all nodes in a cluster. Namespaces Namespaces allow you to create virtual clusters on top of a physical cluster. Namespaces are intended for use in environments with many users spread across multiple teams or projects. They assign resource quotas and logically isolate cluster resources. Labels Labels are key/value pairs that you can assign to pods and other objects in Kubernetes. Labels allow Kubernetes operators to organize and select subset of objects. For example, when monitoring Kubernetes objects, labels let you quickly drill down to the information you’re most interested in. Stateful sets and persistent storage volumes StatefulSets give you the ability to assign unique IDs to pods in case you need to move pods to other nodes, maintain networking between pods, or persist data between them. Similarly, persistent storage volumes provide storage resources for a cluster to which pods can request access as they’re deployed. Other useful components These Kubernetes components are useful but not required for regular Kubernetes functionality: Kubernetes DNS Kubernetes provides this mechanism for DNS-based service discovery between pods. This DNS server works in addition to any other DNS servers you may use in your infrastructure. Cluster-level logs If you have a logging tool, you can integrate it with Kubernetes to extract and store application and system logs from within a cluster, written to standard output and standard error. If you want to use cluster-level logs, it’s important to note that Kubernetes does not provide native log storing; you must provide your own log storage solution. Helm: managing Kubernetes applications Helm is an application package management registry for Kubernetes, maintained by the CNCF. Helm “charts” are pre-configured software application resources you can download and deploy and in your Kubernetes environment. According to a 2018 CNCF survey, 68% of respondents said Helm was the preferred package management tool for Kubernetes applications. Helm charts can help DevOps teams come up to speed more quickly with managing applications in Kubernetes; it allows them leverage existing charts that they can share, version, and deploy into their dev and production environments. Kubernetes and Istio: a popular pairing In a microservices architecture like those that run in Kubernetes, a service mesh is an infrastructure layer that allows your service instances to communicate with one another. The service mesh also lets you configure how your service instances perform critical actions such as service discovery, load balancing, data encryption, and authentication and authorization. Istio is one such service mesh, and current thinking from tech leaders, like Google and IBM, suggests they’re increasingly becoming inseparable. The IBM Cloud team, for example, uses Istio to address the control, visibility, and security issues it has encountered while deploying Kubernetes at massive scale. More specifically, Istio helps IBM: Connect services together and control the flow of traffic Secure interactions between microservices with flexible authorization and authentication policies Provide a control point so IBM can manage services in production Observe what’s happening in their services, via an adapter that sends Istio data to New Relic—allowing it to monitor microservice performance data from Kubernetes alongside the application data it's already gathering. Challenges to Kubernetes adoption Kubernetes clearly has come a long way in the first five years of life. That kind of rapid growth, though, also involves occasional growing pains. Here are a few challenges with Kubernetes adoption: 1. The Kubernetes technology landscape can be confusing. One thing developers love about open-source technologies, like Kubernetes is the potential for fast-paced innovation. But sometimes too much innovation creates confusion, especially when the central Kubernetes code base moves faster than users can keep up with it. Add a plethora of platform and managed service providers, and it can be hard for new adopters to make sense of the landscape. 2. Forward-thinking dev and IT teams don’t always align with business priorities. When budgets are only allocated to maintain the status quo, it can be hard for teams to get funding to experiment with Kubernetes adoption initiatives, as such experiments often absorb a significant amount of time and team resources. Additionally, enterprise IT teams are often adverse to risk and slow to change. 3. Teams are still acquiring the skills required to leverage Kubernetes. It wasn’t until a few years ago that developers and IT operations folks had to readjust their practices to adopt containers—and now, they have to adopt container orchestration, as well. Enterprises hoping to adopt Kubernetes need to hire professionals who can code, as well as knowing how to manage operations and understand application architecture, storage, and data workflows. 4. Kubernetes can be difficult to manage. In fact, you can read any number of Kubernetes horror stories—everything from DNS outages to “a cascading failure of distributed systems”— in the Kubernetes Failure Stories GitHub repo. New Relic can support your Kubernetes journey To fully understand what’s going on in your environment, you need to see into all its layers, including inside your containers. That means holistic, application-centric and infrastructure-centric monitoring. Monitoring application performance in Kubernetes is important, but you also need visibility into your Docker and Kubernetes infrastructure. New Relic's Kubernetes cluster explorer, which is part of New Relic Infrastructure , addresses this need. It leverages an on-host integration for Kubernetes that provides deep monitoring for backend and frontend applications and for hosts running in your clusters. The rollout of New Relic's Kubernetes cluster explorer was one highlight among many during a year packed with innovative upgrades to the New Relic Platform Using Kubernetes cluster explorer, teams can expect total visibility, alerting, and dashboards for all Kubernetes entities—metadata for nodes, namespaces, neployments, ReplicaSets, pods, and containers—that host your applications. This integration can be used with provider offerings as well. For example, teams using Red Hat OpenShift can link New Relic APM data with OpenShift data. This step provides deep application performance monitoring (with code instrumentation and distributed tracing) for the applications running in a cluster. After linking your applications, click any of the hexagons in the cluster explorer—each of which represents a pod in a cluster—to open a detailed view of that pod. From there, you can analyze the performance of applications running in that pod. Examine New Relic APM data about the applications running in your OpenShift clusters. You can even dive into New Relic distributed tracing to inspect the distributed traces captured for the application running in that pod. If you click on an individual span in a distributed trace, you can quickly see the relevant Kubernetes attributes for that application; for example you can find out which pod, cluster, and deployment an individual span belongs to. Get distributing tracing data from the applications running in your OpenShift cluster. Using New Relic to take advantage of the power of Kubernetes is essential for modern software companies looking to move faster with confidence. Learn how to get started monitoring containers yin our Kubernetes environment in the New Relic documentation. Related Topics Kubernetes Monitoring By Ali Gerrard Ali Gerrard is a product marketing manager at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.24344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> can support your Kubernetes journey",
        "body": "Skip to main content We&#x27;re leveling <em>up</em> FutureStack registration with swag, only until 4&#x2F;30. Terms &amp; conditions apply. Register Now Dismiss alert <em>New</em> <em>Relic</em> logo Search Submit Products Products <em>New</em> <em>Relic</em> One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence"
      },
      "id": "6076311628ccbc612e51c156"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/david-gaule-headshot-2-300x300.jpeg?h=6c83441f&itok=lDWSUdlF",
      "url": "https://newrelic.com/blog/nerd-life/new-dublin-emea-headquarters",
      "sections": [
        "AppVeyor",
        "AWS CodeDeploy",
        "AWS Fargate",
        "Bamboo",
        "CircleCI",
        "Codeship",
        "Google App Engine",
        "Helm",
        "Heroku",
        "IBM Cloud",
        "Jenkins",
        "Kubernetes",
        "Octopus Deploy",
        "Red Hat OpenShift",
        "Travis CI",
        "Up",
        "Visual Studio Team Services (VSTS)",
        "Conclusion",
        "Get maximum value from the cloud",
        "Related Topics"
      ],
      "published_at": "2021-04-14T00:18:58Z",
      "title": "Top Tools for Cloud Application Deployment",
      "updated_at": "2021-04-14T00:18:57Z",
      "type": "",
      "external_id": "3a6f623d104cacc318ef02e6277b6f0bb1b00c3d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit New Relic News Top Tools for Cloud Application Deployment Apr 26, 2018 • 8 min read By David Gaule Modern software teams are increasingly adopting the cloud, choosing to host and run their applications and infrastructure using cloud providers and platforms instead of on-premise solutions. But deploying applications in the cloud can be significantly different than doing so in your own data center. A number of steps go into deploying an application in the cloud—from build to package to release—and there can be a lot of overhead in doing that manually. Because of such challenges, more and more software development teams are embracing the practice of continuous integration and continuous deployment (CI/CD) as they seek to automate deploying new code into production. Fortunately, a number of tools specialize in helping you automate the tasks involved, from integrating code tests to build packaging and deployment. Whether you are looking for a one-size-fits-all solution from a large cloud provider or seek to build out a custom tool chain to meet your particular needs (such as pushing code from a build pipeline to a Kubernetes cluster running on a deployment platform) the first step is to get the lay of the land. To provide a roadmap, we looked at 15 top application deployment tools, listed in alphabetical order. Just remember, though, no one tool is perfect for every team. DON’T MISS: The Best Tools for Cloud Infrastructure Automation AppVeyor Teams developing applications on Windows and .NET may want to check out AppVeyor, a CI/CD platform. Open source apps are hosted for free, and enterprise customers have the option of on-premise installations and unlimited build agents. AppVeyor has support for GitHub, Bitbucket, GitLab, and VSTS. Language support includes: .NET Core, C++, and Ruby Developer tool and partner integrations include: GitHub, Bitbucket, GitLab, and Amazon S3 AWS CodeDeploy If you’re an Amazon Web Service (AWS) cloud customer, AWS CodeDeploy is a deployment service that helps you automate your application deployments, no matter whether you’re deploying your app with a single AWS Lambda function or across thousands of Amazon EC2 instances. With CodeDeploy, you can manage your deployments from one place using the AWS Management Console or the AWS CLI. You can even take advantage of additional tools like Amazon CloudWatch, which lets you see exactly when and where you deployed each application revision. You can also integrate application deployments with your existing software delivery toolchain using the AWS CodeDeploy APIs. Language support: Any Developer tool and partner integrations include: Atlassian, GitHub, HashiCorp, and Jenkins AWS Fargate This entry adds a solid offering for any Amazon Elastic Container Service (ECS) users looking to deploy applications in containers without worrying about server or cluster management. AWS Fargate abstracts away server configuration and management, so all you need to do is worry about packaging your applications and setting the CPU, memory, and other application requirements you desire, and AWS Fargate will launch the containers for you—and it'll even scale them as needed. Like CodeDeploy, you can manage your deployments from one place using the AWS Management Console or the AWS CLI. Language support: Any Developer tool and partner integrations include: AWS CodePipeline, SUSE, Mesosphere, and Twistlock Bamboo Part of the Atlassian world, Bamboo is a build, test, and deploy platform with key features like built-in git branching workflows and Jira integration—both essential out-of-the-box features for any modern software team. It runs on Amazon EC2 integrations, so it can easily scale as needed. Language support: Any Developer tool and partner integrations include: Docker, Jira, Amazon S3, and Apache Tomcat CircleCI While CircleCI offers an on-premise solution, this cloud-based service requires  no dedicated server. CircleCI is most often used for either small and open source projects in which easy and efficient deployment are essential. If you’re shipping applications in containers or to mobile, CircleCI comes with support for Docker and iOS application builds. Language support includes: Go, Haskell, Java, Ruby, Python, PHP, and Node.js Developer tool and partner integrations include: Docker, Sauce Labs, and Jira Codeship If you’re into containers, Codeship is a hosted, continuous-delivery service that may fit your deployment needs. Codeship Pro uses Docker as a containerized backend for CI/CD, but your apps don’t have to use Docker, just any type of container. With single-tenant AWS instances, you’ll get performance optimization and security created to match your standards. Codeship offers a variety of powerful setup options. Currently, it’s integrated with popular source code managers GitHub and Bitbucket as well as other CI add-ons and tools. Language support includes: Java, Ruby, Python, and Elixir Developer tool and partner integrations include: Selenium and PagerDuty Google App Engine Part of the Google Cloud Platform (GCP), Google App Engine allows you to build and deploy applications using your favorite language or framework. App Engine provides a fully managed infrastructure platform, so you need to worry only about the applications you’re building and not their host configurations. For security-minded teams, App Engine has its own firewall and provides managed SSL and TLS certificates on your custom domain at no additional cost. And App Engine integrates with a number of GCP cloud developer tools. Language support includes: Node.js, Java, Ruby, C#, Go, Python, and PHP Developer tool and partner integrations include: Cloud Tools for IntelliJ, Firebase Test Lab for Android, and Kubernetes Helm A package manager created specifically for Kubernetes, Helm makes it easy to deploy applications in your Kubernetes clusters. In Helm, application resources are defined in charts, which let you install multiple app instances, each with a different configuration, from one chart. The Kubernetes community has created plenty of charts to get you started, and you can find charts for popular software like PostgreSQL, Elasticsearch, and Apache Kafka. Language support: Any Developer tool and partner integrations include: Docker and Polyaxon Heroku This container-based PaaS, hosted on AWS cloud services, abstracts away your infrastructure concerns, and lets you focus on deploying and managing your applications. With full GitHub integration, Heroku provides application-health monitoring and customized Redis and PostgreSQL applications for your database tier. Essential features of its enterprise offering include access control and private instances. From the Heroku Elements Marketplace you can download or purchase a number of pre-packaged add-ons and services to extend your applications. Language support includes: Java, Python, Ruby, Clojure, Go, Scala, Node, and PHP Developer tool and partner integrations include: IntelliJ, Docker, and GitHub IBM Cloud Formerly called IBM Bluemix, this Platform-as-a-Service (PaaS) offering partners with CloudFoundry and provides options for running apps on traditional servers or through IBM Cloud Container Service. Application development teams can take advantage of services like IBM Watson for building artificial intelligence and other cognition-based functions into their applications. IBM even offers an Internet of Things (IoT) service and mobile backend to support continuous delivery of all kinds of apps. Language support includes: Go, Java, Node.js, PHP, Python, and Ruby Developer tool and partner integrations include: Salesforce and Docker Jenkins Wildly popular, Jenkins has clearly earned its place as the leading open-source automation server. It provides more than 1,400 plugins, covering virtually any platform build, packaging, and deployment-management tasks you might need to perform. With Jenkins, you can enforce deployment workflows, convert CLI scripts to Jenkins jobs, set up build pipelines in the Blue Ocean UI, and take advantage of a pipelines plugin to run parallel or sequential jobs. Language support includes: Python, Ruby, Java, Android, C/C++ Developer tool and partner integrations include: Atlassian, JFrog, and PagerDuty Kubernetes Originally developed by Google, Kubernetes is a container orchestration platform for automating the deployment, scaling, and management of containerized applications. Kubernetes makes it easy to deploy and operate applications based on a microservice architecture for almost any cloud. It does so by creating an abstraction layer on top of a group of hosts, so that development teams can deploy their applications and let Kubernetes manage things like controlling resource consumption by application or team, evenly spread application loads across their host infrastructure, and automatically load balance requests across the different instances of an application. Language support includes: Go, Python, Java, JavaScript, C Sharp Developer tool and partner integrations include: CoreOS, Docker, and JFrog Octopus Deploy If you’re deploying applications on Windows servers or on the .NET framework, check out Octopus Deploy. It provides automated application deployment so your teams can easily deploy and promote releases between environments. With Octopus, you can limit who can deploy to what environments and programmatically promote test-based workflows. Language support includes: ASP.NET, Java, and Node.js Developer tool and partner integrations include: VSTS, Bamboo, and Jenkins Red Hat OpenShift OpenShift offers both a container-based platform and a public cloud platform. OpenShift is built on Docker (with Kubernetes for orchestration), so if your app runs on Docker, you can deploy it anywhere with Openshift right from your IDE or CLI. Key features include dynamic container storage and multi-tenancy. Language support includes: Java, Python, Ruby, .NET Core, and Perl Developer tool and partner integrations include: Jenkins and Ruby on Rails Travis CI Open source application shops may love doing continuous integration from Travis CI if their applications are hosted in GitHub—because it’s basically free in those circumstances. With Travis CI you can deploy to a number of cloud tools, including Heroku, AWS Lambda, and OpenShift. Language support includes: C, C++, Ruby, Rust, Java, PHP, Python, and Clojure Developer tool and partner integrations include: SauceLabs and SonarCloud Up If you’re a forward-thinking early adopter into serverless technologies, this tool may be just what you’re looking for. Up uses AWS Lambda and Amazon API Gateway to deploy your applications, APIs, and static websites. Pro features include encrypted environment variables, alerting via email, SMS text, and Slack, and speed-optimized Amazon S3 uploads. Language support includes: Node.js, Golang, Python, Java, Crystal, and Clojure Developer tool and partner integrations include: AWS Lambda and GitHub Visual Studio Team Services (VSTS) This hosted deployment software runs in the Microsoft Azure cloud, and is platform agnostic. VSTS offers version control and build-and-release management, but can also help you deploy your application to any platform, cloud provider, or app store, using your own build-and-release infrastructure. Take advantage of this platform for its load-testing capabilities. Language support: Any Developer tool and partner integrations include: Eclipse, IntelliJ, and Android Studio Conclusion Much like our list of infrastructure automation tools, these application-deployment tools each have their strengths, weaknesses, and learning curves. Fully integrated solutions, like those from cloud leaders AWS, GCP, and Azure, provide many one-stop benefits. But plenty of other platforms and services provide a range of useful features and integrations. And tools like Jenkins are well proven across the industry. This post is designed to be just one step in a thorough analysis of what tools are right for your cloud adoption, as you work to optimize your customer experience and meet key performance indicators.   Get maximum value from the cloud With New Relic, you can migrate faster, resolve issues faster, and ensure the complete success of your cloud adoption initiative. Learn more >   Related Topics New Relic News By David Gaule David Gaule is an editor at New Relic. Prior to joining the company, he served as senior editor for AllBusiness.com. Way back in the days of paper books, David held positions at HarperCollins Publishers and Little, Brown & Company. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.62001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Helm</em>",
        "body": "Skip to main content We&#x27;re leveling <em>up</em> FutureStack registration with swag, only until 4&#x2F;30. Terms &amp; conditions apply. Register Now Dismiss alert <em>New</em> <em>Relic</em> logo Search Submit Products Products <em>New</em> <em>Relic</em> One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence"
      },
      "id": "607634f2196a67d95b64a772"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/disable_kubernetes_logs_3-1024x955.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/disable-new-relic-logging-for-kubernetes",
      "sections": [
        "Strategy 1: Edit the parser configuration",
        "Strategy 2: Use Kubernetes annotations",
        "Get what you need from New Relic Logs for Kubernetes",
        "Related Topics"
      ],
      "published_at": "2021-04-14T00:02:30Z",
      "title": "How to Disable Logging for a Kubernetes Pod",
      "updated_at": "2021-04-14T00:02:30Z",
      "type": "",
      "external_id": "da4f0006c6c1001fa9a866a291790c466eb582d1",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring How to Disable Logging for a Kubernetes Pod Nov 11, 2019 • 6 min read By Shu Jackson Log data is a valuable and often irreplaceable source of troubleshooting data for software developers, especially for complex platforms like Kubernetes. New Relic offers a Fluent Bit output plugin—that you can deploy as a Helm chart—to enable New Relic Logs for Kubernetes to collect cluster log data. Recently, a customer asked if it’s possible to disable logging from a container or pod after enabling NR Logging for Kubernetes. They wanted to disable access logs from an NGINX server, and Node.js logs coming from an app pod—because those logs weren’t as useful to them, and also because they wanted to optimize costs by not sending unnecessary logging data to New Relic. Building from this example, we can discuss two different strategies to indicate to Fluent Bit which logs it should pick up and which it should ignore. Both of these will get the job done, but we'll explain why the second strategy is generally your better option. Strategy 1: Edit the parser configuration This approach changes Fluentd’s parser configuration to specify which log files it should collect. Once you have installed and configured the Fluent Bit plugin, you can configure how the plugin parses log data. When you install the plugin with Helm, configmap.yml sets the variable {PATH}: That path is used in new-relic-fluent-plugin.yml to set log tailing for all pods to /var/log/containers/*.log. Instead of using *.log to tail all logs, replace this default path with your preferred path, as shown: This is a centralized and simple configuration change, but it can get complicated to manage later on. For example, what if a developer added a new pod or needed new logs? They might not have access to change that central config; or if they do have access, it could become a messy situation with people changing the plugin’s parser config on the fly. For more information about Fluent Bit's parser configurations, see their documentation. Strategy 2: Use Kubernetes annotations In Fluent Bit, Kubernetes annotations are essentially filters you can set to control what logs a pod sends to the Fluent Bit log processor pipeline. More specifically, when you define the config for a pod, you can add the fluentbit.io/exclude, which tells Fluent Bit, \"Hey don't log me.\" The annotation value can be expressed as “true” or “false” and must include quotation marks. Important: This setting will only be processed if you first enable K8S-Logging.Exclude in the Fluent Bit Kubernetes Filter, which is disabled by default. Refer to the Fluent Bit docs for a full list of config parameter options. Here is an example pod definition that uses fluentbit.io/exclude to request that the Fluent Bit processor skip apache logs: At this point, you’ve decentralized the configuration for which logs get processed. This gives developers more flexibility for adjusting their logging needs as they add new pods to a cluster. Get what you need from New Relic Logs for Kubernetes Once you’ve enabled New Relic Logs for Kubernetes, here are some potential next steps: Link your applications in Kubernetes Enable logs-in-context with APM agents Get started with distributed tracing Related Topics Kubernetes Monitoring By Shu Jackson Shu Jackson is a Solutions Engineer at New Relic. She is a certified Azure developer and a Sitecore MVP. She holds a M.S. in Artificial Intelligence. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.10533,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Get what you need from <em>New</em> <em>Relic</em> Logs for Kubernetes",
        "body": ", especially for complex platforms like Kubernetes. <em>New</em> <em>Relic</em> offers a Fluent Bit output plugin—that you can deploy as a <em>Helm</em> <em>chart</em>—to enable <em>New</em> <em>Relic</em> Logs for Kubernetes to collect cluster log data. Recently, a customer asked if it’s possible to disable logging from a container or pod after"
      },
      "id": "60763116196a67d12b64a775"
    }
  ],
  "/terraform/get-started-terraform": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-14T00:08:56Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 416.09814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Step 3: Provision <em>alert</em> conditions based on the four <em>golden</em> <em>signals</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four <em>golden</em> <em>signals</em> of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "70555c1d24e8e54b46763d57010901e206ef2ccb",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.26465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6066782e64441f3610617ac3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-13T01:55:31Z",
      "title": "",
      "updated_at": "2021-04-01T01:51:55Z",
      "type": "",
      "external_id": "5e43fb43faa36807fc9f1eb660748303373fa8dd",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.60464,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6065273be7b9d2336c944613"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/proactive_detection6-1024x765.png",
      "url": "https://newrelic.com/blog/nerdlog/new-capabilities-proactive-detection",
      "sections": [
        "Automatic analysis of every anomaly",
        "See all anomalies in a single view",
        "Alert, query, and leverage the power of anomalies in NRDB",
        "The full power of New Relic AI: anomalies integrated into Incident Intelligence",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:31:44Z",
      "title": "Enhancing New Relic AI With New Capabilities For Proactive Detection",
      "updated_at": "2021-04-13T23:31:44Z",
      "type": "",
      "external_id": "47801e8f396395e32a3da28b34d08b92af08bacb",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit AIOps Enhancing New Relic AI With New Capabilities For Proactive Detection May 4, 2020 • 6 min read By Annette Sheppard The rate of change within your software is faster than ever, and with this pace comes the risk that your team may miss issues, or lose critical time trying to diagnose the causes of errors. Proactive Detection, an essential part of our recently released AIOps solution, New Relic AI, helps DevOps teams avoid such problems and drive faster mean time to resolution (MTTR) by proactively detecting and analyzing anomalies using data from New Relic APM. Whether it’s alerts you didn’t know you needed to set up or dependent systems you may not even own, New Relic AI Proactive Detection surfaces and analyzes anomalies, bringing attention to potential problems before they become bigger issues—all within your team’s existing incident response workflows. Easy to set up, Proactive Detection simply needs a configuration name and a list of the applications to be monitored to begin discovering and analyzing anomalies in your system. Today we’re announcing four key enhancements to Proactive Detection: An in-depth analysis of each anomaly via the Analysis page A complete list of all anomalies in your environment with the Anomaly overview Integration with the New Relic Database (NRDB), so you can create dashboards and alerts based on anomaly data Integration with New Relic AI Incident Intelligence—via NRQL alerts—for deeper context into incidents Automatic analysis of every anomaly Not only does Proactive Detection flag and notify you of anomalies in your system, it also analyzes each anomaly to help you speed troubleshooting. The Analyze page automatically surfaces queries and context to help explain the cause of an anomaly. Each Proactive Detection notification delivered in Slack provides a link to the Analyze page, allowing you to easily investigate an anomaly or switch between anomalies as you dive deeper into issues. Anomalies delivered to your team via Slack quickly link to the Analyze page for deeper analysis The Analyze page provides an overview of the anomaly itself, as well as details and recent activity for an entity. When available, Proactive Detection automatically suggests attributes that help explain the cause of the anomaly and provide paths for further troubleshooting, as shown in the Key Attributes section: The three key attributes surrounding an error spike are visualized to provide you with multiple paths for troubleshooting. Proactive Detection uses APM event data to suggest queries that explain the anomaly, based either on statistical differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “golden signals” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream or downstream of the initial anomaly. Sparklines include anomalies related to the SRE “golden signals” and additional anomalies in related upstream or downstream applications All of this gives your team a holistic view of the events leading up to the anomaly, helping you better identify what is happening in your application and environment. See all anomalies in a single view The Analyze page provides the context surrounding one anomaly, but the Anomaly overview page gives you a broader view of what's happening in your environment. You’ll have a full view of all detected anomalies, with the ability to instantly view more details for each one. If you want to dive in and learn even more about a specific anomaly, simply use the Analyze link. The Anomaly overview page gives you an overview of all anomalies detected in your environment. Alert, query, and leverage the power of anomalies in NRDB Since all anomalies are automatically written to the NRDB, you can use anomaly data to build dashboards, or create alerts. Query any Proactive Detection event from any configured application. For example, use Proactive Detection data in NRQL alerts to notify you when clusters of anomalies occur. Any anomaly can be plotted in a dashboard to discover trends and patterns. You can even build your dashboards to show anomalous events that are relevant to the specific applications you’re monitoring for anomalies in Proactive Detection. Be notified when clusters of anomalies occur. The full power of New Relic AI: anomalies integrated into Incident Intelligence Proactive Detection and Incident Intelligence are New Relic AI’s critical set of capabilities that help teams detect issues early, eliminate alert noise, and drive toward even faster MTTR. Incident Intelligence uses AI and machine learning (ML) to suppress alerts you don’t care about and correlate related incidents and events into single issues, without excessive configuration, training, or onboarding. Stronger together, you can now link anomalies detected with Proactive Detection to Incident Intelligence—via NRQL alerts—to receive enhanced context inside of your Incident Intelligence to gain the full power of New Relic AI. New Relic AI Proactive Detection has a free tier that you can start using today: If you’re new to New Relic, sign up for your free account. Already using New Relic? Get started with Proactive Detection in under 10 minutes by visiting http://one.newrelic.com > New Relic AI > Proactive Detection. Interested in learning more about New Relic AI, check out these resources: Accelerate Incident Response with AIOps: An introduction to AIOps best practices with New Relic AI (eBook) Accelerate Incident Response with AIOps (Webinar) New Relic AI documentation Request a demo   Related Topics AIOps By Annette Sheppard Annette Sheppard is a Senior Product Marketing Manager at New Relic. She is focused on AIOps and is always looking to learn something new. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.16675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Alert</em>, query, and leverage the power of anomalies in NRDB",
        "body": " differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “<em>golden</em> <em>signals</em>” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream"
      },
      "id": "607629e028ccbc02d751c161"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/correlation-assistant.png",
      "url": "https://newrelic.com/blog/how-to-relic/aiops-applied-intelligence",
      "sections": [
        "Detect unusual changes instantly",
        "Cut down on alert noise",
        "Get to the root cause quickly",
        "Respond to incidents faster",
        "How to get started with AIOps",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:16:12Z",
      "title": "Get Ready for Next Gen AIOps to Detect, Understand, and Resolve Problems Faster Than Ever",
      "updated_at": "2021-04-13T23:14:25Z",
      "type": "",
      "external_id": "788beb576c7d9e3116b0d78526be3ee4b4020a3f",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit AIOps Get Ready for Next Gen AIOps to Detect, Understand, and Resolve Problems Faster Than Ever Mar 17, 2021 • 8 min read By Guy Fighel Despite the hype, many DevOps and SRE teams have struggled to make the promise of AIOps a reality. Steep learning curves, long implementation and training times, prohibitive pricing, and a lack of confidence in artificial intelligence (AI) and machine learning (ML) have stood in the way. When we dig into the challenges faced by pager-carrying, on-call engineers, they consistently mention three things that stand in the way of keeping services up and running: Discovering emerging problems and unknowns when you're dependent on alerts or static dashboards to know what's changing is hard. It’s not easy to triage incidents and know how to respond when a cascading failure happens with alerts firing across multiple tools. It’s difficult and time-consuming to diagnose the root causes of problems when you have to manually sift through dashboards to understand why the problem occurred and what's impacted. In short, engineers can no longer afford expensive war rooms and guesswork to troubleshoot incidents, or worse, find out about them from customers. That all changes today with the launch of our next generation of New Relic Applied Intelligence, which makes it easier than ever to: Detect unusual changes instantly: You’ll be able to automatically spot anomalies across your applications, services, and logs to prevent potential problems before they impact customers. Cut down on alert noise: You can reduce the flood of noisy alerts and prioritize issues more easily by grouping alerts and events from any source into a single correlated, actionable issue. Get to root cause quickly: You’ll be able to eliminate guesswork and solve problems faster with automatic insights into the probable root cause of every issue. Respond to incidents faster. You can integrate New Relic Applied Intelligence with ITSM tools and eliminate the toil of managing incidents across tools by keeping everything in sync. Let’s dig into what’s new and now available in Applied Intelligence. Detect unusual changes instantly Continuous, automatic anomaly detection now at no additional cost Applied Intelligence automatically spots anomalies based on golden signals like throughput, errors, and latency across all applications and services—and it’s now automatically enabled for all your instrumented apps and services without configuration and at no additional cost. When it detects anomalies, it will immediately notify you via Slack and other collaboration tools, and give you a real-time feed of every anomaly and in-depth analytics to troubleshoot faster and prevent potential problems from impacting customers.     Log patterns Applied Intelligence now includes a new capability that uses machine learning to detect patterns and surface outliers in your log data, helping you reduce troubleshooting time. You can explore millions of log messages with a single click and reduce manual querying because Log patterns automatically clusters your log data to help you quickly find anomalous patterns and problematic needles in the haystack. Log patterns is currently in public beta—if you’d like to turn it on for your New Relic account, reach out to your customer success manager.   Alerts analytics A new integrated landing page highlights insights and analytics about how your alert configurations are performing. Alerts recurring muting rules Define recurring schedules for muting rules for New Relic Alerts to get more control over alerts suppression during scheduled maintenance windows and periods of planned downtime. Set recurring daily, weekly, or monthly schedules for muting rules via the New Relic UI or API. Cut down on alert noise   Relationship-based correlation You can now correlate related alerts and events based on external relationship data from CMDBs and New Relic entity relationships. In addition to correlating alerts using time-based clustering and context from alert messages, you can now ingest topology data from your relationship datastores (CMDBs) to enable more accurate correlation of alerts that are firing from connected services. This gives you better context into incidents that occur and how they impact your broader environment so that you can prioritize problems more accurately and efficiently. Anomalies in correlated issues You can correlate proactively detected anomalies along with alerts and events from any source together to paint a complete picture of the issue at hand, reducing time to understand and act. Create correlation decisions faster with correlation assistant Did something not correlate that should have? Do you have an idea of how to correlate but aren’t sure where to start? With a new correlation assistant feature, you can simply begin selecting incidents that should be correlated and let New Relic analyze them to show you what they have in common. This gives you more control over how you reduce alert noise. In addition, Applied Intelligence is smart enough to simulate your configuration and shows you in real-time how correlating incidents can reduce alert noise and increase context in the future. Get to the root cause quickly See the probable root cause(s) of every issue Applied Intelligence gives you automatic insights into the probable root cause of every issue. You can quickly see why each open issue occurred, which deployments contributed, and relevant error logs and attributes to help you investigate the problem faster than ever. Applied Intelligence scans the distribution of every attribute within event data ingested, and surfaces possible causes by finding significant changes in the distribution. For example, for every transaction event generated, you can scan to see if a single user starts to take up an unusual share of the requests sent to your app. In addition, root cause analysis automatically classifies issues based on golden signals like errors, traffic, latency, and saturation so you can quickly orient yourself to why the problem occurred.   Understand the impact and scope of every issue You can see which entities (hosts, containers, applications) are affected to quickly and accurately assess the scope and determine what needs to be remediated. You can isolate the source of the problem with automatic insight into how services and components of your environment are impacted by every issue. Respond to incidents faster Two-way integration with ServiceNow for correlated issues Adding to our existing two-way integration with PagerDuty, you can now eliminate the toil of managing incidents across tools by syncing the state of correlated issues in Applied Intelligence with ServiceNow incidents bi-directionally. As the state of each correlated issue changes in either platform, it is now automatically updated in both tools. Applied Intelligence also supports a webhook for integrating with VictorOps, OpsGenie, and other tools of your choice. Suggested responders for New Relic alert violations Get automatic recommendations for individuals on your team who are best equipped to respond to an issue, either because they are experts in the component failing or have resolved similar issues before. This enhancement builds on our existing support for suggesting responders based on PagerDuty incident data, by suggesting responders for issues that originate from New Relic alert violations. Best of all, this feature is completely automatic and requires no configuration or model training—it just works out of the box as New Relic learns from the behaviors of responders on your team. How to get started with AIOps All New Relic Applied Intelligence customers have access to today’s new capabilities at no additional cost. If you’re interested in adding AIOps capabilities to your New Relic implementation, you can get started now by clicking the “Alerts & AI” link in your New Relic account. And if you’re new to New Relic but interested in digging in, experience the simplicity of New Relic One yourself by signing up for a forever free account, and check out New Relic Applied Intelligence.   Related Topics AIOps By Guy Fighel Guy Fighel is the General Manager of applied intelligence and Vice President of product engineering at New Relic. He leads New Relic’s AIOps product and engineering, and is responsible for the company’s overall artificial intelligence and machine learning strategy. Guy was the co-founder and chief technology officer of SignifAI, an event-intelligence company, which was acquired by New Relic in 2019. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.24168,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Cut down on <em>alert</em> noise",
        "body": " across your applications, services, and logs to prevent potential problems before they impact customers. Cut down on <em>alert</em> noise: You can reduce the flood of noisy <em>alerts</em> and prioritize issues more easily by grouping <em>alerts</em> and events from any source into a single correlated, actionable issue. Get"
      },
      "id": "607625d1196a67ad6b64a790"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 411.65314,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.34552,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-12T03:01:08Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.30823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.29294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.29294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    }
  ],
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/embed/",
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "67c529a70a60d530860fbe80be795d214798dfd9",
      "popularity": 1,
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 224.21022,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em>",
        "body": ", account, or user level. This guide explains how to <em>add</em> <em>data</em> and documents to <em>NerdStorage</em>. For an introduction to what <em>NerdStorage</em> is and how it works, see Intro to <em>NerdStorage</em>. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your"
      },
      "id": "6066782e64441f577f617a9d"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:18Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 3014918 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.65594,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Access <em>NerdStorage</em> from your Nerdlet",
        "body": " business objectives. But before you learn that, you need to know something about our mock <em>data</em> service: it requires an Authorization header! In this lesson, you learned how to use <em>NerdStorage</em> to <em>query</em> and <em>mutate</em> <em>data</em> in your application&#x27;s own <em>data</em> store. While <em>NerdStorage</em> is a great place for many"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    },
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.96228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Query</em> your <em>data</em>"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.96228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Query</em> your <em>data</em>"
      },
      "id": "6053433228ccbcdc10c2fd60"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/embed/",
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:56Z",
      "type": "",
      "external_id": "31fc09fc1a4af441ce6fa9a9ea59fa2216dd2058",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.04197,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to <em>NerdStorage</em>",
        "body": ". Documents: A document is formed by an identifier (documentId) and a set of <em>data</em> associated with it. <em>Data</em> associated with a document: <em>NerdStorage</em> accepts any sort of <em>data</em> associated to a documentId. <em>Query</em> and mutation components that are provided work by serializing and deserializing JSON. Caution"
      },
      "id": "6063d63428ccbcff4e43fa92"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/embed/",
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:56Z",
      "type": "",
      "external_id": "31fc09fc1a4af441ce6fa9a9ea59fa2216dd2058",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 314.2503,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>NerdStorage</em> in your <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use <em>NerdStorage</em> SDK <em>components</em>. Use <em>NerdStorage</em> in your <em>apps</em> <em>NerdStorage</em> is used to store and retrieve simple sets of <em>data</em>, including users&#x27; configuration settings"
      },
      "id": "6063d63428ccbcff4e43fa92"
    },
    {
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/embed/",
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "67c529a70a60d530860fbe80be795d214798dfd9",
      "popularity": 1,
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.7102,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "body": " on <em>New</em> <em>Relic</em> <em>One</em>. Load the URL. Click <em>Apps</em> and under Your <em>apps</em> you&#x27;ll see the Use <em>Nerdstorage</em> <em>app</em> listed. Click to launch the <em>app</em>. Add <em>data</em> to <em>NerdStorage</em> Once the <em>app</em> is up and running on <em>New</em> <em>Relic</em> <em>One</em>, you can prepare the <em>app</em> and start adding <em>data</em>. On the How To Use <em>NerdStorage</em> <em>app</em> screen, there&#x27;s"
      },
      "id": "6066782e64441f577f617a9d"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.17453,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or <em>data</em> from another service or API. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>. If you want to get started building quickly, first read the requirements. Tip To use our developer site and <em>New</em> <em>Relic</em> <em>One</em>, as well as the rest of our"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.8869,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:18Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 3014918 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 214.57407,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> <em>NerdStorage</em> from your Nerdlet",
        "body": " End test and approve your action in the modal. Now, you see <em>data</em> in Past tests: When you&#x27;re finished, stop serving your <em>New</em> <em>Relic</em> <em>One</em> application by pressing CTRL+C in the terminal window where you&#x27;re serving your application. Great work! You now have experience using the <em>NerdStorage</em> query"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 404.90317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.5893,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-12T03:01:08Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.5526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.53754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.53754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/embed/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2021-04-13T01:55:31Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "9f3c1bee195dc75bc1fc2d96b7bdeec591e35449",
      "popularity": 1,
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 633.4538,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "body": " our other <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> docs for <em>commands</em> specific to <em>Nerdpack</em> set-up, <em>Nerdpack</em> subscriptions, <em>CLI</em> configuration, plugins, or catalogs. <em>Command</em> details nr1 help See <em>commands</em> and get details Shows all nr1 <em>commands</em> by default. To get details about a specific <em>command</em>, run nr1 help <em>COMMAND</em>_NAME. Usage"
      },
      "id": "6063d63464441f3d6b0c8bee"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 411.65314,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.34552,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-12T03:01:08Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.30823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.29294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:23:32Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 990.1909,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers Guide Roundup",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>",
        "body": " The <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em> provides the necessary <em>components</em> you need to build <em>New</em> <em>Relic</em> <em>One</em> applications. <em>Components</em> of the <em>SDK</em> include: React <em>UI</em> <em>components</em> for controlling text and layout in a <em>New</em> <em>Relic</em> <em>One</em> application <em>Chart</em> <em>components</em> for representing different types of charts <em>Query</em> and <em>storage</em>"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 831.25366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Query</em> <em>and</em> <em>storage</em> <em>components</em>",
        "body": ". <em>Components</em> of the <em>SDK</em> <em>SDK</em> <em>components</em> are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 <em>components</em> can be divided into several categories: <em>UI</em> <em>components</em> <em>Chart</em> <em>components</em> <em>Query</em> and <em>storage</em> <em>components</em> <em>Platform</em> APIs <em>UI</em> <em>components</em> The <em>UI</em> <em>components</em>"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/service-map-graph-1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/service-maps-ga",
      "sections": [
        "Auto-generated dynamic magic maps",
        "Service Maps to support multiple perspectives",
        "Now, go out and play!",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:50:38Z",
      "title": "Introducing General Availability of Service Maps in New Relic APM",
      "updated_at": "2021-04-13T23:50:38Z",
      "type": "",
      "external_id": "8e669e48d0f2577a07dace9c57cb27f75b8dfb2b",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Introducing General Availability of Service Maps in New Relic APM May 6, 2015 • 9 min read By Stevan Arychuk Regardless of the industry, every company is now a software business. The modern architectures enabling these businesses are becoming increasingly complex and difficult to manage. Increased complexity means increased risk, further exacerbated by a lack of understanding of the system as a whole. One response to this increasing complexity is the rise of microservices, which let organizations build software in which specific functions can evolve independently from the rest of the system. This usually allows those functions to scale and move faster. Microservice architectures also help teams isolate complexity, making it easier to solve for a particular problem. But microservices bring their own challenges: how do you give teams visibility into particular service behaviors and how do you manage the ways each microservice interacts with all the other services in a dynamic environment. These trends and fundamental challenges led us to create a tool specifically designed to help our customers view and understand their complex microservices architectures. Once understood, architectures can be better managed. So that’s why today we are happy to announce a new feature in New Relic APM that's designed to do exactly that: Here come Service Maps! Service Maps are a new map visualization feature in New Relic APM specifically designed for microservice and modern architectures that have many decoupled apps, services, and components. Service developers who build these services, ops and site engineering teams that support them, and DevOps teams that do all the above—you can now rejoice! Service Maps will help you better understand your complex software architectures by creating a visual, real-time map that represents your specific view of the world. Auto-generated dynamic magic maps Using visual aids to represent complex architectures is not a new concept. Large-format network or architecture diagrams built in Visio or Omnigraffle have a long history in software businesses. Although useful, these diagrams can be time consuming to create, often require input from numerous people or teams to provide a complete picture, and may become out of date almost immediately due to constant architecture changes. Service Maps will not only show a representation of your architecture as seen by New Relic APM auto-magically, but any changes to the architecture will be reflected in the map. Real-time health status for components shown on the map are made visible for troubleshooting purposes, including evaluating the health of incoming or outgoing connections for each specific app. We worked hard to make creating Service Maps fun and easy, including special assistance getting started: A welcome screen is presented if you have no previously viewed maps, which will suggest interesting applications to start from based on throughput, visits, and connectedness. If you have previously viewed a map, the last map viewed will be automatically loaded on your next visit. Clicking on the “Service Maps” link in the left nav bar while viewing an application in New Relic APM will automatically create a map starting with that application. Service Maps to support multiple perspectives Every individual and team supporting a service or collection of services as part of a platform that provides a business capability will have a unique view of what is most important. We believe this customized perspective is a core concept of microservices architectures, which holds that autonomous and independent services enable teams to move faster while still participating in a larger ecosystem. From our perspective, the impact of change, from the perspectives of the service and the system as a whole, is critical to understand these types of architectures. To illustrate the core concepts and feature itself, let us use an internal example of the New Relic Alerts, which is also made generally available today, and look at some Service Maps representing the view of the world from the New Relic Alerting team. The first perspective we will look at is the view of the alerting system from the developers of the UI components. Their primary focus and interest are the Alerts' UI-related services and components that they designed, developed, and will support both independently and as part of the larger New Relic Software Analytics Platform architecture. This narrow view is represented in a custom Service Map that shows just those core UI components that are important to that team: service map graph 1 This map was created and customized to show only the relevant components for the Alerting UI since that is what is the most important to the team. This includes the following: Incoming browser connections from end users A Postgres database used by the Alert Service - Production Dependencies on other apps/services as they relate to the Alerting UI, including both Alerting and core platform services 3rd-party external services Less interesting services are shown as a group to minimize clutter on the map but remain important as context The UI team can reference this Service Map to see how changes to the architecture and dependent services impact their own services in real time. Now let’s take a broader view, from the ops and site engineering teams involved in keeping the New Relic Platform and products humming. The alerts components are small pieces of a much larger microservices architecture that support all New Relic products; understanding the boundaries of the alerting system and the connections and dependencies among internal New Relic and external services is important for support, scaling, and performance optimizations. This larger custom Service Map has been created to show this broader perspective: service map graph 2 This map is significantly more complex, as it represents the entire alerting system and other New Relic Platform services consumed by the alerting system. Discovering inter-service connections and dependencies and seeing the real-time health of both core and dependent services is helpful in reducing complexity through visual understanding. We can see from this map that there are a number of services in poor health, which could be causing upstream or downstream issues. When things go bad, the ability to quickly identify both impact and causality can ease troubleshooting this complex architecture. Sharing this understanding is particularly important for large teams supporting complex software architectures. Situational awareness can help everyone make better decisions. So we made it easy to save and share maps with others in your account. Shared maps can help drive a shared understanding of different perspectives for complex architectures between teams. The permalink function in the footer generates a unique URL specific to your map, which can be sent to others to quickly see that specific map. Now, go out and play! The Service Maps feature is released for general availability, and is currently being rolled out to all New Relic APM customers with a paid account. If you don’t see the Service map tab in your APM navigation bar, please be patient—we promise it will show up soon! General availability of Service Maps is just the beginning of ongoing work in both spatial and temporal visualizations in APM and across the New Relic Software Analytics Platform. We aim to continue active development on these and similar features will continue over the coming weeks and months. Getting to this point and releasing the feature has been incredibly challenging yet rewarding for the awesome team who worked on it. We would also like to extend our heartfelt thanks to the many customers who provided invaluable feedback during the beta MVP. That input helped shape our philosophy around solving for the explosion in services and complex environments, leading to a map-based visualization tool in APM. We hope you all have as much fun using it as we have had building it. For more information on Service Maps, see: Service Maps documentation Service Maps configuration documentation New Relic's Modern Software Architectures press release   Background image courtesy of Shutterstock.com. Related Topics APM By Stevan Arychuk Stevan Arychuk is a senior product manager at New Relic. He's based in our Portland office. Follow the author Stevan Arychuk on Twitter Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 687.8584,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introducing General Availability of Service Maps in <em>New</em> <em>Relic</em> APM",
        "sections": "Now, go out <em>and</em> play!",
        "body": " of the larger <em>New</em> <em>Relic</em> Software Analytics <em>Platform</em> architecture. This narrow view is represented in a custom Service Map that shows just those core <em>UI</em> <em>components</em> that are important to that team: service map graph 1 This map was created and customized to show only the relevant <em>components</em> for the Alerting <em>UI</em>"
      },
      "id": "60762e4e28ccbcc0fc51c198"
    },
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T13:58:44Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a nerdpack, launcher, and nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 675.96094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Subscribe to your <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "body": " of an older version of <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>. With later versions of nr1, we&#x27;ve moved toward &quot;tags&quot; terminology. Eventually, the <em>UI</em> will also use &quot;tags&quot;. Step 4 of 4 Navigate to the <em>Apps</em> page, and see the AbTest <em>app</em> under Your <em>apps</em>: From there, you can click your <em>app</em> and use it like you did when you were"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/query-and-store-data/embed/",
      "sections": [
        "Query and store data",
        "Tip",
        "Components overview",
        "Query components",
        "Mutation components",
        "Static methods",
        "NrqlQuery"
      ],
      "published_at": "2021-04-13T01:55:31Z",
      "title": "",
      "updated_at": "2021-03-31T01:51:31Z",
      "type": "",
      "external_id": "d3eb598c248158038b798c880cad839c80c69c03",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. Here you can learn how to use the SDK query components, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Tip Query-related React components can be identified by the Query suffix. Mutation-related components can be identified by the Mutation prefix. Components overview Our data components are based on React Apollo. The most basic component is NerdGraphQuery, which accepts any GraphQL (or GraphQL AST generated by the graphql-tag library as the query parameter, and a set of query variables passed as variables. Over this query, we have created an additional set of queries, which can be divided into four groups: User queries: These allow you to query the current user and its associated accounts. Components in this category: UserStorageQuery and AccountsQuery. Entities queries: Because New Relic One is entity-centric, we use queries to make access to your entities easier. You can count, search, list, query, and favorite them. Components in this category: EntityCountQuery, EntitySearchQuery, EntitiesByDomainTypeQuery, EntitiesByGuidsQuery, EntityByGuidQuery, EntityByNameQuery. Storage queries: New Relic One provides a simple storage mechanism that we call NerdStorage. This can be used by Nerdpack creators to store application configuration setting data, user-specific data, and other small pieces of data. Components in this category: UserStorageQuery, AccountStorageQuery, EntityStorageQuery, UserStorageMutation, AccountStorageMutation, and EntityStorageMutation. For details, see NerdStorage. NRQL queries: To be able to query your New Relic data via NRQL (New Relic Query Language), we provide a NrqlQuery component. This component can return data in different formats, so that you can use it for charting and not only for querying. Query components All query components accept a function as a children prop where the different statuses can be passed. This callback receives an object with the following properties: loading: Boolean that is set to true when data fetching is happening. Our components use the cache-and-network strategy, meaning that after the data has loaded, subsequent data reloads might be triggered first with stale data, then refreshed when the most recent data has arrived. data: Root property where the data requested is retrieved. The structure matches a root structure based on the NerdGraph schema. This is true even for highly nested data structures, which means you’ll have to traverse down to find the desired data. error: Contains an Error instance when the query fails. Set to undefined when data is loading or the fetch was successful. fetchMore: Callback function that can be called when the query is being loaded in chunks. The function will only be present when it’s feasible to do so, more data is available, and no fetchMore has already been triggered. Data is loaded in batches of 200 by default. Other components provided by the platform (like the Dropdown or the List) are capable of accepting fetchMore, meaning you can combine them easily. Mutation components Mutation components also accept a children as a function, like the query ones. The mutation can be preconfigured at the component level, and a function is passed back that you can use in your component. This is the standard React Apollo approach for performing mutations, but you might find it easier to use our static mutation method added to the component. More on this topic below. Static methods All of the described components also expose a static method so that they can be used imperatively rather than declaratively. All Query components have a static Query method, and all Mutation components have a mutation method. These static methods accept the same props as their query component, but passed as an object. For example: // Declarative way (using components). function renderAccountList() { return ( <ul> <AccountsQuery> ({data, error}) => { if (error) { return <li>Failed to retrieve list: {error.message}</li>; } return data.map((account) => { <li key={account.id}>{account.name}</li> }); }} </AccountsQuery> </ul> ); } // Imperative way (using promises). async function getAccountList() { let data = {}; try { data = await AccountsQuery.query(); } catch (error) { console.log('Failed to retrieve list: ' + error.message); return; } return data.actor.accounts.map((account) => { return account.name; }); } Copy Similarly, a mutation can happen either way; either declaratively or imperatively. NrqlQuery NrqlQuery deserves additional explanation, because there are multiple formats in which you can return data from it. To provide maximum functionality, all three are exposed through a formatType property. You can find its different values under NrqlQuery.formatType: NERD_GRAPH: Returns the format in which it arrives from NerdGraph. RAW: The format exposed by default in Insights and dashboards when being plotted as JSON. This format is useful if you have a pre-existing script in this format that you're willing to migrate to or incorporate with. CHART: The format used by the charting engine that we also expose. You can find a more detailed explanation of how to manipulate this format in the guide to chart components, and some examples. If you are willing to push data, we currently do not expose NrqlMutation. To do that, see the Event API for how to add custom events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 674.7943,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Query</em> <em>components</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>. Here you can learn how to use the <em>SDK</em> <em>query</em> <em>components</em>, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Tip <em>Query</em>-related React <em>components</em> can be identified by the <em>Query</em>"
      },
      "id": "6063d5a3196a675a1fc6f4a5"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 411.65314,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.34552,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-12T03:01:08Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.30823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.29294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.29294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    }
  ],
  "/build-apps/build-visualization": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T13:58:44Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a nerdpack, launcher, and nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 477.45886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "body": " serving it locally! Tip If you don&#x27;t see the app under Your apps, you may have to refresh the page or clear your browser cache. It&#x27;s important to note that you can <em>subscribe</em> to applications in the <em>catalog</em> with the <em>nr1</em> <em>CLI</em>. Read our documentation to learn more. Unsubscribe from your application"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:16Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: You use this key to associate your New Relic account with the CLI. The CLI then uses the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name>, the <User key>, and the region (either us or eu) with real values. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 375.25873,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic <em>One</em> <em>CLI</em>",
        "body": " this by checking your SDK version: bash Copy $ <em>nr1</em> --version Tip It’s important to distinguish between the newrelic <em>CLI</em> and the <em>nr1</em> <em>CLI</em>. newrelic is for managing entities in your New Relic account. <em>nr1</em> is for managing New Relic <em>One</em> applications. Step 3 of 3 Associate your New Relic account as a <em>CLI</em> profile. Use"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.07248,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to New Relic <em>One</em> SDK",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-12T06:45:09Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.63853,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.65145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom New Relic <em>One</em> application ",
        "sections": "Build a custom New Relic <em>One</em> application",
        "tags": "New Relic <em>One</em>",
        "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic <em>One</em> platform, alongside your other dashboards and data. Feature <em>visualizations</em> that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 404.90317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.5893,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-12T03:01:08Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.5526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.53754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.53754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 404.90317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.5893,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-12T03:01:08Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.5526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.53754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.53754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/embed/",
      "sections": [
        "Nerdpack permissions",
        "Restrictions for basic users",
        "Role-related restrictions",
        "Account access"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "a153ce2cd8dd363ee81cfb2648787713b4b73bb4",
      "popularity": 1,
      "body": "There are several restrictions around who can publish, use, and subscribe to Nerdpacks (the file packages that represent New Relic One applications). Restrictions for basic users The most important permissions factor is user type. A basic user has several restrictions related to their inability to access Full Stack Observability, and a full user theoretically has full abilities. Basic users can: Build and serve their own Nerdpacks locally Use some public Nerdpacks that don't make use of Full Stack Observability features that another user has subscribed their account to. Basic users can't: Publish the Nerdpacks they've built Tag their Nerdpacks Subscribe an account to a Nerdpack Use private Nerdpacks (including their own) Use public Nerdpacks that have Full Stack Observability features Full users can use any Nerdpacks that the account they're in has been subscribed to, whether built by New Relic or others. Full users theoretically have Nerdpack management permissions, but there may be restrictions related to custom role assignments (see below). Role-related restrictions For full users, there are role-related rules that may impact one's ability to manage Nerdpacks (publish them and subscribe to them). How this works depends on your account/user model: Original user model: Owners and Admins can manage Nerdpacks, as can users specifically assigned the Nerdpack manager add-on role. For more details about how account access works for users, see Account access New Relic One user model: the ability to manage Nerdpacks is dependent on the \"modify Nerdpacks\" capability. That capability is included in the All product admin role, which both the default Admin and User groups have. And it can also be assigned to a custom role. To learn more about account/user models, see User model overview. Account access For organizations with master/sub-account structures: If you subscribe to a Nerdpack from a master account, that access is inherited by all of its sub-accounts. A Nerdpack made by your team can only be subscribed to from the master account that was used to publish it, or from its sub-accounts. This means that, if the Nerdpack needs to be available across your organization, you may need a New Relic admin to deploy it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.12463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdpack</em> <em>permissions</em>",
        "body": " by New Relic or others. Full users theoretically have <em>Nerdpack</em> management <em>permissions</em>, but there may be restrictions related to custom role assignments (see below). Role-related restrictions For full users, there are role-related rules that may impact one&#x27;s ability to manage Nerdpacks (publish them"
      },
      "id": "6063d5a3196a676061c6f489"
    },
    {
      "sections": [
        "Add custom visualizations to your dashboards",
        "Add a visualization to a dashboard",
        "Manage your dashboard visualizations"
      ],
      "title": "Add custom visualizations to your dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d6c9973ef2c2547a99539d1da027b54db23af42c",
      "image": "https://docs.newrelic.com/static/5f7bd9c6a2a163d1f19c5c8b0d844d2f/c1b63/dashboard_viz.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/add-custom-visualizations-your-dashboards/",
      "published_at": "2021-04-12T03:11:23Z",
      "updated_at": "2021-03-16T11:03:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can build your own visualizations and add them to a dashboard. This gives you great flexibility around what you display on dashboards, from a company logo to custom queries from any data source. This visualization shows the number of people in each city who are viewing New Relic within an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user permissions, which include the Nerdpack manager role, you can add a visualization to a dashboard as described in the following section. The process for creating a visualization is covered in the guide, Build a custom visualization for dashboards. Add a visualization to a dashboard You can add a visualization to a new or existing dashboard. From New Relic, in the top right, click the Apps button, and then on the Apps page, click Custom Visualizations. Hint: if you don't see the Custom Visualizations tile, use the search to locate it. In Custom Visualizations, select the visualization you want to add to a dashboard and then enable it. If there are configuration options, fill those in. The visualization will update with your changes. Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard. If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name. Click Add to dashboard, then click the link to your dashboard to see the custom visualization. Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.69733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Manage</em> your dashboard visualizations",
        "body": " an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user <em>permissions</em>, which include the <em>Nerdpack</em> <em>manager</em> role, you can add a visualization to a dashboard as described in the following section. The process for creating"
      },
      "id": "603ec4e628ccbc9409eba7ab"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.19784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #5)",
        "sections": "Subscribe to <em>applications</em> with the New Relic One Catalog",
        "body": " Relic One Catalog launcher From there, you can access all our global applications. If you’re a <em>Nerdpack</em> <em>Manager</em>, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the <em>app</em> to add the application to the account you wish to grant access. If your team changes, and you need"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:50Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.19766,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #6)",
        "sections": "Subscribe to <em>apps</em> in the New Relic One Catalog",
        "body": " Catalog launcher. From there, you can access all our global applications. If you’re a <em>Nerdpack</em> <em>Manager</em>, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the <em>app</em> to add the application to the account you wish to grant access. If your team changes, and you need to remove"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/embed/",
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Undeploy your app",
        "Subscribe or unsubscribe apps",
        "Handle duplicate applications"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-03-31T01:50:30Z",
      "type": "",
      "external_id": "ba470ff35277c82e7a52854041f13d8d8caa3002",
      "popularity": 1,
      "body": "When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. bash Copy $ nr1 update Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. bash Copy $ nr1 catalog:submit Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Undeploy your app You can also manually undeploy an app. Undeploying an app is detaching a Nerdpack version from a specific channel. Before undeploying, you need to unsubscribe your account from the deployed Nerdpack, then specify the UUID of the Nerdpack you've unsubscribed as the one to undeploy. Step 1 of 3 To get a list of deployed Nerdpacks that your account is subscribed to, run nr1 subscription:list. Step 2 of 3 Copy the UUID of the Nerdpack that you want to unsubscribe and pass it to the nerdpack-id option of the unsubscribe command: nr1 nerdpack:unsubscribe --nerdpack-id=<UUID> Copy You should get a result like this: Unsubscribed account <your account ID> from the nerdpack <Nerdpack UUID>. Step 3 of 3 Unsubscribe the Nerdpack UUID used in step 2: nr1 nerdpack:undeploy --nerdpack-id=<UUID> -t STABLE Copy You should get the result Undeployed nerdpack <Nerdpack UUID> from the STABLE channel. Subscribe or unsubscribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.05504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add images and metadata to your <em>apps</em>",
        "body": " This guide requires the following: A New Relic One <em>app</em> or <em>Nerdpack</em> New Relic One CLI A <em>Nerdpack</em> <em>manager</em> role for publishing, deploying, and subscribing <em>apps</em>. Serve your <em>app</em> locally You can locally serve the <em>app</em> you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your"
      },
      "id": "6063d56664441f2a6c0c8ba1"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/1qf2g217c4q7m/promo-image.1608575584.png",
      "url": "https://learn.newrelic.com/getting-started-with-dashboards-nrql",
      "sections": [
        "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations.",
        "About this workshop",
        "Getting started with Dashboards & NRQL"
      ],
      "published_at": "2021-04-13T01:38:27Z",
      "title": "[Webinar] Getting started with Dashboards & NRQL",
      "updated_at": "2021-04-13T01:38:27Z",
      "type": "",
      "external_id": "20be8b6c5a3882e951f9dfd70354ea7ceaa38c7c",
      "popularity": 1,
      "body": "Sign In [Webinar] Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. Register | FREE Already registered? Sign In About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 115 About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Live events Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 115 © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.72217,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "[Webinar] Getting started with Dashboards &amp; <em>NRQL</em>",
        "sections": "Learn to use the <em>Data</em> Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of <em>NRQL</em>. Progress to working directly with <em>NRQL</em> to create a wider range of charts and visualizations.",
        "body": " a sandbox account you’ll get familiar with <em>NRQL</em> <em>syntax</em>, work with the Query Builder to build your own queries and charts, and create <em>data</em> rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting"
      },
      "id": "5fe29f8528ccbcf532f15668"
    },
    {
      "image": "https://developer.newrelic.com/static/eb2adf50e7680e8ba5b7daaf06c203d1/757a2/nr1-dashboard.png",
      "url": "https://developer.newrelic.com/collect-data/query-data-nrql/embed/",
      "sections": [
        "Query data with NRQL",
        "Learn more and start building",
        "Documentation",
        "Community forum",
        "GitHub"
      ],
      "published_at": "2021-04-11T13:57:08Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "b702de5dd31aa8a3bfe2548df6ebb92baa78e0d0",
      "popularity": 1,
      "body": "With NRQL, you can query any of the default data being reported by New Relic, plus any custom events and attributes you’ve added. Step 1 of 4 NRQL syntax is comparable to ANSI SQL. Learn more about NRQL syntax SELECT function(attribute) [AS 'label'][, ...] FROM event [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Step 2 of 4 NRQL queries can be as simple as fetching rows of data in a raw tabular form to inspect individual events. Learn what events open source agents provide out of the box -- Fetch a list of Browser PageView events SELECT * FROM PageView Copy Step 3 of 4 NRQL queries can also do extremely powerful calculations before the data is presented to you, such as crafting funnels based on the way people actually use your website. Learn more about NRQL funnels -- See how many users visit, signup, browse and purchase from your site as a funnel SELECT funnel(session, WHERE pageUrl='http://www.demotron.com/' AS 'Visited Homepage', WHERE pageUrl='http://www.demotron.com/signup' AS 'Signed Up', WHERE pageUrl='http://www.demotron.com/browse' AS 'Browsed Items', WHERE pageUrl='http://www.demotron.com/checkout' AS 'Made Purchase') FROM PageView SINCE 12 hours ago Copy Step 4 of 4 Using NRQL, you can customize your New Relic experience by crafting diverse dashboards that show your data from multiple angles. You can share these dashboards with technical and non-technical stakeholders alike. Learn more and start building Documentation For an overview of NRQL syntax, see Introduction to NRQL. For a detailed description of all available functions, see NRQL syntax, components, and functions. Community forum Connect with other developers in the our Explorers Hub. GitHub For examples of integrations and other technologies, check us out on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.27138,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Query <em>data</em> with <em>NRQL</em>",
        "body": "With <em>NRQL</em>, you can query any of the default <em>data</em> being reported by New Relic, plus any custom events and attributes you’ve added. Step 1 of 4 <em>NRQL</em> <em>syntax</em> is comparable to ANSI SQL. Learn more about <em>NRQL</em> <em>syntax</em> SELECT function(attribute) [AS &#x27;label&#x27;][, ...] FROM event [WHERE attribute [comparison"
      },
      "id": "6063d5f328ccbc881c43fa66"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/NRQL-Alerting2.png",
      "url": "https://newrelic.com/blog/nerdlog/nrql-alerts-generally-available",
      "sections": [
        "What are NRQL Alerts?",
        "Why use NRQL alerts?",
        "How can you use NRQL alerts?",
        "Where can I get more information?"
      ],
      "published_at": "2021-04-13T23:50:38Z",
      "title": "NRQL Alerts Goes GA: Easily Convert NRQL Queries to Alert Conditions",
      "updated_at": "2021-04-13T23:50:38Z",
      "type": "",
      "external_id": "4e0e8343f3c4f7592a29c28f30f3c437d6e6f8a3",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog NRQL Alerts Goes GA: Easily Convert NRQL Queries to Alert Conditions May 17, 2017 • 4 min read By Chhavi Nijhawan New Relic Query Language (NRQL), pronounced “nerkel,” is the SQL-like language we have been developing since 2014 specifically for analytics. Our customers use NRQL extensively to write custom queries and analyze the data (both metric and events data) they send to New Relic. Along the way we’ve received many requests to add alerting and notifications using data from NRQL queries. Following up on those requests, we announced NRQL alerts at our FutureStack16 user conference in San Francisco last year. Since then, hundreds of customers have participated in the limited-release beta program. They have not only given us great feedback but also demonstrated a plethora of game-changing use cases for NRQL alerting. That’s why I am so happy to announce that NRQL alerting capability is now generally available. What are NRQL Alerts? NRQL alerts are designed to offer the ability to create highly customized alerts using NRQL queries on the data you store in New Relic Insights and the New Relic database (NRDB). Now NRQL queries can be easily converted to alert conditions using the New Relic Alerts UI. The screenshots below show just how easy it is to use: Why use NRQL alerts? New Relic Alerts are designed to provide an easy-to-use, centralized UI to create alert conditions with full-stack visibility. Alert conditions can be easily created on a wide range of metric data collected from almost all New Relic products (including New Relic APM, New Relic Browser, New Relic Synthetics, New Relic Mobile, and New Relic Infrastructure) using the New Relic Alerts UI. Now, in addition to operationalizing on metric data, NRQL alerts extend that capability to your event data stored in NRDB. This data can contain many dimensions, and NRQL lets you instantly slice and dice it to receive notifications when thresholds are met for the nuanced performance indicators that best represent system or business health. One common use case for NRQL alerts is to alert off a group of things based on some shared criteria; for instance, if you want to trigger an alert any time checkout-related transactions have a duration longer than a particular threshold. The following NRQL query shows how easy it is: Customers familiar with New Relic’s Key Transactions capability may be asking, “Isn’t that the same as a Key Transaction response time condition?” Yes, but with NRQL and the addition of a simple custom attribute like “username,” you can modify the query to notify you when a particular VIP customer had a bad experience with checkout: The ability to arbitrarily filter and aggregate with a flexible analytics-focused query language (NRQL) opens the door to endless possibilities for ops and DevOps teams. How can you use NRQL alerts? Since NRQL alerts has been in limited-release beta, early users have been busy coming up with innovative ways to use it. Nate Heinrich recently wrote a description of how NRQL alerts works, and shared his “giant list of things you can do with this that might inspire you.” Read his post NRQL Alerts Will Change How You Think About Using New Relic Data to find more than a dozen examples of useful queries, including creating percentile-based queries on transaction data, so you don’t get swayed by misleading averages. Where can I get more information? For more information on NRQL alerts, refer to the create alert conditions for NRQL queries section of the New Relic documentation. And lots of great information on how to write NRQL queries can be found in the NRQL syntax, components, functions section of our documentation. Or, now that NRQL alerts is generally available, just go ahead and give it a try yourself!   By Chhavi Nijhawan Chhavi Nijhawan is a senior product marketing manager at New Relic. She is passionate about new technologies. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.35069,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> Alerts Goes GA: Easily Convert <em>NRQL</em> Queries to Alert Conditions",
        "sections": "What are <em>NRQL</em> Alerts?",
        "body": " been developing since 2014 specifically for analytics. Our customers use <em>NRQL</em> extensively to write custom queries and analyze the <em>data</em> (both metric and events <em>data</em>) they send to New Relic. Along the way we’ve received many requests to add alerting and notifications using <em>data</em> from <em>NRQL</em> queries"
      },
      "id": "60762e4e64441fd0499d8569"
    },
    {
      "sections": [
        "Create smoother charts with sliding windows",
        "When to use sliding windows",
        "Valid NRQL syntax for SLIDE BY",
        "Translation from PromQL-style queries",
        "Use SLIDE BY with MAX and AUTO",
        "Tip"
      ],
      "title": "Create smoother charts with sliding windows",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "97fe07b51e5f2c6a2868c924d1c829d82fd8f585",
      "image": "https://docs.newrelic.com/static/9d882293c1b7b04e65b4bcf6f3ae4bbf/e5166/SlidingWindow2.jpg",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows/",
      "published_at": "2021-04-12T03:16:43Z",
      "updated_at": "2021-03-16T13:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Sliding windows are a technique for generating charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. For example, in the image below, a query gathers data with 5 minute windows. The windows \"slide\" by 1 minute. Each window overlaps with the previous window by 4 minutes. 5-minute windows with 1-minute \"slide\" In contrast, with \"tumbling\" or \"cascading\" windows, the windows do not overlap. For example, in this TIMESERIES 3 minutes NRQL query, the windows are 3 minutes in length, with each beginning when the other ends. There is no overlap in the measurement interval. 3-minute windows with no overlap or \"slide\". When to use sliding windows Sliding windows are helpful when you need to smooth out \"spiky\" charts. One common use case is to use sliding windows to smooth line graphs that have a lot of variation over short periods of time in cases where the rolling aggregate (for example a rolling mean) is more important than aggregates from narrow windows of time. In the example below, data varies greatly from one minute to another, so the 1-minute tumbling window chart shows many high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar data but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid NRQL syntax for SLIDE BY Valid NRQL syntax for the SLIDE BY clause will follow the format below. SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units Copy integer1 specifies the sliding window width and integer2 specifies the SLIDE BY interval. units is a time unit, such as second, minute, hour, or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy Translation from PromQL-style queries When applicable, a PromQL-style query is translated into a NRQL sliding window query. For example, if your PromQL style query uses rate(request_count[5m]) for the past 60 minutes with a 1-minute window overlap, the NRQL translation would be the query below. SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000 Copy In the translation output, the default unit of millisecond is used for TIMESERIES and SLIDE BY clauses. For TIMESERIES, 300000 ms is 300 seconds, or 5 minutes, specifying a window size of 5 minutes. For SLIDE BY, 60000 ms is 60 seconds, specifying a slide interval of 1 minute. Use SLIDE BY with MAX and AUTO You can combine SLIDE BY with MAX and AUTO arguments to further tailor query results, as shown in the examples below. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy Tip When paired with SLIDE BY, TIMESERIES does not support AUTO or MAX. The TIMESERIES value must be an integer time unit value. In other words, SLIDE BY AUTO or SLIDE BY MAX will work, but TIMESERIES AUTO or TIMESERIES MAX followed by SLIDE BY and MAX, AUTO, or a specific integer time unit is not supported. Tip The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which will show up as gaps and unexpected results. If you experience these issues with query results, consider checking for instances of SLIDE BY where the step interval exceeds the window size.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.16881,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Valid <em>NRQL</em> <em>syntax</em> for SLIDE BY",
        "tags": "Query your <em>data</em>",
        "body": " high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar <em>data</em> but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid <em>NRQL</em>"
      },
      "id": "603e8a2528ccbc56e5eba774"
    },
    {
      "sections": [
        "NRQL syntax, clauses, and functions",
        "Syntax",
        "Query components",
        "Required clauses",
        "Required: SELECT statement",
        "Avg response time since last week",
        "Required: FROM clause",
        "Query one data type",
        "Query multiple data types",
        "Optional clauses",
        "AS clause",
        "Query using math function and AS",
        "Query using funnel and AS",
        "COMPARE WITH clause",
        "EXTRAPOLATE clause",
        "Important",
        "Example of extrapolating throughput",
        "Example of extrapolating throughput as a time series",
        "FACET clause",
        "Faceted query using count()",
        "Faceted query using uniqueCount()",
        "Grouping results across time",
        "FACET ... AS clause",
        "FACET CASES clause",
        "Basic usage with WHERE",
        "Group based on multiple attributes",
        "Label groups with AS",
        "FACET ... ORDER BY clause",
        "Tip",
        "LIMIT clause",
        "Query using LIMIT",
        "OFFSET clause",
        "ORDER BY clause",
        "SHOW EVENT TYPES clause",
        "Data types in the last day",
        "SINCE clause",
        "SLIDE BY clause",
        "Use SLIDE BY with MAX or AUTO interval",
        "TIMESERIES clause",
        "Use a set interval",
        "Use an automatically set interval",
        "Use MAX interval",
        "UNTIL clause",
        "WHERE clause",
        "Example query with three conditions",
        "WITH METRIC_FORMAT clause",
        "WITH TIMEZONE clause",
        "Query metric data",
        "Aggregator functions",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "Get Apdex for specific customers",
        "Get Apdex for specific transaction",
        "Get overall Apdex for your app",
        "average(attribute)",
        "buckets(attribute, ceiling [,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(*)",
        "derivative(attribute [,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "earliest(attribute)",
        "Get earliest country per user agent from PageView",
        "eventType()",
        "Use eventType() in filter() function",
        "Use eventType() with FACET",
        "filter(function(attribute), WHERE condition)",
        "Analyze purchases that used offer codes",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling [,number of buckets])",
        "Histogram of response times from PageView events",
        "Prometheus histogram buckets",
        "New Relic distribution metric",
        "Histogram with a FACET clause",
        "keyset()",
        "See all attributes for a data type",
        "latest(attribute)",
        "Get most recent country per user agent from PageView",
        "latestrate(attribute, time interval)",
        "Get the most recent rate of change of PageView Duration",
        "max(attribute)",
        "median(attribute)",
        "Median query",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "mod() within a WHERE clause condition",
        "mod() within a FACET clause",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute [, percentile [, ...]])",
        "Basic percentile query",
        "predictLinear(attribute, [,time interval])",
        "rate(function(attribute) [,time interval])",
        "Basic rate query",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute [,limit])",
        "Using tuple",
        "Type conversion"
      ],
      "title": "NRQL syntax, clauses, and functions",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "97c38ce7950d354d9f1d9efa5f432326f9bb4b00",
      "image": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/images/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-04-12T09:29:33Z",
      "updated_at": "2021-04-12T09:29:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQL is a query language you can use to query the New Relic database. This document explains NRQL syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a NRQL query. Other resources for understanding NRQL: Intro to NRQL: explains what NRQL is used for, what data you can query with it, and basic NRQL syntax Examine NRQL queries used to build New Relic charts Learn how to query the Metric data type Simulate SQL JOIN functions Use funnels to evaluate a series of related data Format NRQL for querying with the Event API Query components Every NRQL query will begin with a SELECT statement or a FROM clause. All other clauses are optional. The clause definitions below also contain example NRQL queries. Required clauses Required: SELECT statement SELECT attribute ... Copy SELECT function(attribute) ... Copy The SELECT specifies what portion of a data type you want to query by specifying an attribute or a function. It's followed by one or more arguments separated by commas. In each argument you can: Get the values of all available attributes by using * as a wildcard. For example: SELECT * from Transaction. Get values associated with a specified attribute or multiple attributes specified in a comma separated list. Get aggregated values from specified attributes by selecting an aggregator function. Label the results returned in each argument with the AS clause. You can also use SELECT with basic math functions. Avg response time since last week This query returns the average response time since last week. SELECT average(duration) FROM PageView SINCE 1 week ago Copy Required: FROM clause SELECT ... FROM data type ... Copy Use the FROM clause to specify the data type you wish to query. You can start your query with FROM or with SELECT. You can merge values for the same attributes across multiple data types in a comma separated list. Query one data type This query returns the count of all APM transactions over the last three days: SELECT count(*) FROM Transaction SINCE 3 days ago Copy Query multiple data types This query returns the count of all APM transactions and Browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Optional clauses AS clause SELECT ... AS 'label' ... Copy Use the AS clause to label an attribute, aggregator, step in a funnel, or the result of a math function with a string delimited by single quotes. The label is used in the resulting chart. Query using math function and AS This query returns the number of page views per session: SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView Copy Query using funnel and AS This query returns a count of people who have visited both the main page and the careers page of a site over the past week: SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago Copy COMPARE WITH clause SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... Copy Use the COMPARE WITH clause to compare the values for two different time ranges. COMPARE WITH requires a SINCE or UNTIL statement. The time specified by COMPARE WITH is relative to the time specified by SINCE or UNTIL. For example, SINCE 1 day ago COMPARE WITH 1 day ago compares yesterday with the day before. The time range for theCOMPARE WITH value is always the same as that specified by SINCE or UNTIL. For example, SINCE 2 hours ago COMPARE WITH 4 hours ago might compare 3:00pm through 5:00pm against 11:00am through 1:00pm. COMPARE WITH can be formatted as either a line chart or a billboard: With TIMESERIES, COMPARE WITH creates a line chart with the comparison mapped over time. Without TIMESERIES, COMPARE WITH generates a billboard with the current value and the percent change from the COMPARE WITH value. Example: This query returns data as a line chart showing the 95th percentile for the past hour compared to the same range one week ago. First as a single value, then as a line chart. SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO Copy EXTRAPOLATE clause You can use this clause with these data types: Transaction TransactionError Custom events reported via APM agent APIs The purpose of EXTRAPOLATE is to mathematically compensate for the effects of APM agent sampling of event data so that query results more closely represent the total activity in your system. This clause will be useful when a New Relic APM agent reports so many events that it often passes its harvest cycle reporting limits. When that occurs, the agent begins to sample events. When EXTRAPOLATE is used in a NRQL query that supports its use, the ratio between the reported events and the total events is used to extrapolate a close approximation of the total unsampled data. When it is used in a NRQL query that doesn’t support its use or that hasn’t used sampled data, it has no effect. Important Note that EXTRAPOLATE is most useful for homogenous data (like throughput or error rate). It's not effective when attempting to extrapolate a count of distinct things (like uniqueCount() or uniques()). This clause works only with NRQL queries that use one of the following aggregator functions: apdex average count histogram sum percentage (if function it takes as an argument supports EXTRAPOLATE) rate (if function it takes as an argument supports EXTRAPOLATE) stddev Example of extrapolating throughput A query that will show the extrapolated throughput of a service named interestingApplication. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE Copy Example of extrapolating throughput as a time series A query that will show the extrapolated throughput of a service named interestingApplication by transaction name, displayed as a time series. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE Copy FACET clause SELECT ... FACET attribute ... Copy Use FACET to separate and group your results by attribute values. For example, you could FACET your PageView data by deviceType to figure out what percentage of your traffic comes from mobile, tablet, and desktop devices. Use the LIMIT clause to specify how many facets appear (default is 10). For more complex grouping, use FACET CASES. FACET clauses support up to five attributes, separated by commas. The facets are sorted in descending order by the first field you provide in the SELECT clause. If you are faceting on attributes with more than 2,000 unique values, a subset of facet values is selected and sorted according to the query type. When selecting min(), max(), or count(), FACET uses those functions to determine how facets are picked and sorted. When selecting any other function, FACET uses the frequency of the attribute you are faceting on to determine how facets are picked and sorted. For more on faceting on multiple attributes, with some real-world examples, see this New Relic blog post. Faceted query using count() This query shows cities with the highest pageview counts. This query uses the total number of pageviews per city to determine how facets are picked and ordered. SELECT count(*) FROM PageView FACET city Copy Faceted query using uniqueCount() This query shows the cities that access the highest number of unique URLs. This query uses the total number of times a particular city appears in the results to determine how facets are picked and ordered. SELECT uniqueCount(pageUrl) FROM PageView FACET city Copy Grouping results across time Advanced segmentation and cohort analysis allow you to facet on bucket functions to more effectively break out your data. Cohort analysis is a way to group results together based on timestamps. You can separate them into buckets that cover a specified range of dates and times. FACET ... AS clause Use FACET ... AS to name facets using the AS keyword in queries. This clause is helpful for adding clearer or simplified names for facets in your results. It can also be used to rename facets in nested aggregation queries. FACET ... AS queries will change the facet names in results (when they appear as headers in tables, for example), but not the actual facet names themselves. FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' Copy FACET CASES clause SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... Copy Use FACET CASES to break out your data by more complex conditions than possible with FACET. Separate multiple conditions with a comma ,. For example, you could query your PageView data and FACET CASES into categories like less than 1 second, from 1 to 10 seconds, and greater than 10 seconds. You can combine multiple attributes within your cases, and label the cases with the AS selector. Data points will be added to at most one facet case, the first facet case that they match. You may also use a time function with your attribute. Basic usage with WHERE SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) Copy Group based on multiple attributes This example groups results into one bucket where the transaction name contains login, and another where the URL contains login and a custom attribute indicates that the user was a paid user: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') Copy Label groups with AS This example uses the AS selector to give your results a human-readable name: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') Copy FACET ... ORDER BY clause In NRQL, the default is for the first aggregation in the SELECT clause to guide the selection of facets in a query. FACET ... ORDER BY allows you to override this default behavior by adding an aggregate function with the ORDER BY modifier to specify how facets are selected. Specifically, the clause will override the priority by which facets are chosen to be in the final result before being limited by the LIMIT clause. This clause can be used in querying but not for alerts or streaming. This example shows how to use FACET ... ORDER BY to find the average durations of app transactions, showing the top 10 (default limit) highest durations by apps which have the highest response size. In this case, if FACET ... ORDER BY is not used, the query results will instead show the top 10 by highest durations, with response size being irrelevant to the app selection. FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) Copy Tip Because the operations are performed before the LIMIT clause is applied, FACET ... ORDER BY does not impact the sort of the final query results, which will be particularly noticeable in the results for non-timeseries queries. Important The ORDER BY modifier in this case works differently than the ORDER BY clause. When parsing queries that follow the format FACET attribute1 ORDER BY attribute2, New Relic will read these as FACET ... ORDER BY queries, but only if ORDER BY appears immediately after FACET. Otherwise ORDER BY will be interpreted by New Relic as a clause. LIMIT clause SELECT ... LIMIT count ... Copy Use the LIMIT clause to control the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. This clause takes a single integer value as an argument. If the LIMIT clause is not specified, or no value is provided, the limit defaults to 10 for FACET queries and 100 in the case of SELECT * queries. The maximum allowed value for the LIMIT clause is 2,000. Query using LIMIT This query shows the top 20 countries by session count and provides 95th percentile of response time for each country for Windows users only. SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY Copy OFFSET clause SELECT ... LIMIT count OFFSET count ... Copy Use the OFFSET clause with LIMIT to control the portion of rows returned by SELECT * or SELECT column queries. Like the LIMIT clause, OFFSET takes a single integer value as an argument. OFFSET sets the number of rows to be skipped before the selected rows of your query are returned. This is constrained by LIMIT. OFFSET rows are skipped starting from the most recent record. For example, the query SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1 returns the last 5 values from Minute_Report except for the most recent one. ORDER BY clause The ORDER BY clause allows you to specify how you want to sort your query results in queries that select event attributes by row. This query orders transactions by duration. FROM Transaction SELECT appName, duration ORDER BY duration Copy The default sort order is ascending, but this can be changed by adding the ASC or DESC modifiers. SHOW EVENT TYPES clause SHOW EVENT TYPES... Copy SHOW EVENT TYPES will return a list of all the data types present in your account for a specific time range. It is used as the first clause in a query instead of SELECT. Important In this context, \"event types\" refers to the data types you can access with a NRQL query. Data types in the last day This query will return all the data types present over the past day: SHOW EVENT TYPES SINCE 1 day ago Copy SINCE clause SELECT ... SINCE [numerical units AGO | phrase] ... Copy The default value is 1 hour ago. Use the SINCE clause to define the beginning of a time range for the returned data. When using NRQL, you can set a UTC timestamp or relative time range. You can specify a timezone for the query but not for the results. NRQL results are based on your system time. See Set time range on dashboards and charts for detailed information and examples. SLIDE BY clause The SLIDE BY clause supports a feature known as sliding windows. With sliding windows,SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. To use SLIDE BY, place it in a query after the TIMESERIES clause. For example, this query pulls data in 5-minute windows with a 1-minute SLIDE BY interval, meaning that each window lasts 5 minutes, but window 1 starts at 0 minutes, window 2 starts at 1 minute, window 3 starts at 2 minutes, and so on. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy To learn more about how and when you can use SLIDE BY, see Create smoother charts with sliding windows. Use SLIDE BY with MAX or AUTO interval You can use sliding windows in combination with MAX or AUTO. However, MAX or AUTO may not be placed between TIMESERIES and SLIDE BY. This query will automatically decide a SLIDE BY window interval. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy This query will set the SLIDE BY window to the maximum interval granularity. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy Important The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which can cause gaps and unexpected results. TIMESERIES clause SELECT ... TIMESERIES integer units ... Copy Use the TIMESERIES clause to return data as a time series broken out by a specified period of time. Since TIMESERIES is used to trigger certain charts, there is no default value. To indicate the time range, use integer units. For example: TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds TIMESERIES can be combined with arguments such as MAX, AUTO, and SLIDE BY to further tailor query results, as shown in the examples below. Important For functions such as average( ) or percentile( ), a large aggregation window can have a significant smoothing effect on outliers. This is true whether or not the query makes use of sliding windows. Use a set interval The value provided indicates the units used to break out the graph. For example, to present a one-day graph showing 30 minute increments: SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes Copy Use an automatically set interval TIMESERIES can also be set to AUTO, which will divide your graph into a reasonable number of divisions. For example, a daily chart will be divided into 30 minute intervals and a weekly chart will be divided into 6 hour intervals. This query returns data as a line chart showing the 50th and 90th percentile of client-side transaction time for one week with a data point every 6 hours. SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO Copy Use MAX interval You can set TIMESERIES to MAX, which will automatically adjust your time window to the maximum number of intervals allowed for a given time period. This allows you to update your time windows without having to manually update your TIMESERIES buckets and ensures your time window is being split into the peak number of intervals allowed. The maximum number of TIMESERIES buckets that will be returned is 366. For example, the following query creates 4-minute intervals, which is the ceiling for a daily chart. SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX Copy UNTIL clause SELECT ... UNTIL integer units AGO ... Copy The default value is NOW. Only use UNTIL to specify an end point other than the default. Use the UNTIL clause to define the end of a time range across which to return data. Once a time range has been specified, the data will be preserved and can be reviewed after the time range has ended. You can specify a UTC timestamp or relative time range. You can specify a time zone for the query but not for the results. The returned results are based on your system time. See Set time range on dashboards and charts for detailed information and examples. WHERE clause Use the WHERE clause to filter results. NRQL returns the results that fulfill the condition(s) you specify in the clause. SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... Copy If you specify more than one condition, separate the conditions by the operators AND or OR. If you want to simulate a SQL join, use custom attributes in a WHERE or FACET clause. Operators that the WHERE clause accepts Description =, !=, <, <=, >, >= NRQL accepts standard comparison operators. Example: state = 'WA' AND Used to define an intersection of two conditions. OR Used to define a union of two conditions. IS NULL Determines if an attribute has a null value. IS NOT NULL Determines if an attribute does not have a null value. IN Determines if the string value of an attribute is in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Example: animalType IN ('cat', 'dog', 'fish') NOT IN Determines if the string value of an attribute is not in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Values must be in parentheses, separated by commas. For example: SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') Copy LIKE Determines if an attribute contains a specified sub-string. The string argument for the LIKE operator accepts the percent sign (%) as a wildcard anywhere in the string. If the substring does not begin or end the string you are matching against, the wildcard must begin or end the string. Examples: userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE Determines if an attribute does not contain a specified sub-string. RLIKE Determines if an attribute contains a specified Regex sub-string. Uses RE2 syntax. Examples: appName RLIKE 'z.*|q.*'' z-app q-app hostname RLIKE 'ip-10-351-[0-2]?[0-9]-.*' ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 Important Note: Slashes must be escaped in the Regex pattern. For example, \\d must be \\\\d. Regex defaults to full-string matching, therefore ^ and $ are implicit and you do not need to add them. If the Regex pattern contains a capture group, the group will be ignored. That is, the group will not be captured for use later in the query. NOT RLIKE Determines if an attribute does not contain a specified Regex sub-string. Uses RE2 syntax. Example query with three conditions This query returns the browser response time for pages with checkout in the URL for Safari users in the United States and Canada over the past 24 hours. SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago Copy WITH METRIC_FORMAT clause For information on querying metric data, see Query metrics. WITH TIMEZONE clause SELECT ... WITH TIMEZONE (selected zone) ... Copy By default, query results are displayed in the timezone of the browser you're using. Use the WITH TIMEZONE clause to select a time zone for a date or time in the query that hasn't already had a time zone specified for it. For example, the query clause SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York' will return data recorded from Monday at midnight, Eastern Standard Time, until midnight Tuesday, Eastern Standard Time. Available Time Zone Selections Africa/Abidjan Africa/Addis_Ababa Africa/Algiers Africa/Blantyre Africa/Cairo Africa/Windhoek America/Adak America/Anchorage America/Araguaina America/Argentina/Buenos_Aires America/Belize America/Bogota America/Campo_Grande America/Cancun America/Caracas America/Chicago America/Chihuahua America/Dawson_Creek America/Denver America/Ensenada America/Glace_Bay America/Godthab America/Goose_Bay America/Havana America/La_Paz America/Los_Angeles America/Miquelon America/Montevideo America/New_York America/Noronha America/Santiago America/Sao_Paulo America/St_Johns Asia/Anadyr Asia/Bangkok Asia/Beirut Asia/Damascus Asia/Dhaka Asia/Dubai Asia/Gaza Asia/Hong_Kong Asia/Irkutsk Asia/Jerusalem Asia/Kabul Asia/Katmandu Asia/Kolkata Asia/Krasnoyarsk Asia/Magadan Asia/Novosibirsk Asia/Rangoon Asia/Seoul Asia/Tashkent Asia/Tehran Asia/Tokyo Asia/Vladivostok Asia/Yakutsk Asia/Yekaterinburg Asia/Yerevan Atlantic/Azores Atlantic/Cape_Verde Atlantic/Stanley Australia/Adelaide Australia/Brisbane Australia/Darwin Australia/Eucla Australia/Hobart Australia/Lord_Howe Australia/Perth Chile/EasterIsland Etc/GMT+10 Etc/GMT+8 Etc/GMT-11 Etc/GMT-12 Europe/Amsterdam Europe/Belfast Europe/Belgrade Europe/Brussels Europe/Dublin Europe/Lisbon Europe/London Europe/Minsk Europe/Moscow Pacific/Auckland Pacific/Chatham Pacific/Gambier Pacific/Kiritimati Pacific/Marquesas Pacific/Midway Pacific/Norfolk Pacific/Tongatapu UTC See Set time range on dashboards and charts for detailed information and examples. Query metric data Metric data is more complex than other types of data. There are specific tips for querying it well. We have two types of metric data, each with their own query guidelines: Query dimensional metrics, which are reported by our Metric API and by some of our tools that use that API, like our Telemetry SDKs and our open-source telemetry integrations (OpenTelemetry, Kamon, Micrometer, more). Query metric timeslice data, which is our original metric data type reported by our APM, mobile monitoring, and browser monitoring. For more on understanding these data types, see Metric data types. Aggregator functions Use aggregator functions to filter and aggregate data in a NRQL query. Some helpful information about using aggregator functions: See the New Relic University tutorials for Filter queries, Apdex queries, and Percentile queries. Or, go to the full online course Writing NRQL queries. Data type \"coercion\" is not supported. Read about available type conversion functions. Cohort analysis functions appear on the New Relic Insights Cohort analysis page. The cohort functions aggregate transactions into time segments. Here are the available aggregator functions. The definitions below contain example NRQL queries. Examples: SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy aggregationendtime() Use the aggregationendtime() function to return the time of the relevant aggregation. More specifically, for a given aggregate, the aggregationendtime() function provides the timestamp of the end of the time period of that aggregation. For example, in a timeseries query, for a data point that encompasses an hour’s worth of data, the function would return the timestamp of the end of that hour period. apdex(attribute, t: ) Use the apdex function to return an Apdex score for a single transaction or for all your transactions. The attribute can be any attribute based on response time, such as duration or backendDuration. The t: argument defines an Apdex T threshold in seconds. The Apdex score returned by the apdex( ) function is based only on execution time. It does not account for APM errors. If a transaction includes an error but completes in Apdex T or less, that transaction will be rated satisfying by the apdex ( ) function. Get Apdex for specific customers If you have defined custom attributes, you can filter based on those attributes. For example, you could monitor the Apdex for a particularly important customer: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy Get Apdex for specific transaction Use the name attribute to return a score for a specific transaction, or return an overall Apdex by omitting name. This query returns an Apdex score for the Controller/notes/index transaction over the last hour: SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago Copy The apdex function returns an Apdex score that measures user satisfaction with your site. Arguments are a response time attribute and an Apdex T threshold in seconds. Get overall Apdex for your app This example query returns an overall Apdex for the application over the last three weeks: SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago Copy average(attribute) Use the average( ) function to return the average value for an attribute. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. buckets(attribute, ceiling [,number of buckets]) Use the buckets() function to aggregate data split up by a FACET clause into buckets based on ranges. You can bucket by any attribute that is stored as a numerical value in the New Relic database. It takes three arguments: Attribute name Maximum value of the sample range. Any outliers will appear in the final bucket. Total number of buckets For more information and examples, see Split your data into buckets. bucketPercentile(attribute) The bucketPercentile( ) function is the NRQL equivalent of the histogram_quantile function in Prometheus. It is intended to be used with dimensional metric data. Instead of the quantile, New Relic returns the percentile, which is the quantile * 100. Use the bucketPercentile( ) function to calculate the quantile from the histogram data in a Prometheus format. It takes the bucket name as an argument and reports percentiles along the bucket's boundaries: SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago Copy Optionally, you can add percentile specifications as an argument: SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago Copy Because multiple metrics are used to make up Prometheus histogram data, you must query for specific Prometheus metrics in terms of the associated <basename>. For example, to compute percentiles from a Prometheus histogram, with the <basename> prometheus_http_request_duration_seconds using NRQL, use bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50). Note how _ bucket is added to the end of the <basename> as a suffix. See the Prometheus.io documentation for more information. cardinality(attribute) Use the cardinality( ) function to obtain the number of combinations of all the dimensions (attributes) on a metric. It takes three arguments, all optional: Metric name: if present, cardinality( ) only computes the metric specified. Include: if present, the include list restricts the cardinality computation to those attributes. Exclude: if present, the exclude list causes those attributes to be ignored in the cardinality computation. SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) Copy count(*) Use the count( ) function to return a count of available records. It takes a single argument; either *, an attribute, or a constant value. Currently, it follows typical SQL behavior and counts all records that have values for its argument. Since count(*) does not name a specific attribute, the results will be formatted in the default \"humanize\" format. derivative(attribute [,time interval]) derivative() finds the rate of change for a given dataset. The rate of change is calculated using a linear least-squares regression to approximate the derivative. Since this calculation requires comparing more than one datapoint, if only one datapoint is included in the evaluation range, the calculation is indeterminate and won't work, resulting in a null value. The time interval is the period for which the rate of change is calculated. For example, derivative(attributeName, 1 minute) will return the rate of change per minute. dimensions(include: {attributes}, exclude: {attributes}) Use the dimensions( ) function to return all the dimensional values on a data type. You can explicitly include or exclude specific attributes using the optional arguments: Include: if present, the include list limits dimensions( ) to those attributes. Exclude: if present, the dimensions( ) calculation ignores those attributes. FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() Copy When used with a FACET clause, dimensions( ) produces a unique timeseries for all facets available on the event type, similar to how Prometheus behaves with non-aggregated queries. earliest(attribute) Use the earliest( ) function to return the earliest value for an attribute over the specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get earliest country per user agent from PageView This query returns the earliest country code per each user agent from the PageView event. SELECT earliest(countryCode) FROM PageView FACET userAgentName Copy eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... Copy Use the eventType() function in a FACET clause to break out results by the selected data type or in a WHERE clause to filter results to a specific data type. This is particularly useful for targeting specific data types with the filter() and percentage() functions. Important In this context, \"event type\" refers to the types of data you can access with a NRQL query. Use eventType() in filter() function This query returns the percentage of total TransactionError results out of the total Transaction results. You can use the eventType() function to target specific types of data with the filter() function. SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago Copy Use eventType() with FACET This query displays a count of how many records each data type (Transaction and TransactionError) returns. SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES Copy filter(function(attribute), WHERE condition) Use the filter() function to limit the results for one of the aggregator functions in your SELECT statement. You can use filter() in conjunction with FACET or TIMESERIES. Filter is only useful when selecting multiple different aggregations such as SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' .... Otherwise, it's better to just use the standard WHERE clause. Analyze purchases that used offer codes You could use filter() to compare the items bought in a set of transactions for those using an offer code versus those who aren't: Use the filter( ) function to limit the results for one of the aggregator functions in your SELECT statement. funnel(attribute, steps) Use the funnel() function to generate a funnel chart. It takes an attribute as its first argument. You then specify steps as WHERE clauses (with optional AS clauses for labels) separated by commas. For details and examples, see the funnels documentation. getField(attribute, field) Use the getField() function to extract a field from complex metrics. It takes the following arguments: Metric type Supported fields summary count, total, max, min gauge count, total, max, min, latest distribution count, total, max, min counter count Examples: SELECT max(getField(mySummary, count)) from Metric Copy SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 Copy histogram(attribute, ceiling [,number of buckets]) Use the histogram( ) function to generate histograms. It takes three arguments: Attribute name Maximum value of the sample range Total number of buckets (between 1 and 500, inclusive) Histogram of response times from PageView events This query results in a histogram of response times ranging up to 10 seconds over 20 buckets. SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy Prometheus histogram buckets histogram( ) accepts Prometheus histogram buckets: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago Copy New Relic distribution metric histogram( ) accepts Distribution metric as an input: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago Copy Histogram with a FACET clause Use histogram( ) with a FACET clause to generate a heatmap chart: SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago Copy keyset() Using keyset() will allow you to see all of the attributes for a given data type over a given time range. It takes no arguments. It returns a JSON structure containing groups of string-typed keys, numeric-typed keys, boolean-typed keys, and all keys. See all attributes for a data type This query returns the attributes found for PageView events from the last day: SELECT keyset() FROM PageView SINCE 1 day ago Copy latest(attribute) Use the latest( ) function to return the most recent value for an attribute over a specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get most recent country per user agent from PageView This query returns the most recent country code per each user agent from the PageView event. SELECT latest(countryCode) FROM PageView FACET userAgentName Copy latestrate(attribute, time interval) Use the latestrate( ) function to return the rate of change of a value based on the last 2 data points. It takes the attribute in question as the first argument and the unit of time for the resulting rate as the second argument. The function returns a result in units of change in attribute/time interval. This function can be useful to provide the most recent rate of change for an attribute in order to see leading-edge trends. Get the most recent rate of change of PageView Duration This query returns the rate of change of duration based on the last 2 data points. It will be returned in units of duration/second because of the 1 SECOND argument. SELECT latestrate(duration, 1 SECOND) FROM PageView Copy max(attribute) Use the max( ) function to return the maximum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. median(attribute) Use the median( ) function to return an attribute's median, or 50th percentile. For more information about percentile queries, see percentile(). Tip The median( ) query is only available when using the query builder. Median query This query will generate a line chart for the median value. SELECT median(duration) FROM PageView TIMESERIES AUTO Copy min(attribute) Use the min( ) function to return the minimum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. minuteOf(attribute) Use the minuteOf() function to extract only the minute portion (i.e. 0-59) of an attribute holding a valid timestamp value. mod(attribute, divisor) Use the mod( ) function to return the floor modulus after dividing the value of the provided numeric attribute (the first argument, or dividend) by a numeric value (the second argument, or divisor). This modulo operation can be used within a WHERE clause condition to filter to an arbitrary subset of results or within a FACET clause as a way to subdivide the result set. mod() within a WHERE clause condition FROM Transaction SELECT * WHERE mod(port, 2) = 1 Copy mod() within a FACET clause FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) Copy percentage(function(attribute), WHERE condition) Use the percentage( ) function to return the percentage of a target data set that matches some condition. The first argument requires an aggregator function against the desired attribute. Use exactly two arguments (arguments after the first two will be ignored). If the attribute is not numeric, this function returns a value of 100%. percentile(attribute [, percentile [, ...]]) Use the percentile( ) function to return an attribute's approximate value at a given percentile. It requires an attribute and can take any number of arguments representing percentile points. The percentile() function enables percentiles to displays with up to three digits after the decimal point, providing greater precision. Percentile thresholds may be specified as decimal values, but be aware that for most data sets, percentiles closer than 0.1 from each other will not be resolved. Percentile display examples Use TIMESERIES to generate a line chart with percentiles mapped over time. Omit TIMESERIES to generate a billboard and attribute sheet showing aggregate values for the percentiles. If no percentiles are listed, the default is the 95th percentile. To return only the 50th percentile value, the median, you can also use median(). Basic percentile query This query will generate a line chart with lines for the 5th, 50th, and 95th percentile. SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO Copy predictLinear(attribute, [,time interval]) predictLinear() is an extension of the derivative() function. It uses a similar method of least-squares linear regression to predict the future values for a dataset. The time interval is how far the query will look into the future. For example, predictLinear(attributeName, 1 hour) is a linear prediction 1 hour into the future of the query time window. Generally, predictLinear() is helpful for continuously growing values like disk space, or predictions on large trends. Since predictLinear() is a linear regression, familiarity with the dataset being queried helps to ensure accurate long-term predictions. Any dataset which grows exponentially, logarithmically, or by other nonlinear means will likely only be successful in very short-term predictions. New Relic recommends against using predictLinear in TIMESERIES queries. This is because each bucket will be making an individual prediction based on its relative timeframe within the query, meaning that such queries will not show predictions from the end of the timeseries forward. rate(function(attribute) [,time interval]) Use the rate( ) function to visualize the frequency or rate of a given query per time interval. For example, you might want to know the number of pageviews per minute over an hour-long period or the count of unique sessions on your site per hour over a day-long period. Use TIMESERIES to generate a line chart with rates mapped over time. Omit TIMESERIES to generate a billboard showing a single rate value averaged over time. Basic rate query This query will generate a line chart showing the rate of throughput for APM transactions per 10 minutes over the past 6 hours. SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES Copy round(attribute) Use the round( ) function to return the rounded value of an attribute. Optionally round( ) can take a second argument, to_nearest, to round the first argument to the closest multiple of the second one. to_nearest can be fractional. SELECT round(n [, to_nearest]) Copy stddev(attribute) Use the stddev( ) function to return one standard deviation for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. stdvar(attribute) Use the stdvar( ) function to return the standard variance for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. sum(attribute) Use the sum( ) function to return the sum recorded values of a numeric attribute over the time range specified. It takes a single argument. Arguments after the first will be ignored. If the attribute is not numeric, it will return a value of zero. uniqueCount(attribute) Use the uniqueCount( ) function to return the number of unique values recorded for an attribute over the time range specified. Tip To optimize query performance, this function returns approximate results for queries that inspect more than 256 unique values. uniques(attribute [,limit]) Use the uniques( ) function to return a list of unique values recorded for an attribute over the time range specified. When used along with the facet clause, a list of unique attribute values will be returned per each facet value. The limit parameter is optional. When it is not provided, the default limit of 1,000 unique attribute values per facet is applied. You may specify a different limit value, up to a maximum of 10,000. The uniques( ) function will return the first set of unique attribute values discovered, until the limit is reached. Therefore, if you have 5,000 unique attribute values in your data set, and the limit is set to 1,000, the operator will return the first 1,000 unique values that it discovers, regardless of their frequency. The maximum number of values that can be returned in a query result is the product of the uniques( ) limit times the facet limit. In the following query, the theoretical maximum number of values that can be returned is 5 million (5,000 x 1,000). Depending on the data set being queried, and the complexity of the query, memory protection limits may prevent a very large query from being executed. From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 Copy Using tuple If you'd like to know the unique combinations of a handful of attributes, you can structure a query in the format SELECT unique(tuple(x, y, ... z)) ...` to get all the unique tuples of values, to maintain their relationship. In the following query, tuple is used on index and cellName together to find uniques where those two values occur in combination. FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) Copy Type conversion NRQL does not support \"coercion.\" This means that a float stored as a string is treated as a string and cannot be operated on by functions expecting float values. You can convert a string with a numeric value or a boolean with a string value to their numeric and boolean types with these functions: Use the numeric() function to convert a number with a string format to a numeric function. The function can be built into a query that uses math functions on query results or NRQL aggregator functions, such as average(). Use the boolean() function to convert a string value of \"true\" or \"false\" to the corresponding boolean value.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.68512,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> <em>syntax</em>, clauses, and functions",
        "sections": "<em>NRQL</em> <em>syntax</em>, clauses, and functions",
        "tags": "Query your <em>data</em>",
        "body": " <em>NRQL</em> is used for, what <em>data</em> you can query with it, and basic <em>NRQL</em> <em>syntax</em> Examine <em>NRQL</em> queries used to build New Relic charts Learn how to query the Metric <em>data</em> type Simulate SQL JOIN functions Use funnels to evaluate a series of related <em>data</em> Format <em>NRQL</em> for querying with the Event API Query"
      },
      "id": "604456c1196a678db8960f41"
    }
  ],
  "/automate-workflows/diagnose-problems/error-alerts": [
    {
      "sections": [
        "データエクスプローラーの概要",
        "ヒント",
        "重要な理由",
        "データのクエリ",
        "データエクスプローラーを使用する",
        "イベントを詳しく調べる",
        "メトリックスを詳しく調べる",
        "重要",
        "調査を可視化し絞り込む",
        "クエリエリア",
        "NRQLクエリ表示",
        "チャートエリア",
        "共有してエクスポート",
        "使用事例",
        "新規データを確認",
        "データを検証",
        "データの問題のトラブルシューティング",
        "その他のヘルプ"
      ],
      "title": "データエクスプローラーの概要",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "94545f74e5fd5ab0b18f47342f7a8f2a2fa82558",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-12T03:13:32Z",
      "updated_at": "2021-04-12T03:13:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データエクスプローラーを使用すれば、NRQLの知識がなくても、すべてのデータを視覚的に操作できます。データエクスプローラーを使用してデータにアクセスしクエリやカスタマイズ、視覚化を行い、サービスとサービスをつなぎ、一貫したキュレート済みの体験を実現します。 ヒント データエクスプローラー、およびその他のオブザーバビリティ プラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 システムの状態を調査しますか？リソースの計画を作成し、インシデントを特定しそれに対応し、動作不良のトラブルシューティングを行う必要がありますか？データエクスプローラーにより、NRQLを使用したりクエリを構築せずに、視覚的なメニューを通じて、探しているデータを簡単に特定、取得し、視覚化できます。 データエクスプローラーを使用して、次のことを行えます。 イベントやメトリックスデータに、迅速で直感的な方法でアクセスする。 視覚化し簡単に実行できるようにして、データのディメンションを詳しく調べる。 さまざまな観点からデータを把握する：生データや、進歩や配信などについての知見を提供するさまざまな視覚化。 フィルターによりデータを掘り下げる。 1回のクリックで検索をダッシュボードに追加する。 NRQLのしくみについて理解する: データエクスプローラーは、利用可能なデータを検索している間にクエリがどのように構築されるかを示します。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 データのクエリ データエクスプローラーにアクセスするには、one.newrelic.comに移動し ページの上部にあるデータをクエリアイコンをクリックします。 データのブラウズドロップダウンで、イベントまたはメトリクスを選択します。 データエクスプローラーは、New Relicにあるすべてのデータを詳しく調べるためのポータルです。データエクスプローラーUIにあるイベントやメトリックスを詳しく調べたり、LogsやTracesアプリを選択して詳しく調べることができます。また、タブをクリックして、いつでもクエリビルダーにアクセスすることもできます。 データエクスプローラーを使用する データエクスプローラーは、上部にある範囲絞り込みセクション（a）、左側のデータブラウジングエリア（b）、ワークスペース（c）で構成されます。 データエクスプローラーを使用するには： 調べる範囲を定義する：ブラウズするアカウントとデータタイプ（メトリックまたはイベント）を選択します。 タイムピッカーを使用して時間範囲を選択します。 左側のブロックを使用して、イベントかメトリックスのいずれかについて使用可能なデータをブラウズし、検索を作成します。1ブロックにつき1つの要素しか選択できません。ブロックは検索可能です。 イベントを詳しく調べる イベントタイプ 選択したアカウントで使用できるすべてのイベントを表示します。 デフォルトでは、イベントは名前で並び替えられます。 プロット 以前選択したイベントのすべての数字属性を表示します。 リストの最初の項目はcount( * )で、これは属性ではありません。選択したイベントの数を計算します。 デフォルトでは、属性は名前で並び替えられます。 プロットする関数を選択します。デフォルトでは、各属性は関数Averageに設定されます。 ディメンション 以前選択したイベントとプロットのすべてのディメンションを表示します。 ディメンションは、イベントについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 メトリックスを詳しく調べる APM 時間区切りデータを調べるには、AppID、AppName、またはEntityGuidをステップとして選択します（またはそれらのステップでグループ化します）。それ以外の場合は、すべてのエンティティの集計データを取得します。 メトリック 選択したアカウントで使用できるすべてのメトリックスを表示します。 デフォルトでは、メトリックスは名前で並べ替えられます。 ディメンション 以前選択したメトリックのすべてのディメンションを表示します。 ディメンションは、メトリックについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 重要 ユニットの表示には、メトリックシステム（メトリックSIプレフィックスを含む）が使用されています。 調査を可視化し絞り込む 調査の結果は、右側のワーキングスペースに表示されます。 調査を絞り込むか、チャートを共有する ワーキングスペースには、次のものが表示されます。 クエリエリア クエリエリアでは、クエリを異なる構成要素に分解します。ここで、NRQLクエリとして調査の結果を簡単に読み、プロットしている正確なデータをチェックできます。 NRQLに習熟していない場合、このエリアをチェックしクエリの作成方法について学習します。 クエリの別の部分は次のとおりです。 [ イベントのみ]FROM: 最初のブロックで選択したイベント。 SELECT: 選択したプロットまたはメトリック。この入力では、1つの値と1つの関数のみをプロットします。 GROUP BY: FACET句を表し、選択したディメンションごとにデータをグループ化します。 LIMIT: 表示する値の量を入力します。 WHERE: このフィールドを使用して、結果にさらにフィルターを適用します。この入力では、n値をプロットします。 各項目は、xをクリックしてクエリから削除できます。 NRQLクエリ表示 上記のフィールドと、タイムピッカーで選択した時間範囲で構成される、完全なクエリを表示できます。 ヒント より詳細な検索を行う、またはチャートをカスタマイズする必要がある場合データエクスプローラーから、クエリビルダーにアクセスしてクエリを編集できます。 チャートエリア デフォルトでは、データは線チャートで表示されます。チャートピッカーを使用して、面グラフ、円グラフ、およびバーチャートに簡単に切り替えることができます。結果の生データをテーブルまたはJSON形式として表示することもできます。 ディメンションを選択している場合、チャートは異なるファセットで更新されます。チャートの下に、ファセットのリストとそれぞれの値があるファセットの表が表示されます。 ファセットテーブルを使用して、データをドリルダウンします。クリックしたファセットはフィルターとして適用されます。表は表示されたままなので、別のファセットを簡単に選択して調査を続けることができます。 共有してエクスポート 右上にあるオプションメニューを使用して、チャートを画像として取得、またはリンクとして共有、ダッシュボードに追加できます。 また、URLをコピーし、その他のNew Relicユーザーと調査全体を共有することもできます。 使用事例 次の例で、データエクスプローラーをいつどのように使用するかについて学習してください。 新規データを確認 新規インストゥルメンテーションに接続したばかりで、新規データを利用できるかどうか確認したいと思っています。 アカウントとイベント、または新規データを生成しているメトリックを選択します。 データエクスプローラーで別のツールを使用して、利用できるようになった新規データを使ってみる：そのイベントまたはメトリックの生データを表として見る、またはリストとする、またはクリックしてチャートとしてプロットされることを確認します。 イベントやメトリックを選択した後、ディメンションでデータの形状を確認します。濃度を使用して、あらゆるデータの異なる視点を確認できます。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 データを検証 カスタムイベント/メトリックを変更したので、この変更が正常に行われたかどうかをチェックする必要がある。 データエクスプローラータブで、変更したアカウントとデータタイプ、イベント/メトリックを選択します。 エンティティがデータをレポートしていることと、すべての属性がプロットされていることを確認します。 変更した属性を検索し、更新が正常に行われたことをチェックします。 データの問題のトラブルシューティング アラートやダッシュボードからのイベント/メトリックで何か問題があることが分かっている。イベント/メトリック属性の動作について、根本原因を知る必要がある。 データエクスプローラーで、メニューを使用して、想定どおりに動作していないイベントやメトリックを選択し、データエクスプローラーでそのチャートをプロットします。 そこから、そのデータのディメンションを掘り下げて、関連する属性によりフィルターを適用できます。 また、次のような異なる観点からそのデータを把握することもできます：分布や値の順位、経時進化。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.946205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "605343b4196a6754132d166e"
    },
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.1237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.1237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053433228ccbcdc10c2fd60"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Tip",
        "Why it matters",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "8f390d6aa6f57d215b3c23f8cf08c02ef310bddc",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-12T03:13:31Z",
      "updated_at": "2021-03-16T11:03:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Tip To use the data explorer and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces apps to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From data explorer you can access query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 49.987743,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": " icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs and Traces apps to <em>explore</em> those. You can also access the query builder any time"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Data explorer: Query and chart event data",
        "Important",
        "Events vs metrics",
        "UI components",
        "Data samples",
        "Caution"
      ],
      "title": "Data explorer: Query and chart event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Explore data"
      ],
      "external_id": "72a23b59b41a3cb521c184c24603d50c28cffdb1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/data-explorer-query-chart-event-data/",
      "published_at": "2021-04-11T15:45:15Z",
      "updated_at": "2021-03-30T08:43:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you explore the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs metrics In New Relic Insights, the Data explorer page has two tabs: Events: In the context of the Insights UI, this refers to any data that can be queried via NRQL. This includes all our major data types, including events and the Metric, Log, and Span data types. Metrics: In the context of the Insights UI, this refers to metric timeslice data. (Note that metric timeslice data is available for querying with NRQL in New Relic One.) For an improved querying and charting experience, we recommend using New Relic One chart builder and dashboards. UI components Use the Events data explorer to view and explore the data available to you. The UI includes: A dropdown that lets you select a data type, like PageView or Transaction. A time-based chart for that data. A sample of that data type, showing its attached attributes, and the ability to see other samples. Ability to search by group by and search for specific attributes. Data samples The most recent sample for the chosen data type is listed at the bottom of the page. Default attributes are underlined. To see more samples, select See more samples. You may need to scroll left and right to see the full table of data. Caution The amount of data stored for a given event type can run into the hundreds of thousands, or even millions, of records. This report only shows a small sample. Use this UI to review the structure of the data, not the contents of a specific record. For example, you can use it to make sure an attribute is populating properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 46.584587,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data <em>explorer</em>: Query and chart event data",
        "sections": "Data <em>explorer</em>: Query and chart event data",
        "tags": "<em>Explore</em> data",
        "body": " our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you <em>explore</em> the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs"
      },
      "id": "6043efa0e7b9d2b78d5799d2"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/query-and-store-data/embed/",
      "sections": [
        "Query and store data",
        "Tip",
        "Components overview",
        "Query components",
        "Mutation components",
        "Static methods",
        "NrqlQuery"
      ],
      "published_at": "2021-04-13T01:55:31Z",
      "title": "",
      "updated_at": "2021-03-31T01:51:31Z",
      "type": "",
      "external_id": "d3eb598c248158038b798c880cad839c80c69c03",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. Here you can learn how to use the SDK query components, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Tip Query-related React components can be identified by the Query suffix. Mutation-related components can be identified by the Mutation prefix. Components overview Our data components are based on React Apollo. The most basic component is NerdGraphQuery, which accepts any GraphQL (or GraphQL AST generated by the graphql-tag library as the query parameter, and a set of query variables passed as variables. Over this query, we have created an additional set of queries, which can be divided into four groups: User queries: These allow you to query the current user and its associated accounts. Components in this category: UserStorageQuery and AccountsQuery. Entities queries: Because New Relic One is entity-centric, we use queries to make access to your entities easier. You can count, search, list, query, and favorite them. Components in this category: EntityCountQuery, EntitySearchQuery, EntitiesByDomainTypeQuery, EntitiesByGuidsQuery, EntityByGuidQuery, EntityByNameQuery. Storage queries: New Relic One provides a simple storage mechanism that we call NerdStorage. This can be used by Nerdpack creators to store application configuration setting data, user-specific data, and other small pieces of data. Components in this category: UserStorageQuery, AccountStorageQuery, EntityStorageQuery, UserStorageMutation, AccountStorageMutation, and EntityStorageMutation. For details, see NerdStorage. NRQL queries: To be able to query your New Relic data via NRQL (New Relic Query Language), we provide a NrqlQuery component. This component can return data in different formats, so that you can use it for charting and not only for querying. Query components All query components accept a function as a children prop where the different statuses can be passed. This callback receives an object with the following properties: loading: Boolean that is set to true when data fetching is happening. Our components use the cache-and-network strategy, meaning that after the data has loaded, subsequent data reloads might be triggered first with stale data, then refreshed when the most recent data has arrived. data: Root property where the data requested is retrieved. The structure matches a root structure based on the NerdGraph schema. This is true even for highly nested data structures, which means you’ll have to traverse down to find the desired data. error: Contains an Error instance when the query fails. Set to undefined when data is loading or the fetch was successful. fetchMore: Callback function that can be called when the query is being loaded in chunks. The function will only be present when it’s feasible to do so, more data is available, and no fetchMore has already been triggered. Data is loaded in batches of 200 by default. Other components provided by the platform (like the Dropdown or the List) are capable of accepting fetchMore, meaning you can combine them easily. Mutation components Mutation components also accept a children as a function, like the query ones. The mutation can be preconfigured at the component level, and a function is passed back that you can use in your component. This is the standard React Apollo approach for performing mutations, but you might find it easier to use our static mutation method added to the component. More on this topic below. Static methods All of the described components also expose a static method so that they can be used imperatively rather than declaratively. All Query components have a static Query method, and all Mutation components have a mutation method. These static methods accept the same props as their query component, but passed as an object. For example: // Declarative way (using components). function renderAccountList() { return ( <ul> <AccountsQuery> ({data, error}) => { if (error) { return <li>Failed to retrieve list: {error.message}</li>; } return data.map((account) => { <li key={account.id}>{account.name}</li> }); }} </AccountsQuery> </ul> ); } // Imperative way (using promises). async function getAccountList() { let data = {}; try { data = await AccountsQuery.query(); } catch (error) { console.log('Failed to retrieve list: ' + error.message); return; } return data.actor.accounts.map((account) => { return account.name; }); } Copy Similarly, a mutation can happen either way; either declaratively or imperatively. NrqlQuery NrqlQuery deserves additional explanation, because there are multiple formats in which you can return data from it. To provide maximum functionality, all three are exposed through a formatType property. You can find its different values under NrqlQuery.formatType: NERD_GRAPH: Returns the format in which it arrives from NerdGraph. RAW: The format exposed by default in Insights and dashboards when being plotted as JSON. This format is useful if you have a pre-existing script in this format that you're willing to migrate to or incorporate with. CHART: The format used by the charting engine that we also expose. You can find a more detailed explanation of how to manipulate this format in the guide to chart components, and some examples. If you are willing to push data, we currently do not expose NrqlMutation. To do that, see the Event API for how to add custom events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.61783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Mutation</em> <em>components</em>",
        "body": " <em>method</em> so that they can be used imperatively rather than declaratively. All <em>Query</em> <em>components</em> have a <em>static</em> <em>Query</em> <em>method</em>, and all <em>Mutation</em> <em>components</em> have a <em>mutation</em> <em>method</em>. These <em>static</em> <em>methods</em> accept the same props as their <em>query</em> component, but passed as an object. For example: &#x2F;&#x2F; Declarative way"
      },
      "id": "6063d5a3196a675a1fc6f4a5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/embed/",
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:56Z",
      "type": "",
      "external_id": "31fc09fc1a4af441ce6fa9a9ea59fa2216dd2058",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.40424,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ": AccountStorage<em>Query</em> and AccountStorage<em>Mutation</em> Entity access: EntityStorage<em>Query</em> and EntityStorage<em>Mutation</em> Each of these <em>components</em> can operate declaratively (for example, as part of your React rendering <em>methods</em>) or imperatively (by using the <em>static</em> <em>methods</em> for <em>query</em> and <em>mutation</em>). For more information"
      },
      "id": "6063d63428ccbcff4e43fa92"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360/",
      "sections": [
        "Java agent v3.36.0",
        "Improvements",
        "Fixes"
      ],
      "published_at": "2021-04-11T16:59:02Z",
      "title": "Java agent v3.36.0",
      "updated_at": "2021-03-11T03:30:39Z",
      "type": "docs",
      "external_id": "620b9aa4068c44bd29515f153020db735791cd39",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic’s built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.50862,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page"
      },
      "id": "60445ebc196a676dd6960f5e"
    },
    {
      "sections": [
        "newrelic_add_custom_tracer (PHP agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples",
        "Instrument a function",
        "Instrument a method within a class",
        "Instrument a method within a namespaced class"
      ],
      "title": "newrelic_add_custom_tracer (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "c3a4f57bd2b02aa46f896e6e54ef818bac7d66b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer/",
      "published_at": "2021-04-11T21:47:50Z",
      "updated_at": "2021-03-11T06:57:21Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_add_custom_tracer(string $function_name) Copy Specify functions or methods for the agent to instrument with custom instrumentation. Requirements Compatible with all agent versions. Description Specify functions or methods for the agent to target for custom instrumentation. This is the API equivalent of the newrelic.transaction_tracer.custom setting. You cannot apply custom tracing to internal PHP functions. Parameters Parameter Description $function_name string Required. The name can be formatted either as function_name for procedural functions, or as \"ClassName::method\" for methods. Both static and instance methods will be instrumented if the method syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return values Returns true if the tracer was added successfully. Examples Instrument a function function example_function() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"example_function\"); } } Copy Instrument a method within a class class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"ExampleClass::example_method\"); } } } Copy Instrument a method within a namespaced class namespace Foo\\Bar; class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"Foo\\\\Bar\\\\ExampleClass::example_method\"); } } } Copy Alternatively, on PHP 5.5 or later, the ::class syntax can be used instead: namespace Foo\\Bar { class ExampleClass { function example_method() { // ... } } } namespace { use Foo\\Bar; if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(Bar::class . \"::example_method\"); } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 33.59401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument a <em>method</em> within a class",
        "body": "&quot; for <em>methods</em>. Both <em>static</em> and instance <em>methods</em> will be instrumented if the <em>method</em> syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return values Returns true if the tracer was added successfully. Examples Instrument"
      },
      "id": "6043c950196a67e23d960f2d"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-04-11T21:39:43Z",
      "updated_at": "2021-03-11T02:31:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events to Insights. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the first call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 29.761902,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: <em>Static</em> <em>methods</em> on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/graphql_aws_services-1024x593.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/graphql-api",
      "sections": [
        "Using GraphQL in New Relic",
        "Example 1: Querying Infrastructure cloud integrations with NerdGraph",
        "Example 2: Modifying integration configurations with NerdGraph",
        "Transfering NerdGraph data to the terminal",
        "New Relic and GraphQL—easing the path for developers"
      ],
      "published_at": "2021-04-14T00:03:24Z",
      "title": "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "381e6b1a3bca81ebc8b6efc8199d2b75983befca",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read By Mark Weitzel As you build observability into your workflows and processes, you need the ability to quickly retrieve, sort, and process all kinds of telemetry through APIs. With New Relic, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous API operations. With the NerdGraph API explorer—built on GraphQL—you can more easily query the data you need, without over-or under-fetching, and reduce manual toil in your data analysis workflows. More specifically, in New Relic you can use NerdGraph to: Query all the entities associated with your account Query, create, and update the workloads associated with your account Create, manage, and add tags to entities Query distributed tracing data Fetch data when building a New Relic One application Understand upstream and downstream relationships with your services Configure your New Relic Infrastructure cloud integrations Query event data and custom event data with NRQL In this post, I’ll walk through two examples using NerdGraph to query information about New Relic Infrastructure cloud integrations and update their configuration values. But first a bit of history. Using GraphQL in New Relic Unlike typical REST APIs that often require loading from multiple endpoints, GraphQL provides a single endpoint that can manage complex queries so developers can get all the data their app needs from many services in one request. GraphQL is strongly typed, which allows developers to explicitly declare what information is available via queries to the GraphQL service. This declaration is done via a GraphQL schema. Schemas give developers the flexibility they need to express information about the data they return. For example, each field has a description, which developers can use to indicate the proper usage of the data. Schemas also provide the API blueprint developers need to build tools for properly constructing queries and guiding proper usage of any returned data. For example, developers can use the schema to indicate if a field has been deprecated so tools like IDEs can surface this fact and discourage use of that data. And “schema stitching”—creating a single schema from several underlying GraphQL APIs—allows developers to deliver a unified access experience across all of their APIs, as we’ve done at New Relic: The New Relic GraphQL implementation includes several underlying GraphQL APIs—including accounts, Infrastructure, and the New Relic database (for constructing NRQL queries). For more information on GraphQL, the following examples of querying cloud integration configuration data use GraphQL queries and mutations: Queries: GraphQL requests that only fetch data Mutations: GraphQL requests that modify and fetch data NerdGraph has a single endpoint: https://api.newrelic.com/graphiql. This launches (after authenticating the user) the NerdGraph API interface—an interactive, browser-based IDE for running GraphQL requests. In the NerdGraph API explorer, you build and run your query on the left, and the result is returned on the right. You can click into fields to drill into their definitions. For example, if you drill into actor, you’ll see it contains fields for user and accounts: { actor { user { name email } accounts { id name } } } The fields under actor expose data from different downstream services that are unified in the GrahQL schema delivered by the GraphQL server. When you issue a query, the GraphQL server pulls apart the query and invokes a resolver for each of the services. When the queries complete (or time out or encounter errors), the GraphQL server assembles the result and returns it to you. In the example above, we get information about the user and all the accounts that they have access to. Let’s walk through our examples to show the full power of GraphQL’s data collection capabilities. Example 1: Querying Infrastructure cloud integrations with NerdGraph In my first example, I’ll use NerdGraph to query for various data about the AWS integrations that are running in my New Relic account. I’ll use the data I gather in this example to update some specific settings in the next section. Tip: If you’re planning on following along, make sure you generate an API key that you can use with New Relic’s GraphQL API. In fact, you can generate one directly from NerdGraph. Let's start with a list of the AWS integrations I have available in New Relic Infrastructure: AWS integrations installed in New Relic Infrastructure. Next, let's retrieve some information about these AWS services via a GraphQL query. I’m going to query for the cloud provider (in this case, AWS) that’s linked to my account and the set of integrations from AWS that I’ve installed. To do this, I need to pass the ID of the account I want to query—this is the account(id: MY ACCOUNT ID) part of the query. Notice that I’m “nesting” requests to get information about the cloud provider and the integrations I’m using. If I were using a REST API, this would require multiple calls, but with the GraphQL API, I can gather this information with just one query.   { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { id name slug } integrations { id name service { id slug name createdAt updatedAt provider { name id } } } } } } } } When the query completes, the GraphQL server assembles the results about the AWS integrations I’ve installed, as shown below (note that I’ve truncated the example): { \"data\": { \"actor\": { \"account\": { \"cloud\": { \"linkedAccounts\": [ { \"authLabel\": \"arn:aws:iam::8xxxxxxx7:role/NewRelicInfrastructure-Integrations-Origami\", \"externalId\": \"8xxxxxxx7\", \"id\": 3542, \"integrations\": [ { \"id\": 75540, \"name\": \"RDS\", \"service\": { \"createdAt\": 1470991744, \"id\": 3, \"name\": \"RDS\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"rds\", \"updatedAt\": 1534242454 } }, { \"id\": 14233, \"name\": \"S3\", \"service\": { \"createdAt\": 1470991745, \"id\": 4, \"name\": \"S3\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"s3\", \"updatedAt\": 1534242454 } }, { \"id\": 12223, \"name\": \"Lambda\", \"service\": { \"createdAt\": 1477910055, \"id\": 14, \"name\": \"Lambda\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"lambda\", \"updatedAt\": 1534242454 } }, { \"id\": 172534, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 } }, } } ] } } } } } But what if I want more specific information about one of the integrations? Specifically, I want to see what tags (user-defined metadata) I’ve applied to a particular integration as well as its metrics polling interval (how often New Relic polls the integration for data), and when these settings were last updated. To do this, I’ll need to use one of the more nuanced features of GraphQL—interfaces, an abstract type that represents a collection of common fields that other object types can implement. So in my original query, I’ll add two new clauses: ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } Now, if my query hits a result that is of type CloudDynamodbIntegration or CloudReshiftIntegration, it also return the fields metricsPollingInterval, tagKey, tagValue, and updatedAt. Here's what my (truncated) query will like now: { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { ... } integrations { id name service { ... } } ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } } } } } } In the result, notice that the DynamoDb and Redshift configuration information contain the extra fields that I specified in the query using their interfaces. { \"id\": 173397, \"metricsPollingInterval\": 900, \"name\": \"Redshift\", \"service\": { \"createdAt\": 1497364366, \"id\": 21, \"name\": \"Redshift\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"redshift\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1544435410 }, { \"id\": 112183, \"metricsPollingInterval\": 900, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1549499902 }, OK! I’ve successfully queried information about my AWS integrations in New Relic Infrastructure, and I’ve used an interface to get additional information about a specific integration. Now, I’ll use the GraphQL API to update the metrics data polling intervals in one of these integrations. Example 2: Modifying integration configurations with NerdGraph In GraphQL, when you modify data with a write operation, it’s called a mutation. In this example, I’ll build a mutation to update the polling intervals of an AWS integration. First, though, I’ll set a polling interval so that we'll notice when I change it with NerdGraph. Here are the configuration options for my AWS DynamoDB integration: DynamoDB integration configuration options in New Relic Infrastructure. As you can see, I’ve set the metrics data and inventory data polling intervals to every 5 minutes, and I’ve also toggled Collect tags to ON. Now I’ll build the mutation query. First, I'll start with the keyword mutation, and like any GraphQL API request, enclose it in a pair of curly braces,{ }. Next, I want to specify that I’m configuring a cloud integration; so I’ll add cloudConfigureIntegration, which takes two arguments: accountId and integrations. For accountId, I’ll use the same account id from the first example to get information about the Infrastructure-linked accounts. The second argument is the integrations that I want to update. Again, integrations are specified by cloud provider, so here I want to include aws. So far my mutation looks like this: mutation{ cloudConfigureIntegration( accountId:MY ACCOUNT ID integrations:{aws I want to specify that I’m updating the configuration for DynamoDB, so I’ll pass in an object with dynamodb as the key and an array that contains objects with the values I want to to set. Remember, for our mutation, we want to update the metricsPollingInterval (valid values are 300, 900, 1800, and 3600 seconds) and add a tagKey (metadata about the function of the integration). The final part of the mutation adds a set of fields to return if my request is successful and a set of fields to return if there are any errors. Here's the full query: mutation{ cloudConfigureIntegration( accountId:630060 integrations:{aws:{ dynamodb:[ { linkedAccountId:4912 metricsPollingInterval:1800 tagKey:\"mdw-test\" }] } } ) { integrations{ id name updatedAt ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } errors{ linkedAccountId message integrationSlug } } } And here’s the result, which shows no errors and indicates DynamoDB’s configuration was successfully updated: { \"data\": { \"cloudConfigureIntegration\": { \"errors\": [], \"integrations\": [ { \"id\": 177184, \"metricsPollingInterval\": 1800, \"name\": \"DynamoDB\", \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1551139957 } ] } } } I can now return to New Relic Infrastructure and refresh the DynamoDB configuration page: Refreshing the DynamoDB configuration in New Relic Infrastructure. Our mutation changed the metric polling interval from 300 seconds (5 minutes) to 1800 seconds (30 minutes), and entered tag key value of mdw-test. That's it! I've successfully updated the configuration of a New Relic Infrastructure integration using NerdGraph. Transfering NerdGraph data to the terminal So, now you know how to explore the New Relic data available to you in NerdGraph, and you know how to create queries and mutations, but how do you transfer this data to your code? To capture code-ready queries and mutations, select the Tools drop down in the NerdGraph explorer. To copy a curl statement with the in-scope query to your clipboard, select Copy as CURL. Paste this code snippet into your terminal, or use it to populate an HTTP request in your code. If you’re working with the New Relic CLI, select Copy as New Relic CLI from the drop down to generate a command-line ready query or mutation. New Relic and GraphQL—easing the path for developers As these examples show, GraphQL is extremely flexible and lightweight, and dramatically reduces the overhead of working with your New Relic data. If you want to challenge yourself even more, create some more complex queries in the Query Builder. For example, can you create a query to grab the count of all of your reporting entities? Hint: check out NerdGraph’s entity search field. We’re passionate about making life for developers as easy as possible. Check out the resources available at developer.newrelic.com, and engage in the discussion with fellow developers on the Explorer’s Hub. By Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.72571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Started With <em>NerdGraph</em>—The New Relic GraphQL API Explorer",
        "sections": "Transfering <em>NerdGraph</em> data to the <em>terminal</em>",
        "body": " Infrastructure integration using <em>NerdGraph</em>. Transfering <em>NerdGraph</em> data to the <em>terminal</em> So, now you know how to explore the New Relic data available to you in <em>NerdGraph</em>, and you know how to create queries and <em>mutations</em>, but how do you transfer this data to your code? To capture code-ready queries and <em>mutations</em>"
      },
      "id": "6076314c64441f483e9d8576"
    },
    {
      "sections": [
        "NerdGraph cloud integrations API tutorial",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph cloud integrations API tutorial",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-04-12T04:27:46Z",
      "updated_at": "2021-04-12T04:27:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to https://api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } }</integration_slug></provider_slug> Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } }</integration_slug></provider_slug> Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 210.56148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> cloud integrations API tutorial",
        "sections": "<em>NerdGraph</em> cloud integrations API tutorial",
        "tags": "<em>NerdGraph</em>",
        "body": "This document provides examples of how to use New Relic <em>NerdGraph</em> to <em>query</em> and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the <em>NerdGraph</em> GraphiQL explorer, you can also <em>query</em> NRQL data. These examples for querying"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "image": "https://developer.newrelic.com/static/0ce8c387a290d7fbd6be155322be9bce/bc8d6/create-account.png",
      "url": "https://developer.newrelic.com/collect-data/get-started-nerdgraph-api-explorer/embed/",
      "sections": [
        "Explore NerdGraph using the API Explorer",
        "Before you begin",
        "Build a query to retrieve your name",
        "Click the play button to see the result",
        "Add more fields to your query",
        "Experiment with mutations",
        "Tip",
        "Try your NerdGraph query in the terminal",
        "Next steps"
      ],
      "published_at": "2021-04-11T14:02:35Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "48a6f61f0a9e7054169b785f20fbdd6cd97f2a25",
      "popularity": 1,
      "body": "NerdGraph is New Relic's GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don't need to know the query format: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want and filling out their required values. Before you begin Go to api.newrelic.com/graphiql and log in using your New Relic user ID and password: the NerdGraph API Explorer loads up. Make sure you have a valid New Relic user key. You can create one from the NerdGraph API Explorer or view and create them in the API keys UI. Step 1 of 5 Build a query to retrieve your name Time for your first NerdGraph query. Search for your name in the New Relic database: Erase everything in the query editor. Select the following fields in the query explorer in this order: actor, user, name. This GraphQL snippet appears in the editor. { actor { user { name } } } Copy Step 2 of 5 Click the play button to see the result With this query, you're telling NerdGraph to retrieve your name. You're asking for the name field, which is nested within the user field. This refers to the user who owns the API key, which in turn is nested within actor. Click the play button to see the result: It has almost the same shape as the request. All the fields in the Query Builder make up what's called the GraphQL schema, which describes all the available data types and their attributes. To learn more about each field, click the Docs button, or hover over a field in the editor. Step 3 of 5 Add more fields to your query Now you can try adding more fields to your query. The simplest way is clicking the fields in the Query Builder: The API Explorer knows where the attributes should go in the query. In the example, you add the account id and email fields. Once again, running the GraphQL query results in just the data you need, without over or under-fetching data. Notice that the id field has an argument: passing arguments is a powerful way of customizing your NerdGraph queries. Every field and object can contain arguments, so instead of running multiple queries, you just compose the one that you need. { actor { user { name email } account(id: 12345678) } } Copy Step 4 of 5 Experiment with mutations In GraphQL, mutations are a way to execute queries with side effects that can alter the data by creating, updating, or deleting objects (Commonly referred to as CRUD operations in REST APIs). Ready for your first mutation? Erase what's in the editor. Scroll down the Query Builder and expand mutation. Select the fields in the following screenshot: In this case, you're trying to add a custom tag to an entity. Notice that the editor complains if you don't select errors: mutations must have a way of telling you how the operation performed in the backend (failed requests result in null responses). Tip Unlike REST, GraphQL APIs like NerdGraph can return partial responses. For example, if you try adding tags to multiple entities, some mutations can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your NerdGraph query in the terminal Let's say that you've built a NerdGraph query you're happy with and you want to test it elsewhere. To capture code-ready queries and mutations: Select the Tools menu. Copy the query as a curl call or as a New Relic CLI command. bash Copy $ # curl version $ curl https://api.newrelic.com/graphql \\ > -H 'Content-Type: application/json' \\ > -H 'API-Key: API_KEY_REDACTED' \\ > --data-binary '{\"query\":\"{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id: 12345678)\\n }\\n}\\n\", \"variables\":\"\"}' $ $ # New Relic CLI version $ newrelic nerdgraph query '{ $ actor { $ user { $ name $ email $ } $ account(id: 12345678) $ } $ } $ ' Next steps Now you know the basics of composing and testing NerdGraph queries, but how do you turn them into client or server code? Solutions such as GraphQL Code Generator can help you turn the NerdGraph queries into code for your implementation. Try creating more complex queries by clicking fields and expanding objects in the Query Builder (be careful with mutations though, since they could write data to your account). For more information on NerdGraph and explore other projects from the developer community, check out the threads on the Explorer’s Hub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.47986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Try your <em>NerdGraph</em> <em>query</em> in the <em>terminal</em>",
        "body": " entities, some <em>mutations</em> can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your <em>NerdGraph</em> <em>query</em> in the <em>terminal</em> Let&#x27;s say that you&#x27;ve built a <em>NerdGraph</em> <em>query</em> you&#x27;re happy with and you want to test it elsewhere. To capture code-ready queries and <em>mutations</em>: Select"
      },
      "id": "6063d63364441f87210c8bb4"
    },
    {
      "sections": [
        "NerdGraph API: Examples",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "NerdGraph API: Examples ",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-04-12T02:20:11Z",
      "updated_at": "2021-03-13T02:52:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.5183,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: Examples ",
        "sections": "<em>Mutations</em>",
        "tags": "Alerts and <em>Nerdgraph</em>",
        "body": " Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and <em>mutations</em> is through the <em>NerdGraph</em> API explorer. <em>NerdGraph</em> API explorer Our <em>NerdGraph</em> API explorer is a GraphiQL editor where you can prototype queries and <em>mutations</em>. Here are some examples showing"
      },
      "id": "6043fe3864441f2dd2378ee8"
    },
    {
      "sections": [
        "Use NerdGraph to manage license keys and user keys",
        "Overview of feature description",
        "Before using examples",
        "Create keys",
        "Create a user key",
        "Update keys",
        "Delete keys",
        "Query keys"
      ],
      "title": "Use NerdGraph to manage license keys and user keys",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "5610c77ebfcd92d59c1d0a1b15343f499c8e310e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys/",
      "published_at": "2021-04-12T04:28:58Z",
      "updated_at": "2021-03-16T08:11:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains tutorials on how to use NerdGraph to programmatically manage some New Relic API keys. For general information about New Relic keys, see API keys. Overview of feature description You can use the API keys UI to create and manage keys. Alternatively, you can use NerdGraph's ApiAccess field to programmatically create and manage the following types of keys: User keys License keys, including: General license key (used for APM, infrastructure monitoring, more) Browser key (for browser monitoring) One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. Notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Regarding license keys: License keys are categorized by NerdGraph as ingest keys. This is because their main use is to allow data ingest. You can create up to 1,000 keys of each license key type, which allows for key rotation. You can't manage or delete original license keys; you can only create additional license keys and manage keys you've created. Before using examples Things to note before using these example queries: The examples below use license keys (aka ingest keys), but you can query user keys in similar ways, replacing the ingest-key-specific fields with user-key-specific fields. To understand the data structure, we recommend experimenting with queries using the GraphiQL explorer. You can also create, view, and delete user keys using the UI. Create keys You can create multiple keys in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Here's an example of using this query to create a user key: Create a user key To create a user key, you'd change the above query slightly, in the keys section: mutation { apiAccessCreateKeys(keys: {user: {accountId: YOUR_ACCOUNT_ID, userId: YOUR_USER_ID}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Copy Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.44543,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>NerdGraph</em> to manage license keys and user keys",
        "sections": "Use <em>NerdGraph</em> to manage license keys and user keys",
        "tags": "<em>NerdGraph</em>",
        "body": " to let you rotate keys for security purposes. Note that you can&#x27;t use this <em>NerdGraph</em> functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you&#x27;ve created. Notes about this functionality: All <em>mutations</em> can accept multiple keys"
      },
      "id": "603e96bf28ccbc326aeba75c"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/K8s2.png",
      "url": "https://newrelic.com/blog/how-to-relic/kubernetes-operators-for-parallel-deployment",
      "sections": [
        "What is a Kubernetes Operator?",
        "About the New Relic Kubernetes Operator",
        "Before you begin",
        "Installing the operator on your Kubernetes cluster",
        "Using the Kubernetes operator",
        "Workflow overview",
        "Creating your first alert policy",
        "Add NRQL alert conditions to your alert policy",
        "What’s next?",
        "Related Topics"
      ],
      "published_at": "2021-04-14T00:03:23Z",
      "title": "How to Use the New Relic Kubernetes Operators for Parallel Deployment",
      "updated_at": "2021-04-14T00:01:39Z",
      "type": "",
      "external_id": "4b06941f074b16cd874c3c525c2153dfc224613d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring How to Use the New Relic Kubernetes Operators for Parallel Deployment Jul 1, 2020 • 6 min read By Sander Blue The New Relic Developer Toolkit offers a suite of tools expressly built to reduce toil for developers. In Practicing Observability as Code: Defining New Relic Alert Policies with Terraform, we explained how to use the New Relic Terraform provider to deploy monitoring and alerting configurations alongside your infrastructure and application code. Now we're doing the same for Kubernetes. In this post, we'll briefly go over Kubernetes Operators, why they're useful, and show how the New Relic Kubernetes Operator provides a seamless way to deploy New Relic resources alongside your Kubernetes deployment. What is a Kubernetes Operator? Operators are software extensions to Kubernetes that make use of custom resources to manage applications and their components. Operators follow Kubernetes principles, notably the control loop. Kubernetes is becoming the de-facto standard for orchestrating containerized services in the cloud. Kubernetes introduced the Operator pattern in version 1.7, giving you the ability to extend Kubernetes by defining custom Kubernetes objects that can perform domain-specific operations, such as configuring and provisioning third-party services. About the New Relic Kubernetes Operator The New Relic Kubernetes Operator provides the ability to configure your New Relic monitoring resources the same way you manage the rest of your Kubernetes configuration. For example, once you've installed the operator in your cluster, you can create a New Relic alert policy via kubectl apply using New Relic's custom Kubernetes AlertsPolicy object. You can also configure the AlertsPolicy object using NRQL alert conditions. To configure a standalone New Relic NRQL alert condition and apply it to a pre-existing alert policy, you can use New Relic's custom AlertsNrqlCondition object. Note: This post was written with the New Relic Kubernetes Operator version v0.0.2 and Kubernetes version 1.18.2. Before you begin This walkthrough assumes you’ve already deployed a Kubernetes cluster. You could even create a local cluster on your machine with kind. To complete the full exercise, you’ll need to: Install kubectl, and point it at the correct cluster, as this will determine the cluster where you’ll install the New Relic operator. Install kustomize. Installing the operator on your Kubernetes cluster Installing the New Relic operator is a two-step process. First, install cert-manager, which automatically provisions and manages TLS certificates in Kubernetes: kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.15.0/cert-manager.yaml Next, install the Kubernetes operator: kustomize build https://github.com/newrelic/newrelic-kubernetes-operator/configs/default | kubectl apply -f - To confirm the installation was successful, run a few kubectl commands to check the status of the Kubernetes operator. Ensure the Kubernetes operator's namespace, newrelic-kubernetes-operator-system, has been applied: kubectl get namespaces The output should be similar to the example below, which includes the Kubernetes operator's namespace, newrelic-kubernetes-operator-system: NAME                                     STATUS   AGE cert-manager                          Active   4m35s default                               Active   20m kube-node-lease                       Active   20m kube-public                           Active   20m kube-system                           Active   20m newrelic-kubernetes-operator-system   Active   3m48s Now, make sure the Kubernetes operator's controller manager is running: kubectl get pods --namespace newrelic-kubernetes-operator-system Note: Don't forget to include the --namespace (shorthand -n) option when running kubectl get pods to ensure you're inspecting resources within the correct namespace. You should see output similar to the following: NAME                                                               READY   STATUS    RESTARTS   AGE newrelic-kubernetes-operator-controller-manager-7b9c64f58crwg9j   2/2     Running   0          157m If you see output similar to the above, you’re ready for the next step. If you don’t see a pod named newrelic-kubernetes-operator-controller-manager-<hash>, double check your Kubernetes configuration to ensure you’re within the correct context and pointing to the correct cluster. Using the Kubernetes operator Now that Kubernetes operator is deployed to your cluster, you can put it to work. You’ll write the alert policy and NRQL alert condition configuration the same way you write your other Kubernetes configurations. Workflow overview Generally, it’s a three-step process to create your first alert policy using kubectl apply. Using a declarative approach, you’ll write an alert policy configuration file. You’ll add your New Relic personal API key to the configuration. You’ll run kubectl apply when your configuration is ready to go. Creating your first alert policy To kick things off, start small. First, create an alert policy with the minimum required configuration, then add a NRQL alert condition to the policy, which will add the condition to the policy in New Relic. A minimal alert policy configuration is represented in the code below. For the sake of this walkthrough, name this file new_relic_alert_policy.yaml. new_relic_alert_policy.yaml apiVersion: nr.k8s.newrelic.com/v1 kind: AlertsPolicy metadata: name: my-policy spec: account_id: <your New Relic account ID> api_key: <your New Relic personal API key> name: \"Alert Policy Created With k8s\" # Feel free to rename region: \"us\" Note: For help locating your personal API key, check out New Relic's personal API key documentation. Now run the kubectl apply command to create your alert policy: kubectl apply -f ./new_relic_alert_policy.yaml You'll see output that reads similar to the following: alertspolicy.nr.k8s.newrelic.com/my-policy created\\ Confirm that your alert policy was created by viewing your policies at alerts.newrelic.com/accounts/{your account ID}/policies. You can search for your new policy by its name. In this case , you’d search for \"Alert Policy Created With k8s.\" You should see your new alert policy. Now it’s time to add a NRQL alert condition to the policy using the same configuration file. Add NRQL alert conditions to your alert policy Now that you’ve created an alert policy, you’ll want to add some alert conditions to the policy so you can trigger alerts when certain metrics are out of line. In your new_relic_alert_policy.yaml file, add a NRQL alert condition to the policy that will alert you when an application's average overall response time is above five seconds for a three minute period. new_relic_alert_policy.yaml # The policy from the previous steps apiVersion: nr.k8s.newrelic.com/v1 kind: AlertsPolicy metadata: name: my-policy spec: account_id: <your New Relic account ID> api_key: <your New Relic personal API key> name: \"Alert Policy Created With k8s\" # Feel free to rename region: \"us\" # Add a NRQL alert condition to the policy conditions: - spec: type: \"NRQL\" name: \"NRQL Alert Condition Created With k8s\" nrql: query: \"SELECT average(duration) FROM Transaction WHERE appName = 'YOUR APP NAME'\" evaluationOffset: 3 enabled: true terms: - threshold: \"5\" threshold_occurrences: \"ALL\" threshold_duration: 180 priority: \"CRITICAL\" operator: \"ABOVE\" violationTimeLimit: \"ONE_HOUR\" valueFunction: \"SINGLE_VALUE\" Note: To receive notifications when an alert is triggered, you'll want to add notification channels to your alert policy. With the alert condition added to the configuration,  you can apply the update, which will create a NRQL alert condition and add it to your policy. kubectl apply -f ./new_relic_alert_policy.yaml To confirm the successful creation of the NRQL alert condition, refresh your alert policy. If you see a new alert condition added to the alert policy, it was a success. To finish things off,  create and add an alert channel to your alert policy. For example, maybe you want to send an email out to your team when your alert condition is triggered. What’s next? Nice work—now you can manage your New Relic alert policies and NRQL alert conditions with code that integrates seamlessly within your Kubernetes workflow. This allows you to configure and manage your alerts with a domain-specific pattern, providing consistency and maintainability. You also gain the benefits of code reviews for any potential changes moving forward. As you and your team progress, you may need to adjust some of the configuration values to better fit your needs. The New Relic Kubernetes Operator is just one of several tools in the New Relic Developer Toolkit aimed at facilitating observability as code. Check out the New Relic Kubernetes Operator and other tools to help automate your workflows at New Relic Open Source. Related Topics Kubernetes Monitoring By Sander Blue Sander is a Senior Software Engineer at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 242.49875,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to Use the New Relic <em>Kubernetes</em> <em>Operators</em> for Parallel Deployment",
        "sections": "Add <em>NRQL</em> <em>alert</em> <em>conditions</em> to your <em>alert</em> policy",
        "body": " also configure the AlertsPolicy object using <em>NRQL</em> <em>alert</em> <em>conditions</em>. To configure a standalone New Relic <em>NRQL</em> <em>alert</em> condition and apply it to a pre-existing <em>alert</em> policy, you can use New Relic&#x27;s custom Alerts<em>Nrql</em>Condition object. Note: This post was written with the New Relic <em>Kubernetes</em> <em>Operator</em>"
      },
      "id": "607630e3e7b9d2705da5c672"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-kubernetes/embed/",
      "sections": [
        "Set up New Relic using the Kubernetes operator",
        "Before you begin",
        "Installing the operator on your Kubernetes cluster",
        "Creating your first alert policy",
        "Add NRQL alert conditions to your alert policy",
        "Try it out now",
        "Important",
        "What’s next?"
      ],
      "published_at": "2021-04-13T01:55:31Z",
      "title": "",
      "updated_at": "2021-04-02T01:47:43Z",
      "type": "",
      "external_id": "8fdc25f02e298f98c65266f8c1f05998b32e071f",
      "popularity": 1,
      "body": "Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications. You can use it to provision all kinds of infrastructure and services, including New Relic entities. In this guide you'll learn how to set up New Relic for the first time with the official New Relic Kubernetes operator. More specifically, you'll provision an alert policy with NRQL conditions in your New Relic account using Kubernetes. Before you begin This walkthrough assumes you’ve already deployed a Kubernetes cluster. You could even create a local cluster on your machine with kind. To use this guide, you should have some basic knowledge of both New Relic and Kubernetes. To complete the full exercise, you’ll need to: Deploy a New Relic agent if you haven't done so yet. Install New Relic for your application. Install kubectl and point it at the correct cluster; this determines the cluster where you’ll install the New Relic operator. Install kustomize. Step 1 of 3 Installing the operator on your Kubernetes cluster First, install cert-manager, which automatically provisions and manages TLS certificates in Kubernetes. bash Copy $ kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.15.0/cert-manager.yaml Next, install the Kubernetes operator. bash Copy $ kustomize build https://github.com/newrelic/newrelic-kubernetes-operator/config/default | kubectl apply -f - To confirm the installation was successful, run a few kubectl commands to check the status of the Kubernetes operator. Ensure the Kubernetes operator's namespace, newrelic-kubernetes-operator-system, has been applied: bash Copy $ kubectl get namespaces The output should be similar to the following, which includes the Kubernetes operator's namespace, newrelic-kubernetes-operator-system: bash Copy NAME STATUS AGE cert-manager Active 4m35s default Active 20m kube-node-lease Active 20m kube-public Active 20m kube-system Active 20m newrelic-kubernetes-operator-system Active 3m48s Now, make sure the Kubernetes operator's controller manager is running: Note: Don't forget to include the --namespace (shorthand -n) option when running kubectl get pods to ensure you're inspecting resources within the correct namespace. bash Copy $ kubectl get pods --namespace newrelic-kubernetes-operator-system You should see output similar to the following: bash Copy NAME READY STATUS RESTARTS AGE newrelic-kubernetes-operator-controller-manager-7b9c64f58crwg9j 2/2 Running 0 157m If your output is similar to the example shown, you’re ready for the next step. If you don’t see a pod named newrelic-kubernetes-operator-controller-manager-<hash>, double check your Kubernetes configuration to ensure you’re within the correct context and pointing to the correct cluster. Step 2 of 3 Creating your first alert policy To kick things off, start small. First, create an alert policy with the minimum required configuration, then add a NRQL alert condition to the policy, which will add the condition to the policy in New Relic. A minimal alert policy configuration is represented in the code below. For the sake of this walkthrough, name this file new_relic_alert_policy.yaml. Note: For help locating your user key, check out New Relic's user key documentation. apiVersion: nr.k8s.newrelic.com/v1 kind: AlertsPolicy metadata: name: my-policy spec: account_id: <your New Relic account ID> api_key: <your New Relic user key> name: 'Alert Policy Created With k8s' # Feel free to rename region: 'us' Copy Now run the kubectl apply command to create your alert policy. bash Copy $ kubectl apply -f ./new_relic_alert_policy.yaml You'll see output that reads similar to the following: bash Copy alertspolicy.nr.k8s.newrelic.com/my-policy created Confirm that your alert policy was created by viewing your policies at alerts.newrelic.com/accounts/{your account ID}/policies. You can search for your new policy by its name. In this case, search for \"Alert Policy Created With k8s.\" You should see your new alert policy. Next it’s time to add a NRQL alert condition to the policy using the same configuration file. Step 3 of 3 Add NRQL alert conditions to your alert policy In the previous section you created an alert policy; now, you’ll add some alert conditions to the policy so you can trigger alerts when certain metrics are out of line. In your new_relic_alert_policy.yaml file, add a NRQL alert condition to the policy that will alert you when an application's average overall response time is above five seconds for a three minute period. Note: To receive notifications when an alert is triggered, add notification channels to your alert policy, with this code. # The policy from the previous steps apiVersion: nr.k8s.newrelic.com/v1 kind: AlertsPolicy metadata: name: my-policy spec: account_id: <your New Relic account ID> api_key: <your New Relic user key> name: 'Alert Policy Created With k8s' # Feel free to rename region: 'us' # Add a NRQL alert condition to the policy conditions: - spec: type: 'NRQL' name: 'NRQL Alert Condition Created With k8s' nrql: query: \"SELECT average(duration) FROM Transaction WHERE appName = 'YOUR APP NAME'\" evaluationOffset: 3 enabled: true terms: - threshold: '5' threshold_occurrences: 'ALL' threshold_duration: 180 priority: 'CRITICAL' operator: 'ABOVE' violationTimeLimit: 'ONE_HOUR' valueFunction: 'SINGLE_VALUE' Copy With the alert condition added to the configuration, you can apply the update, which will create a NRQL alert condition and add it to your policy. bash Copy $ kubectl apply -f ./new_relic_alert_policy.yaml To confirm that the NRQL alert condition was created successfully, refresh your alert policy. If you see a new alert condition added to the alert policy, it was a success. To finish things off, you'll create and add an alert channel to your alert policy. For example, maybe you want to send an email out to your team when your alert condition is triggered. Try it out now We have a Kubernetes test cluster ready for you in 2 minutes. By following this on-line tutorial, you will learn how to: Deploy the New Relic agent in a Kubernetes environment Use the New Relic Kubernetes operator Some tips to use the on-line tutorial window: Accept the cookies, so you can see the menu bar. Click anywhere in the tutorial window to start. It will take about 2 minutes for your environment to be ready. Press CTRL-l or type clear to clear the terminal window Click on the finish flag icon in the bottom menu to hide or show the instructions Good luck! Important Some browsers automatically disable the use of iframes. If the module isn't loading please check your browser settings. Your browser does not support iframes. What’s next? Nice work — now you can manage your New Relic alert policies and NRQL alert conditions with code that integrates seamlessly within your Kubernetes workflow. This provides the ability to configure and manage your alerts with a domain-specific pattern, providing consistency and maintainability. You also gain the benefits of code reviews for any potential changes moving forward. As you and your team move forward, you might need to adjust some of the configuration values to better fit your needs. The New Relic Kubernetes Operator is just one of several tools in the New Relic Developer Toolkit aimed at facilitating observability as code.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.93842,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>NRQL</em> <em>alert</em> <em>conditions</em> to your <em>alert</em> policy",
        "body": " with the official New Relic <em>Kubernetes</em> <em>operator</em>. More specifically, you&#x27;ll provision an <em>alert</em> policy with <em>NRQL</em> <em>conditions</em> in your New Relic account using <em>Kubernetes</em>. Before you begin This walkthrough assumes you’ve already deployed a <em>Kubernetes</em> cluster. You could even create a local cluster on your machine"
      },
      "id": "606677c064441fbf70617a9a"
    },
    {
      "sections": [
        "Create NRQL alert conditions",
        "Tip",
        "Create a NRQL alert condition",
        "NRQL alert syntax",
        "Important",
        "Reformatting incompatible NRQL",
        "NRQL alert threshold examples",
        "Alert on specific segments of your data",
        "Alert on Nth percentile of your data",
        "Alert on max, min, avg of your data",
        "Alert on a percentage of your data",
        "Alert on Apdex with any T-value",
        "Alert conditions and query order of operations",
        "Example: null value returned",
        "Example: zero value returned",
        "Nested aggregation NRQL alerts",
        "Nested queries with a non-faceted innermost query are not currently supported",
        "Queries at all levels must have the same aggregation window size",
        "Signal loss is not yet supported for nested queries",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps"
      ],
      "title": "Create NRQL alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "2872f770a5fc8a802f99b9f848906f7e351ad761",
      "image": "https://docs.newrelic.com/static/eb8e1b2d826f9fd9cf46fe3dd5455217/c1b63/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/",
      "published_at": "2021-04-12T02:14:25Z",
      "updated_at": "2021-04-06T05:25:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. Tip For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Copy Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount Tip If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions, but not baseline or static Include an optional FACET clause in your NRQL syntax depending on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. Important If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. Reformatting incompatible NRQL Some elements of NRQL used in charts don’t make sense in the streaming context of alerts. Here’s a list of the most common incompatible elements and suggestions for reformatting a NRQL alert query to achieve the same effect. Element Notes SINCE and UNTIL Example: SELECT percentile(largestContentfulPaint, 75) FROM PageViewTiming WHERE (appId = 837807) SINCE yesterday Copy NRQL Alerting produces a never-ending stream of windowed query results, so the SINCE and UNTIL keywords to scope the query to a point in time are not compatible. As a convenience, we automatically strip SINCE and UNTIL from a query when creating a NRQL Alert Condition from the context of a chart. TIMESERIES In NRQL queries, the TIMESERIES clause is used to return data as a time series broken out by a specified period of time. For NRQL alerts, the equivalent property of a signal is the aggregation window. histogram() The histogram() aggregation function is used to generate histograms. histogram() is not compatible with NRQL alerting: histogram aggregations can not be formatted as a time series. To create an alert from a portion of a histogram (e.g. 95th percentile), use the percentile() aggregation function. Multiple Aggregation Functions Each alert condition can only target a single aggregated stream of data. To alert on multiple streams simultaneously, you’ll need to decompose them into individual conditions within the same policy. Original Query: SELECT count(foo), average(bar), max(baz) from Transaction Copy Decomposed: SELECT count(foo) from Transaction SELECT average(bar) from Transaction SELECT max(baz) from Transaction Copy COMPARE WITH The COMPARE WITH clause is used to compare the values for two different time ranges. This type of query is incompatible with NRQL alerting. We recommend using a Baseline Alert Condition to dynamically detect deviations for a particular signal. SLIDE BY The SLIDE BY clause supports a feature known as sliding windows. With sliding windows, SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. Sliding windows are not currently supported in NRQL alerts. LIMIT In NRQL queries, the LIMIT clause is used to control the amount of data a query returns, either the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. LIMIT is not compatible with NRQL alerting: evaluation is always performed on the full result set. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) Copy SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Copy Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction Copy SELECT percentile(databaseDuration, 75) FROM Transaction Copy Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction Copy SELECT average(duration) FROM Transaction Copy Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction Copy SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Copy Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Copy Alert conditions and query order of operations By default, the aggregation window is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, New Relic will collect data for that window using the function in the NRQL alert condition’s query. The query is parsed and executed by our systems in the following order: FROM clause – which event type needs to be grabbed? WHERE clause – what can be filtered out? SELECT clause – what information needs to be returned from the now-filtered data set? Example: null value returned Let's say this is your alert condition query: SELECT count(*) FROM SyntheticCheck WHERE monitorName = 'My Cool Monitor' AND result = 'FAILURE' Copy If there are no failures for the aggregation window: The system will execute the FROM clause by grabbing all SyntheticCheck events on your account. Then it will execute the WHERE clause to filter through those events by looking only for the ones that match the monitor name and result specified. If there are still events left to scan through after completing the FROM and WHERE operations, the SELECT clause will be executed. If there are no remainig events, the SELECT clause will not be executed. This means that aggregators like count() and uniqueCount() will never return a zero value. When there is a count of 0, the SELECT clause is ignored and no data is returned, resulting in a value of NULL. Example: zero value returned If you have a data source delivering legitimate numeric zeroes, the query will return zero values and not null values. Let's say this is your alert condition query, and that MyCoolEvent is an attribute that can sometimes return a zero value. SELECT average(MyCoolAttribute) FROM MyCoolEvent Copy If, in the aggregation window being evaluated, there's at least one instance of MyCoolEvent and if the average value of all MyCoolAttribute attributes from that window is equal to zero, then a 0 value will be returned. If there are no MyCoolEvent events during that minute, then a NULL will be returned due to the order of operations. Tip For more information about this topic, you can check out our blog post on troubleshooting for zero versus null values. Tip You can determine how null values will be handled by adjusting loss of signal and gap filling settings in the Alert Conditions UI. Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ​​​​​ Copy Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)​​ Copy Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. Tip To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you can't use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Important Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Tip Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Tip Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. Important When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.37096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "sections": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alert</em> <em>conditions</em>",
        "body": "You can use <em>NRQL</em> queries to create <em>alert</em> <em>conditions</em>. Once you&#x27;ve defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts &amp; AI"
      },
      "id": "603ef04864441fbc114e8883"
    },
    {
      "sections": [
        "Recommended ECS alert conditions",
        "Recommended alert conditions"
      ],
      "title": "Recommended ECS alert conditions",
      "type": "docs",
      "tags": [
        "Integrations",
        "Elastic Container Service integration",
        "Understand use data"
      ],
      "external_id": "334d80a75b3ef0a7b6125bf2a15f643ea46d7282",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/elastic-container-service-integration/understand-use-data/ecs-integration-recommended-alert-conditions/",
      "published_at": "2021-04-12T17:19:58Z",
      "updated_at": "2021-03-16T05:41:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's ECS integration reports and displays performance data from your Amazon ECS environment. This document provides some recommended alert conditions for monitoring ECS performance. Recommended alert conditions Here are some recommended ECS alert conditions. To add these alerts, go to the Alerts UI and add the following NRQL alert conditions to an existing or new alert policy: High CPU usage NRQL: FROM ContainerSample SELECT cpuUsed / cpuLimitCores Critical: > 90% for 5 minutes High memory usage NRQL: FROM ContainerSample SELECT memoryUsageBytes / memorySizeLimitBytes Critical: > 80% for 5 minutes Restart count NRQL: FROM ContainerSample SELECT max(restartCount) - min(restartCount) Critical: > 5 for 5 minutes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.23421,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "sections": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "body": " to the Alerts UI and add the following <em>NRQL</em> <em>alert</em> <em>conditions</em> to an existing or new <em>alert</em> policy: High CPU usage <em>NRQL</em>: FROM ContainerSample SELECT cpuUsed &#x2F; cpuLimitCores Critical: &gt; 90% for 5 minutes High memory usage <em>NRQL</em>: FROM ContainerSample SELECT memoryUsageBytes &#x2F; memorySizeLimitBytes Critical: &gt; 80% for 5 minutes Restart count <em>NRQL</em>: FROM ContainerSample SELECT max(restartCount) - min(restartCount) Critical: &gt; 5 for 5 minutes"
      },
      "id": "603e7eee64441f0f674e889f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/eric_mittelhammer-2-150x150.jpeg?h=cc872d96&itok=5zbAjVGy",
      "url": "https://newrelic.com/blog/how-to-relic/best-practices-new-relic-alert-conditions",
      "sections": [
        "Configuring alert conditions for Browser applications",
        "Configuring alert conditions for APM applications",
        "Configuring alert conditions for Infrastructure hosts",
        "Related Topics"
      ],
      "published_at": "2021-04-14T00:09:47Z",
      "title": "Best Practices for Getting Started With New Relic Alert Conditions",
      "updated_at": "2021-04-14T00:09:47Z",
      "type": "",
      "external_id": "bbbb86104aba47986f3a0c5bc6ab7968f05c80ae",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Best Practices for Getting Started With New Relic Alert Conditions Jan 13, 2020 • 6 min read By Eric Mittelhammer For successful DevOps teams, alerting is an indispensable practice. You can’t possibly watch every service in your application every second of every day, yet you must be ready to take action immediately, should any service hit a snag. With New Relic Alerts, you can ensure that the right members of your team get the alerts they need as quickly as possible. If a monitored application, host, or other entity triggers a predefined alert condition, New Relic Alerts notifies you automatically. At the same time, though, your team needs to minimize alert fatigue, which too often leads to mistakes and miscommunication in your incident-response process. With New Relic Alerts, you can easily manage alert policies and conditions that focus on key metrics, while filtering out expected behavior. To help you get started, we created a list of suggestions, based on best practices from the field, for setting alert conditions for apps instrumented with New Relic Browser and New Relic APM, and for hosts monitored with New Relic Infrastructure. These suggestions serve as a great starting point for teams looking to get up and running with New Relic Alerts, or for teams looking to improve their workflows. Note: This post covers alert conditions only. You should create alert policies based on how your organization is structured and on your incident response workflow. In some cases, you might have an alert policy that contains a condition that spans your entire New Relic account. In other circumstances, you’ll have to scope the condition to one or more apps or hosts. Similarly, if you’re a mature DevOps team, you may be grouping conditions for Browser, APM, and Infrastructure into the same policy, segmented by app or product. More traditionally structured teams may want to separate Infrastructure, APM, and Browser conditions into different policies. If you’re not already familiar with New Relic Alerts, be sure to review the following before getting started: The Alerts documentation (including NRQL Alert Conditions, Baseline Alerts, and Outlier Detection) Getting Started with New Relic Alerts: Best Practices That Set You Up for Success You should also be familiar with these two terms: Thresholds: These are alert condition settings that define what is considered a violation. Threshold values include the value that a data source must pass to trigger a violation and the time-related settings that define a violation; for example: An application’s average web response time is greater than 5 seconds for 15 minutes. An application’s error rate per minute hits 10% or higher at least once in an hour. An application’s AJAX response time deviates a certain amount from its expected baseline behavior. For more information, see the New Relic documentation for setting thresholds for alert conditions. Baselines: You can use baseline alert conditions to define thresholds that adjust to the behavior of your data. Baselines are useful for creating alert conditions that: Notify you only when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. Work well out-of-the-box for new applications with as-yet-unknown behaviors. For more information, see the New Relic documentation for creating baseline alert conditions. Configuring alert conditions for Browser applications Use the following examples as best practices for getting started with alert conditions for frontend applications you’re monitoring with New Relic Browser. Condition Usage Threshold condition on Pageview load time Triggers an alert if page load times spike over the accepted threshold. Baseline condition on Pageview throughput Triggers an alert for sudden traffic drops or spikes only. (Baseline conditions reduce noise by accounting for expected traffic fluctuations.) Threshold conditions on JavaScript errors Triggers alerts when JavaScript errors appear in browser applications. Baseline throughput conditions on AJAX request response time Triggers alerts when AJAX requests that contact your backend services affect network latency. Baseline throughput conditions on key Page actions (e.g., button clicks) Triggers alerts for user behavior changes that don’t set off other alerts; for example, if a CSS change moves the \"checkout\" button off the viewable screen, it won't cause a spike in errors or response times but will affect customer experience. Configuring alert conditions for APM applications Use the following examples as best practice for getting started with alert conditions for applications you’ve instrumented with New Relic APM. [table id=37 /] Configuring alert conditions for Infrastructure hosts Use the following examples as best practice for getting started with alert conditions for hosts you’re monitoring with New Relic Infrastructure. [table id=38 /] Next steps: An alerting strategy, when effectively implemented, is one of the most important parts of any successful DevOps team. Check out Effective Alerting In Practice to learn: How shifts in modern technology stacks are leading to changes in alerting strategies Some alerting best practices for dynamic and scaled environments How to design and maintain an alerting system useful to your organization and teams Related Topics APM By Eric Mittelhammer As a Solution Consultant, Eric helps New Relic's customers maximize the value they get from the platform via strategic guidance and thought leadership. Before joining New Relic, he spent nearly two decades building software in individual contributor and leadership roles. Eric is a DevOps zealot, and the fact that you're not deploying as frequently as you could be keeps him up at night. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.09012,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Best Practices for Getting Started With New Relic <em>Alert</em> <em>Conditions</em>",
        "sections": "Configuring <em>alert</em> <em>conditions</em> for Browser applications",
        "body": " with New Relic Alerts, be sure to review the following before getting started: The Alerts documentation (including <em>NRQL</em> <em>Alert</em> <em>Conditions</em>, Baseline Alerts, and Outlier Detection) Getting Started with New Relic Alerts: Best Practices That Set You Up for Success You should also be familiar with these two"
      },
      "id": "607632cbe7b9d2749ba5c62b"
    }
  ],
  "/automate-workflows/diagnose-problems": [
    {
      "sections": [
        "データエクスプローラーの概要",
        "ヒント",
        "重要な理由",
        "データのクエリ",
        "データエクスプローラーを使用する",
        "イベントを詳しく調べる",
        "メトリックスを詳しく調べる",
        "重要",
        "調査を可視化し絞り込む",
        "クエリエリア",
        "NRQLクエリ表示",
        "チャートエリア",
        "共有してエクスポート",
        "使用事例",
        "新規データを確認",
        "データを検証",
        "データの問題のトラブルシューティング",
        "その他のヘルプ"
      ],
      "title": "データエクスプローラーの概要",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "94545f74e5fd5ab0b18f47342f7a8f2a2fa82558",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-12T03:13:32Z",
      "updated_at": "2021-04-12T03:13:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データエクスプローラーを使用すれば、NRQLの知識がなくても、すべてのデータを視覚的に操作できます。データエクスプローラーを使用してデータにアクセスしクエリやカスタマイズ、視覚化を行い、サービスとサービスをつなぎ、一貫したキュレート済みの体験を実現します。 ヒント データエクスプローラー、およびその他のオブザーバビリティ プラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 システムの状態を調査しますか？リソースの計画を作成し、インシデントを特定しそれに対応し、動作不良のトラブルシューティングを行う必要がありますか？データエクスプローラーにより、NRQLを使用したりクエリを構築せずに、視覚的なメニューを通じて、探しているデータを簡単に特定、取得し、視覚化できます。 データエクスプローラーを使用して、次のことを行えます。 イベントやメトリックスデータに、迅速で直感的な方法でアクセスする。 視覚化し簡単に実行できるようにして、データのディメンションを詳しく調べる。 さまざまな観点からデータを把握する：生データや、進歩や配信などについての知見を提供するさまざまな視覚化。 フィルターによりデータを掘り下げる。 1回のクリックで検索をダッシュボードに追加する。 NRQLのしくみについて理解する: データエクスプローラーは、利用可能なデータを検索している間にクエリがどのように構築されるかを示します。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 データのクエリ データエクスプローラーにアクセスするには、one.newrelic.comに移動し ページの上部にあるデータをクエリアイコンをクリックします。 データのブラウズドロップダウンで、イベントまたはメトリクスを選択します。 データエクスプローラーは、New Relicにあるすべてのデータを詳しく調べるためのポータルです。データエクスプローラーUIにあるイベントやメトリックスを詳しく調べたり、LogsやTracesアプリを選択して詳しく調べることができます。また、タブをクリックして、いつでもクエリビルダーにアクセスすることもできます。 データエクスプローラーを使用する データエクスプローラーは、上部にある範囲絞り込みセクション（a）、左側のデータブラウジングエリア（b）、ワークスペース（c）で構成されます。 データエクスプローラーを使用するには： 調べる範囲を定義する：ブラウズするアカウントとデータタイプ（メトリックまたはイベント）を選択します。 タイムピッカーを使用して時間範囲を選択します。 左側のブロックを使用して、イベントかメトリックスのいずれかについて使用可能なデータをブラウズし、検索を作成します。1ブロックにつき1つの要素しか選択できません。ブロックは検索可能です。 イベントを詳しく調べる イベントタイプ 選択したアカウントで使用できるすべてのイベントを表示します。 デフォルトでは、イベントは名前で並び替えられます。 プロット 以前選択したイベントのすべての数字属性を表示します。 リストの最初の項目はcount( * )で、これは属性ではありません。選択したイベントの数を計算します。 デフォルトでは、属性は名前で並び替えられます。 プロットする関数を選択します。デフォルトでは、各属性は関数Averageに設定されます。 ディメンション 以前選択したイベントとプロットのすべてのディメンションを表示します。 ディメンションは、イベントについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 メトリックスを詳しく調べる APM 時間区切りデータを調べるには、AppID、AppName、またはEntityGuidをステップとして選択します（またはそれらのステップでグループ化します）。それ以外の場合は、すべてのエンティティの集計データを取得します。 メトリック 選択したアカウントで使用できるすべてのメトリックスを表示します。 デフォルトでは、メトリックスは名前で並べ替えられます。 ディメンション 以前選択したメトリックのすべてのディメンションを表示します。 ディメンションは、メトリックについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 重要 ユニットの表示には、メトリックシステム（メトリックSIプレフィックスを含む）が使用されています。 調査を可視化し絞り込む 調査の結果は、右側のワーキングスペースに表示されます。 調査を絞り込むか、チャートを共有する ワーキングスペースには、次のものが表示されます。 クエリエリア クエリエリアでは、クエリを異なる構成要素に分解します。ここで、NRQLクエリとして調査の結果を簡単に読み、プロットしている正確なデータをチェックできます。 NRQLに習熟していない場合、このエリアをチェックしクエリの作成方法について学習します。 クエリの別の部分は次のとおりです。 [ イベントのみ]FROM: 最初のブロックで選択したイベント。 SELECT: 選択したプロットまたはメトリック。この入力では、1つの値と1つの関数のみをプロットします。 GROUP BY: FACET句を表し、選択したディメンションごとにデータをグループ化します。 LIMIT: 表示する値の量を入力します。 WHERE: このフィールドを使用して、結果にさらにフィルターを適用します。この入力では、n値をプロットします。 各項目は、xをクリックしてクエリから削除できます。 NRQLクエリ表示 上記のフィールドと、タイムピッカーで選択した時間範囲で構成される、完全なクエリを表示できます。 ヒント より詳細な検索を行う、またはチャートをカスタマイズする必要がある場合データエクスプローラーから、クエリビルダーにアクセスしてクエリを編集できます。 チャートエリア デフォルトでは、データは線チャートで表示されます。チャートピッカーを使用して、面グラフ、円グラフ、およびバーチャートに簡単に切り替えることができます。結果の生データをテーブルまたはJSON形式として表示することもできます。 ディメンションを選択している場合、チャートは異なるファセットで更新されます。チャートの下に、ファセットのリストとそれぞれの値があるファセットの表が表示されます。 ファセットテーブルを使用して、データをドリルダウンします。クリックしたファセットはフィルターとして適用されます。表は表示されたままなので、別のファセットを簡単に選択して調査を続けることができます。 共有してエクスポート 右上にあるオプションメニューを使用して、チャートを画像として取得、またはリンクとして共有、ダッシュボードに追加できます。 また、URLをコピーし、その他のNew Relicユーザーと調査全体を共有することもできます。 使用事例 次の例で、データエクスプローラーをいつどのように使用するかについて学習してください。 新規データを確認 新規インストゥルメンテーションに接続したばかりで、新規データを利用できるかどうか確認したいと思っています。 アカウントとイベント、または新規データを生成しているメトリックを選択します。 データエクスプローラーで別のツールを使用して、利用できるようになった新規データを使ってみる：そのイベントまたはメトリックの生データを表として見る、またはリストとする、またはクリックしてチャートとしてプロットされることを確認します。 イベントやメトリックを選択した後、ディメンションでデータの形状を確認します。濃度を使用して、あらゆるデータの異なる視点を確認できます。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 データを検証 カスタムイベント/メトリックを変更したので、この変更が正常に行われたかどうかをチェックする必要がある。 データエクスプローラータブで、変更したアカウントとデータタイプ、イベント/メトリックを選択します。 エンティティがデータをレポートしていることと、すべての属性がプロットされていることを確認します。 変更した属性を検索し、更新が正常に行われたことをチェックします。 データの問題のトラブルシューティング アラートやダッシュボードからのイベント/メトリックで何か問題があることが分かっている。イベント/メトリック属性の動作について、根本原因を知る必要がある。 データエクスプローラーで、メニューを使用して、想定どおりに動作していないイベントやメトリックを選択し、データエクスプローラーでそのチャートをプロットします。 そこから、そのデータのディメンションを掘り下げて、関連する属性によりフィルターを適用できます。 また、次のような異なる観点からそのデータを把握することもできます：分布や値の順位、経時進化。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.946205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "605343b4196a6754132d166e"
    },
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.1237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.1237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053433228ccbcdc10c2fd60"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Tip",
        "Why it matters",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "8f390d6aa6f57d215b3c23f8cf08c02ef310bddc",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-12T03:13:31Z",
      "updated_at": "2021-03-16T11:03:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Tip To use the data explorer and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces apps to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From data explorer you can access query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 49.987743,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": " icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs and Traces apps to <em>explore</em> those. You can also access the query builder any time"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Data explorer: Query and chart event data",
        "Important",
        "Events vs metrics",
        "UI components",
        "Data samples",
        "Caution"
      ],
      "title": "Data explorer: Query and chart event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Explore data"
      ],
      "external_id": "72a23b59b41a3cb521c184c24603d50c28cffdb1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/data-explorer-query-chart-event-data/",
      "published_at": "2021-04-11T15:45:15Z",
      "updated_at": "2021-03-30T08:43:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you explore the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs metrics In New Relic Insights, the Data explorer page has two tabs: Events: In the context of the Insights UI, this refers to any data that can be queried via NRQL. This includes all our major data types, including events and the Metric, Log, and Span data types. Metrics: In the context of the Insights UI, this refers to metric timeslice data. (Note that metric timeslice data is available for querying with NRQL in New Relic One.) For an improved querying and charting experience, we recommend using New Relic One chart builder and dashboards. UI components Use the Events data explorer to view and explore the data available to you. The UI includes: A dropdown that lets you select a data type, like PageView or Transaction. A time-based chart for that data. A sample of that data type, showing its attached attributes, and the ability to see other samples. Ability to search by group by and search for specific attributes. Data samples The most recent sample for the chosen data type is listed at the bottom of the page. Default attributes are underlined. To see more samples, select See more samples. You may need to scroll left and right to see the full table of data. Caution The amount of data stored for a given event type can run into the hundreds of thousands, or even millions, of records. This report only shows a small sample. Use this UI to review the structure of the data, not the contents of a specific record. For example, you can use it to make sure an attribute is populating properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 46.584587,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data <em>explorer</em>: Query and chart event data",
        "sections": "Data <em>explorer</em>: Query and chart event data",
        "tags": "<em>Explore</em> data",
        "body": " our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you <em>explore</em> the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs"
      },
      "id": "6043efa0e7b9d2b78d5799d2"
    }
  ],
  "/automate-workflows/get-started-terraform": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-14T00:08:56Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 416.09814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Step 3: Provision <em>alert</em> conditions based on the four <em>golden</em> <em>signals</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four <em>golden</em> <em>signals</em> of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "70555c1d24e8e54b46763d57010901e206ef2ccb",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.26465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6066782e64441f3610617ac3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-13T01:55:31Z",
      "title": "",
      "updated_at": "2021-04-01T01:51:55Z",
      "type": "",
      "external_id": "5e43fb43faa36807fc9f1eb660748303373fa8dd",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.60464,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6065273be7b9d2336c944613"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/proactive_detection6-1024x765.png",
      "url": "https://newrelic.com/blog/nerdlog/new-capabilities-proactive-detection",
      "sections": [
        "Automatic analysis of every anomaly",
        "See all anomalies in a single view",
        "Alert, query, and leverage the power of anomalies in NRDB",
        "The full power of New Relic AI: anomalies integrated into Incident Intelligence",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:31:44Z",
      "title": "Enhancing New Relic AI With New Capabilities For Proactive Detection",
      "updated_at": "2021-04-13T23:31:44Z",
      "type": "",
      "external_id": "47801e8f396395e32a3da28b34d08b92af08bacb",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit AIOps Enhancing New Relic AI With New Capabilities For Proactive Detection May 4, 2020 • 6 min read By Annette Sheppard The rate of change within your software is faster than ever, and with this pace comes the risk that your team may miss issues, or lose critical time trying to diagnose the causes of errors. Proactive Detection, an essential part of our recently released AIOps solution, New Relic AI, helps DevOps teams avoid such problems and drive faster mean time to resolution (MTTR) by proactively detecting and analyzing anomalies using data from New Relic APM. Whether it’s alerts you didn’t know you needed to set up or dependent systems you may not even own, New Relic AI Proactive Detection surfaces and analyzes anomalies, bringing attention to potential problems before they become bigger issues—all within your team’s existing incident response workflows. Easy to set up, Proactive Detection simply needs a configuration name and a list of the applications to be monitored to begin discovering and analyzing anomalies in your system. Today we’re announcing four key enhancements to Proactive Detection: An in-depth analysis of each anomaly via the Analysis page A complete list of all anomalies in your environment with the Anomaly overview Integration with the New Relic Database (NRDB), so you can create dashboards and alerts based on anomaly data Integration with New Relic AI Incident Intelligence—via NRQL alerts—for deeper context into incidents Automatic analysis of every anomaly Not only does Proactive Detection flag and notify you of anomalies in your system, it also analyzes each anomaly to help you speed troubleshooting. The Analyze page automatically surfaces queries and context to help explain the cause of an anomaly. Each Proactive Detection notification delivered in Slack provides a link to the Analyze page, allowing you to easily investigate an anomaly or switch between anomalies as you dive deeper into issues. Anomalies delivered to your team via Slack quickly link to the Analyze page for deeper analysis The Analyze page provides an overview of the anomaly itself, as well as details and recent activity for an entity. When available, Proactive Detection automatically suggests attributes that help explain the cause of the anomaly and provide paths for further troubleshooting, as shown in the Key Attributes section: The three key attributes surrounding an error spike are visualized to provide you with multiple paths for troubleshooting. Proactive Detection uses APM event data to suggest queries that explain the anomaly, based either on statistical differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “golden signals” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream or downstream of the initial anomaly. Sparklines include anomalies related to the SRE “golden signals” and additional anomalies in related upstream or downstream applications All of this gives your team a holistic view of the events leading up to the anomaly, helping you better identify what is happening in your application and environment. See all anomalies in a single view The Analyze page provides the context surrounding one anomaly, but the Anomaly overview page gives you a broader view of what's happening in your environment. You’ll have a full view of all detected anomalies, with the ability to instantly view more details for each one. If you want to dive in and learn even more about a specific anomaly, simply use the Analyze link. The Anomaly overview page gives you an overview of all anomalies detected in your environment. Alert, query, and leverage the power of anomalies in NRDB Since all anomalies are automatically written to the NRDB, you can use anomaly data to build dashboards, or create alerts. Query any Proactive Detection event from any configured application. For example, use Proactive Detection data in NRQL alerts to notify you when clusters of anomalies occur. Any anomaly can be plotted in a dashboard to discover trends and patterns. You can even build your dashboards to show anomalous events that are relevant to the specific applications you’re monitoring for anomalies in Proactive Detection. Be notified when clusters of anomalies occur. The full power of New Relic AI: anomalies integrated into Incident Intelligence Proactive Detection and Incident Intelligence are New Relic AI’s critical set of capabilities that help teams detect issues early, eliminate alert noise, and drive toward even faster MTTR. Incident Intelligence uses AI and machine learning (ML) to suppress alerts you don’t care about and correlate related incidents and events into single issues, without excessive configuration, training, or onboarding. Stronger together, you can now link anomalies detected with Proactive Detection to Incident Intelligence—via NRQL alerts—to receive enhanced context inside of your Incident Intelligence to gain the full power of New Relic AI. New Relic AI Proactive Detection has a free tier that you can start using today: If you’re new to New Relic, sign up for your free account. Already using New Relic? Get started with Proactive Detection in under 10 minutes by visiting http://one.newrelic.com > New Relic AI > Proactive Detection. Interested in learning more about New Relic AI, check out these resources: Accelerate Incident Response with AIOps: An introduction to AIOps best practices with New Relic AI (eBook) Accelerate Incident Response with AIOps (Webinar) New Relic AI documentation Request a demo   Related Topics AIOps By Annette Sheppard Annette Sheppard is a Senior Product Marketing Manager at New Relic. She is focused on AIOps and is always looking to learn something new. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.16675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Alert</em>, query, and leverage the power of anomalies in NRDB",
        "body": " differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “<em>golden</em> <em>signals</em>” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream"
      },
      "id": "607629e028ccbc02d751c161"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/correlation-assistant.png",
      "url": "https://newrelic.com/blog/how-to-relic/aiops-applied-intelligence",
      "sections": [
        "Detect unusual changes instantly",
        "Cut down on alert noise",
        "Get to the root cause quickly",
        "Respond to incidents faster",
        "How to get started with AIOps",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:16:12Z",
      "title": "Get Ready for Next Gen AIOps to Detect, Understand, and Resolve Problems Faster Than Ever",
      "updated_at": "2021-04-13T23:14:25Z",
      "type": "",
      "external_id": "788beb576c7d9e3116b0d78526be3ee4b4020a3f",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit AIOps Get Ready for Next Gen AIOps to Detect, Understand, and Resolve Problems Faster Than Ever Mar 17, 2021 • 8 min read By Guy Fighel Despite the hype, many DevOps and SRE teams have struggled to make the promise of AIOps a reality. Steep learning curves, long implementation and training times, prohibitive pricing, and a lack of confidence in artificial intelligence (AI) and machine learning (ML) have stood in the way. When we dig into the challenges faced by pager-carrying, on-call engineers, they consistently mention three things that stand in the way of keeping services up and running: Discovering emerging problems and unknowns when you're dependent on alerts or static dashboards to know what's changing is hard. It’s not easy to triage incidents and know how to respond when a cascading failure happens with alerts firing across multiple tools. It’s difficult and time-consuming to diagnose the root causes of problems when you have to manually sift through dashboards to understand why the problem occurred and what's impacted. In short, engineers can no longer afford expensive war rooms and guesswork to troubleshoot incidents, or worse, find out about them from customers. That all changes today with the launch of our next generation of New Relic Applied Intelligence, which makes it easier than ever to: Detect unusual changes instantly: You’ll be able to automatically spot anomalies across your applications, services, and logs to prevent potential problems before they impact customers. Cut down on alert noise: You can reduce the flood of noisy alerts and prioritize issues more easily by grouping alerts and events from any source into a single correlated, actionable issue. Get to root cause quickly: You’ll be able to eliminate guesswork and solve problems faster with automatic insights into the probable root cause of every issue. Respond to incidents faster. You can integrate New Relic Applied Intelligence with ITSM tools and eliminate the toil of managing incidents across tools by keeping everything in sync. Let’s dig into what’s new and now available in Applied Intelligence. Detect unusual changes instantly Continuous, automatic anomaly detection now at no additional cost Applied Intelligence automatically spots anomalies based on golden signals like throughput, errors, and latency across all applications and services—and it’s now automatically enabled for all your instrumented apps and services without configuration and at no additional cost. When it detects anomalies, it will immediately notify you via Slack and other collaboration tools, and give you a real-time feed of every anomaly and in-depth analytics to troubleshoot faster and prevent potential problems from impacting customers.     Log patterns Applied Intelligence now includes a new capability that uses machine learning to detect patterns and surface outliers in your log data, helping you reduce troubleshooting time. You can explore millions of log messages with a single click and reduce manual querying because Log patterns automatically clusters your log data to help you quickly find anomalous patterns and problematic needles in the haystack. Log patterns is currently in public beta—if you’d like to turn it on for your New Relic account, reach out to your customer success manager.   Alerts analytics A new integrated landing page highlights insights and analytics about how your alert configurations are performing. Alerts recurring muting rules Define recurring schedules for muting rules for New Relic Alerts to get more control over alerts suppression during scheduled maintenance windows and periods of planned downtime. Set recurring daily, weekly, or monthly schedules for muting rules via the New Relic UI or API. Cut down on alert noise   Relationship-based correlation You can now correlate related alerts and events based on external relationship data from CMDBs and New Relic entity relationships. In addition to correlating alerts using time-based clustering and context from alert messages, you can now ingest topology data from your relationship datastores (CMDBs) to enable more accurate correlation of alerts that are firing from connected services. This gives you better context into incidents that occur and how they impact your broader environment so that you can prioritize problems more accurately and efficiently. Anomalies in correlated issues You can correlate proactively detected anomalies along with alerts and events from any source together to paint a complete picture of the issue at hand, reducing time to understand and act. Create correlation decisions faster with correlation assistant Did something not correlate that should have? Do you have an idea of how to correlate but aren’t sure where to start? With a new correlation assistant feature, you can simply begin selecting incidents that should be correlated and let New Relic analyze them to show you what they have in common. This gives you more control over how you reduce alert noise. In addition, Applied Intelligence is smart enough to simulate your configuration and shows you in real-time how correlating incidents can reduce alert noise and increase context in the future. Get to the root cause quickly See the probable root cause(s) of every issue Applied Intelligence gives you automatic insights into the probable root cause of every issue. You can quickly see why each open issue occurred, which deployments contributed, and relevant error logs and attributes to help you investigate the problem faster than ever. Applied Intelligence scans the distribution of every attribute within event data ingested, and surfaces possible causes by finding significant changes in the distribution. For example, for every transaction event generated, you can scan to see if a single user starts to take up an unusual share of the requests sent to your app. In addition, root cause analysis automatically classifies issues based on golden signals like errors, traffic, latency, and saturation so you can quickly orient yourself to why the problem occurred.   Understand the impact and scope of every issue You can see which entities (hosts, containers, applications) are affected to quickly and accurately assess the scope and determine what needs to be remediated. You can isolate the source of the problem with automatic insight into how services and components of your environment are impacted by every issue. Respond to incidents faster Two-way integration with ServiceNow for correlated issues Adding to our existing two-way integration with PagerDuty, you can now eliminate the toil of managing incidents across tools by syncing the state of correlated issues in Applied Intelligence with ServiceNow incidents bi-directionally. As the state of each correlated issue changes in either platform, it is now automatically updated in both tools. Applied Intelligence also supports a webhook for integrating with VictorOps, OpsGenie, and other tools of your choice. Suggested responders for New Relic alert violations Get automatic recommendations for individuals on your team who are best equipped to respond to an issue, either because they are experts in the component failing or have resolved similar issues before. This enhancement builds on our existing support for suggesting responders based on PagerDuty incident data, by suggesting responders for issues that originate from New Relic alert violations. Best of all, this feature is completely automatic and requires no configuration or model training—it just works out of the box as New Relic learns from the behaviors of responders on your team. How to get started with AIOps All New Relic Applied Intelligence customers have access to today’s new capabilities at no additional cost. If you’re interested in adding AIOps capabilities to your New Relic implementation, you can get started now by clicking the “Alerts & AI” link in your New Relic account. And if you’re new to New Relic but interested in digging in, experience the simplicity of New Relic One yourself by signing up for a forever free account, and check out New Relic Applied Intelligence.   Related Topics AIOps By Guy Fighel Guy Fighel is the General Manager of applied intelligence and Vice President of product engineering at New Relic. He leads New Relic’s AIOps product and engineering, and is responsible for the company’s overall artificial intelligence and machine learning strategy. Guy was the co-founder and chief technology officer of SignifAI, an event-intelligence company, which was acquired by New Relic in 2019. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.24168,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Cut down on <em>alert</em> noise",
        "body": " across your applications, services, and logs to prevent potential problems before they impact customers. Cut down on <em>alert</em> noise: You can reduce the flood of noisy <em>alerts</em> and prioritize issues more easily by grouping <em>alerts</em> and events from any source into a single correlated, actionable issue. Get"
      },
      "id": "607625d1196a67ad6b64a790"
    }
  ],
  "/automate-workflows/diagnose-problems/high-response-times": [
    {
      "sections": [
        "データエクスプローラーの概要",
        "ヒント",
        "重要な理由",
        "データのクエリ",
        "データエクスプローラーを使用する",
        "イベントを詳しく調べる",
        "メトリックスを詳しく調べる",
        "重要",
        "調査を可視化し絞り込む",
        "クエリエリア",
        "NRQLクエリ表示",
        "チャートエリア",
        "共有してエクスポート",
        "使用事例",
        "新規データを確認",
        "データを検証",
        "データの問題のトラブルシューティング",
        "その他のヘルプ"
      ],
      "title": "データエクスプローラーの概要",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "94545f74e5fd5ab0b18f47342f7a8f2a2fa82558",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-12T03:13:32Z",
      "updated_at": "2021-04-12T03:13:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データエクスプローラーを使用すれば、NRQLの知識がなくても、すべてのデータを視覚的に操作できます。データエクスプローラーを使用してデータにアクセスしクエリやカスタマイズ、視覚化を行い、サービスとサービスをつなぎ、一貫したキュレート済みの体験を実現します。 ヒント データエクスプローラー、およびその他のオブザーバビリティ プラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 システムの状態を調査しますか？リソースの計画を作成し、インシデントを特定しそれに対応し、動作不良のトラブルシューティングを行う必要がありますか？データエクスプローラーにより、NRQLを使用したりクエリを構築せずに、視覚的なメニューを通じて、探しているデータを簡単に特定、取得し、視覚化できます。 データエクスプローラーを使用して、次のことを行えます。 イベントやメトリックスデータに、迅速で直感的な方法でアクセスする。 視覚化し簡単に実行できるようにして、データのディメンションを詳しく調べる。 さまざまな観点からデータを把握する：生データや、進歩や配信などについての知見を提供するさまざまな視覚化。 フィルターによりデータを掘り下げる。 1回のクリックで検索をダッシュボードに追加する。 NRQLのしくみについて理解する: データエクスプローラーは、利用可能なデータを検索している間にクエリがどのように構築されるかを示します。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 データのクエリ データエクスプローラーにアクセスするには、one.newrelic.comに移動し ページの上部にあるデータをクエリアイコンをクリックします。 データのブラウズドロップダウンで、イベントまたはメトリクスを選択します。 データエクスプローラーは、New Relicにあるすべてのデータを詳しく調べるためのポータルです。データエクスプローラーUIにあるイベントやメトリックスを詳しく調べたり、LogsやTracesアプリを選択して詳しく調べることができます。また、タブをクリックして、いつでもクエリビルダーにアクセスすることもできます。 データエクスプローラーを使用する データエクスプローラーは、上部にある範囲絞り込みセクション（a）、左側のデータブラウジングエリア（b）、ワークスペース（c）で構成されます。 データエクスプローラーを使用するには： 調べる範囲を定義する：ブラウズするアカウントとデータタイプ（メトリックまたはイベント）を選択します。 タイムピッカーを使用して時間範囲を選択します。 左側のブロックを使用して、イベントかメトリックスのいずれかについて使用可能なデータをブラウズし、検索を作成します。1ブロックにつき1つの要素しか選択できません。ブロックは検索可能です。 イベントを詳しく調べる イベントタイプ 選択したアカウントで使用できるすべてのイベントを表示します。 デフォルトでは、イベントは名前で並び替えられます。 プロット 以前選択したイベントのすべての数字属性を表示します。 リストの最初の項目はcount( * )で、これは属性ではありません。選択したイベントの数を計算します。 デフォルトでは、属性は名前で並び替えられます。 プロットする関数を選択します。デフォルトでは、各属性は関数Averageに設定されます。 ディメンション 以前選択したイベントとプロットのすべてのディメンションを表示します。 ディメンションは、イベントについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 メトリックスを詳しく調べる APM 時間区切りデータを調べるには、AppID、AppName、またはEntityGuidをステップとして選択します（またはそれらのステップでグループ化します）。それ以外の場合は、すべてのエンティティの集計データを取得します。 メトリック 選択したアカウントで使用できるすべてのメトリックスを表示します。 デフォルトでは、メトリックスは名前で並べ替えられます。 ディメンション 以前選択したメトリックのすべてのディメンションを表示します。 ディメンションは、メトリックについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 重要 ユニットの表示には、メトリックシステム（メトリックSIプレフィックスを含む）が使用されています。 調査を可視化し絞り込む 調査の結果は、右側のワーキングスペースに表示されます。 調査を絞り込むか、チャートを共有する ワーキングスペースには、次のものが表示されます。 クエリエリア クエリエリアでは、クエリを異なる構成要素に分解します。ここで、NRQLクエリとして調査の結果を簡単に読み、プロットしている正確なデータをチェックできます。 NRQLに習熟していない場合、このエリアをチェックしクエリの作成方法について学習します。 クエリの別の部分は次のとおりです。 [ イベントのみ]FROM: 最初のブロックで選択したイベント。 SELECT: 選択したプロットまたはメトリック。この入力では、1つの値と1つの関数のみをプロットします。 GROUP BY: FACET句を表し、選択したディメンションごとにデータをグループ化します。 LIMIT: 表示する値の量を入力します。 WHERE: このフィールドを使用して、結果にさらにフィルターを適用します。この入力では、n値をプロットします。 各項目は、xをクリックしてクエリから削除できます。 NRQLクエリ表示 上記のフィールドと、タイムピッカーで選択した時間範囲で構成される、完全なクエリを表示できます。 ヒント より詳細な検索を行う、またはチャートをカスタマイズする必要がある場合データエクスプローラーから、クエリビルダーにアクセスしてクエリを編集できます。 チャートエリア デフォルトでは、データは線チャートで表示されます。チャートピッカーを使用して、面グラフ、円グラフ、およびバーチャートに簡単に切り替えることができます。結果の生データをテーブルまたはJSON形式として表示することもできます。 ディメンションを選択している場合、チャートは異なるファセットで更新されます。チャートの下に、ファセットのリストとそれぞれの値があるファセットの表が表示されます。 ファセットテーブルを使用して、データをドリルダウンします。クリックしたファセットはフィルターとして適用されます。表は表示されたままなので、別のファセットを簡単に選択して調査を続けることができます。 共有してエクスポート 右上にあるオプションメニューを使用して、チャートを画像として取得、またはリンクとして共有、ダッシュボードに追加できます。 また、URLをコピーし、その他のNew Relicユーザーと調査全体を共有することもできます。 使用事例 次の例で、データエクスプローラーをいつどのように使用するかについて学習してください。 新規データを確認 新規インストゥルメンテーションに接続したばかりで、新規データを利用できるかどうか確認したいと思っています。 アカウントとイベント、または新規データを生成しているメトリックを選択します。 データエクスプローラーで別のツールを使用して、利用できるようになった新規データを使ってみる：そのイベントまたはメトリックの生データを表として見る、またはリストとする、またはクリックしてチャートとしてプロットされることを確認します。 イベントやメトリックを選択した後、ディメンションでデータの形状を確認します。濃度を使用して、あらゆるデータの異なる視点を確認できます。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 データを検証 カスタムイベント/メトリックを変更したので、この変更が正常に行われたかどうかをチェックする必要がある。 データエクスプローラータブで、変更したアカウントとデータタイプ、イベント/メトリックを選択します。 エンティティがデータをレポートしていることと、すべての属性がプロットされていることを確認します。 変更した属性を検索し、更新が正常に行われたことをチェックします。 データの問題のトラブルシューティング アラートやダッシュボードからのイベント/メトリックで何か問題があることが分かっている。イベント/メトリック属性の動作について、根本原因を知る必要がある。 データエクスプローラーで、メニューを使用して、想定どおりに動作していないイベントやメトリックを選択し、データエクスプローラーでそのチャートをプロットします。 そこから、そのデータのディメンションを掘り下げて、関連する属性によりフィルターを適用できます。 また、次のような異なる観点からそのデータを把握することもできます：分布や値の順位、経時進化。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.946205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "605343b4196a6754132d166e"
    },
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.1237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.1237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053433228ccbcdc10c2fd60"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Tip",
        "Why it matters",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "8f390d6aa6f57d215b3c23f8cf08c02ef310bddc",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-12T03:13:31Z",
      "updated_at": "2021-03-16T11:03:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Tip To use the data explorer and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces apps to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From data explorer you can access query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 49.987743,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": " icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs and Traces apps to <em>explore</em> those. You can also access the query builder any time"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Data explorer: Query and chart event data",
        "Important",
        "Events vs metrics",
        "UI components",
        "Data samples",
        "Caution"
      ],
      "title": "Data explorer: Query and chart event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Explore data"
      ],
      "external_id": "72a23b59b41a3cb521c184c24603d50c28cffdb1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/data-explorer-query-chart-event-data/",
      "published_at": "2021-04-11T15:45:15Z",
      "updated_at": "2021-03-30T08:43:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you explore the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs metrics In New Relic Insights, the Data explorer page has two tabs: Events: In the context of the Insights UI, this refers to any data that can be queried via NRQL. This includes all our major data types, including events and the Metric, Log, and Span data types. Metrics: In the context of the Insights UI, this refers to metric timeslice data. (Note that metric timeslice data is available for querying with NRQL in New Relic One.) For an improved querying and charting experience, we recommend using New Relic One chart builder and dashboards. UI components Use the Events data explorer to view and explore the data available to you. The UI includes: A dropdown that lets you select a data type, like PageView or Transaction. A time-based chart for that data. A sample of that data type, showing its attached attributes, and the ability to see other samples. Ability to search by group by and search for specific attributes. Data samples The most recent sample for the chosen data type is listed at the bottom of the page. Default attributes are underlined. To see more samples, select See more samples. You may need to scroll left and right to see the full table of data. Caution The amount of data stored for a given event type can run into the hundreds of thousands, or even millions, of records. This report only shows a small sample. Use this UI to review the structure of the data, not the contents of a specific record. For example, you can use it to make sure an attribute is populating properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 46.584587,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data <em>explorer</em>: Query and chart event data",
        "sections": "Data <em>explorer</em>: Query and chart event data",
        "tags": "<em>Explore</em> data",
        "body": " our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you <em>explore</em> the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs"
      },
      "id": "6043efa0e7b9d2b78d5799d2"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/embed/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-11T13:51:33Z",
      "type": "",
      "external_id": "7487158c521f4cccda9ec299bae4c06242ad07e7",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"Nerdpack\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-Nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"Nerdlet\", \"id\": \"ab-test-Nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet artifact inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 743.51904,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Launchers</em>",
        "body": " that the <em>launcher</em> opens when it&#x27;s selected. This <em>Nerdpack</em> has only <em>one</em> <em>Nerdlet</em>, called ab-test-<em>nerdlet</em>, but some Nerdpacks may have multiple. Make sure that you set the root<em>Nerdlet</em>Id to the <em>Nerdlet</em> you want the <em>launcher</em> to open. <em>Nerdlets</em> The <em>nerdlets</em> directory contains all the <em>Nerdlets</em> that make up your <em>New</em> <em>Relic</em>"
      },
      "id": "6072fee664441ffa0d9d8546"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/embed/",
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-03-31T01:50:30Z",
      "type": "",
      "external_id": "ca6bf3fbbc9a8b6c767f9f9d59f055069300be80",
      "popularity": 1,
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 667.093,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": " building guides and the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> command reference. <em>Nerdpack</em> <em>file</em> <em>structure</em> When you generate a <em>Nerdpack</em> template using the nr1 create command, it has the following <em>file</em> <em>structure</em>: my-<em>nerdlet</em> ├── README.md ├── <em>launchers</em> │   └── my-<em>nerdlet</em>-<em>launcher</em> │   ├── icon.png │   └── nr1.json"
      },
      "id": "6063d566196a67d66cc6f473"
    },
    {
      "image": "https://developer.newrelic.com/static/cf9bafc3fc03f7562e4f969cafcd7659/30c01/visualization-apps-navigation.png",
      "url": "https://developer.newrelic.com/build-apps/build-visualization/embed/",
      "sections": [
        "Build a custom visualization for dashboards",
        "Before you begin",
        "Create a new visualization",
        "Tip",
        "Render the visualization in local development",
        "Important",
        "Advanced nerdpack configuration",
        "Deploy and use your visualization",
        "Summary",
        "Additional resources"
      ],
      "published_at": "2021-04-13T01:55:31Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "70fef5cbf4bc667802c0d2c05ce43a0317e8188e",
      "popularity": 1,
      "body": "Building your own visualizations for New Relic dashboards enables you and your organization to query data from any source and display it on your dashboard. In this guide, you'll learn how to use the CLI to generate a visualization file structure, run it locally where you can quickly test and iterate, and then deploy it for use in a dashboard. Before you begin To get started, make sure you have a New Relic account. To complete this guide, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. Create a new visualization In this first set of steps you will use the CLI to quickly generate the boilerplate for a new visualization. Step 1 of 3 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 3 Start with a new Nerdpack. If you just installed the New Relic One CLI, then you have a new Nerdpack project directory (called something like my-awesome-nerdpack). If you need to create one, run nr1 create and select the nerdpack option. bash Copy $ nr1 create --type nerdpack --name my-awesome-nerdpack Tip Note: If you only want to build a visualization in your Nerdpack, you can remove the nerdlets/ and launchers/ folders from the nerdpack Step 3 of 3 Navigate to the root of your Nerdpack project and run the nr1 create command, selecting the visualization option. bash Copy $ cd my-awesome-nerdpack $ nr1 create --type visualization --name my-awesome-visualization As a result, you have a new visualization directory matching the name you gave your visualization. It is located in the visualizations directory in the root of your Nerdpack project. The files created provide an example visualization – a radar chart populated by a basic NRQL query. The nr1.json file provides metadata. The configuration key in this metadata defines the prop-input fields to be shown in the UI. These are the fields users will fill in to create an instance of the visualization. Supported input types are: boolean string number json enum: a developer-defined list of string options. nrql: a single NRQL query string. namespace: a group of input fields to be displayed together under a shared heading in the prop-editing UI. collection: a repeatable group of input fields to be displayed together under a shared heading in the prop-editing UI. The nrqlQueries entry is an example of a collection type. The index.js file is where you define the React component that receives the props and renders the visualization. You can install and import any JavaScript libraries you find useful. The example component imports Recharts, a library that wraps D3 submodules for easy-to-compose visualizations. If your visualization queries data over a time range and you want it to utilize the platform time range setting, you will need to utilize the timeRange value from PlatformStateContext. The timeRange can be passed directly to the NrqlQuery component. Setting the NrqlQuery component's pollInterval prop to NrqlQuery.AUTO_POLL_INTERVAL automatically handles calculating an appriate data polling interval. <PlatformStateContext.Consumer> {({timeRange}) => ( <NrqlQuery timeRange={timeRange} pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} > ... Copy Render the visualization in local development Now run the generated visualization locally, and view it in Custom Visualizations. There you can quickly test changes to your code. Step 1 of 7 Start the local Node server for your Nerdpack. bash Copy $ nr1 nerdpack:serve Important To see changes to the nr1.json file take effect, restart the local Node server. Changes to the definition of the configuration field will not show up in the prop configuration side bar of the Custom Visualizations UI until you stop the local Node server and start it back up. Step 2 of 7 In a browser, open https://one.newrelic.com/?nerdpacks=local. This url is also shown in the terminal when the Node server starts. The nerdpacks=local query string will direct the UI to load your new visualization artifact from the local Node server. Advanced nerdpack configuration See the advanced nerdpack configuration section for detailed information about how your local Node server is proxied to the browser and how you can override webpack configuration if needed. Step 3 of 7 Open the Apps page, and navigate to Custom Visualizations, which you will find favorited by default. Step 4 of 7 In the Custom Visualizations listing, find and click on the tile for your visualization. If the tile is not showing up or it is not indicating that it is running locally, restart the Node server and refresh the browser. When you select your locally running visualization, the visualization hosted by your local Node server is rendered with prop-configuration inputs. Here you can take advantage of the features outlined in the following steps. Step 5 of 7 You can set prop values and see the visualization update automatically. The prop inputs are listed as defined in the prop definitions located in the nr1.json file in the visualization folder (for example ./visualizations/my-awesome-visualization/nr1.json). Fill in values for the props and see the visualization update automatically. As you change props in the sidebar, a render cycle of your visualization's React component is triggered. Step 6 of 7 Modify the visualization's Javascript code and see the result automatically update in the UI. For example, you can change the value for fillOpacity on the Radar component in index.js. Upon save, you will see the page automatically update. fillOpacity={1.0} visualizations/your-visualization/index.js Copy Step 7 of 7 To add more props, you must update the configuration field in the nr1.json file for your visualization and restart the local Node server. The props you define in the configuration field allow New Relic One to cleanly display a prop-editing UI for users interacting with your visualization. See above for more information about the configuration field. Deploy and use your visualization When your visualization is ready to be added to a dashboard, just follow these steps. Step 1 of 2 Open and follow the guide to publish and deploy the Nerdpack to New Relic One and subscribe accounts to it. Step 2 of 2 Then you can add your visualization to a dashboard. Summary Congratulations on completing the steps in this example! You've learned how to: Create a visualization and run it locally Quickly test and iterate on visualization code changes in Custom Visualizations Deploy a visualization Add a custom visualization to a dashboard Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 417.9915,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a <em>new</em> visualization",
        "body": "Building your own visualizations for <em>New</em> <em>Relic</em> dashboards enables you and your organization to query data from any source and display it on your dashboard. In this guide, you&#x27;ll learn how to use the <em>CLI</em> to generate a visualization <em>file</em> <em>structure</em>, run it locally where you can quickly test"
      },
      "id": "6063d5f364441f94f40c8bf1"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course"
      ],
      "published_at": "2021-04-11T14:00:18Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to lookup the application user's account ID and the time range they selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your nerdlet. You can also use navigation for other nerdlets and launchers. Step 1 of 10 Change to the add-navigation directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now openApmEntity() knows that entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you've created a button and configured it to call .openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row but the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application: Click App performance: Now you see the stacked entity! Congratulations! You're finished writing all the code you'll write for you New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo application that is running an A/B test. You've created several charts, buttons, and other UI elements. You've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and out of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to deploy and subscribe to your New Relic application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 416.88177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add navigation to your <em>Nerdlet</em>",
        "body": " to your <em>nerdlet</em>, before starting this <em>one</em>. In the last lesson, you used PlatformStateContext from the <em>New</em> <em>Relic</em> <em>One</em> SDK to lookup the application user&#x27;s account ID and the time range they selected from the app&#x27;s time picker. Now, you&#x27;ll learn about another component that interacts with the <em>New</em> <em>Relic</em>"
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 403.0873,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular <em>New</em> <em>Relic</em> <em>One</em> Applications (Roundup #5)",
        "sections": "Subscribe to applications with the <em>New</em> <em>Relic</em> <em>One</em> Catalog",
        "body": " Subscribe to applications with the <em>New</em> <em>Relic</em> <em>One</em> Catalog Before we start accessing the applications via the <em>CLI</em>, let’s look at how to access these applications directly within <em>New</em> <em>Relic</em> <em>One</em>. To explore available applications, navigate to <em>New</em> <em>Relic</em> <em>One</em> and click on the <em>New</em> <em>Relic</em> <em>One</em> Catalog <em>launcher</em>. <em>New</em>"
      },
      "id": "60762e1f64441fbf2e9d856e"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 214.97131,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.71043,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-12T03:01:08Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.66125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.65346,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.65346,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "https://developer.newrelic.com/static/a2b20353935db8fba0dbfd0cdc71d8e6/b01d9/use-nerdgraph-launcher.png",
      "url": "https://developer.newrelic.com/build-apps/add-nerdgraphquery-guide/embed/",
      "sections": [
        "Add the NerdGraphQuery component to an application",
        "Important",
        "Before you begin",
        "Prepare the sample code",
        "Add the NerdGraphQuery component",
        "How to use NerdGraphQuery.query",
        "Review the results of the NerdGraph query",
        "Summary"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "b3165fe5bf522e8281dca658bf3ac296c0997ae9",
      "popularity": 1,
      "body": "This guide steps you through the process of adding the `NerdGraphQuery` component to a sample transaction overview application. This allows you to query data from your New Relic account and add it to a dropdown menu. NerdGraph is our GraphQL implementation. GraphQL has some key differences when compared to REST: The client, not the server, determines what data is returned. You can easily collect data from multiple sources. For example, in a single query, you can get account information, infrastructure data, and issue a NRQL request. Important Before completing this exercise, you can experiment with GraphQL queries in our NerdGraph API explorer. We also have a 14-minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1–4 of our CLI quick start, and be sure to make a copy of your account ID from step 1 because you’ll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 8 If you haven't already done so, clone the example applications from our how-to GitHub repo. Here's an example using HTTPS: bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 8 Change to the directory use-nerdgraph-nerdlet: bash Copy $ cd nr1-how-to/use-nerdgraph/nerdlets/use-nerdgraph-nerdlet Step 3 of 8 In your preferred text editor, open index.js. Step 4 of 8 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 8 Change to the /nr1-howto/use-nerdgraph directory: bash Copy $ cd ../.. Step 6 of 8 If this is your first time executing this code run the below command to install all the required modules: bash Copy $ npm install Step 7 of 8 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 8 of 8 Once the sample application is successfully served, go to the local New Relic One homepage (https://one.newrelic.com/?nerdpacks=local), click Apps, and then click Use NerdGraph. After launching the Use NerdGraph application, you see a dashboard that gives an overview of the transactions in your account: Add the NerdGraphQuery component Now you can create a dropdown menu for changing the account the application is viewing. The first step is to import the NerdGraphQuery component into the application's index.js file. Important If you need more details about our example below, see the APIs and components page on https://developer.newrelic.com Step 1 of 3 Add the NerdGraphQuery component into the first StackItem inside of the return in the index.js file: <NerdGraphQuery query={query} variables={variables}> {({ loading, error, data }) => { console.log({ loading, error, data }); if (loading) { return <Spinner />; } if (error) { return 'Error!'; } return null; }} </NerdGraphQuery>; Copy Step 2 of 3 The NerdGraphQuery component takes a query object that states the source you want to access and the data you want returned. Add the following code to your index.js file in the render method: Important In the browser console, you can see the data from your query returned in an object that follows the same structure of the object in the initial query. const query = ` query($id: Int!) { actor { account(id: $id) { name } } } `; Copy Step 3 of 3 To take the data returned by the NerdGraph query and display it in the application, replace the return null in the current NerdGraphQuery component with this return statement: return <HeadingText>{data.actor.account.name} Apps:</HeadingText>; Copy When you go back to the browser and view your application, you see a new headline showing the name of your account returned from NerdGraph: How to use NerdGraphQuery.query At this point, you have implemented the NerdGraphQuery component with the application's render method and displayed the return data within the transaction overview application. Here's what you need to do next: Query NerdGraph inside of the componentDidMount lifecycle method. Save the returned data for later use in the application. Step 1 of 2 This code takes the response from NerdGraph and makes sure the results are processed, stored into the application state, and logged to the browser console for viewing. Add this code into the index.js file just under the constructor: componentDidMount() { const accountId = this.state; const gql = `{ actor { accounts { id name } } }`; const accounts = NerdGraphQuery.query({query: gql}) //The NerdGraphQuery.query method called with the query object to get your account data is stored in the accounts variable. accounts.then(results => { console.log('Nerdgraph Response:', results); const accounts = results.data.actor.accounts.map(account => { return account; }); const account = accounts.length > 0 && accounts[0]; this.setState({ selectedAccount: account, accounts }); }).catch((error) => { console.log('Nerdgraph Error:', error); }) } Copy Step 2 of 2 After the data is stored into state, display a selection so users can change accounts and update the application. To do this, add this code to index.js for the second StackItem in the return statement: { accounts && ( <StackItem> <Select value={selectedAccount} onChange={(evt, value) => this.selectAccount(value)} > {accounts.map((a) => { return ( <SelectItem key={a.id} value={a}> {a.name} </SelectItem> ); })} </Select> </StackItem> ); } Copy Review the results of the NerdGraph query After you complete these steps, look at the application in your browser, and note the following: The dropdown menu now displays the data returned from the NerdGraphQuery.query and allows you to select an account. After you select a new account, the application shows data from the new selection. The final index.js file should have code similar to the code below. This completed sample is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, NerdGraphQuery, Spinner, HeadingText, Grid, GridItem, Stack, StackItem, Select, SelectItem, AreaChart, TableChart, PieChart } from 'nr1' import { timeRangeToNrql } from '@newrelic/nr1-community'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class UseNerdgraphNerdletNerdlet extends React.Component { constructor(props){ super(props) this.state = { accountId: <YOUR ACCOUNT ID>, accounts: null, selectedAccount: null, } } componentDidMount() { const accountId = this.state; const gql = `{ actor { accounts { id name } } }`; const accounts = NerdGraphQuery.query({ query: gql }) accounts.then(results => { console.log('Nerdgraph Response:', results); const accounts = results.data.actor.accounts.map(account => { return account; }); const account = accounts.length > 0 && accounts[0]; this.setState({ selectedAccount: account, accounts }); }).catch((error) => { console.log('Nerdgraph Error:', error); }) } selectAccount(option) { this.setState({ accountId: option.id, selectedAccount: option }); } render() { const { accountId, accounts, selectedAccount } = this.state; console.log({ accountId, accounts, selectedAccount }); const query = ` query($id: Int!) { actor { account(id: $id) { name } } } `; const variables = { id: accountId, }; const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <Stack fullWidth horizontalType={Stack.HORIZONTAL_TYPE.FILL} gapType={Stack.GAP_TYPE.EXTRA_LOOSE} spacingType={[Stack.SPACING_TYPE.MEDIUM]} directionType={Stack.DIRECTION_TYPE.VERTICAL}> <StackItem> <NerdGraphQuery query={query} variables={variables}> {({loading, error, data}) => { if (loading) { return <Spinner />; } if (error) { return 'Error!'; } return <HeadingText>{data.actor.account.name} Apps:</HeadingText>; }} </NerdGraphQuery> </StackItem> {accounts && <StackItem> <Select value={selectedAccount} onChange={(evt, value) => this.selectAccount(value)}> {accounts.map(a => { return ( <SelectItem key={a.id} value={a}> {a.name} </SelectItem> ) })} </Select> </StackItem> } <StackItem> <hr /> <PlatformStateContext.Consumer> {(PlatformState) => { /* Taking a peek at the PlatformState */ const since = timeRangeToNrql(PlatformState); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Transaction Overview </HeadingText> <TableChart fullWidth accountId={accountId} query={trxOverview+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Average Response Time </HeadingText> <AreaChart fullWidth accountId={accountId} query={avgResTime+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Response Code </HeadingText> <PieChart fullWidth accountId={accountId} query={responseCodes+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Transaction Errors </HeadingText> <PieChart fullWidth accountId={accountId} query={errCount+since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> </StackItem> </Stack> ) } } Copy Summary Now that you've completed all the steps in this example, you've successfully queried data from your account using the NerdGraphQuery component in two methods: Using the NerdGraphQuery component inside the application's render method and then passing the returned data into the children's components. Using the NerdGraphQuery.query method to query data before the application renders.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 683.8525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add the <em>NerdGraphQuery</em> <em>component</em> to an <em>application</em>",
        "body": " headline showing the name of your <em>account</em> returned from <em>NerdGraph</em>: How to use <em>NerdGraphQuery.query</em> At this point, you have implemented the <em>NerdGraphQuery</em> <em>component</em> with the application&#x27;s render method and displayed the return <em>data</em> within the <em>transaction</em> <em>overview</em> application. Here&#x27;s what you need to do"
      },
      "id": "6063d5f328ccbc4e6d43fa95"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/embed/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Course",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-04-11T13:55:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:55:24Z",
      "type": "",
      "external_id": "f2af52e45942b4cf9499282a654340b132766741",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorage from your nerdlet, before starting this one. Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in .componentDidMount(), you've queried NerdGraph for your api_token data. .componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives .showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your nerdlet's state is the current token that your nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called .componentDidUpdate(). Now, every time your nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers .componentDidUpdate(). In .componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Fetch data from a third-party service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 578.8762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Access <em>NerdStorageVault</em> from your <em>Nerdlet</em>",
        "body": " { <em>nerd</em>StorageVault { secret(key: $key) { value } } } } `; const variables = { key: &quot;api_token&quot;, }; <em>NerdGraphQuery.query</em>( { <em>query</em>: <em>query</em>, variables: variables, } ).then( ({ loading, error, <em>data</em> }) =&gt; { if (error) { console.error(error); this.showPrompt(); } if (<em>data</em> &amp;&amp; <em>data.actor.nerd</em>"
      },
      "id": "6072ffcd64441f6cc09d8544"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/graphql_aws_services-1024x593.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/graphql-api",
      "sections": [
        "Using GraphQL in New Relic",
        "Example 1: Querying Infrastructure cloud integrations with NerdGraph",
        "Example 2: Modifying integration configurations with NerdGraph",
        "Transfering NerdGraph data to the terminal",
        "New Relic and GraphQL—easing the path for developers"
      ],
      "published_at": "2021-04-14T00:03:24Z",
      "title": "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "381e6b1a3bca81ebc8b6efc8199d2b75983befca",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read By Mark Weitzel As you build observability into your workflows and processes, you need the ability to quickly retrieve, sort, and process all kinds of telemetry through APIs. With New Relic, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous API operations. With the NerdGraph API explorer—built on GraphQL—you can more easily query the data you need, without over-or under-fetching, and reduce manual toil in your data analysis workflows. More specifically, in New Relic you can use NerdGraph to: Query all the entities associated with your account Query, create, and update the workloads associated with your account Create, manage, and add tags to entities Query distributed tracing data Fetch data when building a New Relic One application Understand upstream and downstream relationships with your services Configure your New Relic Infrastructure cloud integrations Query event data and custom event data with NRQL In this post, I’ll walk through two examples using NerdGraph to query information about New Relic Infrastructure cloud integrations and update their configuration values. But first a bit of history. Using GraphQL in New Relic Unlike typical REST APIs that often require loading from multiple endpoints, GraphQL provides a single endpoint that can manage complex queries so developers can get all the data their app needs from many services in one request. GraphQL is strongly typed, which allows developers to explicitly declare what information is available via queries to the GraphQL service. This declaration is done via a GraphQL schema. Schemas give developers the flexibility they need to express information about the data they return. For example, each field has a description, which developers can use to indicate the proper usage of the data. Schemas also provide the API blueprint developers need to build tools for properly constructing queries and guiding proper usage of any returned data. For example, developers can use the schema to indicate if a field has been deprecated so tools like IDEs can surface this fact and discourage use of that data. And “schema stitching”—creating a single schema from several underlying GraphQL APIs—allows developers to deliver a unified access experience across all of their APIs, as we’ve done at New Relic: The New Relic GraphQL implementation includes several underlying GraphQL APIs—including accounts, Infrastructure, and the New Relic database (for constructing NRQL queries). For more information on GraphQL, the following examples of querying cloud integration configuration data use GraphQL queries and mutations: Queries: GraphQL requests that only fetch data Mutations: GraphQL requests that modify and fetch data NerdGraph has a single endpoint: https://api.newrelic.com/graphiql. This launches (after authenticating the user) the NerdGraph API interface—an interactive, browser-based IDE for running GraphQL requests. In the NerdGraph API explorer, you build and run your query on the left, and the result is returned on the right. You can click into fields to drill into their definitions. For example, if you drill into actor, you’ll see it contains fields for user and accounts: { actor { user { name email } accounts { id name } } } The fields under actor expose data from different downstream services that are unified in the GrahQL schema delivered by the GraphQL server. When you issue a query, the GraphQL server pulls apart the query and invokes a resolver for each of the services. When the queries complete (or time out or encounter errors), the GraphQL server assembles the result and returns it to you. In the example above, we get information about the user and all the accounts that they have access to. Let’s walk through our examples to show the full power of GraphQL’s data collection capabilities. Example 1: Querying Infrastructure cloud integrations with NerdGraph In my first example, I’ll use NerdGraph to query for various data about the AWS integrations that are running in my New Relic account. I’ll use the data I gather in this example to update some specific settings in the next section. Tip: If you’re planning on following along, make sure you generate an API key that you can use with New Relic’s GraphQL API. In fact, you can generate one directly from NerdGraph. Let's start with a list of the AWS integrations I have available in New Relic Infrastructure: AWS integrations installed in New Relic Infrastructure. Next, let's retrieve some information about these AWS services via a GraphQL query. I’m going to query for the cloud provider (in this case, AWS) that’s linked to my account and the set of integrations from AWS that I’ve installed. To do this, I need to pass the ID of the account I want to query—this is the account(id: MY ACCOUNT ID) part of the query. Notice that I’m “nesting” requests to get information about the cloud provider and the integrations I’m using. If I were using a REST API, this would require multiple calls, but with the GraphQL API, I can gather this information with just one query.   { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { id name slug } integrations { id name service { id slug name createdAt updatedAt provider { name id } } } } } } } } When the query completes, the GraphQL server assembles the results about the AWS integrations I’ve installed, as shown below (note that I’ve truncated the example): { \"data\": { \"actor\": { \"account\": { \"cloud\": { \"linkedAccounts\": [ { \"authLabel\": \"arn:aws:iam::8xxxxxxx7:role/NewRelicInfrastructure-Integrations-Origami\", \"externalId\": \"8xxxxxxx7\", \"id\": 3542, \"integrations\": [ { \"id\": 75540, \"name\": \"RDS\", \"service\": { \"createdAt\": 1470991744, \"id\": 3, \"name\": \"RDS\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"rds\", \"updatedAt\": 1534242454 } }, { \"id\": 14233, \"name\": \"S3\", \"service\": { \"createdAt\": 1470991745, \"id\": 4, \"name\": \"S3\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"s3\", \"updatedAt\": 1534242454 } }, { \"id\": 12223, \"name\": \"Lambda\", \"service\": { \"createdAt\": 1477910055, \"id\": 14, \"name\": \"Lambda\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"lambda\", \"updatedAt\": 1534242454 } }, { \"id\": 172534, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 } }, } } ] } } } } } But what if I want more specific information about one of the integrations? Specifically, I want to see what tags (user-defined metadata) I’ve applied to a particular integration as well as its metrics polling interval (how often New Relic polls the integration for data), and when these settings were last updated. To do this, I’ll need to use one of the more nuanced features of GraphQL—interfaces, an abstract type that represents a collection of common fields that other object types can implement. So in my original query, I’ll add two new clauses: ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } Now, if my query hits a result that is of type CloudDynamodbIntegration or CloudReshiftIntegration, it also return the fields metricsPollingInterval, tagKey, tagValue, and updatedAt. Here's what my (truncated) query will like now: { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { ... } integrations { id name service { ... } } ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } } } } } } In the result, notice that the DynamoDb and Redshift configuration information contain the extra fields that I specified in the query using their interfaces. { \"id\": 173397, \"metricsPollingInterval\": 900, \"name\": \"Redshift\", \"service\": { \"createdAt\": 1497364366, \"id\": 21, \"name\": \"Redshift\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"redshift\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1544435410 }, { \"id\": 112183, \"metricsPollingInterval\": 900, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1549499902 }, OK! I’ve successfully queried information about my AWS integrations in New Relic Infrastructure, and I’ve used an interface to get additional information about a specific integration. Now, I’ll use the GraphQL API to update the metrics data polling intervals in one of these integrations. Example 2: Modifying integration configurations with NerdGraph In GraphQL, when you modify data with a write operation, it’s called a mutation. In this example, I’ll build a mutation to update the polling intervals of an AWS integration. First, though, I’ll set a polling interval so that we'll notice when I change it with NerdGraph. Here are the configuration options for my AWS DynamoDB integration: DynamoDB integration configuration options in New Relic Infrastructure. As you can see, I’ve set the metrics data and inventory data polling intervals to every 5 minutes, and I’ve also toggled Collect tags to ON. Now I’ll build the mutation query. First, I'll start with the keyword mutation, and like any GraphQL API request, enclose it in a pair of curly braces,{ }. Next, I want to specify that I’m configuring a cloud integration; so I’ll add cloudConfigureIntegration, which takes two arguments: accountId and integrations. For accountId, I’ll use the same account id from the first example to get information about the Infrastructure-linked accounts. The second argument is the integrations that I want to update. Again, integrations are specified by cloud provider, so here I want to include aws. So far my mutation looks like this: mutation{ cloudConfigureIntegration( accountId:MY ACCOUNT ID integrations:{aws I want to specify that I’m updating the configuration for DynamoDB, so I’ll pass in an object with dynamodb as the key and an array that contains objects with the values I want to to set. Remember, for our mutation, we want to update the metricsPollingInterval (valid values are 300, 900, 1800, and 3600 seconds) and add a tagKey (metadata about the function of the integration). The final part of the mutation adds a set of fields to return if my request is successful and a set of fields to return if there are any errors. Here's the full query: mutation{ cloudConfigureIntegration( accountId:630060 integrations:{aws:{ dynamodb:[ { linkedAccountId:4912 metricsPollingInterval:1800 tagKey:\"mdw-test\" }] } } ) { integrations{ id name updatedAt ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } errors{ linkedAccountId message integrationSlug } } } And here’s the result, which shows no errors and indicates DynamoDB’s configuration was successfully updated: { \"data\": { \"cloudConfigureIntegration\": { \"errors\": [], \"integrations\": [ { \"id\": 177184, \"metricsPollingInterval\": 1800, \"name\": \"DynamoDB\", \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1551139957 } ] } } } I can now return to New Relic Infrastructure and refresh the DynamoDB configuration page: Refreshing the DynamoDB configuration in New Relic Infrastructure. Our mutation changed the metric polling interval from 300 seconds (5 minutes) to 1800 seconds (30 minutes), and entered tag key value of mdw-test. That's it! I've successfully updated the configuration of a New Relic Infrastructure integration using NerdGraph. Transfering NerdGraph data to the terminal So, now you know how to explore the New Relic data available to you in NerdGraph, and you know how to create queries and mutations, but how do you transfer this data to your code? To capture code-ready queries and mutations, select the Tools drop down in the NerdGraph explorer. To copy a curl statement with the in-scope query to your clipboard, select Copy as CURL. Paste this code snippet into your terminal, or use it to populate an HTTP request in your code. If you’re working with the New Relic CLI, select Copy as New Relic CLI from the drop down to generate a command-line ready query or mutation. New Relic and GraphQL—easing the path for developers As these examples show, GraphQL is extremely flexible and lightweight, and dramatically reduces the overhead of working with your New Relic data. If you want to challenge yourself even more, create some more complex queries in the Query Builder. For example, can you create a query to grab the count of all of your reporting entities? Hint: check out NerdGraph’s entity search field. We’re passionate about making life for developers as easy as possible. Check out the resources available at developer.newrelic.com, and engage in the discussion with fellow developers on the Explorer’s Hub. By Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 457.3825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Started With <em>NerdGraph</em>—The New Relic <em>GraphQL</em> API Explorer",
        "sections": "Example 1: <em>Querying</em> Infrastructure cloud integrations with <em>NerdGraph</em>",
        "body": "QL—you can more easily <em>query</em> the <em>data</em> you need, without over-or under-fetching, and reduce manual toil in your <em>data</em> analysis workflows. More specifically, in New Relic you can use <em>NerdGraph</em> to: <em>Query</em> all the entities associated with your <em>account</em> <em>Query</em>, create, and update the workloads associated"
      },
      "id": "6076314c64441f483e9d8576"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/5-server-error.png",
      "url": "https://newrelic.com/blog/nerdlog/apollo-server-plugin",
      "sections": [
        "Troubleshooting errors and latency",
        "Scenario 1: Troubleshooting an error",
        "Scenario 2: Latency is caused by an external service"
      ],
      "published_at": "2021-04-13T23:25:03Z",
      "title": "How to Monitor GraphQL Apps with New Relic Apollo Server Plugin",
      "updated_at": "2021-04-13T23:25:03Z",
      "type": "",
      "external_id": "ed9ecf22946c370441fabd487527ea21ce3cec38",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog How to Monitor GraphQL Apps with New Relic Apollo Server Plugin Dec 15, 2020 • 6 min read By Rebecca Rodriguez Apollo Server, an open source GraphQL server that helps you connect a GraphQL schema to an HTTP server in Node, can be used with popular frameworks such as Express, Connect, Hapi, Koa, Restify, and AWS Lambda. Developed four years ago when Facebook open sourced GraphQL, it has accelerated in popularity over REST APIs, mainly due to its efficiency. However, GraphQL can be challenging to monitor. With GraphQL, you can fetch and retrieve data in a single query, enabling you to ask for exactly the data you need while minimizing the amount of data transferred over the network and improving performance. However, this single operation or endpoint is exactly what makes GraphQL operations challenging to monitor. Measuring the response time of one GraphQL endpoint won’t tell you enough about an application’s health. The New Relic Apollo Server plugin provides visibility into GraphQL payloads down to the resolver level and associated external service calls. To monitor your GraphQL applications, you want to understand the timing of individual GraphQL operations and then have the ability to filter down to the root cause of an issue. If a GraphQL operation is slow, the cause of the latency could be due to several things. For one, it could be the structure of the operation itself. For example, batched operations could cause the operation to take longer than desired. Resolvers, the functions responsible for populating the data for a single field in your schema, could also cause latency. In this case, you’d want to adjust the function call. However, latency could also be caused by an external service’s poor performance, such as an API or a database. Using distributed tracing, you can identify which external service the GraphQL field is calling and attribute the latency to that external service. By using the New Relic Apollo Server plugin to instrument your applications, you can get to the root cause of issues. The plugin records the overall timing of the operations and then parses the payload so you can uncover and diagnose the cause of your slow GraphQL operations. Distributed tracing goes further and provides the capability to understand if the latency is coming from the application itself or other services. Troubleshooting errors and latency Let’s walk through two troubleshooting scenarios: We built a simple example Node application that interfaces with NASA’s Near Earth Objects API (search for near earth object). The app allows us to monitor how close an asteroid is to Earth and when it will get here, so we have time to prepare and minimize impact. Using GraphQL, you can query NASA’s API for the asteroid’s relative velocity and distance from the Earth. It’s important that the GraphQL queries avoid errors and latency to avoid misjudging the time it will take the asteroid to reach us. Scenario 1: Troubleshooting an error In this first example, you see a GraphQL error on the error events page and will want to find the root cause to fix it quickly. 1. Click on the error class to see more detailed error information. 2. Select the transaction name in the transaction view, and explore it using distributed tracing. 3. In the distributed trace view, you can identify the transactions that are throwing the errors. 4. Click on a particular trace to get a detailed view of the operation span with the error message and the offending query. In this case, you can see an internal server error related to the resolver. 5. Finally, you can always keep track of your slow operations and resolvers through a custom dashboard view. Scenario 2: Latency is caused by an external service In this example, you have a transaction view that shows a slow transaction: 1. By hovering over it, you see it’s from a slow GraphQL query called ClosestAstroidFound. 2. To understand why the query is slow, click on the transaction and select Find distributed traces for this transaction. 3. When you see slow transactions, you can explore them using distributed tracing. 4. When exploring the transaction, expand the GraphQL resolver span and see it making a call to another instrumented service taking most of this transaction’s time. Instrument your apps to get to the root cause of GraphQL errors and slowness in GraphQL operations with the New Relic Apollo Server plugin. By Rebecca Rodriguez Rebecca Rodriguez is a Senior Product Manager at New Relic with a focus on Python, Node, and Browser observability data ingest. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.62262,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to Monitor <em>GraphQL</em> <em>Apps</em> with New Relic Apollo Server Plugin",
        "body": " navigation <em>menu</em>, 4 items How to Relic Best Practices <em>Nerd</em> Life Nerdlog Search the blog Submit Nerdlog How to Monitor <em>Graph</em>QL Apps with New Relic Apollo Server Plugin Dec 15, 2020 • 6 min read By Rebecca Rodriguez Apollo Server, an open source <em>Graph</em>QL server that helps you connect a <em>Graph</em>QL schema"
      },
      "id": "6076284f196a67dc5764a7a5"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/app-server-breakdown.png",
      "url": "https://newrelic.com/blog/how-to-relic/go-agent-apm",
      "sections": [
        "Up and Running With the <br>New Relic APM Go Agent",
        "Overview",
        "My example",
        "Instrument all the things!",
        "Transactions",
        "Segments",
        "Attributes",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:59:47Z",
      "title": "Up and Running With the New Relic APM Go Agent",
      "updated_at": "2021-04-13T23:59:47Z",
      "type": "",
      "external_id": "76e4f026f6277f62a5571f68605f5c48ffeb67c9",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Up and Running With the <br>New Relic APM Go Agent Aug 23, 2016 • 9 min read By Erika Arnold The Go programming language’s performance, ease of deployment, and simple concurrency model are common reasons developers switch to Go. I didn’t know much about Go, so I recently converted a personal Python project and started monitoring it with the New Relic Go Agent. Using my app as an example, I’ll overview the agent and dig into some of its coolest features, including transactions, segments, and attributes that give me insight into my application’s throughput, error rate, and response time like I used to have with the Python Agent. See also: The Most Popular Programming Languages of 2016 Overview The Go agent works a little differently than other New Relic agents, such as PHP or Ruby, which you import as a library or module and they “automagically” collect data. This magic is possible because those languages provide hooks into their virtual machine that the agents use to access and wrap functions. However, Go is a compiled language; it doesn’t use a virtual machine. This means the best way to monitor Go applications is to use an API. While this makes the Go agent a little more work to install, it provides tremendous flexibility and control over what gets instrumented. And it still has the magic, too! Simply importing the agent and creating an application gives you useful runtime information about the number of goroutines, garbage collection statistics, and memory and CPU usage. We even made a special “Go runtime” page for these metrics in New Relic APM. It’s useful, actionable information for any Go developer to have at a glance. Go runtime metrics Reporting these metrics for your application is easy. First, download the library from GitHub or via go get. Add it to your application’s import block, then create a config and an application in your main() or init() function: config := newrelic.NewConfig(\"Your App Name\", \"YOUR_LICENSE_KEY\") app, err := newrelic.NewApplication(config) The agent periodically records information sourced from the MemStats structure in the runtime package. We’ve already had several customers report that the goroutines chart has identified leaks they didn’t know existed. While Go provides several good monitoring tools, they are valuable only when used consistently. Integrating New Relic into your app automates monitoring and helps you quickly spot new issues with each deploy. My example Have you ever heard of the Kevin Bacon Six Degrees of Separation game? In that spirit, I had built a Python app called wikiGraph to query the shortest path between any two of Wikipedia’s 4.5 million pages, which I stuffed into a Neo4j graph database. This allows you to answer all sorts of interesting questions, like how many clicks does it take to get from Grace Hopper to sushi? [See bottom of post for answer.] When a user inputs two page names, the server queries a smaller SQLite database for page information and queries the graph database for the shortest path. It then asks the graph database for a selection of “neighboring” pages, assembles a graph, and passes it back to the frontend. Converting my Python app to Go was fun! I especially enjoyed using structs that could easily unmarshal into JSON and using goroutines to make my database queries concurrent. Once my app was in Go, I was ready to install the New Relic APM agent and start monitoring it. Instrument all the things! As mentioned earlier, runtime metrics are only the beginning of the information our Go agent can provide. With so much flexibility, though, how do you decide what to instrument? Should you collect information about every function? What if you want information about only a small block of code? I suggest starting with your most important areas of concern. I decided to focus on these two questions: What is the timing information for my server’s routes? What is the breakdown of time spent in the databases? Whatever questions you decide to tackle first, the next decision is how to handle the application structure you just created. You’ll need to access it within your handlers in order to create transactions and custom events. Should the application be a global variable or should it be passed around as a parameter? The answer mostly depends on your developer worldview. Choosing a global structure certainly makes access convenient. However, passing around parameters makes the application an explicit dependency of the function that uses it. The code becomes more modular and easier to test, since you can just swap in applications for a particular test. As a first pass, I recommend making the application global, but I don’t think I would leave it this way long term. Transactions What is a Go transaction? The short answer is that it’s whatever you want it to be. You can start and end a transaction around a route, a function, or just a block of code. In the New Relic realm, transactions are traditionally equated with server requests. For my app, I use half a dozen routes to serve frontend requests so that paradigm makes sense for me. With the New Relic APM Go agent, you have the power to (and you must) start and stop the transaction explicitly. If you don’t need to scope the transaction to a particular bit of code, defer statements are a convenient way to end a transaction: txn := app.StartTransaction(\"/query\", responseWriter, request) defer txn.End() But wait, there’s more: the Go agent has built-in support for request handling! If you are using the http standard library package, you can use the agent’s wrappers to automatically start and end transactions with the request and response writer. This is how I created transactions for each route: http.HandleFunc(newrelic.WrapHandleFunc(app, \"/query\", queryHandler)) One important restriction is that each transaction should be used in only a single goroutine. If you want to access the transaction in a new goroutine, just start a new transaction for it. You’ll probably want to access the current transaction within the handler to do fun things with segments and attributes. The newrelic.Transaction structure actually embeds the response writer, so be sure to use the transaction in place of the original writer. This means you can get the transaction with a simple type assertion. func queryHandler(w http.ResponseWriter, r *http.Request) { if txn, ok := w.(newrelic.Transaction); ok { txn.NoticeError(errors.New(\"my error message\")) } } Once I converted the handlers in my app to use the wrapper, I checked out what that looked like in New Relic APM: top 5 web transactions Sadly, it wasn’t a very colorful chart, but it did answer my first question: the vast majority of time is spent in the “/query” route. What is that handler spending all its time doing? Scoping transactions to entire routes can obfuscate important information. So let’s dig into the details using segments. Segments Segments are meaningful chunks of a transaction. The Go agent currently supports external, datastore, and generic segment flavors. I suspected the bulk of the query time in my app was spent in the datastores, so I started by adding segments for each call. As with transactions, you are responsible for stopping and starting your segments. Segment calls are safe to use even without checking whether the transaction is nil. If your call spans an entire function call, you can use a rather elegant single-line defer statement: defer newrelic.DatastoreSegment{ StartTime: newrelic.StartSegmentNow(txn), Product:   newrelic.DatastoreSQLite, Collection: \"pagenames_table\", Operation: \"SELECT\", }.End() err := db.QueryRow(query, item.value).Scan(&result) Because I found it easiest to interact with the Neo4j database through its REST API, I needed to make POST requests rather than use a driver. I wrapped the request with a Datastore segment (notice how I added Neo4j as a new product): segment := newrelic.DatastoreSegment{ StartTime: newrelic.StartSegmentNow(txn), Product:   newrelic.DatastoreProduct(\"Neo4j\"), Operation: r.operation, } response, err := http.Post(url, \"application/json\", bytes) segment.End() Let’s see what that looks like in New Relic. Under the “/query” transaction, I found the breakdown of time. As I expected, most of the time was spent in the graph database. The shortest-path query was about 50% of the total response time, with the neighbor page query making up another 30%. (The SQLite calls aren’t in this transaction since they are made by another handler.) app server breakdown     This chart answered my second question and I could keep an eye on these numbers as I further optimized the query times. Attributes Finally, I wanted to build a New Relic Insights dashboard to track some of the fun paths users were finding in my app. For those not familiar with custom attributes, they are key-value pairs you attach to events, which you can then use in Insights. I was particularly interested in database timing and the pages in the path. If there was an especially long response time, the start and end pages allow me to reproduce it. You get the total database duration for free with the transaction event, but in order to add the query results, I concatenated the pages into a string for the “path” value: txn.AddAttribute(\"path\", path) I added other attributes for the start/end pages, the path length, as well as the original query. Then I created a dashboard to explore the most recent path found, the longest path found, and the path with the longest response time: insights dashboard     In case you’re curious, here’s the NRQL query for the longest shortest path found: SELECT max(length) FROM Transaction WHERE query IS NOT NULL FACET query My favorite part is the filter I set up on the query attribute, which lets me click on an interesting path to filter the whole dashboard for that path result. Did you know the Louisville Zoo Wikipedia page links to Brazil nuts through just one other page, the Hyacinth macaw? That’s my tale of getting up and running with the New Relic APM Go agent. Hopefully it will give you ideas of how to use it on your own Go applications. We invite you to try it out and tell us what you think on the New Relic forums. For more details, check out our Go Agent guide and public Docs site.   [Answer] Three clicks. In 1991, Grace Hopper won the National Medal of Technology and Innovation, the same award that Frederick McKinley Jones and Joseph A. Numero won for advances in refrigeration, which had a huge influence on the rise of the Japanese sushi industry.   Gopher image cc 3.o original by Renee French. Related Topics APM By Erika Arnold Erika Arnold works on the PHP Agent team at New Relic. A former biologist, she’s collected bugs all over the world. Now she just enjoys finding bugs in code. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 412.57596,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Transactions</em>",
        "body": " used consistently. Integrating New Relic into your <em>app</em> automates monitoring and helps you quickly spot new issues with each deploy. My example Have you ever heard of the Kevin Bacon Six Degrees of Separation game? In that spirit, I had built a Python <em>app</em> called wiki<em>Graph</em> to <em>query</em> the shortest path"
      },
      "id": "60763073196a676eb464a79a"
    }
  ],
  "/explore-docs/nerdstoragevault": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/embed/",
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "027dd39d82c1996136231ffad1636034152cf482",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 419.80383,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Using <em>NerdStorageVault</em> in your <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use <em>NerdStorageVault</em> to store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution. Using <em>NerdStorageVault</em> in your <em>apps</em> <em>NerdStorageVault</em> is used to store and retrieve sensitive secrets <em>data</em>"
      },
      "id": "6063d5f3e7b9d2632f70376b"
    },
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-04-12T10:06:38Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 371.06824,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "NerdGraph allows you to <em>access</em> your <em>New</em> <em>Relic</em> <em>data</em>, but when you want to fetch third-party <em>data</em>, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and <em>encrypted</em> <em>storage</em> location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/jp/whats-new/",
      "sections": [
        "New Relicの新機能"
      ],
      "published_at": "2021-04-12T09:07:40Z",
      "title": "What's new in New Relic",
      "updated_at": "2021-04-12T09:07:40Z",
      "type": "docs-jp",
      "external_id": "cfaaa9015112cddf53bade5c9f859c3bfbc53a97",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "April 9 Level up at FutureStack on May 25-27! Connect with Nerds from across the globe to learn, share, and get inspired at our free, virtual event April 8 Aggregated health and activity for your Workloads New Relic Workloads are now easier to read. April 5 Guided install for Java and .NET APM agents We’ve made it simple to set up APM (Java and .NET) using our recently-launched guided installation flow, so you can instrument your systems and start analyzing your telemetry data in 5 minutes - no instrumentation expertise required. April 1 NRQL Updates You can now use Regex within your NRQL queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and New Relic One. FedRAMP: Logs and Metrics now certified Protecting your data is our highest priority, which is why we achieved the US Government’s rigorous FedRAMP Moderate certification in 2020. And now we’re adding support for Logs and Metrics to our long list of supported services. March 30 Kubernetes: Metric Update Moving to container_memory_working_set_bytes and away from container_memory_usage_bytes metric Slow transactions on the service Summary Quickly dive into the most time-consuming requests to your application or service March 25 Nerdlog Roundup: New Relic Lookout, Guided Install, and Open Source Docs Get real-time visibility into your stack, simplify your instrumentation, and edit our docs March 18 Nerdlog Roundup: Root Cause Analysis, Topology (Relationship-Based) Correlation, and more! Reduce your MTTR with free Automatic Proactive Anomaly Detection, find problems fast with root cause analysis, and increase context for issues using topology correlation. March 17 AIOps Made Easy: Get to root cause and respond faster Automatically find root cause and respond faster than ever March 16 Heroku cloud integration for log management Detailed log data made easier than ever Visualize log details in Dashboards with our new Logs Table Widget More flexibility and control for log message visualizations March 15 AIOps Made Easy: Cut down on alert noise Reduce alert fatigue and prioritize what’s important March 10 AIOps Made Easy: Detect unusual changes instantly Automatic proactive anomaly detection for free Nerdlog Roundup: See hosts, services, containers, and more in one view with New Relic Navigator See hundreds of entities in a compact, high-level view March 8 Nerdlog Roundup: Muting Rules, Custom Data Visualizations, and more AIOps fun! Smarter incident intelligence and custom data visualizations February 25 Nerdlog Roundup: Ingesting OpenTelemetry Data, RUM, and more Ingest OpenTelemery data and logs, drop your data, and monitor your browser performance February 24 New Relic Explorer: Say goodbye to blindspots Gain unprecedented visibility into your entire system February 19 Nerdlog Roundup: K6 Load Testing and the ServiceNow and Snowflake Integrations Keep your issues in sync, view your Snowflake and k6 performance data in New Relic One. February 11 Data Dropping update: Now, drop entire dimensional metrics Filter sensitive or low-value data February 8 Check out the Nerdlog We have a new live-stream changelog on Twitch! January 28 Agentless syslog onboarding for New Relic log management Host-based log ingestion using rsyslog or syslog-ng with a new TCP endpoint January 21 New Python agent features Python agent now auto instruments HTTPX and Django ASGI January 19 New Anomalies feed as part of AI overview page View all your anomalies in a single place January 13 New Relic Snowflake Integration New Relic now integrates with Snowflake. January 6 Schedule recurring muting rules Suppress or mute notifications with ease December 7, 2020 Recap: Top 10 new observability features you need to know Our engineers and product managers share their favorite features, capabilities, and integrations to help you be more productive and collaborative. December 1, 2020 Alerts and Applied Intelligence new landing page Surface insights with a new landing page. Percentiles now available in events-to-metrics service For the events-to-metrics service, return an attribute's approximate value at a given percentile. November 12, 2020 API keys app There's a new app for managing your API keys. New Relic Lambda extension Our new extension improves observability of your Lambda data. Share dashboards and curated views with permalinks Sharing what you’re seeing just got easier. November 10, 2020 Invite a teammate See how easy it is to invite your team to New Relic. November 9, 2020 Enhanced errors experience in New Relic One We've improved the new errors experience. November 3, 2020 Troubleshoot performance and crash issues faster with New Relic's real-time Java profiling New Relic is excited to announce the availability of real-time Java profiling using Java Flight Recorder (JFR). October 30, 2020 Build high-resolution charts using sliding windows Increase your chart resolution with rolling aggregates, powered by sliding windows. Kafka Connect: Unlock open source and alternative instrumentation sources Build observability pipelines from open source tools and alternative instrumentation sources with the New Relic connector for Kafka Connect. Veneur sink: Your pipeline to 3rd party metrics Send metrics to New Relic using our Veneur sink. October 29, 2020 Three big updates for your native mobile apps Three big updates: The New Relic iOS and tvOS agents will now be distributed as the New Relic XCFramework Agent 7.0.0. For instrumenting React Native applications, we have an experimental open source React Native Module. Plus, we’ve improved reliability from our Android service and changed the way our service handles Android stack deobfuscation. October 27, 2020 Monitor ASGI apps using the Python agent The Python agent now supports monitoring Uvicorn, Starlette, and FastAPI ASGI applications. Monitor Apollo Server GraphQL Node applications Use our Node.js agent plugin to capture executed GraphQL queries. October 15, 2020 Applied Intelligence: Better, smarter webhooks Webhooks now automatically deliver anomaly charts. October 14, 2020 New Relic One now has a new UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry data. October 13, 2020 Store data in an encrypted storage solution with NerdStorageVault Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save your table column, time range, etc. in the logs UI October 9, 2020 Alerting: Loss of signal detection and configurable gap-filling strategies Specify how long the system should wait before a signal is considered lost. October 7, 2020 New Relic achieves AWS Outposts Ready designation New Relic has achieved the AWS Outposts Ready designation, part of the Amazon Web Services (AWS) Service Ready Program. October 1, 2020 Applied Intelligence now features accelerated suggested decisions Reduce alert noise by using our suggested correlation decisions. September 30, 2020 Applied Intelligence: Deployment events in the issue feed Applied Intelligence now includes any relevant APM deployment data. September 29, 2020 New Relic Edge with Infinite Tracing New Relic users with Pro or Enterprise Full-Stack Observability can now access and benefit from New Relic Edge. September 11, 2020 Anomalies visible in the activity stream The activity stream shows recent events so you can quickly see what's happening in your system. September 9, 2020 Windows Logs supported Support for Windows Logs with New Relic's infrastructure agent September 4, 2020 New Relic One has dark mode! We now have dark mode! New Relic Support for Amazon Web Services (AWS) Bottlerocket Gain full visibility into your workloads and infrastructure running on AWS Bottlerocket. What's new? Your in-product destination for New Relic One updates! September 1, 2020 Issue summary and analysis in Applied Intelligence Rely on the issue summary to help you identify and resolve relevant issues. Visual issue timeline in Applied Intelligence Use our Gantt-style timeline chart to see your related events. August 26, 2020 Real-user monitoring support for W3C trace context and Google Core Web Vitals We've added support for W3C trace context and Google Core Web Vitals! August 18, 2020 Alert analysis for Applied Intelligence Alert analysis gives you greater context for your alert violations and notifications. August 16, 2020 Ingest New Relic Logs directly with Amazon Web Services (AWS) Kinesis Data Firehose New Relic can ingest data from Amazon's Kinesis Data Firehose. Tracing the gap: AWS X-Ray integration Use New Relic with AWS X-Ray, a critical distributed tracing tool for getting visibility across your AWS services. August 10, 2020 Create Grafana dashboards with Prometheus data stored in New Relic You can create Grafana dashboards with Prometheus data stored in New Relic! July 30, 2020 Overall New Relic One experience updates We've made updates across all of New Relic One! Scheduled alert muting Schedule when you want to mute alerts to avoid messages during maintenance or deployments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 301.81302,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What&#x27;s <em>new</em> in <em>New</em> <em>Relic</em>",
        "sections": "<em>New</em> <em>Relic</em>の新機能",
        "body": " queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and <em>New</em> <em>Relic</em> <em>One</em>. FedRAMP: Logs and Metrics now certified Protecting your <em>data</em> is our highest priority, which is why we achieved"
      },
      "id": "6050daaa196a6746822d164e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/",
      "sections": [
        "What's new in New Relic"
      ],
      "published_at": "2021-04-12T01:42:43Z",
      "title": "What's new in New Relic",
      "updated_at": "2021-04-11T01:50:40Z",
      "type": "docs",
      "external_id": "49467ca3d09d7a4f1c1c69fd16be4e20050a7686",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "April 9 Level up at FutureStack on May 25-27! Connect with Nerds from across the globe to learn, share, and get inspired at our free, virtual event April 8 Aggregated health and activity for your Workloads New Relic Workloads are now easier to read. April 5 Guided install for Java and .NET APM agents We’ve made it simple to set up APM (Java and .NET) using our recently-launched guided installation flow, so you can instrument your systems and start analyzing your telemetry data in 5 minutes - no instrumentation expertise required. April 1 NRQL Updates You can now use Regex within your NRQL queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and New Relic One. FedRAMP: Logs and Metrics now certified Protecting your data is our highest priority, which is why we achieved the US Government’s rigorous FedRAMP Moderate certification in 2020. And now we’re adding support for Logs and Metrics to our long list of supported services. March 30 Kubernetes: Metric Update Moving to container_memory_working_set_bytes and away from container_memory_usage_bytes metric Slow transactions on the service Summary Quickly dive into the most time-consuming requests to your application or service March 25 Nerdlog Roundup: New Relic Lookout, Guided Install, and Open Source Docs Get real-time visibility into your stack, simplify your instrumentation, and edit our docs March 18 Nerdlog Roundup: Root Cause Analysis, Topology (Relationship-Based) Correlation, and more! Reduce your MTTR with free Automatic Proactive Anomaly Detection, find problems fast with root cause analysis, and increase context for issues using topology correlation. March 17 AIOps Made Easy: Get to root cause and respond faster Automatically find root cause and respond faster than ever March 16 Heroku cloud integration for log management Detailed log data made easier than ever Visualize log details in Dashboards with our new Logs Table Widget More flexibility and control for log message visualizations March 15 AIOps Made Easy: Cut down on alert noise Reduce alert fatigue and prioritize what’s important March 10 AIOps Made Easy: Detect unusual changes instantly Automatic proactive anomaly detection for free Nerdlog Roundup: See hosts, services, containers, and more in one view with New Relic Navigator See hundreds of entities in a compact, high-level view March 8 Nerdlog Roundup: Muting Rules, Custom Data Visualizations, and more AIOps fun! Smarter incident intelligence and custom data visualizations February 25 Nerdlog Roundup: Ingesting OpenTelemetry Data, RUM, and more Ingest OpenTelemery data and logs, drop your data, and monitor your browser performance February 24 New Relic Explorer: Say goodbye to blindspots Gain unprecedented visibility into your entire system February 19 Nerdlog Roundup: K6 Load Testing and the ServiceNow and Snowflake Integrations Keep your issues in sync, view your Snowflake and k6 performance data in New Relic One. February 11 Data Dropping update: Now, drop entire dimensional metrics Filter sensitive or low-value data February 8 Check out the Nerdlog We have a new live-stream changelog on Twitch! January 28 Agentless syslog onboarding for New Relic log management Host-based log ingestion using rsyslog or syslog-ng with a new TCP endpoint January 21 New Python agent features Python agent now auto instruments HTTPX and Django ASGI January 19 New Anomalies feed as part of AI overview page View all your anomalies in a single place January 13 New Relic Snowflake Integration New Relic now integrates with Snowflake. January 6 Schedule recurring muting rules Suppress or mute notifications with ease December 7, 2020 Recap: Top 10 new observability features you need to know Our engineers and product managers share their favorite features, capabilities, and integrations to help you be more productive and collaborative. December 1, 2020 Alerts and Applied Intelligence new landing page Surface insights with a new landing page. Percentiles now available in events-to-metrics service For the events-to-metrics service, return an attribute's approximate value at a given percentile. November 12, 2020 API keys app There's a new app for managing your API keys. New Relic Lambda extension Our new extension improves observability of your Lambda data. Share dashboards and curated views with permalinks Sharing what you’re seeing just got easier. November 10, 2020 Invite a teammate See how easy it is to invite your team to New Relic. November 9, 2020 Enhanced errors experience in New Relic One We've improved the new errors experience. November 3, 2020 Troubleshoot performance and crash issues faster with New Relic's real-time Java profiling New Relic is excited to announce the availability of real-time Java profiling using Java Flight Recorder (JFR). October 30, 2020 Build high-resolution charts using sliding windows Increase your chart resolution with rolling aggregates, powered by sliding windows. Kafka Connect: Unlock open source and alternative instrumentation sources Build observability pipelines from open source tools and alternative instrumentation sources with the New Relic connector for Kafka Connect. Veneur sink: Your pipeline to 3rd party metrics Send metrics to New Relic using our Veneur sink. October 29, 2020 Three big updates for your native mobile apps Three big updates: The New Relic iOS and tvOS agents will now be distributed as the New Relic XCFramework Agent 7.0.0. For instrumenting React Native applications, we have an experimental open source React Native Module. Plus, we’ve improved reliability from our Android service and changed the way our service handles Android stack deobfuscation. October 27, 2020 Monitor ASGI apps using the Python agent The Python agent now supports monitoring Uvicorn, Starlette, and FastAPI ASGI applications. Monitor Apollo Server GraphQL Node applications Use our Node.js agent plugin to capture executed GraphQL queries. October 15, 2020 Applied Intelligence: Better, smarter webhooks Webhooks now automatically deliver anomaly charts. October 14, 2020 New Relic One now has a new UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry data. October 13, 2020 Store data in an encrypted storage solution with NerdStorageVault Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save your table column, time range, etc. in the logs UI October 9, 2020 Alerting: Loss of signal detection and configurable gap-filling strategies Specify how long the system should wait before a signal is considered lost. October 7, 2020 New Relic achieves AWS Outposts Ready designation New Relic has achieved the AWS Outposts Ready designation, part of the Amazon Web Services (AWS) Service Ready Program. October 1, 2020 Applied Intelligence now features accelerated suggested decisions Reduce alert noise by using our suggested correlation decisions. September 30, 2020 Applied Intelligence: Deployment events in the issue feed Applied Intelligence now includes any relevant APM deployment data. September 29, 2020 New Relic Edge with Infinite Tracing New Relic users with Pro or Enterprise Full-Stack Observability can now access and benefit from New Relic Edge. September 11, 2020 Anomalies visible in the activity stream The activity stream shows recent events so you can quickly see what's happening in your system. September 9, 2020 Windows Logs supported Support for Windows Logs with New Relic's infrastructure agent September 4, 2020 New Relic One has dark mode! We now have dark mode! New Relic Support for Amazon Web Services (AWS) Bottlerocket Gain full visibility into your workloads and infrastructure running on AWS Bottlerocket. What's new? Your in-product destination for New Relic One updates! September 1, 2020 Issue summary and analysis in Applied Intelligence Rely on the issue summary to help you identify and resolve relevant issues. Visual issue timeline in Applied Intelligence Use our Gantt-style timeline chart to see your related events. August 26, 2020 Real-user monitoring support for W3C trace context and Google Core Web Vitals We've added support for W3C trace context and Google Core Web Vitals! August 18, 2020 Alert analysis for Applied Intelligence Alert analysis gives you greater context for your alert violations and notifications. August 16, 2020 Ingest New Relic Logs directly with Amazon Web Services (AWS) Kinesis Data Firehose New Relic can ingest data from Amazon's Kinesis Data Firehose. Tracing the gap: AWS X-Ray integration Use New Relic with AWS X-Ray, a critical distributed tracing tool for getting visibility across your AWS services. August 10, 2020 Create Grafana dashboards with Prometheus data stored in New Relic You can create Grafana dashboards with Prometheus data stored in New Relic! July 30, 2020 Overall New Relic One experience updates We've made updates across all of New Relic One! Scheduled alert muting Schedule when you want to mute alerts to avoid messages during maintenance or deployments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 280.6981,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What&#x27;s <em>new</em> in <em>New</em> <em>Relic</em>",
        "sections": "What&#x27;s <em>new</em> in <em>New</em> <em>Relic</em>",
        "body": " queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and <em>New</em> <em>Relic</em> <em>One</em>. FedRAMP: Logs and Metrics now certified Protecting your <em>data</em> is our highest priority, which is why we achieved"
      },
      "id": "60422917196a677e2fa83ddf"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.15933,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or <em>data</em> from another service or API. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>. If you want to get started building quickly, first read the requirements. Tip To use our developer site and <em>New</em> <em>Relic</em> <em>One</em>, as well as the rest of our"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:51Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 206.59918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Most Popular New Relic One <em>Applications</em> (Round up #3)",
        "sections": "<em>Page</em> <em>View</em> <em>Map</em>",
        "body": " working with our GraphQL service and a third party library. <em>Page</em> <em>View</em> <em>Map</em> creates geographic visualizations of New Relic Browser application data Fork or deploy the <em>Page</em> <em>Views</em> <em>Map</em> <em>app</em> from GitHub Specific requirements for this <em>app</em> You must have the New Relic Browser Agent(s) installed, as well"
      },
      "id": "60762e1f196a673d0a64a782"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/embed/",
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "published_at": "2021-04-11T13:59:30Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:45Z",
      "type": "",
      "external_id": "5c7a60b535745e446d5ac1b026d9c5e8323ed7bb",
      "popularity": 1,
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin Before you begin, we recommend first reading about permissions. To start building, you must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.25735,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "body": " guides: Build a &quot;Hello, World!&quot; application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. <em>Map</em> pageviews by <em>region</em> takes you through the steps to create one of our popular open source apps. You learn to add a <em>custom</em> query"
      },
      "id": "6063d5a2196a677164c6f49e"
    },
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/embed/",
      "sections": [
        "Add a chart group",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "e94780ac131f1a4ce5999771f9bee9650d4f5e9b",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add tables, before starting this one. In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add user interface components to your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.50467,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-programmability-course&#x2F;add-a-chart-group Step 2 of 9 In nerdlets&#x2F;ab-test-nerdlet, add a new Javascript file named <em>page</em>-<em>views</em>.js: bash Copy $ touch <em>page</em>-<em>views</em>.js Step 3 of 9 In this new file, create a component called Version<em>PageViews</em> to hold a LineChart, which shows the number of times a <em>page</em> is viewed"
      },
      "id": "6072ff19e7b9d25dbba5c689"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings",
        "Course"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a grid, before starting this one. Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add version descriptions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.93544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-<em>views</em>.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your <em>custom</em> components: import React from &#x27;react&#x27;; import { HeadingText, LineChart } from &#x27;nr1&#x27;; export default class NewsletterSignups"
      },
      "id": "6072ff1928ccbc140b51c16e"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions",
        "Course"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart headings, before starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 7 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 2 of 7 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 3 of 7 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 4 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 5 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 7 of 7 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add a section to end your test.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.26392,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "&#x27;; import TotalSubscriptions from &#x27;.&#x2F;total-subscriptions&#x27;; import VersionDescription from &#x27;.&#x2F;description&#x27;; import Version<em>PageViews</em> from &#x27;.&#x2F;<em>page</em>-<em>views</em>&#x27;; import VersionTotals from &#x27;.&#x2F;totals&#x27;; const VERSION_A_DESCRIPTION = &#x27;The newsletter signup message says, &quot;Sign up for our newsletter&quot;&#x27; const"
      },
      "id": "6072569228ccbc932d51c172"
    }
  ],
  "/components/charts": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T13:58:44Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a nerdpack, launcher, and nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 244.11444,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Account access, deselect the account you want to unsubscribe from the app, and select Update <em>1</em> account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you&#x27;ve built a New Relic One application from the ground up. You&#x27;ve used the <em>nr1</em> <em>CLI</em> to create a <em>nerdpack</em>"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:16Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: You use this key to associate your New Relic account with the CLI. The CLI then uses the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name>, the <User key>, and the region (either us or eu) with real values. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.77469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic One <em>CLI</em>",
        "body": " for this course: bash Copy $ <em>nr1</em> profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ <em>nr1</em> profiles --help Now, you’re ready to build an application with the New Relic One <em>CLI</em>. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a <em>Nerdpack</em>."
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.12447,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-12T06:45:09Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.680336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:51Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.18037,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-container-explorer.git cd <em>nr1</em>-container-explorer <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure"
      },
      "id": "60762e1f196a673d0a64a782"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T13:58:44Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a nerdpack, launcher, and nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 556.8258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> to your New Relic <em>One</em> <em>application</em>",
        "body": " serving it locally! Tip If you don&#x27;t see the app under Your apps, you may have to refresh the page or clear your browser cache. It&#x27;s important to note that you can <em>subscribe</em> to <em>applications</em> in the <em>catalog</em> with the <em>nr1</em> <em>CLI</em>. Read our documentation to learn more. Unsubscribe from your application"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:16Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: You use this key to associate your New Relic account with the CLI. The CLI then uses the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name>, the <User key>, and the region (either us or eu) with real values. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 375.55484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic <em>One</em> <em>CLI</em>",
        "body": " this by checking your SDK version: bash Copy $ <em>nr1</em> --version Tip It’s important to distinguish between the newrelic <em>CLI</em> and the <em>nr1</em> <em>CLI</em>. newrelic is for managing entities in your New Relic account. <em>nr1</em> is for managing New Relic <em>One</em> <em>applications</em>. Step 3 of 3 Associate your New Relic account as a <em>CLI</em> profile. Use"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 350.34375,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic <em>One</em> <em>Applications</em> (Roundup #5)",
        "sections": "<em>Subscribe</em> to <em>applications</em> with the New Relic <em>One</em> <em>Catalog</em>",
        "body": " GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The <em>Nerdpack</em> <em>file</em> <em>structure</em>, including how to link your application with an entity. Application&#x2F;data access and permissions and security. <em>NR1</em> Workshop: a step-by-step, self-paced, open source"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:50Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 318.62866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic <em>One</em> <em>Applications</em> (Roundup #6)",
        "sections": "<em>Subscribe</em> to apps in the New Relic <em>One</em> <em>Catalog</em>",
        "body": " to your New Relic account using the following commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-attributory.git cd <em>nr1</em>-attributory <em>nr1</em> <em>nerdpack</em>:publish <em>nr1</em> <em>nerdpack</em>:deploy -c STABLE <em>nr1</em> <em>nerdpack:subscribe</em> -c STABLE Then go to the homepage of <em>one</em>.newrelic.com and select the app’s launcher"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.9597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to New Relic <em>One</em> SDK",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/embed/",
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "published_at": "2021-04-11T13:59:30Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:45Z",
      "type": "",
      "external_id": "5c7a60b535745e446d5ac1b026d9c5e8323ed7bb",
      "popularity": 1,
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin Before you begin, we recommend first reading about permissions. To start building, you must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.24228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Contribute to <em>developer.newrelic.com</em>",
        "body": "If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> command line interface (<em>CLI</em>) An <em>API</em> <em>key</em>, which you get when you download the <em>CLI</em> Depending on what you want to do with your app, you might have some additional setup"
      },
      "id": "6063d5a2196a677164c6f49e"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Steps for a successful transition",
        "Get started with New Relic One",
        "Query anything",
        "Visualize more data"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-04-12T02:59:18Z",
      "updated_at": "2021-04-05T03:35:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries, charts, and dashboards. With New Relic One, we have modernized the experience for you to access, analyze, and visualize your data. New Relic One offers an improved charts and dashboards experience, and it provides a platform where we can more rapidly bring new innovations to you. This transition guide can help you understand: What are some of the new and improved features you get with New Relic One charts, dashboards, and queries Why it's easy to transition to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Steps for a successful transition The transition to New Relic One has two parts: the UI and mobile app experience (April 12, 2021) and the Dashboard API (July 2021). Insights functionality Transition to New Relic One UI We have already taken care of your transition from Insights to New Relic One for you! As of April 12, 2021, your old Insights web URLs redirect automatically to New Relic One. We recommend that you familiarize yourself with the new UI features available to you, as described in this transition guide. If you need to view any Insights charts embedded in other websites, go to one.newrelic.com > More > Manage Data. (These older embedded charts will continue to function as expected.) Mobile apps Your Insights mobile app is deprecated as of April 11, 2021. Go to the Google Play Store 2 or Apple App store. Delete your old Insights mobile app, and download the New Relic One mobile app. tvOS apps and large displays New Relic's tvOS app is still available. No action is needed by you at this time. Some New Relic customers with the original pricing model may have set up dashboards on wall screens for restricted users with kiosk mode. No action is required for you to continue to view these dashboards. APIs The Insights API to create dashboards will be deprecated and replaced with the new Dashboards API as of July 2021. We encourage you to start exploring the capabilities of the Dashboards API in NerdGraph now! You can continue to use your Insights insert API key with the Dashboards API, or you can create a new user API key. Every user who wants to query with the NerdGraph API will need their own user API key. The REST API for Insights queries is not affected by this change and will not be deprecated. For more information about which key to use with our APIs, see our documentation about API keys. Easily access your insert and query API keys by going to one.newrelic.com > More > Manage Insights Data> API Keys Partnership accounts This applies only if your account is one of the few using our partnership account structure to deliver New Relic services to your direct customers. In this situation, the Insights EOL will not affect your customers’ pricing. This is simply an EOL for the UI, not an EOL for the account type. Questions If you have questions about the transition, please comment in our Explorers Hub post. Or, if you work with an account team, they will be happy to help you. Get started with New Relic One New Relic One dashboards are an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more! one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. All of the dashboards you previously created in Insights are automatically available in New Relic One. Query anything With New Relic One, you get: Better querying and charting experiences: Query access is available globally, no matter where you are in New Relic One. This includes a \"basic\" query mode that doesn't require knowledge of NRQL. Improved query experience: You can query both the Metric data type and metric timeslice data. Easy customization: Every visualization now has the query accessible. You can augment any curated chart just by changing the NRQL. Visualize more data Not only can you select a wide range of visualization options, you can also add more to your dashboards: Better display options: Make your data easier to understand by using visualizations other than dense, line-heavy charts. New Relic One also offers a better TV mode. More charts or widgets across dashboards: Insights restricted you to a 3-across limit. Now you can display up to 12 across your dashboard, providing increased data density along with improved tooltips and tracking across charts. Easier creation of multi-page dashboards: Insights referred to these as data apps. Your Insights data apps are preserved as multi-page dashboards in New Relic One. Chart consistency and flexibility: Dashboards include facet color consistency across widgets and faster loading times for more performant dashboards. Also, you can add any chart type to a dashboard in New Relic One! The New Relic Insights UI has served our users well for many years, but it's time to give you an even better experience. Join us and make the switch to New Relic One!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.80481,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and considerations when you make the switch How to get the most out of using <em>New</em> <em>Relic</em> <em>One</em> Steps for a successful transition The transition to <em>New</em> <em>Relic</em> <em>One</em> has two parts: the UI and mobile app experience (April 12, 2021) and the Dashboard <em>API</em> (July 2021). Insights functionality Transition to <em>New</em>"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/embed/",
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "f17736ed026e1bf9fd253b8b716db26f1f13cc58",
      "popularity": 1,
      "body": "To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.9265,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "body": "To build a <em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (command line interface). This page explains how to use <em>CLI</em> commands to: Generate"
      },
      "id": "6063d63364441f61c30c8be9"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.71043,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or data from another service or <em>API</em>. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> apps. If you want to get started building quickly, first read the requirements. Tip To use our <em>developer</em> site and <em>New</em> <em>Relic</em> <em>One</em>, as well as the rest of our"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.68027,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use the <em>API</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph <em>API</em> to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    }
  ],
  "/build-apps/custom-visualizations-and-the-new-relic-one-sdk": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T13:58:44Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a nerdpack, launcher, and nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 477.45886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "body": " serving it locally! Tip If you don&#x27;t see the app under Your apps, you may have to refresh the page or clear your browser cache. It&#x27;s important to note that you can <em>subscribe</em> to applications in the <em>catalog</em> with the <em>nr1</em> <em>CLI</em>. Read our documentation to learn more. Unsubscribe from your application"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:16Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: You use this key to associate your New Relic account with the CLI. The CLI then uses the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name>, the <User key>, and the region (either us or eu) with real values. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 375.25873,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic <em>One</em> <em>CLI</em>",
        "body": " this by checking your SDK version: bash Copy $ <em>nr1</em> --version Tip It’s important to distinguish between the newrelic <em>CLI</em> and the <em>nr1</em> <em>CLI</em>. newrelic is for managing entities in your New Relic account. <em>nr1</em> is for managing New Relic <em>One</em> applications. Step 3 of 3 Associate your New Relic account as a <em>CLI</em> profile. Use"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.07248,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to New Relic <em>One</em> SDK",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-12T06:45:09Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.63853,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.65145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom New Relic <em>One</em> application ",
        "sections": "Build a custom New Relic <em>One</em> application",
        "tags": "New Relic <em>One</em>",
        "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic <em>One</em> platform, alongside your other dashboards and data. Feature <em>visualizations</em> that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/build-apps/customize-visualizations-with-configuration": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T13:58:44Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a nerdpack, launcher, and nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 477.70966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Subscribe to your New Relic <em>One</em> application",
        "body": " Account access, deselect the account you want to unsubscribe from the app, and select Update <em>1</em> account: If you navigate back to Apps, you will see your app in the <em>catalog</em>. Throughout this course, you&#x27;ve built a New Relic <em>One</em> application from the ground up. You&#x27;ve used the <em>nr1</em> <em>CLI</em> to create a nerdpack"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:16Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: You use this key to associate your New Relic account with the CLI. The CLI then uses the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name>, the <User key>, and the region (either us or eu) with real values. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 375.55484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic <em>One</em> <em>CLI</em>",
        "body": " this by checking your SDK version: bash Copy $ <em>nr1</em> --version Tip It’s important to distinguish between the newrelic <em>CLI</em> and the <em>nr1</em> <em>CLI</em>. newrelic is for managing entities in your New Relic account. <em>nr1</em> is for managing New Relic <em>One</em> applications. Step 3 of 3 Associate your New Relic account as a <em>CLI</em> profile. Use"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.61505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to New Relic <em>One</em> SDK",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "image": "https://developer.newrelic.com/static/28a19f070d3ae2b215793dd163851d7c/0086b/click-add-to-dashboard.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/embed/",
      "sections": [
        "Add custom visualizations to your dashboards",
        "Before you begin",
        "Note",
        "Add your custom visualization to a dashboard",
        "Manage your dashboard visualizations",
        "Summary",
        "Additional resources"
      ],
      "published_at": "2021-04-12T01:54:51Z",
      "title": "",
      "updated_at": "2021-04-10T01:54:48Z",
      "type": "",
      "external_id": "230f853d85188e6617cfa0014204b34fcb2e5c70",
      "popularity": 1,
      "body": "This lesson builds off of the previous Customize visualizations with configuration lesson. If you haven't followed that lesson, please start there as this lesson assumes you have the code you built there to get started. If you don't have a visualization to follow the examples in this gude, a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using nr1.json configuration, in the following steps, you will configure and add your custom visualization to a New Relic dashboard. Before you begin To get started, follow the Customize visualizations with configuration lesson. Then, publish and subscribe to your Nerdpack. Note To publish a Nerdpack you must be a Full user and granted the Nerdpacks “modify” privilege (which is granted by default). Read our documentation to learn more about Nerdpacks privileges. Add your custom visualization to a dashboard Once you've published your custom visualization to your account, in the following steps you'll configure your visualization and add it to a dashboard. You can add a visualization to a new or existing dashboard within your New Relic account. Step 1 of 6 To find the My Awesome Visualization that you have deployed, you need to look for your visualization in the app catalog. From the New Relic One homepage, select the Apps button in the top right navigation bar: Step 2 of 6 Once on the Apps page, click the Custom Visualizations launcher: Note If you don't see the Custom Visualizations tile, use the search to locate it. Step 3 of 6 In Custom Visualizations, you will see all of the visualization that have been deployed to your account and any visualizations you are serving locally. Select the My Awesome Visualization to add to a dashboard and then enable it: Step 4 of 6 In the previous lesson, you reconfigured your visualization to use the platform configurations panel. Use the configuration options to select your desired chart, select your account, insert a NRQL query, and any other configurations you desire. As you make your selections, the visualization will update with your changes: Step 5 of 6 Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name: Step 6 of 6 Click Add to dashboard, then click the link to your dashboard to see the custom visualization: Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations. Summary Congratulations on completing this final lesson and adding your custom visualization to a New Relic dashboard. In the previous lessons, you've used the tools in the New Relic SDK to create a new custom visualization, configured the visualization using the SDK and using the platform configuration panel. Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.42001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add custom <em>visualizations</em> to your dashboards",
        "body": ", a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using <em>nr1</em>.json configuration"
      },
      "id": "60710568196a6793b864a754"
    },
    {
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/embed/",
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "edab33e46fbc9f8e054670c52397176ce989ae3a",
      "popularity": 1,
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type nerdpack --name my-first-viz $ cd my-first-viz $ nr1 create --type visualization --name custom-viz The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ nr1 nerdpack:serve Then visit New Relic and navigate to Apps > Custom Visualizations > CustomViz to see it in action: Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack artifacts, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.59094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Introduction to custom <em>visualizations</em>",
        "body": " Relic <em>One</em> SDK and make sure you have the latest version: bash Copy $ <em>nr1</em> update Create a Nerdpack and a visualization: bash Copy $ <em>nr1</em> create --type nerdpack --name my-first-viz $ cd my-first-viz $ <em>nr1</em> create --type visualization --name custom-viz The visualization you created in the my-first-viz"
      },
      "id": "607105a064441fa6da9d8530"
    }
  ],
  "/build-apps/ab-test/third-party-service": [
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/embed/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:16Z",
      "type": "",
      "external_id": "58de68bd963cdd2062e88db55cb90ad124055eb6",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to take use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy PlatformStateContext.Consumer provides access to the platform's URL state. This state contains two important values for you to use in this context: accountId timeRange Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your nerdlet, you can use accountId from the platform URL state. Step 3 of 10 Use platformState.accountId in your NrqlQuery: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Next, notice that your query uses a SINCE clause, which identifies the historical timeframe your query should fetch data from. Step 4 of 10 Utilize platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. Tip While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery is now using the account ID, which it got from platform state. It's also using the platform state's time range, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1255.7955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> PlatformStateContext to your Nerdlet",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Fetch</em> <em>data</em> <em>from</em> a <em>third</em>"
      },
      "id": "6073000164441f84ce9d853d"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/embed/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Course",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-04-11T13:55:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:55:24Z",
      "type": "",
      "external_id": "f2af52e45942b4cf9499282a654340b132766741",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorage from your nerdlet, before starting this one. Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in .componentDidMount(), you've queried NerdGraph for your api_token data. .componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives .showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your nerdlet's state is the current token that your nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called .componentDidUpdate(). Now, every time your nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers .componentDidUpdate(). In .componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Fetch data from a third-party service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 462.50986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> NerdStorageVault <em>from</em> your Nerdlet",
        "body": " software is helping you meet your business objectives. Sometimes, New Relic <em>data</em> is all you need to make that happen, but other times you need to look beyond New Relic for <em>data</em> to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. Continue on to the next lesson: <em>Fetch</em> <em>data</em> <em>from</em> a <em>third</em>-<em>party</em> <em>service</em>."
      },
      "id": "6072ffcd64441f6cc09d8544"
    },
    {
      "image": "https://developer.newrelic.com/static/9fef87cd4b59ba7b2e8df08c97bd3b85/ba3ac/incorrect-auth-header.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/embed/",
      "sections": [
        "Fetch data from a third-party service",
        "Course"
      ],
      "published_at": "2021-04-11T14:00:18Z",
      "title": "",
      "updated_at": "2021-04-07T01:54:54Z",
      "type": "",
      "external_id": "5a9959f254359afeec9b0a9a9f39dd8b83d8c1ee",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorageVault from your nerdlet, before starting this one. In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -h 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add PlatformStateContext to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.22382,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Fetch</em> <em>data</em> <em>from</em> <em>a</em> <em>third</em>-<em>party</em> <em>service</em>",
        "body": " your nerdlet, before starting this one. In previous lessons, you learned of a <em>third</em>-<em>party</em> <em>service</em> that you can use to <em>fetch</em> mock cancellation <em>data</em> for the Total cancellations per version chart in your New Relic One application. Even though the <em>data</em> in this <em>service</em> is fake, the real value"
      },
      "id": "606d10ee28ccbc1cd5e1c991"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:23:32Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.74799,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create <em>a</em> &quot;Hello, World&quot; <em>app</em>",
        "body": ", gathered <em>from</em> myriad sources—including <em>third</em>-<em>party</em> open source <em>data</em>—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-04-12T10:06:38Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.79484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in <em>an</em> encrypted storage solution with NerdStorageVault",
        "sections": "Store <em>data</em> in <em>an</em> encrypted storage solution with NerdStorageVault",
        "body": "NerdGraph allows you to access your New Relic <em>data</em>, but when you want to <em>fetch</em> <em>third</em>-<em>party</em> <em>data</em>, NerdStorageVault allows you to safely store a secret to authenticate with a <em>third</em>-<em>party</em> <em>service</em>. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    }
  ],
  "/build-apps/ab-test/chart-headings": [
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings",
        "Course"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a grid, before starting this one. Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add version descriptions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1504.3109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>chart</em> <em>headings</em>",
        "body": ": The design guide details what data each <em>chart</em> shows. Use those details to craft useful <em>headings</em> for your charts. Step 1 of 6 Change to the <em>add</em>-<em>chart</em>-<em>headings</em> directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-<em>chart</em>-<em>headings</em> Step 2 of 6 In newsletter-signups.js, page"
      },
      "id": "6072ff1928ccbc140b51c16e"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions",
        "Course"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart headings, before starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 7 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 2 of 7 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 3 of 7 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 4 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 5 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 7 of 7 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add a section to end your test.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1210.7019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> version descriptions",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>chart</em> <em>headings</em>, before"
      },
      "id": "6072569228ccbc932d51c172"
    },
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/embed/",
      "sections": [
        "Add a grid",
        "Course",
        "Technical detail"
      ],
      "published_at": "2021-04-11T14:01:08Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "bfd5e04da0f000d6970b16677cd5faf8c3b2f461",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add user interface components to your application, before starting this one. In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add chart headings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 990.176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a grid",
        "body": " six steps, you significantly improved the readability and usability of your A&#x2F;B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll <em>add</em> <em>headings</em> to your charts to remind yourself of what data each <em>chart</em> presents. Course This lesson"
      },
      "id": "6072565d28ccbc6baf51c18b"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-04-11T13:57:58Z",
      "title": "",
      "updated_at": "2021-04-11T13:57:58Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.0481,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> user interface components to your application",
        "body": " functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll <em>add</em> <em>headings</em> to clarify what each <em>chart</em> represents. Third, you&#x27;ll <em>add</em> descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section"
      },
      "id": "6073006628ccbce73151c12f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Delayed-Jobs-New-Relic-1024x837.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/monitoring-delayedjob",
      "sections": [
        "Related Topics"
      ],
      "published_at": "2021-04-14T00:06:04Z",
      "title": "Monitoring DelayedJob",
      "updated_at": "2021-04-14T00:06:04Z",
      "type": "",
      "external_id": "2e9c1f784c773aa1fa509a112bcd338cac37c70e",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Monitoring DelayedJob Sep 12, 2012 • 6 min read By Bill Kayser Like many Ruby shops we use the DelayedJob job runner to run many of our background tasks. The New Relic agent has had some basic DelayedJob instrumentation for a while now but until recently you were limited to a few metrics which could only be viewed using the somewhat limited and unwieldy custom charts. But no longer! In the latest release of the Ruby Agent we are sending much richer, useful metrics for DelayedJob workers, and the recently released Custom Dashboards allows you to to build a truly useful view for monitoring and troubleshooting your jobs. Here's what it looks like: This is a Custom Dashboard we built for our DelayedJobs workers running in production. Below, I'll show you the steps to create this in your own New Relic account. But first let me explain what we are looking at. There are four graphs with data reported by the agent running in the DelayedJob worker. Job Queue Length shows the number of jobs waiting to be executed at any given time, based on one minute samples. We break out these numbers by priority since we manage separate workers in three different priority levels. In the graph above, you can see that our highest priority worker maintains a pretty healthy queue while we get a few spikes in our low priority worker every now and then, since the jobs in the low priority queue tend to run a little longer. In our configuration, we destroy jobs when they've run successfully and leave the failed ones. The agent polls the failed jobs and reports the count which we graph in the Failed Jobs chart. We pay particular attention to this chart during a deploy to look for any jump in failing jobs caused by a regression. Locked Jobs is particularly interesting. Jobs are locked while executing, so the number of jobs locked at any given time should not exceed the number of workers. With idle workers, the count will be low. With workers fully utilized, the number will approach the total number of workers. We find you do have to be careful as some jobs occasionally fail without clearing their lock, so you have to manually clear those out. But you can use the Locked Jobs graph as a gauge of your overall worker utilization. The Average Job Execution time graph is simply a graph of the average response time of the DelayedJob transactions. Creating a Custom Dashboard for DelayedJobs Let's walk through the steps to get this set up in a typical account. The first thing you need is the current version of the Ruby Agent gem. You must be running at least version 3.4.2. Then follow these steps in the New Relic application: 1) Select the application where DelayedJob is running. In our case it's \"Background Jobs\". 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and \"Grid\" chart type. 3) Choose Add chart to add the first chart to your dashboard.  Fill in the basic properties, including the titles and chart type, which is \"Stacked Area.\" 4) Select the DelayedJob queue lengths for the graph. Start typing in Workers/. Initially it will say the metric doesn't exist, but when you enter the slash it will display the list of available metrics in the Workers namespace. Keep typing Workers/DelayedJob/queue_length/priority/*.  The metrics will auto-complete as you enter each segment. The asterisk at the end indicates that you want to break down the graph by priority. If you don't use priorities you can chart a single line for the queue length using the metric name Workers/DelayedJob/queue_length/all. 5. That's generally good enough to display the chart, but there are a couple of other properties you can customize. In our case, we removed the limit on the number of different priorities it will show, added \"jobs\" to the y-axis labels, and fixed the application to \"RPM Background\" where the DelayedJob agent reports to. Here's what it looks like: 6. Add the Failed Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking failed jobs: Workers/DelayedJob/failed_jobs. 7. Add the Locked Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking locked jobs: Workers/DelayedJob/locked_jobs. 8. Add the Job Execution Time chart. Repeat steps 3 - 5 but enter the metric for the response time of delayed jobs:  OtherTransaction/DelayedJob/all. We show execution time in milliseconds so we chose To Milliseconds for the Number Format and \"ms\" as the y-axis unit label. We also hide the legend. That's enough to get you started with a good dashboard for monitoring your DelayedJob workers. But you don't have to stop there. You can add a table showing you the summary metrics for each job or a breakdown chart of all the jobs. In addition to showing the response time of jobs, you could chart the throughput. We combine our staging and production servers onto one dashboard by duplicating the charts and picking a different application. Custom Dashboards now makes it easy to configure the charts for the exact data you want to display. If you haven't already, try New Relic today to see how you can improve the performance of your Ruby applications. And as always, we welcome your feedback on this post. Let us know what you think of Custom Dashboards and how you're using them to monitor your applications. Related Topics APM By Bill Kayser Bill has been with New Relic from the beginning as both a developer and a data scientist. Having worked in application performance management for nearly two decades, his role now entails discovering new ways of exploring and interpreting data as well as prototyping innovative new features. Follow the author Bill Kayser on Twitter Bill Kayser on GitHub Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.25891,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " in the New Relic application: 1) Select the application where DelayedJob is running. In our case it&#x27;s &quot;Background Jobs&quot;. 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and &quot;Grid&quot; <em>chart</em> type. 3) Choose <em>Add</em> <em>chart</em> to <em>add</em> the first <em>chart</em> to your dashboard.  Fill"
      },
      "id": "607631ece7b9d201aea5c63a"
    }
  ],
  "/build-apps/ab-test/persist-version": [
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/persist-version/embed/",
      "sections": [
        "Persist the selected version",
        "Course"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:17Z",
      "type": "",
      "external_id": "000f29685ee92dffc2ce7e70539ee1663037ffcb",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a section to end your test, before starting this one. In the previous lesson, you created a section of your application that allows you to pick the most effective design from your A/B test. The goal of this section is to end the test once you’ve selected a winner: When you select a version from this form, the selection does not persist in the Select component. Now, it’s time to implement that behavior. Step 1 of 11 Change to the persist-selected-version directory of the coursework repository: bash Copy $ cd nru-programmability-course/persist-selected-version Step 2 of 11 In end-test.js, initialize EndTestSection.state with a default selectedVersion field: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 3 of 11 Pass the selectedVersion, as a prop, to VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 4 of 11 Supply the selectedVersion to your Select component in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 5 of 11 Create a method, selectVersion(), that updates EndTestSection.state: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy You must bind selectVersion to the EndTestSection component so it can access state. Step 6 of 11 Pass the method to VersionSelector as a prop: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 7 of 11 Set selectVersion as the onChange callback in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 8 of 11 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 9 of 11 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 10 of 11 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 11 of 11 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Voila! When you select a new version as the winner of the A/B test, that version is reflected in the menu. However, when you press End test, nothing happens. In the next lesson, you'll create a confirmation dialog to protect yourself from prematurely ending your A/B test. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Present an end test confirmation modal.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1444.1764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Persist</em> <em>the</em> <em>selected</em> <em>version</em>",
        "body": " does not <em>persist</em> in the <em>Select</em> component. Now, it’s time to implement that behavior. Step 1 of 11 Change to the <em>persist</em>-<em>selected</em>-<em>version</em> directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>persist</em>-<em>selected</em>-<em>version</em> Step 2 of 11 In end-test.js, initialize"
      },
      "id": "60730001196a67905864a75f"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/embed/",
      "sections": [
        "Add a section to end your test",
        "Course"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "6c1d9d3997eff7f27d00dbf9c8f451f5bec750d9",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add version descriptions, before starting this one. In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Persist the selected version.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1230.9219,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " that <em>Select</em> displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to <em>persist</em> your <em>version</em> choice in the <em>Select</em> component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Persist</em> the <em>selected</em> <em>version</em>."
      },
      "id": "6072569228ccbc8f6151c174"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/embed/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:16Z",
      "type": "",
      "external_id": "58de68bd963cdd2062e88db55cb90ad124055eb6",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to take use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy PlatformStateContext.Consumer provides access to the platform's URL state. This state contains two important values for you to use in this context: accountId timeRange Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your nerdlet, you can use accountId from the platform URL state. Step 3 of 10 Use platformState.accountId in your NrqlQuery: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Next, notice that your query uses a SINCE clause, which identifies the historical timeframe your query should fetch data from. Step 4 of 10 Utilize platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. Tip While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery is now using the account ID, which it got from platform state. It's also using the platform state's time range, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 641.5722,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ": &lt;PlatformStateContext.Consumer&gt; {(platformState) =&gt; { console.log(platformState.timeRange.duration); }} &lt;&#x2F;PlatformStateContext.Consumer&gt;; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course&#x2F;<em>persist</em>-<em>selected</em>-<em>version</em>&#x2F;ab-test. Step 6 of 10 Generate a new UUID"
      },
      "id": "6073000164441f84ce9d853d"
    },
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/embed/",
      "sections": [
        "Present an end test confirmation modal",
        "Course",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-04-11T13:52:26Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "554a84f8fe2faf9c2b867686538360771e22fc3c",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Persist the selected version, before starting this one. In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 View your application: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. View your application where the modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add NrqlQuery components to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 528.97266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>the</em> <em>version</em> you <em>selected</em> in your modal",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Persist</em> the <em>selected</em> <em>version</em>"
      },
      "id": "6072565e64441f34dd9d8548"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:18Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 3014918 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.16617,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", BlockText, Button, Grid, GridItem, HeadingText, Modal, <em>Select</em>, <em>Select</em>Item, } from &#x27;nr1&#x27;; class <em>Version</em>Selector extends React.Component { constructor(props) { super(props); } render() { return &lt;<em>Select</em> onChange={this.props.<em>selectVersion</em>} value={this.props.<em>selectedVersion</em>}&gt; &lt;<em>Select</em>Item value"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    }
  ],
  "/build-apps/ab-test/nerdstoragevault": [
    {
      "image": "https://developer.newrelic.com/static/9fef87cd4b59ba7b2e8df08c97bd3b85/ba3ac/incorrect-auth-header.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/embed/",
      "sections": [
        "Fetch data from a third-party service",
        "Course"
      ],
      "published_at": "2021-04-11T14:00:18Z",
      "title": "",
      "updated_at": "2021-04-07T01:54:54Z",
      "type": "",
      "external_id": "5a9959f254359afeec9b0a9a9f39dd8b83d8c1ee",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorageVault from your nerdlet, before starting this one. In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -h 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add PlatformStateContext to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1830.4087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Fetch data <em>from</em> a third-party service",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Access</em> <em>NerdStorageVault</em> <em>from</em>"
      },
      "id": "606d10ee28ccbc1cd5e1c991"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:18Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 3014918 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 879.7362,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "body": " categories of data, it&#x27;s not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you&#x27;d use <em>NerdStorageVault</em>. Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. Continue on to the next lesson: <em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>nerdlet</em>."
      },
      "id": "607256cae7b9d2df5ba5c67c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:23:32Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 803.9215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to <em>NerdStorageVault</em> - New Feature!",
        "body": " to the catalog Intro to <em>NerdStorageVault</em> - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store <em>your</em> data. <em>NerdStorageVault</em> lets you store and retrieve sensitive data secrets such as: Personal <em>access</em> tokens License keys API keys Other third-party"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/embed/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Course",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-04-11T13:55:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:55:24Z",
      "type": "",
      "external_id": "f2af52e45942b4cf9499282a654340b132766741",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorage from your nerdlet, before starting this one. Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in .componentDidMount(), you've queried NerdGraph for your api_token data. .componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives .showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your nerdlet's state is the current token that your nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called .componentDidUpdate(). Now, every time your nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers .componentDidUpdate(). In .componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Fetch data from a third-party service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 726.71875,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "body": ". The secure data store you&#x27;ll use is called <em>NerdStorageVault</em>. It&#x27;s different <em>from</em> <em>NerdStorage</em>, which you used in the last lesson, because it only supports user <em>storage</em> and encrypts its data. Store <em>your</em> API token Step 1 of 3 Change to the add-<em>nerdstoragevault</em> directory of the coursework repository: bash"
      },
      "id": "6072ffcd64441f6cc09d8544"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/embed/",
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "027dd39d82c1996136231ffad1636034152cf482",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 533.3823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Using <em>NerdStorageVault</em> in <em>your</em> apps",
        "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use <em>NerdStorageVault</em> to store data in an encrypted <em>storage</em> solution. Using <em>NerdStorageVault</em> in <em>your</em> apps <em>NerdStorageVault</em> is used to store and retrieve sensitive secrets data"
      },
      "id": "6063d5f3e7b9d2632f70376b"
    }
  ],
  "/build-apps/ab-test/version-descriptions": [
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions",
        "Course"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart headings, before starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 7 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 2 of 7 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 3 of 7 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 4 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 5 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 7 of 7 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add a section to end your test.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 986.49084,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>version</em> <em>descriptions</em>",
        "body": " starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you&#x27;ll continue that trend by creating <em>descriptions</em> for each design <em>version</em> in your A&#x2F;B test. Step 1 of 7 In nerdlets&#x2F;ab-test-nerdlet, <em>add</em>"
      },
      "id": "6072569228ccbc932d51c172"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings",
        "Course"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a grid, before starting this one. Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add version descriptions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 800.40735,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> chart headings",
        "body": " into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it&#x27;d be nice to <em>add</em> <em>descriptions</em> to help you remember what each <em>version</em> in your A&#x2F;B test represents. In the next lesson, you&#x27;ll <em>add</em> a description for each design"
      },
      "id": "6072ff1928ccbc140b51c16e"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/embed/",
      "sections": [
        "Add a section to end your test",
        "Course"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "6c1d9d3997eff7f27d00dbf9c8f451f5bec750d9",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add version descriptions, before starting this one. In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Persist the selected version.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 755.6128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a section to end your test",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>version</em> <em>descriptions</em>"
      },
      "id": "6072569228ccbc8f6151c174"
    },
    {
      "image": "https://developer.newrelic.com/static/b9344bea39589c73def76207c066da73/e49c0/screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/embed/",
      "sections": [
        "Describe your app for the catalog",
        "Course",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "baf09ac55fe0770a7b7de7102f2a2a7a463d49de",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add navigation to your nerdlet, before starting this one. In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your nerdpack. Step 1 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/describe-app/ab-test. Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create -t catalog This creates a catalog directory with template files for inputting custom information about your application. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory: Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Publish your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.94116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " and <em>version</em> <em>descriptions</em> in local storage. We can use this app for future A&#x2F;B tests as well! Copy For this course, you&#x27;re keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source"
      },
      "id": "606e63d8e7b9d201e9bfa819"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-04-11T13:57:58Z",
      "title": "",
      "updated_at": "2021-04-11T13:57:58Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.57666,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> user interface components to your application",
        "body": " functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll <em>add</em> headings to clarify what each chart represents. Third, you&#x27;ll <em>add</em> <em>descriptions</em> for your A and B design versions to the top of your app. Finally, you’ll create a section"
      },
      "id": "6073006628ccbce73151c12f"
    }
  ],
  "/build-apps/ab-test/nerdstorage": [
    {
      "image": "https://developer.newrelic.com/static/9fef87cd4b59ba7b2e8df08c97bd3b85/ba3ac/incorrect-auth-header.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/embed/",
      "sections": [
        "Fetch data from a third-party service",
        "Course"
      ],
      "published_at": "2021-04-11T14:00:18Z",
      "title": "",
      "updated_at": "2021-04-07T01:54:54Z",
      "type": "",
      "external_id": "5a9959f254359afeec9b0a9a9f39dd8b83d8c1ee",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorageVault from your nerdlet, before starting this one. In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -h 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add PlatformStateContext to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1589.2815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Fetch data <em>from</em> a third-party service",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Access</em> <em>NerdStorage</em>Vault <em>from</em>"
      },
      "id": "606d10ee28ccbc1cd5e1c991"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/embed/",
      "sections": [
        "Customize NRQL data",
        "Course",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T14:01:47Z",
      "type": "",
      "external_id": "f51f9d86d3b873b24e967c687d5408eb9918a33f",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add NrqlQuery components to your nerdlet, before starting this one. In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your nerdpack served locally, view your application to see your charts serving real data: In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorage from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1475.8787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Merge NRQL <em>from</em> multiple sources",
        "body": " version Past tests Unfortunately, <em>your</em> demo application doesn&#x27;t create custom New Relic events when a user unsubscribes <em>from</em> <em>your</em> newsletter or you end an A&#x2F;B test. In the next lesson, you&#x27;ll learn how to use <em>Nerd</em>Graph and <em>NerdStorage</em> to populate Past tests. Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. Continue on to the next lesson: <em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>nerdlet</em>."
      },
      "id": "6073014b28ccbc70b651c134"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:18Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 3014918 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1009.1487,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "body": " categories of data, it&#x27;s not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you&#x27;d use <em>NerdStorage</em>Vault. Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. Continue on to the next lesson: <em>Access</em> <em>NerdStorage</em>Vault <em>from</em> <em>your</em> <em>nerdlet</em>."
      },
      "id": "607256cae7b9d2df5ba5c67c"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/embed/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Course",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-04-11T13:55:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:55:24Z",
      "type": "",
      "external_id": "f2af52e45942b4cf9499282a654340b132766741",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorage from your nerdlet, before starting this one. Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in .componentDidMount(), you've queried NerdGraph for your api_token data. .componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives .showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your nerdlet's state is the current token that your nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called .componentDidUpdate(). Now, every time your nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers .componentDidUpdate(). In .componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Fetch data from a third-party service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 870.15796,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application <em>from</em> the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em>"
      },
      "id": "6072ffcd64441f6cc09d8544"
    },
    {
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/embed/",
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "67c529a70a60d530860fbe80be795d214798dfd9",
      "popularity": 1,
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 445.04077,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Query data <em>from</em> <em>NerdStorage</em>",
        "body": " .&#x2F;nerdlets&#x2F;use-<em>nerdstorage</em>-<em>nerdlet</em>&#x2F;index.js file in the text editor of <em>your</em> choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addTo<em>NerdStorage</em>, and you need to update it to add User<em>Storage</em>Mutation The User<em>Storage</em>"
      },
      "id": "6066782e64441f577f617a9d"
    }
  ],
  "/build-apps/ab-test/catalog": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/publish/embed/",
      "sections": [
        "Publish your New Relic One application",
        "Course",
        "Versions and tags",
        "Tip",
        "Publish your first application",
        "Technical detail",
        "View your application in the catalog",
        "Submit catalog information",
        "Update your version tag"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:17Z",
      "type": "",
      "external_id": "41ee1ef02494dc82084533ad141ff3202f8ae2d4",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Describe your app for the catalog, before starting this one. In the last lesson, you created catalog information for the A/B test app you've been building throughout this course. Now, it's time to publish your app to the New Relic One catalog and submit those catalog details. Versions and tags Publishing an application requires two key pieces of information: version tag An application's version identifies the code it contains and is stored in the nerdpack's root-level package.json file. Every time you modify code in your nerdpack and are ready to release it, you'll update the version in package.json. For example, if you fix some bugs in the first major version your application code, you might publish the changes under version 1.0.1. An app version's tags describe its state. For example, version 0.0.1 of a work-in-progress application might be published with a DEV tag to indicate that it's in development. Tip There are some rules governing how you can use tags and you can read about those in our tags documentation. Publish your first application Step 1 of 6 Change to the publish directory of the coursework repository: bash Copy $ cd nru-programmability-course/publish This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/publish/ab-test. Step 3 of 6 Generate your own app UUID: bash Copy $ nr1 nerdpack:uuid -gf The UUID is used to identify your app in the New Relic One app registry. Because you're using code that we developed for this course, an application with the existing UUID already exists in the registry. By generating your own, you're now able to publish this application. Technical detail The UUID also ties your app to your account and, therefore, allows the application to make Nerdgraph requests on behalf of the account that installed it. Step 4 of 6 In package.json, set version to 1.0.0: { \"private\": true, \"name\": \"ab-test\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"2d923ba6-d231-4dd3-830f-b1923577a422\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } Copy New Relic One uses semantic versioning and, under this convention, 1.0.0 signals the first major release. Now, you're ready to publish! Step 5 of 6 Publish your New Relic One application: bash Copy $ nr1 nerdpack:publish -t DEV That's it! You published your application to New Relic's registry. The -t parameter specifies a tag for your published version. Among other logs, you should see the following confirmation in your console: bash Copy Publishing Nerdpack AbTest (9da77738-9cf6-43c7-9ba0-e3a8c6ac7380) ✔ Nerdpack published successfully! ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as DEV. For now, you've tagged the 1.0.0 release as DEV because it's still a work in progress. Step 6 of 6 View your app's registry information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 4 Version Date Tags ------- ------------- ------ 1.0.0 5 minutes ago DEV The results of this command detail the information stored in New Relic's registry for your application, including its UUID, version, and account ID. View your application in the catalog Now that your application is published and tagged, you can view it in the New Relic One app catalog. Step 1 of 3 Go to New Relic. Notice that you're not using the ?nerdpacks=local querystring parameter. You don't need it anymore because you're not serving your app locally. Step 2 of 3 From the homepage, navigate to Apps: From here, you can see your application under New Relic One catalog: Notice that this is different than when you locally served your app. Local apps and published apps you're subscribed to show under Your apps instead. Step 3 of 3 Click on your app to see more details: Notice the release date and app version. This page should show the information you created in the last lesson. It doesn't yet, because you haven't submitted that information to the catalog, and publishing your app doesn't do that for you. Submit catalog information Even though you've published your application, there are some things that the catalog doesn't know about. These are the descriptions, screenshots, and metadata you created in the last lesson. nr1 catalog is used to submit and view this information. Step 1 of 3 Submit your catalog information: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for AbTest 1.0.0 If everything goes right, you should see a success message notifying you that the screenshots and metadata were updated. You may, however, get an error when submitting this information to the catalog: bash Copy Uploading screenshots... › Error: 1 error while updating AbTest 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN If you do, try again in a minute or two. It can take a few seconds for the catalog to update with the new version of your application. If that doesn't work, make sure you published your app with nr1 nerdpack:publish. Step 2 of 3 View your catalog information: bash Copy $ nr1 catalog:info description: Nerdpack ab-test details: Display test data for our newsletter subscription A/B test displayName: AbTest icon.url: https://nr3.nr-ext.net/artifact-index-production/a685fec2-29fb-40b0-9f65-4178... previews.0.url: https://application-catalog-production.s3.us-east-2.amazonaws.com/nerdpacks/a... releaseDate: 2021-03-12T15:46:09.600138Z repository: https://github.com/newrelic-experimental/nru-programmability-course tagline: Win @ newsletter subscriptions version: 1.0.0 whatsNew.changes: Initial release! Includes: - A variety of charts for understanding the test r... whatsNew.version: 1.0.0 All the information from catalog shows here. Step 3 of 3 View your app in the catalog: Notice the tagline on the app's catalog entry. Click on the app to see more: Here, you see app details, a documentation tab, release notes, and screenshots. Update your version tag Your app looks great in the catalog, complete with metadata, images, and documentation. Before, you tagged the app as DEV because all of the information wasn't ready for public consumption. Now, it is. It's time to update your version tag. Step 1 of 2 Update your 1.0.0 app version from DEV to STABLE: bash Copy $ nr1 nerdpack:tag -t STABLE ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as STABLE. Without specifying a version, nr1 uses the version specified in package.json. You can specify a version with the -V command. Learn more about nerdpack:tag with the nr1 nerdpack:tag --help command. Step 2 of 2 View your app information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ------------- ------ 1.0.0 30 minutes ago STABLE The app is now tagged with STABLE, indicating it's ready for public use. Technical detail Even though the app is ready for public use, it's still only visible to users of your account. Other accounts can't see apps created by other private accounts unless those apps are added to the public New Relic One catalog. Now that your app is published and its metadata is submitted, you can subscribe your account to the app from the catalog. In the next lesson, you'll learn the ways to subscribe and unsubscribe to your new application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Subscribe to your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1455.9263,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View <em>your</em> <em>application</em> in <em>the</em> <em>catalog</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Describe</em> <em>your</em> <em>app</em>"
      },
      "id": "60730001e7b9d2de18a5c660"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course"
      ],
      "published_at": "2021-04-11T14:00:18Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to lookup the application user's account ID and the time range they selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your nerdlet. You can also use navigation for other nerdlets and launchers. Step 1 of 10 Change to the add-navigation directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now openApmEntity() knows that entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you've created a button and configured it to call .openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row but the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application: Click App performance: Now you see the stacked entity! Congratulations! You're finished writing all the code you'll write for you New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo application that is running an A/B test. You've created several charts, buttons, and other UI elements. You've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and out of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to deploy and subscribe to your New Relic application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1317.9318,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add navigation to <em>your</em> Nerdlet",
        "body": " development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Describe</em> <em>your</em> <em>app</em> for the <em>catalog</em>."
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "image": "https://developer.newrelic.com/static/b9344bea39589c73def76207c066da73/e49c0/screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/embed/",
      "sections": [
        "Describe your app for the catalog",
        "Course",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "baf09ac55fe0770a7b7de7102f2a2a7a463d49de",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add navigation to your nerdlet, before starting this one. In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your nerdpack. Step 1 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/describe-app/ab-test. Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create -t catalog This creates a catalog directory with template files for inputting custom information about your application. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory: Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Publish your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.71512,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Describe</em> <em>your</em> <em>app</em> <em>for</em> <em>the</em> <em>catalog</em>",
        "body": " by showing and telling them what the <em>app</em> does, how to use it, and more. Create <em>catalog</em> information To supply information to the <em>catalog</em> about <em>your</em> <em>app</em>, you need to create the <em>catalog</em> directory in <em>your</em> nerdpack. Step 1 of 6 Navigate to the root of <em>your</em> Nerdpack at nru-programmability-course&#x2F;<em>describe</em>"
      },
      "id": "606e63d8e7b9d201e9bfa819"
    },
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T13:58:44Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a nerdpack, launcher, and nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.80292,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Subscribe to <em>your</em> New Relic One <em>application</em>",
        "body": " application, before starting this one. In the last lesson, you published <em>your</em> A&#x2F;B test <em>app</em> to the New Relic One <em>catalog</em>. You then submitted <em>your</em> <em>app</em>&#x27;s description, metadata, documentation, and screenshots. Now, it&#x27;s time to subscribe <em>your</em> account to the published <em>app</em>. Subscribe to <em>your</em> application"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.34772,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>The</em> Most Popular New Relic One <em>Applications</em> (Roundup #5)",
        "sections": "Subscribe to <em>applications</em> with <em>the</em> New Relic One <em>Catalog</em>",
        "body": " Relic One <em>Catalog</em> launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the <em>app</em> to add the application to the account you wish to grant access. If <em>your</em> team changes, and you need"
      },
      "id": "60762e1f64441fbf2e9d856e"
    }
  ],
  "/build-apps/ab-test/chart-group": [
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/embed/",
      "sections": [
        "Add a chart group",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "e94780ac131f1a4ce5999771f9bee9650d4f5e9b",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add tables, before starting this one. In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add user interface components to your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1510.6311,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> <em>chart</em> <em>group</em>",
        "body": " response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll <em>group</em> them with a <em>ChartGroup</em> and specify that their values are measured in milliseconds. Step 1 of 9 Change to the <em>add</em>-a-<em>chart</em>-<em>group</em> directory of the coursework repository: bash Copy $ cd nru"
      },
      "id": "6072ff19e7b9d25dbba5c689"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-04-11T13:57:58Z",
      "title": "",
      "updated_at": "2021-04-11T13:57:58Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1444.6545,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> user interface components to your <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> a <em>chart</em> <em>group</em>, before"
      },
      "id": "6073006628ccbce73151c12f"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Course",
        "Extra credit"
      ],
      "published_at": "2021-04-11T14:01:09Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add pie charts, before starting this one. In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a chart group.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1222.4792,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> tables",
        "body": " looking at a code sample. This practice will reinforce what you&#x27;ve learned in this lesson. If you need help, review the <em>add</em>-a-<em>chart</em>-<em>group</em> directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each <em>chart</em> you’ll <em>add</em>"
      },
      "id": "60725692196a67b68c64a778"
    },
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/embed/",
      "sections": [
        "Add a grid",
        "Course",
        "Technical detail"
      ],
      "published_at": "2021-04-11T14:01:08Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "bfd5e04da0f000d6970b16677cd5faf8c3b2f461",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add user interface components to your application, before starting this one. In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add chart headings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.67252,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> grid",
        "body": ", import Grid and GridItem. Then, update your nerdlet&#x27;s render() method by placing each <em>chart</em> in a GrildItem. Finally, place all your items in a Grid: import React from &#x27;react&#x27;; import { <em>ChartGroup</em>, Grid, GridItem } from &#x27;nr1&#x27;; import NewsletterSignups from &#x27;.&#x2F;newsletter-signups&#x27;; import PastTests from"
      },
      "id": "6072565d28ccbc6baf51c18b"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions",
        "Course"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart headings, before starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 7 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 2 of 7 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 3 of 7 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 4 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 5 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 7 of 7 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add a section to end your test.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.3252,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> version descriptions",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>chart</em> headings, before"
      },
      "id": "6072569228ccbc932d51c172"
    }
  ],
  "/build-apps/ab-test/pie-charts": [
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/embed/",
      "sections": [
        "Add pie charts",
        "Course"
      ],
      "published_at": "2021-04-11T13:55:24Z",
      "title": "",
      "updated_at": "2021-04-11T13:55:23Z",
      "type": "",
      "external_id": "c0f472d2ed9df8035313cd76ee83ec43e75d0a4a",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add your first chart, before starting this one. You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add tables.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1762.2156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>pie</em> <em>charts</em>",
        "body": " serving your application. Your application is starting to take shape. You’ve created a line <em>chart</em> and two <em>pie</em> <em>charts</em>. For now, these <em>charts</em> use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your <em>charts</em>, however, you’ll learn how to <em>add</em> a table"
      },
      "id": "6072ffcc28ccbc786651c18a"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Course",
        "Extra credit"
      ],
      "published_at": "2021-04-11T14:01:09Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add pie charts, before starting this one. In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a chart group.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 886.49695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> tables",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>pie</em> <em>charts</em>, before"
      },
      "id": "60725692196a67b68c64a778"
    },
    {
      "image": "https://developer.newrelic.com/static/733ffe1b10df224863d5c0b4f69894ce/0086b/first-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/first-chart/embed/",
      "sections": [
        "Add your first chart",
        "Course"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:17Z",
      "type": "",
      "external_id": "a6647ae7e6f32626783c432c4c7a2d4e0d896f8d",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart components to your A/B test application, before starting this one. In this course, you’re building an A/B test application for the New Relic platform. Previously, you learned about the New Relic One SDK and its component library. Now, It’s time for you to start building your application focusing first on chart components. Before you write any code, consult your design guide to remember what the application will look like when you finish: There are several charts you need to create, which may seem overwhelming at first, but take it one step at a time. The topmost chart, and the first you’ll create, is a line chart that shows the number of users who sign up for your newsletter and what version of your website they were shown. Step 1 of 8 Change to the add-your-first-chart directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-your-first-chart This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named newsletter-signups.js: bash Copy $ touch newsletter-signups.js Step 3 of 8 In this new file, create a component called NewsletterSignups to hold your first LineChart and some mock data: import React from 'react'; import { LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <LineChart data={[versionASignups, versionBSignups]} fullWidth /> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you’ve created two arbitrary data series which represent versions A and B of your test. Right now, you're using manually-crafted data points. In the future, you'll replace these with data queried from New Relic. Notice that you’ve specified a color for each series in the chart. The color metadata attribute takes any CSS-acceptable color format. Setting viz: 'main' means that you want to render the LineChart series as a line, the component's default display style. For the data prop in the LineChart component, you passed the two series in an array so that both are represented together. Finally, you used the chart’s fullWidth prop to stretch the chart’s width to fill the view. Step 4 of 8 In your Nerdlet's index.js file, import your new component and replace the default heading in your Nerdlet's render() method with your new component: import React from 'react'; import NewsletterSignups from './newsletter-signups'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-your-first-chart/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the LineChart displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. In seven steps, you’ve breathed life into your New Relic One application. Instead of a bland “Hello world” message, your application now shows a colorful line chart with two mocked data series. These data series represent server-side traffic for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another chart type. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add pie charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 841.65015,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> your first <em>chart</em>",
        "body": " for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another <em>chart</em> type. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> <em>pie</em> <em>charts</em>."
      },
      "id": "607256c964441f74479d8559"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings",
        "Course"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a grid, before starting this one. Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add version descriptions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.36887,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>chart</em> headings",
        "body": ": The design guide details what data each <em>chart</em> shows. Use those details to craft useful headings for your <em>charts</em>. Step 1 of 6 Change to the <em>add</em>-<em>chart</em>-headings directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-<em>chart</em>-headings Step 2 of 6 In newsletter-signups.js, page"
      },
      "id": "6072ff1928ccbc140b51c16e"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/embed/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "Course",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-04-11T14:01:08Z",
      "title": "",
      "updated_at": "2021-04-11T14:01:08Z",
      "type": "",
      "external_id": "43c5fb39b73ee2dbbe5f216a577ff77051fcc513",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Present an end test confirmation modal, before starting this one. In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 View your changes: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 2 of 2 With your nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Customize NRQL data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.18207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Populate <em>charts</em> with pageView event data",
        "body": ", <em>pie</em> <em>charts</em>, and table <em>charts</em>. Each of these <em>charts</em> currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost <em>chart</em>: Newsletter subscriptions per version. With the query you&#x27;ve built in the Data explorer, you already have the data you need"
      },
      "id": "60730124196a6731e464a778"
    }
  ],
  "/build-apps/ab-test/demo-setup": [
    {
      "image": "https://developer.newrelic.com/static/555c6dd44f2ffbceff682f7fbc78e01c/ba3ac/demo-service.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/demo-setup/embed/",
      "sections": [
        "Spin up your demo services",
        "Course",
        "Important"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "ec4e6154accdaf3768fc5b029e77e94337973ed8",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Before you build your New Relic One application, you need to spin up your demo services. This coursework depends on two important services: A web service that shows a newsletter signup form. The form's heading text alternates between two versions because you're performing an A/B test to determine which text leads to more high-quality subscriptions. A simulator service that sends steady traffic to the website so that you don't have to manually generate data To spin up your demo services, you first need to install Docker and Docker compose. Spin up your demo services Step 1 of 5 Clone the coursework repository from GitHub: bash Copy $ git clone https://github.com/newrelic-experimental/nru-programmability-course This repository contains code for creating NodeJS New Relic automations. It also contains a an app code directory for each lesson in the course. You'll use these directories to follow along with the course content. Step 2 of 5 Change to the demo directory, called ab-test-app: bash Copy $ cd nru-programmability-course/ab-test-app This directory contains configuration files and READMEs for using the demo. Step 3 of 5 Build and run the web service and simulator containers, using docker-compose: bash Copy $ NEW_RELIC_LICENSE_KEY=<your New Relic license key> docker-compose up -d Important Make sure you replace <your New Relic license key> with your actual license key. Once it's finished, view the website at localhost:3001: Step 4 of 5 Visit New Relic, and navigate to APM in the top navigation menu. Select Newsletter from the list of instrumented services: You may have to wait a minute or two for New Relic to recieve data from your demo services. Once it's ready, you'll see transaction data, such as performance, throughput, and an Apdex score: Step 5 of 5 To spin down your demo services, run docker-compose down from your ab-test-app directory: bash Copy $ docker-compose down Now you're ready to build your New Relic One application! The first step is to install and configure the New Relic One CLI. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Install and configure the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2219.0522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Spin</em> <em>up</em> <em>your</em> <em>demo</em> <em>services</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground <em>up</em>. If you haven&#x27;t already, check out the course introduction. Before you build <em>your</em> New Relic One application, you need to <em>spin</em> <em>up</em> <em>your</em> <em>demo</em> <em>services</em>. This coursework depends on two"
      },
      "id": "6072ff1928ccbc111f51c16a"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:16Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: You use this key to associate your New Relic account with the CLI. The CLI then uses the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name>, the <User key>, and the region (either us or eu) with real values. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1337.7024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground <em>up</em>. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Spin</em> <em>up</em> <em>your</em> <em>demo</em> <em>services</em>"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/6-Snowflake-new-orders-received.png",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-snowflake-integration",
      "sections": [
        "Detect and resolve warehouse performance issues",
        "Optimize costs, credits used",
        "Detect potential security issues and failed logins",
        "Monitoring and alerting custom Snowflake data",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:25:02Z",
      "title": "New Relic Snowflake Integration Boosts Observability",
      "updated_at": "2021-04-13T23:25:02Z",
      "type": "",
      "external_id": "03e7785a57d3c95f9665eb6cb43c0b27760405e9",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Integrations New Relic Snowflake Integration Boosts Observability Jan 12, 2021 • 6 min read By Daniel Fitzgerald Snowflake, a data platform company that provides a scalable infrastructure in the cloud, can meet a diverse set of needs, from building a data lake to data warehousing, reporting, and analytics. This versatility, plus the benefits of running in the cloud, such as low maintenance and access to massive scale, means that more and more companies are turning to Snowflake. Like any piece of critical infrastructure, once Snowflake starts to play a key role in delivering value to a company or set of users, it’s critically important to make sure it’s secure, performant, and delivers the data you need in a timely fashion. That sounds like a job for New Relic. We are introducing our Snowflake integration, which gives you a broad view of how Snowflake is working across the following areas: costs, performance, security, and availability. In this post, we’ll walk through some key use cases to help you: Detect and resolve warehouse performance issues Optimize costs—whether that’s expensive queries, users running many queries, or warehouses that contribute the most to your bill Detect potential security issues and failed logins Monitor and alert on custom Snowflake data Detect and resolve warehouse performance issues In Snowflake, a virtual warehouse is a massively parallel processing (MPP) cluster, which you can spin up on-demand to execute user queries. Virtual warehouses can be different sizes for different workloads. If a warehouse doesn’t have enough capacity to run the queries in-memory, it will spill some bytes to the disk or remote storage. When this happens, there is a significant impact on query performance. Keep an eye on these metrics, consider setting up alerts to see when these cases happen, and think about increasing the size of virtual warehouses that experience these symptoms. Warehouse size also impacts the number of queries that you can process at any one time. A sign that a cluster needs to be resized is when you see disk spillage (bytes spilled to local or remote storage) or queries being queued. Here are two queries you can use to detect each of these scenarios: SELECT average(BYTES_SPILLED_TO_LOCAL_STORAGE_AVERAGE)FROM SnowflakeVirtualWarehouse WHERE metric_type = 'snowflake.query_performance' SELECT average(QUEUED_LOAD_AVERAGE) FROM SnowflakeVirtualWarehouse WHERE metric_type = 'snowflake.warehouse_performance' You can use New Relic Alerts to tell you when a warehouse is queueing queries and should be resized. If an alert triggers, you can resize the warehouse or increase the maximum number of clusters if you have the multi-cluster warehouses setting enabled. A key area for performance improvements is pinpointing inefficient or poorly written queries. In the chart below, we can detect when Snowflake is spending long periods compiling and executing queries. If you detect a spike in these times, you can dive in further to pinpoint which queries are causing the impact and optimize them to be more efficient. Optimize costs, credits used One of Snowflake’s key benefits is its consumption-based pricing model that allows you to spin up new capacity instantly. Of course, with great power comes great responsibility. Like any consumption-based system, it’s easy to spend more than you mean to; that’s why it’s important to keep an eye on costs and alert when spend goes over an acceptable level. Using a linear prediction function, you can predict when a warehouse spend is likely to reach a certain level in the future based on historical data. You can also alert when a particular warehouse spend goes over a certain amount using NRQL alerts, which can help you get an instant notification if a spend goes above a certain threshold, preventing an unexpected bill due to user error or misconfiguration. Detect potential security issues and failed logins Maintain the security of your Snowflake account by looking at who is logging in. You can track the number of logins, whether they are successful or failed logins, and the  method used, such as an ODBC Connector, via the UI or using a programmatic interface such as the Python driver. A rise in the number of failed logins can indicate that someone is trying to gain unauthorized access to the account or an application or integration that has been misconfigured and could suggest an issue with an application. Monitoring and alerting custom Snowflake data Out of the box, the Snowflake integration collects a wide range of performance-related data. What’s more, the integration enables you to ingest any data stored in Snowflake. If you want to keep an eye on orders, revenue, or customer interactions in real time, you can. All you need to do is add a new query to the integration .yml file, and our agent will store the result of that query in New Relic, running at an interval you choose. Check the GitHub repository for further instructions. It’s easy to export custom data from Snowflake. Here we see tracking sales orders in real time, alongside the valuable performance data. Snowflake is becoming ever more popular, but to ensure that its adoption goes smoothly within your organization, you must have a level of observability across different aspects such as performance, costs, and security. With the New Relic Snowflake integration, this is easily achievable. Sign up for a free New Relic account today and start monitoring your Snowflake account. Related Topics Integrations By Daniel Fitzgerald Daniel Fitzgerald is a senior solutions consultant for New Relic, based in London, UK. He helps some of the New Relic's largest European clients develop their monitoring and observability strategy. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.677086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ") cluster, which you can <em>spin</em> <em>up</em> on-demand to execute user queries. Virtual warehouses can be different sizes for different workloads. If a warehouse doesn’t have enough capacity to run the queries in-memory, it will spill some bytes to the disk or remote storage. When this happens"
      },
      "id": "6076284e28ccbc11b651c174"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/health-map-screenshot-1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/health-map-application-infrastructure-visualization",
      "sections": [
        "The importance of tracking application to infrastructure dependencies",
        "Enter Health Map: Transforming your Network Operating Center wallboard",
        "Try Health Map now!"
      ],
      "published_at": "2021-04-13T23:50:38Z",
      "title": "Introducing Health Map: Innovative Visualization Integrates Our Application and Infrastructure Monitoring Data",
      "updated_at": "2021-04-13T23:50:38Z",
      "type": "",
      "external_id": "48a71cc6dcafbf8fc194398575e094abebcb140a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog Introducing Health Map: Innovative Visualization Integrates Our Application and Infrastructure Monitoring Data May 24, 2017 • 6 min read By Ravi Tharisayi New Relic is pleased to announce general availability of Health Map, our innovative visualization that integrates our industry-leading application and infrastructure monitoring data to help operations teams understand and troubleshoot their applications. As organizations shift towards microservices on ephemeral systems, ops and DevOps teams often find it increasingly difficult to fully understand all the dependencies for their applications. Health Map is a high-density, color-coded view that shows the health of all your applications as well as the health of the infrastructure hosts where those applications are deployed. The importance of tracking application to infrastructure dependencies The performance of modern applications is increasingly tied to understanding the infrastructure hosts that the application relies upon. In modern architectures, a web application is often replicated and dependent upon multiple dynamic infrastructure resources. Every time a customer touches your web application, a load balancer directs traffic to one of those application instances that in turn rely on highly dynamic infrastructure. Keeping track of the relationships between one application and its ever-changing hosts can be hard, and many operations teams are charged with tracking hundreds of applications across a complex network of hundreds of hosts. When a performance issue arises, it can be exceedingly difficult to determine whether the source of the issue lies in the code or with one of the infrastructure hosts. What’s needed is a straightforward way to see the big picture of the applications you’re maintaining and also be able to confidently drill down into the infrastructure supporting them to troubleshoot issues. Enter Health Map: Transforming your Network Operating Center wallboard With Health Map you get one integrated, prioritized view of your applications. While many ops teams must look in separate views or even separate tools to see application and infrastructure health, Health Map delivers one combined view of all of your applications and the infrastructure hosts that the applications depends on. Better still, Health Map detects these relationships automatically—no configuration required! health map dashboard example Each card provides a color-coded visualization of both application and infrastructure health, along with basic metrics such as Apdex (application performance index), error rate, and throughput for applications and CPU%, memory%, and load average for hosts. The data points and color coding are generated seamlessly based on data and alerting policies that have been set up in New Relic APM and New Relic Infrastructure. When troubleshooting an issue, you can use filters that help quickly find applications or hosts that you’re particularly interested in based on the labels that you’ve set up. You can then mouse over any particular unhealthy application or host to see the open alert violations. Once an area of analysis has been identified, you can click on the application or hosts to go deeper into the issue within New Relic APM or Infrastructure. And all of these powerful insights are available on the go in your New Relic mobile app.   Watch the short demo video below to see how much more effective you can be in pinpointing errors within your applications with New Relic Health Map: Try Health Map now! If you’re a New Relic APM and New Relic Infrastructure customer, find the “Maps” link in your New Relic navigation and give Health Map a spin. Make your Health Map more even more powerful by defining useful alert conditions for your applications and hosts. And if you’re an APM customer who hasn’t yet taken the plunge with Infrastructure, now is a great time to get started. With a 30-day free trial, you can see your application and infrastructure health more clearly through Health Map. For more information: Health Map documentation New Relic Alerts documentation New Relic Infrastructure information and sign-up New Relic APM information and sign-up   By Ravi Tharisayi Ravi Tharisayi is a Senior Product Marketing Manager, APM. He has 15 years of experience in the IT industry, starting as a Java web developer before a 10-year stint at IBM in consulting and marketing roles. Having first-hand experience with the frustrations of the waterfall software development methodology, Ravi is passionate about DevOps and development on the cloud. He’s also a proud Boston native and cheered for the Patriots even when they had Steve Grogan. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.044846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Enter Health Map: Transforming <em>your</em> Network Operating Center wallboard",
        "body": " deeper into the issue within New Relic APM or Infrastructure. And all of these powerful insights are available on the go in <em>your</em> New Relic mobile app.   Watch the short <em>demo</em> video below to see how much more effective you can be in pinpointing errors within <em>your</em> applications with New Relic Health Map"
      },
      "id": "60762e4e28ccbccd5b51c153"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:23:32Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.41174,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source <em>demo</em>-deployer to <em>spin</em> <em>up</em> the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world"
      },
      "id": "607627f464441f7e2b9d8537"
    }
  ],
  "/build-apps/ab-test/platform-state-context": [
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course"
      ],
      "published_at": "2021-04-11T14:00:18Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to lookup the application user's account ID and the time range they selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your nerdlet. You can also use navigation for other nerdlets and launchers. Step 1 of 10 Change to the add-navigation directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now openApmEntity() knows that entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you've created a button and configured it to call .openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row but the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application: Click App performance: Now you see the stacked entity! Congratulations! You're finished writing all the code you'll write for you New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo application that is running an A/B test. You've created several charts, buttons, and other UI elements. You've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and out of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to deploy and subscribe to your New Relic application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1282.8384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " to <em>your</em> <em>nerdlet</em>, before starting this one. In the last lesson, you used <em>PlatformStateContext</em> from the New Relic One SDK to lookup the application user&#x27;s account ID and the time range they selected from the app&#x27;s time picker. Now, you&#x27;ll learn about another component that interacts with the New Relic"
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "image": "https://developer.newrelic.com/static/9fef87cd4b59ba7b2e8df08c97bd3b85/ba3ac/incorrect-auth-header.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/embed/",
      "sections": [
        "Fetch data from a third-party service",
        "Course"
      ],
      "published_at": "2021-04-11T14:00:18Z",
      "title": "",
      "updated_at": "2021-04-07T01:54:54Z",
      "type": "",
      "external_id": "5a9959f254359afeec9b0a9a9f39dd8b83d8c1ee",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorageVault from your nerdlet, before starting this one. In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -h 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add PlatformStateContext to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1059.7588,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the usability of <em>your</em> New Relic One application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>PlatformStateContext</em> to <em>your</em> <em>nerdlet</em>."
      },
      "id": "606d10ee28ccbc1cd5e1c991"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/embed/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:16Z",
      "type": "",
      "external_id": "58de68bd963cdd2062e88db55cb90ad124055eb6",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to take use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy PlatformStateContext.Consumer provides access to the platform's URL state. This state contains two important values for you to use in this context: accountId timeRange Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your nerdlet, you can use accountId from the platform URL state. Step 3 of 10 Use platformState.accountId in your NrqlQuery: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Next, notice that your query uses a SINCE clause, which identifies the historical timeframe your query should fetch data from. Step 4 of 10 Utilize platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. Tip While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery is now using the account ID, which it got from platform state. It's also using the platform state's time range, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 578.19324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>PlatformStateContext</em> <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " to the correct directory at the start of each lesson, you leave <em>your</em> custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets&#x2F;ab-test-<em>nerdlet</em>&#x2F;newsletter-signups.js, <em>add</em> a <em>PlatformStateContext</em>.Consumer to <em>your</em> NewsletterSignups"
      },
      "id": "6073000164441f84ce9d853d"
    },
    {
      "image": "https://developer.newrelic.com/static/7f679da4c4ffce5fa547a04b27ac700d/0086b/add-timepicker.png",
      "url": "https://developer.newrelic.com/build-apps/add-time-picker-guide/embed/",
      "sections": [
        "Add a time picker",
        "Before you begin",
        "Important",
        "Prepare the time picker sample code",
        "Import the PlatformStateContext component",
        "Add the time to the queries",
        "Summary"
      ],
      "published_at": "2021-04-12T01:54:52Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "852014728d86d0fcfc4345d6402f7533d9ca5e2e",
      "popularity": 1,
      "body": "This guide steps you through the process of adding access to our time picker in the sample transaction overview application. The sample application provides an overview of the telemetry data showing your account's transactions by application, average response time, HTTP response codes, and transaction errors. When you enable the time picker, users can specify the time range of data to view. We also have a 12 minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1–4 of the CLI quick start. In step 1, be sure to make a copy of the number preceding your account name. This is your accound ID, and you’ll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the time picker sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 7 If you haven't already done so, clone the example applications from our how-to GitHub repo. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 7 Change to the directory nr1-howto-add-time-picker-nerdlet: bash Copy $ cd nr1-how-to/add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet Step 3 of 7 In your preferred text editor, open index.js. Step 4 of 7 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 7 Change to the add-time-picker directory: bash Copy $ cd /nr1-how-to/add-time-picker Step 6 of 7 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 7 of 7 Once the sample application is successfully served, go to the local version of New Relic One (https://one.newrelic.com/?nerdpacks=local) click Apps, and click Add Time Picker. After launching the Add Time Picker application, you see a dashboard that gives an overview of the transactions in your New Relic account: By default, the application shows your data within the last 60 minutes. If you toggle the time picker, it doesn't update the charts because the transaction overview application isn't connected to the New Relic One platform. It has no access to the data from the time picker. In the following sections, you'll add the time picker to the example application and add the time to the queries. Import the PlatformStateContext component The first step in adding the time picker is to import the PlatformStateContext component. Important If you need more details about the PlatformStateContext example that follows, see the APIs and components page Here's what the PlatformStateContext component does: Wraps all of the code within the return statement of the render method Makes a function call passing in the New Relic platform state Returns all of the code within our current return statement Complete these steps: Step 1 of 5 In a text editor, open /add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet/index.js. Step 2 of 5 Add the PlatformStateContext component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, PlatformStateContext, } from 'nr1'; Copy Step 3 of 5 Just below the current return insert this code for the PlatformStateContext component: <PlatformStateContext.Consumer> {(platformState) => { return ( // ADD THE CURRENT RETURN CODE HERE ) }} </PlatformStateContext.Consumer> Copy Step 4 of 5 Move the current application code so it is under the return of the PlatformState function call. The return statement should now look like this: return ( <PlatformStateContext.Consumer> {(PlatformState) => { return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); Copy Step 5 of 5 Add a console.log statement to make sure you are seeing appropriate data. Insert the following code inside the PlatformState return statement just before the opening tag for the <Grid> component: /* Taking a peek at the PlatformState */ console.log(PlatformState); Copy After you complete these steps, your browser console displays something like this: Add the time to the queries In your console, you should see some data from the New Relic platform state. Now you're ready to add timeRange data to update the charts in the transaction overview application. This step requires you to import the timeRangeToNrql utility method from the New Relic One community library. Important You can get more details on the New Relic One community library from our GitHub repo. This helper method takes your PlatformState.timeRange duration data, formats it from milliseconds, and returns a formatted SINCE statement to add to your NRQL. Step 1 of 4 Import the timeRangeToNrql method by inserting this line of code below the other import sections: Important You don't need to include the AccountDropdown from the community import example. import { timeRangeToNrql } from '@newrelic/nr1-community'; Copy Step 2 of 4 Pass the PlatformState to the timeRangeToNrql helper, and save its output as a since statement for later use: const since = timeRangeToNrql(PlatformState); Copy Step 3 of 4 After creating the since variable, go through the code in the PlatformStateContext return statement and concatenate the since variable in each of the existing chart component queries. Here's a TableChart example: <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} />; Copy Step 4 of 4 After you update all of the chart components, confirm that the final index.js file looks similar to this: Important This completed sample code is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, } from 'nr1'; import { timeRangeToNrql } from '@newrelic/nr1-community'; export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props) { super(props); this.accountId = 1; } render() { const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <PlatformStateContext.Consumer> {(PlatformState) => { /* Taking a peek at the PlatformState */ console.log(PlatformState); const since = timeRangeToNrql(PlatformState); console.log(since); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount + since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); } } Copy Summary When you completed all the steps in this example, you successfully implemented the time picker in your application by importing the PlatformStateContext component and accessing its timePicker data object.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 422.31122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> the time <em>to</em> the queries",
        "body": " these steps: Step 1 of 5 In a text editor, open &#x2F;<em>add</em>-time-picker&#x2F;nerdlets&#x2F;nr1-howto-<em>add</em>-time-picker-<em>nerdlet</em>&#x2F;index.js. Step 2 of 5 <em>Add</em> the <em>PlatformStateContext</em> component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart"
      },
      "id": "6063d5f464441fcf580c8bbd"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 358.30228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Platform</em> APIs",
        "body": ": <em>PlatformStateContext</em>: provides read access to the <em>platform</em> URL <em>state</em> variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new <em>Nerdlet</em>. <em>NerdletStateContext</em>: provides read access to the <em>Nerdlet</em> URL <em>state</em> variables. Example: an entityGuid in the entity explorer. <em>nerdlet</em>: an object that provides write access to the <em>Nerdlet</em> URL <em>state</em>."
      },
      "id": "60652884196a67886047e800"
    }
  ],
  "/build-apps/ab-test/grid": [
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/embed/",
      "sections": [
        "Add a grid",
        "Course",
        "Technical detail"
      ],
      "published_at": "2021-04-11T14:01:08Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "bfd5e04da0f000d6970b16677cd5faf8c3b2f461",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add user interface components to your application, before starting this one. In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add chart headings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1094.582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> <em>grid</em>",
        "body": " your <em>Grid</em>: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the <em>add</em>-a-<em>grid</em> directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-a-<em>grid</em> Step 2 of 6 In your Nerdlet&#x27;s index.js file"
      },
      "id": "6072565d28ccbc6baf51c18b"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-04-11T13:57:58Z",
      "title": "",
      "updated_at": "2021-04-11T13:57:58Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1072.8408,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> user interface components to your <em>application</em>",
        "body": " functionality. First, you’ll use a <em>Grid</em> component to arrange your charts to match the layout in your design guide. Second, you’ll <em>add</em> headings to clarify what each chart represents. Third, you&#x27;ll <em>add</em> descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section"
      },
      "id": "6073006628ccbce73151c12f"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings",
        "Course"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a grid, before starting this one. Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add version descriptions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 919.96924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> chart headings",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> a <em>grid</em>, before starting"
      },
      "id": "6072ff1928ccbc140b51c16e"
    },
    {
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/embed/",
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "67c529a70a60d530860fbe80be795d214798dfd9",
      "popularity": 1,
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 387.7177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, query, <em>and</em> mutate data using NerdStorage",
        "body": " <em>Grid</em>Item to the application immediately before the closing <em>Grid</em> tag. In the new <em>Grid</em>Item <em>add</em> the following code to display your new button: &lt;Button onClick={() =&gt; this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType"
      },
      "id": "6066782e64441f577f617a9d"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions",
        "Course"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart headings, before starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 7 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 2 of 7 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 3 of 7 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 4 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 5 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 7 of 7 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add a section to end your test.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.60541,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> version descriptions",
        "body": " version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a <em>Grid</em>Item with a columnSpan of 12, to stretch the rule the full width of the <em>grid</em>. Step 4 of 7 Navigate to the root of your Nerdpack at nru-programmability-course&#x2F;<em>add</em>"
      },
      "id": "6072569228ccbc932d51c172"
    }
  ],
  "/build-apps/ab-test/nrql-customizations": [
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/embed/",
      "sections": [
        "Customize NRQL data",
        "Course",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T14:01:47Z",
      "type": "",
      "external_id": "f51f9d86d3b873b24e967c687d5408eb9918a33f",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add NrqlQuery components to your nerdlet, before starting this one. In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your nerdpack served locally, view your application to see your charts serving real data: In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorage from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 810.33923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Customize</em> <em>NRQL</em> <em>data</em>",
        "body": " steps, you&#x27;ll learn how to <em>customize</em> <em>Nrql</em>Query results to merge <em>data</em> from multiple sources. Merge <em>NRQL</em> from multiple sources Step 1 of 9 Change to the <em>customize</em>-<em>nrql</em>-<em>data</em> directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>customize</em>-<em>nrql</em>-<em>data</em> This directory contains"
      },
      "id": "6073014b28ccbc70b651c134"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/embed/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "Course",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-04-11T14:01:08Z",
      "title": "",
      "updated_at": "2021-04-11T14:01:08Z",
      "type": "",
      "external_id": "43c5fb39b73ee2dbbe5f216a577ff77051fcc513",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Present an end test confirmation modal, before starting this one. In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 View your changes: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 2 of 2 With your nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Customize NRQL data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 403.55725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>NrqlQuery</em> components to your Nerdlet",
        "body": " did for the charts you&#x27;ve been dealing with because <em>NRQL</em> has no method for querying <em>data</em> from multiple sources. In the next lesson, you&#x27;ll learn how to supply <em>data</em> to these two charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Customize</em> <em>NRQL</em> <em>data</em>."
      },
      "id": "60730124196a6731e464a778"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:18Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 3014918 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.20343,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Customize</em> <em>NRQL</em> <em>data</em>, before"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    },
    {
      "sections": [
        "NRQL syntax, clauses, and functions",
        "Syntax",
        "Query components",
        "Required clauses",
        "Required: SELECT statement",
        "Avg response time since last week",
        "Required: FROM clause",
        "Query one data type",
        "Query multiple data types",
        "Optional clauses",
        "AS clause",
        "Query using math function and AS",
        "Query using funnel and AS",
        "COMPARE WITH clause",
        "EXTRAPOLATE clause",
        "Important",
        "Example of extrapolating throughput",
        "Example of extrapolating throughput as a time series",
        "FACET clause",
        "Faceted query using count()",
        "Faceted query using uniqueCount()",
        "Grouping results across time",
        "FACET ... AS clause",
        "FACET CASES clause",
        "Basic usage with WHERE",
        "Group based on multiple attributes",
        "Label groups with AS",
        "FACET ... ORDER BY clause",
        "Tip",
        "LIMIT clause",
        "Query using LIMIT",
        "OFFSET clause",
        "ORDER BY clause",
        "SHOW EVENT TYPES clause",
        "Data types in the last day",
        "SINCE clause",
        "SLIDE BY clause",
        "Use SLIDE BY with MAX or AUTO interval",
        "TIMESERIES clause",
        "Use a set interval",
        "Use an automatically set interval",
        "Use MAX interval",
        "UNTIL clause",
        "WHERE clause",
        "Example query with three conditions",
        "WITH METRIC_FORMAT clause",
        "WITH TIMEZONE clause",
        "Query metric data",
        "Aggregator functions",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "Get Apdex for specific customers",
        "Get Apdex for specific transaction",
        "Get overall Apdex for your app",
        "average(attribute)",
        "buckets(attribute, ceiling [,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(*)",
        "derivative(attribute [,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "earliest(attribute)",
        "Get earliest country per user agent from PageView",
        "eventType()",
        "Use eventType() in filter() function",
        "Use eventType() with FACET",
        "filter(function(attribute), WHERE condition)",
        "Analyze purchases that used offer codes",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling [,number of buckets])",
        "Histogram of response times from PageView events",
        "Prometheus histogram buckets",
        "New Relic distribution metric",
        "Histogram with a FACET clause",
        "keyset()",
        "See all attributes for a data type",
        "latest(attribute)",
        "Get most recent country per user agent from PageView",
        "latestrate(attribute, time interval)",
        "Get the most recent rate of change of PageView Duration",
        "max(attribute)",
        "median(attribute)",
        "Median query",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "mod() within a WHERE clause condition",
        "mod() within a FACET clause",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute [, percentile [, ...]])",
        "Basic percentile query",
        "predictLinear(attribute, [,time interval])",
        "rate(function(attribute) [,time interval])",
        "Basic rate query",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute [,limit])",
        "Using tuple",
        "Type conversion"
      ],
      "title": "NRQL syntax, clauses, and functions",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "97c38ce7950d354d9f1d9efa5f432326f9bb4b00",
      "image": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/images/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-04-12T09:29:33Z",
      "updated_at": "2021-04-12T09:29:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQL is a query language you can use to query the New Relic database. This document explains NRQL syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a NRQL query. Other resources for understanding NRQL: Intro to NRQL: explains what NRQL is used for, what data you can query with it, and basic NRQL syntax Examine NRQL queries used to build New Relic charts Learn how to query the Metric data type Simulate SQL JOIN functions Use funnels to evaluate a series of related data Format NRQL for querying with the Event API Query components Every NRQL query will begin with a SELECT statement or a FROM clause. All other clauses are optional. The clause definitions below also contain example NRQL queries. Required clauses Required: SELECT statement SELECT attribute ... Copy SELECT function(attribute) ... Copy The SELECT specifies what portion of a data type you want to query by specifying an attribute or a function. It's followed by one or more arguments separated by commas. In each argument you can: Get the values of all available attributes by using * as a wildcard. For example: SELECT * from Transaction. Get values associated with a specified attribute or multiple attributes specified in a comma separated list. Get aggregated values from specified attributes by selecting an aggregator function. Label the results returned in each argument with the AS clause. You can also use SELECT with basic math functions. Avg response time since last week This query returns the average response time since last week. SELECT average(duration) FROM PageView SINCE 1 week ago Copy Required: FROM clause SELECT ... FROM data type ... Copy Use the FROM clause to specify the data type you wish to query. You can start your query with FROM or with SELECT. You can merge values for the same attributes across multiple data types in a comma separated list. Query one data type This query returns the count of all APM transactions over the last three days: SELECT count(*) FROM Transaction SINCE 3 days ago Copy Query multiple data types This query returns the count of all APM transactions and Browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Optional clauses AS clause SELECT ... AS 'label' ... Copy Use the AS clause to label an attribute, aggregator, step in a funnel, or the result of a math function with a string delimited by single quotes. The label is used in the resulting chart. Query using math function and AS This query returns the number of page views per session: SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView Copy Query using funnel and AS This query returns a count of people who have visited both the main page and the careers page of a site over the past week: SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago Copy COMPARE WITH clause SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... Copy Use the COMPARE WITH clause to compare the values for two different time ranges. COMPARE WITH requires a SINCE or UNTIL statement. The time specified by COMPARE WITH is relative to the time specified by SINCE or UNTIL. For example, SINCE 1 day ago COMPARE WITH 1 day ago compares yesterday with the day before. The time range for theCOMPARE WITH value is always the same as that specified by SINCE or UNTIL. For example, SINCE 2 hours ago COMPARE WITH 4 hours ago might compare 3:00pm through 5:00pm against 11:00am through 1:00pm. COMPARE WITH can be formatted as either a line chart or a billboard: With TIMESERIES, COMPARE WITH creates a line chart with the comparison mapped over time. Without TIMESERIES, COMPARE WITH generates a billboard with the current value and the percent change from the COMPARE WITH value. Example: This query returns data as a line chart showing the 95th percentile for the past hour compared to the same range one week ago. First as a single value, then as a line chart. SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO Copy EXTRAPOLATE clause You can use this clause with these data types: Transaction TransactionError Custom events reported via APM agent APIs The purpose of EXTRAPOLATE is to mathematically compensate for the effects of APM agent sampling of event data so that query results more closely represent the total activity in your system. This clause will be useful when a New Relic APM agent reports so many events that it often passes its harvest cycle reporting limits. When that occurs, the agent begins to sample events. When EXTRAPOLATE is used in a NRQL query that supports its use, the ratio between the reported events and the total events is used to extrapolate a close approximation of the total unsampled data. When it is used in a NRQL query that doesn’t support its use or that hasn’t used sampled data, it has no effect. Important Note that EXTRAPOLATE is most useful for homogenous data (like throughput or error rate). It's not effective when attempting to extrapolate a count of distinct things (like uniqueCount() or uniques()). This clause works only with NRQL queries that use one of the following aggregator functions: apdex average count histogram sum percentage (if function it takes as an argument supports EXTRAPOLATE) rate (if function it takes as an argument supports EXTRAPOLATE) stddev Example of extrapolating throughput A query that will show the extrapolated throughput of a service named interestingApplication. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE Copy Example of extrapolating throughput as a time series A query that will show the extrapolated throughput of a service named interestingApplication by transaction name, displayed as a time series. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE Copy FACET clause SELECT ... FACET attribute ... Copy Use FACET to separate and group your results by attribute values. For example, you could FACET your PageView data by deviceType to figure out what percentage of your traffic comes from mobile, tablet, and desktop devices. Use the LIMIT clause to specify how many facets appear (default is 10). For more complex grouping, use FACET CASES. FACET clauses support up to five attributes, separated by commas. The facets are sorted in descending order by the first field you provide in the SELECT clause. If you are faceting on attributes with more than 2,000 unique values, a subset of facet values is selected and sorted according to the query type. When selecting min(), max(), or count(), FACET uses those functions to determine how facets are picked and sorted. When selecting any other function, FACET uses the frequency of the attribute you are faceting on to determine how facets are picked and sorted. For more on faceting on multiple attributes, with some real-world examples, see this New Relic blog post. Faceted query using count() This query shows cities with the highest pageview counts. This query uses the total number of pageviews per city to determine how facets are picked and ordered. SELECT count(*) FROM PageView FACET city Copy Faceted query using uniqueCount() This query shows the cities that access the highest number of unique URLs. This query uses the total number of times a particular city appears in the results to determine how facets are picked and ordered. SELECT uniqueCount(pageUrl) FROM PageView FACET city Copy Grouping results across time Advanced segmentation and cohort analysis allow you to facet on bucket functions to more effectively break out your data. Cohort analysis is a way to group results together based on timestamps. You can separate them into buckets that cover a specified range of dates and times. FACET ... AS clause Use FACET ... AS to name facets using the AS keyword in queries. This clause is helpful for adding clearer or simplified names for facets in your results. It can also be used to rename facets in nested aggregation queries. FACET ... AS queries will change the facet names in results (when they appear as headers in tables, for example), but not the actual facet names themselves. FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' Copy FACET CASES clause SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... Copy Use FACET CASES to break out your data by more complex conditions than possible with FACET. Separate multiple conditions with a comma ,. For example, you could query your PageView data and FACET CASES into categories like less than 1 second, from 1 to 10 seconds, and greater than 10 seconds. You can combine multiple attributes within your cases, and label the cases with the AS selector. Data points will be added to at most one facet case, the first facet case that they match. You may also use a time function with your attribute. Basic usage with WHERE SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) Copy Group based on multiple attributes This example groups results into one bucket where the transaction name contains login, and another where the URL contains login and a custom attribute indicates that the user was a paid user: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') Copy Label groups with AS This example uses the AS selector to give your results a human-readable name: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') Copy FACET ... ORDER BY clause In NRQL, the default is for the first aggregation in the SELECT clause to guide the selection of facets in a query. FACET ... ORDER BY allows you to override this default behavior by adding an aggregate function with the ORDER BY modifier to specify how facets are selected. Specifically, the clause will override the priority by which facets are chosen to be in the final result before being limited by the LIMIT clause. This clause can be used in querying but not for alerts or streaming. This example shows how to use FACET ... ORDER BY to find the average durations of app transactions, showing the top 10 (default limit) highest durations by apps which have the highest response size. In this case, if FACET ... ORDER BY is not used, the query results will instead show the top 10 by highest durations, with response size being irrelevant to the app selection. FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) Copy Tip Because the operations are performed before the LIMIT clause is applied, FACET ... ORDER BY does not impact the sort of the final query results, which will be particularly noticeable in the results for non-timeseries queries. Important The ORDER BY modifier in this case works differently than the ORDER BY clause. When parsing queries that follow the format FACET attribute1 ORDER BY attribute2, New Relic will read these as FACET ... ORDER BY queries, but only if ORDER BY appears immediately after FACET. Otherwise ORDER BY will be interpreted by New Relic as a clause. LIMIT clause SELECT ... LIMIT count ... Copy Use the LIMIT clause to control the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. This clause takes a single integer value as an argument. If the LIMIT clause is not specified, or no value is provided, the limit defaults to 10 for FACET queries and 100 in the case of SELECT * queries. The maximum allowed value for the LIMIT clause is 2,000. Query using LIMIT This query shows the top 20 countries by session count and provides 95th percentile of response time for each country for Windows users only. SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY Copy OFFSET clause SELECT ... LIMIT count OFFSET count ... Copy Use the OFFSET clause with LIMIT to control the portion of rows returned by SELECT * or SELECT column queries. Like the LIMIT clause, OFFSET takes a single integer value as an argument. OFFSET sets the number of rows to be skipped before the selected rows of your query are returned. This is constrained by LIMIT. OFFSET rows are skipped starting from the most recent record. For example, the query SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1 returns the last 5 values from Minute_Report except for the most recent one. ORDER BY clause The ORDER BY clause allows you to specify how you want to sort your query results in queries that select event attributes by row. This query orders transactions by duration. FROM Transaction SELECT appName, duration ORDER BY duration Copy The default sort order is ascending, but this can be changed by adding the ASC or DESC modifiers. SHOW EVENT TYPES clause SHOW EVENT TYPES... Copy SHOW EVENT TYPES will return a list of all the data types present in your account for a specific time range. It is used as the first clause in a query instead of SELECT. Important In this context, \"event types\" refers to the data types you can access with a NRQL query. Data types in the last day This query will return all the data types present over the past day: SHOW EVENT TYPES SINCE 1 day ago Copy SINCE clause SELECT ... SINCE [numerical units AGO | phrase] ... Copy The default value is 1 hour ago. Use the SINCE clause to define the beginning of a time range for the returned data. When using NRQL, you can set a UTC timestamp or relative time range. You can specify a timezone for the query but not for the results. NRQL results are based on your system time. See Set time range on dashboards and charts for detailed information and examples. SLIDE BY clause The SLIDE BY clause supports a feature known as sliding windows. With sliding windows,SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. To use SLIDE BY, place it in a query after the TIMESERIES clause. For example, this query pulls data in 5-minute windows with a 1-minute SLIDE BY interval, meaning that each window lasts 5 minutes, but window 1 starts at 0 minutes, window 2 starts at 1 minute, window 3 starts at 2 minutes, and so on. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy To learn more about how and when you can use SLIDE BY, see Create smoother charts with sliding windows. Use SLIDE BY with MAX or AUTO interval You can use sliding windows in combination with MAX or AUTO. However, MAX or AUTO may not be placed between TIMESERIES and SLIDE BY. This query will automatically decide a SLIDE BY window interval. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy This query will set the SLIDE BY window to the maximum interval granularity. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy Important The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which can cause gaps and unexpected results. TIMESERIES clause SELECT ... TIMESERIES integer units ... Copy Use the TIMESERIES clause to return data as a time series broken out by a specified period of time. Since TIMESERIES is used to trigger certain charts, there is no default value. To indicate the time range, use integer units. For example: TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds TIMESERIES can be combined with arguments such as MAX, AUTO, and SLIDE BY to further tailor query results, as shown in the examples below. Important For functions such as average( ) or percentile( ), a large aggregation window can have a significant smoothing effect on outliers. This is true whether or not the query makes use of sliding windows. Use a set interval The value provided indicates the units used to break out the graph. For example, to present a one-day graph showing 30 minute increments: SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes Copy Use an automatically set interval TIMESERIES can also be set to AUTO, which will divide your graph into a reasonable number of divisions. For example, a daily chart will be divided into 30 minute intervals and a weekly chart will be divided into 6 hour intervals. This query returns data as a line chart showing the 50th and 90th percentile of client-side transaction time for one week with a data point every 6 hours. SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO Copy Use MAX interval You can set TIMESERIES to MAX, which will automatically adjust your time window to the maximum number of intervals allowed for a given time period. This allows you to update your time windows without having to manually update your TIMESERIES buckets and ensures your time window is being split into the peak number of intervals allowed. The maximum number of TIMESERIES buckets that will be returned is 366. For example, the following query creates 4-minute intervals, which is the ceiling for a daily chart. SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX Copy UNTIL clause SELECT ... UNTIL integer units AGO ... Copy The default value is NOW. Only use UNTIL to specify an end point other than the default. Use the UNTIL clause to define the end of a time range across which to return data. Once a time range has been specified, the data will be preserved and can be reviewed after the time range has ended. You can specify a UTC timestamp or relative time range. You can specify a time zone for the query but not for the results. The returned results are based on your system time. See Set time range on dashboards and charts for detailed information and examples. WHERE clause Use the WHERE clause to filter results. NRQL returns the results that fulfill the condition(s) you specify in the clause. SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... Copy If you specify more than one condition, separate the conditions by the operators AND or OR. If you want to simulate a SQL join, use custom attributes in a WHERE or FACET clause. Operators that the WHERE clause accepts Description =, !=, <, <=, >, >= NRQL accepts standard comparison operators. Example: state = 'WA' AND Used to define an intersection of two conditions. OR Used to define a union of two conditions. IS NULL Determines if an attribute has a null value. IS NOT NULL Determines if an attribute does not have a null value. IN Determines if the string value of an attribute is in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Example: animalType IN ('cat', 'dog', 'fish') NOT IN Determines if the string value of an attribute is not in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Values must be in parentheses, separated by commas. For example: SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') Copy LIKE Determines if an attribute contains a specified sub-string. The string argument for the LIKE operator accepts the percent sign (%) as a wildcard anywhere in the string. If the substring does not begin or end the string you are matching against, the wildcard must begin or end the string. Examples: userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE Determines if an attribute does not contain a specified sub-string. RLIKE Determines if an attribute contains a specified Regex sub-string. Uses RE2 syntax. Examples: appName RLIKE 'z.*|q.*'' z-app q-app hostname RLIKE 'ip-10-351-[0-2]?[0-9]-.*' ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 Important Note: Slashes must be escaped in the Regex pattern. For example, \\d must be \\\\d. Regex defaults to full-string matching, therefore ^ and $ are implicit and you do not need to add them. If the Regex pattern contains a capture group, the group will be ignored. That is, the group will not be captured for use later in the query. NOT RLIKE Determines if an attribute does not contain a specified Regex sub-string. Uses RE2 syntax. Example query with three conditions This query returns the browser response time for pages with checkout in the URL for Safari users in the United States and Canada over the past 24 hours. SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago Copy WITH METRIC_FORMAT clause For information on querying metric data, see Query metrics. WITH TIMEZONE clause SELECT ... WITH TIMEZONE (selected zone) ... Copy By default, query results are displayed in the timezone of the browser you're using. Use the WITH TIMEZONE clause to select a time zone for a date or time in the query that hasn't already had a time zone specified for it. For example, the query clause SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York' will return data recorded from Monday at midnight, Eastern Standard Time, until midnight Tuesday, Eastern Standard Time. Available Time Zone Selections Africa/Abidjan Africa/Addis_Ababa Africa/Algiers Africa/Blantyre Africa/Cairo Africa/Windhoek America/Adak America/Anchorage America/Araguaina America/Argentina/Buenos_Aires America/Belize America/Bogota America/Campo_Grande America/Cancun America/Caracas America/Chicago America/Chihuahua America/Dawson_Creek America/Denver America/Ensenada America/Glace_Bay America/Godthab America/Goose_Bay America/Havana America/La_Paz America/Los_Angeles America/Miquelon America/Montevideo America/New_York America/Noronha America/Santiago America/Sao_Paulo America/St_Johns Asia/Anadyr Asia/Bangkok Asia/Beirut Asia/Damascus Asia/Dhaka Asia/Dubai Asia/Gaza Asia/Hong_Kong Asia/Irkutsk Asia/Jerusalem Asia/Kabul Asia/Katmandu Asia/Kolkata Asia/Krasnoyarsk Asia/Magadan Asia/Novosibirsk Asia/Rangoon Asia/Seoul Asia/Tashkent Asia/Tehran Asia/Tokyo Asia/Vladivostok Asia/Yakutsk Asia/Yekaterinburg Asia/Yerevan Atlantic/Azores Atlantic/Cape_Verde Atlantic/Stanley Australia/Adelaide Australia/Brisbane Australia/Darwin Australia/Eucla Australia/Hobart Australia/Lord_Howe Australia/Perth Chile/EasterIsland Etc/GMT+10 Etc/GMT+8 Etc/GMT-11 Etc/GMT-12 Europe/Amsterdam Europe/Belfast Europe/Belgrade Europe/Brussels Europe/Dublin Europe/Lisbon Europe/London Europe/Minsk Europe/Moscow Pacific/Auckland Pacific/Chatham Pacific/Gambier Pacific/Kiritimati Pacific/Marquesas Pacific/Midway Pacific/Norfolk Pacific/Tongatapu UTC See Set time range on dashboards and charts for detailed information and examples. Query metric data Metric data is more complex than other types of data. There are specific tips for querying it well. We have two types of metric data, each with their own query guidelines: Query dimensional metrics, which are reported by our Metric API and by some of our tools that use that API, like our Telemetry SDKs and our open-source telemetry integrations (OpenTelemetry, Kamon, Micrometer, more). Query metric timeslice data, which is our original metric data type reported by our APM, mobile monitoring, and browser monitoring. For more on understanding these data types, see Metric data types. Aggregator functions Use aggregator functions to filter and aggregate data in a NRQL query. Some helpful information about using aggregator functions: See the New Relic University tutorials for Filter queries, Apdex queries, and Percentile queries. Or, go to the full online course Writing NRQL queries. Data type \"coercion\" is not supported. Read about available type conversion functions. Cohort analysis functions appear on the New Relic Insights Cohort analysis page. The cohort functions aggregate transactions into time segments. Here are the available aggregator functions. The definitions below contain example NRQL queries. Examples: SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy aggregationendtime() Use the aggregationendtime() function to return the time of the relevant aggregation. More specifically, for a given aggregate, the aggregationendtime() function provides the timestamp of the end of the time period of that aggregation. For example, in a timeseries query, for a data point that encompasses an hour’s worth of data, the function would return the timestamp of the end of that hour period. apdex(attribute, t: ) Use the apdex function to return an Apdex score for a single transaction or for all your transactions. The attribute can be any attribute based on response time, such as duration or backendDuration. The t: argument defines an Apdex T threshold in seconds. The Apdex score returned by the apdex( ) function is based only on execution time. It does not account for APM errors. If a transaction includes an error but completes in Apdex T or less, that transaction will be rated satisfying by the apdex ( ) function. Get Apdex for specific customers If you have defined custom attributes, you can filter based on those attributes. For example, you could monitor the Apdex for a particularly important customer: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy Get Apdex for specific transaction Use the name attribute to return a score for a specific transaction, or return an overall Apdex by omitting name. This query returns an Apdex score for the Controller/notes/index transaction over the last hour: SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago Copy The apdex function returns an Apdex score that measures user satisfaction with your site. Arguments are a response time attribute and an Apdex T threshold in seconds. Get overall Apdex for your app This example query returns an overall Apdex for the application over the last three weeks: SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago Copy average(attribute) Use the average( ) function to return the average value for an attribute. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. buckets(attribute, ceiling [,number of buckets]) Use the buckets() function to aggregate data split up by a FACET clause into buckets based on ranges. You can bucket by any attribute that is stored as a numerical value in the New Relic database. It takes three arguments: Attribute name Maximum value of the sample range. Any outliers will appear in the final bucket. Total number of buckets For more information and examples, see Split your data into buckets. bucketPercentile(attribute) The bucketPercentile( ) function is the NRQL equivalent of the histogram_quantile function in Prometheus. It is intended to be used with dimensional metric data. Instead of the quantile, New Relic returns the percentile, which is the quantile * 100. Use the bucketPercentile( ) function to calculate the quantile from the histogram data in a Prometheus format. It takes the bucket name as an argument and reports percentiles along the bucket's boundaries: SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago Copy Optionally, you can add percentile specifications as an argument: SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago Copy Because multiple metrics are used to make up Prometheus histogram data, you must query for specific Prometheus metrics in terms of the associated <basename>. For example, to compute percentiles from a Prometheus histogram, with the <basename> prometheus_http_request_duration_seconds using NRQL, use bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50). Note how _ bucket is added to the end of the <basename> as a suffix. See the Prometheus.io documentation for more information. cardinality(attribute) Use the cardinality( ) function to obtain the number of combinations of all the dimensions (attributes) on a metric. It takes three arguments, all optional: Metric name: if present, cardinality( ) only computes the metric specified. Include: if present, the include list restricts the cardinality computation to those attributes. Exclude: if present, the exclude list causes those attributes to be ignored in the cardinality computation. SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) Copy count(*) Use the count( ) function to return a count of available records. It takes a single argument; either *, an attribute, or a constant value. Currently, it follows typical SQL behavior and counts all records that have values for its argument. Since count(*) does not name a specific attribute, the results will be formatted in the default \"humanize\" format. derivative(attribute [,time interval]) derivative() finds the rate of change for a given dataset. The rate of change is calculated using a linear least-squares regression to approximate the derivative. Since this calculation requires comparing more than one datapoint, if only one datapoint is included in the evaluation range, the calculation is indeterminate and won't work, resulting in a null value. The time interval is the period for which the rate of change is calculated. For example, derivative(attributeName, 1 minute) will return the rate of change per minute. dimensions(include: {attributes}, exclude: {attributes}) Use the dimensions( ) function to return all the dimensional values on a data type. You can explicitly include or exclude specific attributes using the optional arguments: Include: if present, the include list limits dimensions( ) to those attributes. Exclude: if present, the dimensions( ) calculation ignores those attributes. FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() Copy When used with a FACET clause, dimensions( ) produces a unique timeseries for all facets available on the event type, similar to how Prometheus behaves with non-aggregated queries. earliest(attribute) Use the earliest( ) function to return the earliest value for an attribute over the specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get earliest country per user agent from PageView This query returns the earliest country code per each user agent from the PageView event. SELECT earliest(countryCode) FROM PageView FACET userAgentName Copy eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... Copy Use the eventType() function in a FACET clause to break out results by the selected data type or in a WHERE clause to filter results to a specific data type. This is particularly useful for targeting specific data types with the filter() and percentage() functions. Important In this context, \"event type\" refers to the types of data you can access with a NRQL query. Use eventType() in filter() function This query returns the percentage of total TransactionError results out of the total Transaction results. You can use the eventType() function to target specific types of data with the filter() function. SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago Copy Use eventType() with FACET This query displays a count of how many records each data type (Transaction and TransactionError) returns. SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES Copy filter(function(attribute), WHERE condition) Use the filter() function to limit the results for one of the aggregator functions in your SELECT statement. You can use filter() in conjunction with FACET or TIMESERIES. Filter is only useful when selecting multiple different aggregations such as SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' .... Otherwise, it's better to just use the standard WHERE clause. Analyze purchases that used offer codes You could use filter() to compare the items bought in a set of transactions for those using an offer code versus those who aren't: Use the filter( ) function to limit the results for one of the aggregator functions in your SELECT statement. funnel(attribute, steps) Use the funnel() function to generate a funnel chart. It takes an attribute as its first argument. You then specify steps as WHERE clauses (with optional AS clauses for labels) separated by commas. For details and examples, see the funnels documentation. getField(attribute, field) Use the getField() function to extract a field from complex metrics. It takes the following arguments: Metric type Supported fields summary count, total, max, min gauge count, total, max, min, latest distribution count, total, max, min counter count Examples: SELECT max(getField(mySummary, count)) from Metric Copy SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 Copy histogram(attribute, ceiling [,number of buckets]) Use the histogram( ) function to generate histograms. It takes three arguments: Attribute name Maximum value of the sample range Total number of buckets (between 1 and 500, inclusive) Histogram of response times from PageView events This query results in a histogram of response times ranging up to 10 seconds over 20 buckets. SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy Prometheus histogram buckets histogram( ) accepts Prometheus histogram buckets: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago Copy New Relic distribution metric histogram( ) accepts Distribution metric as an input: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago Copy Histogram with a FACET clause Use histogram( ) with a FACET clause to generate a heatmap chart: SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago Copy keyset() Using keyset() will allow you to see all of the attributes for a given data type over a given time range. It takes no arguments. It returns a JSON structure containing groups of string-typed keys, numeric-typed keys, boolean-typed keys, and all keys. See all attributes for a data type This query returns the attributes found for PageView events from the last day: SELECT keyset() FROM PageView SINCE 1 day ago Copy latest(attribute) Use the latest( ) function to return the most recent value for an attribute over a specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get most recent country per user agent from PageView This query returns the most recent country code per each user agent from the PageView event. SELECT latest(countryCode) FROM PageView FACET userAgentName Copy latestrate(attribute, time interval) Use the latestrate( ) function to return the rate of change of a value based on the last 2 data points. It takes the attribute in question as the first argument and the unit of time for the resulting rate as the second argument. The function returns a result in units of change in attribute/time interval. This function can be useful to provide the most recent rate of change for an attribute in order to see leading-edge trends. Get the most recent rate of change of PageView Duration This query returns the rate of change of duration based on the last 2 data points. It will be returned in units of duration/second because of the 1 SECOND argument. SELECT latestrate(duration, 1 SECOND) FROM PageView Copy max(attribute) Use the max( ) function to return the maximum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. median(attribute) Use the median( ) function to return an attribute's median, or 50th percentile. For more information about percentile queries, see percentile(). Tip The median( ) query is only available when using the query builder. Median query This query will generate a line chart for the median value. SELECT median(duration) FROM PageView TIMESERIES AUTO Copy min(attribute) Use the min( ) function to return the minimum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. minuteOf(attribute) Use the minuteOf() function to extract only the minute portion (i.e. 0-59) of an attribute holding a valid timestamp value. mod(attribute, divisor) Use the mod( ) function to return the floor modulus after dividing the value of the provided numeric attribute (the first argument, or dividend) by a numeric value (the second argument, or divisor). This modulo operation can be used within a WHERE clause condition to filter to an arbitrary subset of results or within a FACET clause as a way to subdivide the result set. mod() within a WHERE clause condition FROM Transaction SELECT * WHERE mod(port, 2) = 1 Copy mod() within a FACET clause FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) Copy percentage(function(attribute), WHERE condition) Use the percentage( ) function to return the percentage of a target data set that matches some condition. The first argument requires an aggregator function against the desired attribute. Use exactly two arguments (arguments after the first two will be ignored). If the attribute is not numeric, this function returns a value of 100%. percentile(attribute [, percentile [, ...]]) Use the percentile( ) function to return an attribute's approximate value at a given percentile. It requires an attribute and can take any number of arguments representing percentile points. The percentile() function enables percentiles to displays with up to three digits after the decimal point, providing greater precision. Percentile thresholds may be specified as decimal values, but be aware that for most data sets, percentiles closer than 0.1 from each other will not be resolved. Percentile display examples Use TIMESERIES to generate a line chart with percentiles mapped over time. Omit TIMESERIES to generate a billboard and attribute sheet showing aggregate values for the percentiles. If no percentiles are listed, the default is the 95th percentile. To return only the 50th percentile value, the median, you can also use median(). Basic percentile query This query will generate a line chart with lines for the 5th, 50th, and 95th percentile. SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO Copy predictLinear(attribute, [,time interval]) predictLinear() is an extension of the derivative() function. It uses a similar method of least-squares linear regression to predict the future values for a dataset. The time interval is how far the query will look into the future. For example, predictLinear(attributeName, 1 hour) is a linear prediction 1 hour into the future of the query time window. Generally, predictLinear() is helpful for continuously growing values like disk space, or predictions on large trends. Since predictLinear() is a linear regression, familiarity with the dataset being queried helps to ensure accurate long-term predictions. Any dataset which grows exponentially, logarithmically, or by other nonlinear means will likely only be successful in very short-term predictions. New Relic recommends against using predictLinear in TIMESERIES queries. This is because each bucket will be making an individual prediction based on its relative timeframe within the query, meaning that such queries will not show predictions from the end of the timeseries forward. rate(function(attribute) [,time interval]) Use the rate( ) function to visualize the frequency or rate of a given query per time interval. For example, you might want to know the number of pageviews per minute over an hour-long period or the count of unique sessions on your site per hour over a day-long period. Use TIMESERIES to generate a line chart with rates mapped over time. Omit TIMESERIES to generate a billboard showing a single rate value averaged over time. Basic rate query This query will generate a line chart showing the rate of throughput for APM transactions per 10 minutes over the past 6 hours. SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES Copy round(attribute) Use the round( ) function to return the rounded value of an attribute. Optionally round( ) can take a second argument, to_nearest, to round the first argument to the closest multiple of the second one. to_nearest can be fractional. SELECT round(n [, to_nearest]) Copy stddev(attribute) Use the stddev( ) function to return one standard deviation for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. stdvar(attribute) Use the stdvar( ) function to return the standard variance for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. sum(attribute) Use the sum( ) function to return the sum recorded values of a numeric attribute over the time range specified. It takes a single argument. Arguments after the first will be ignored. If the attribute is not numeric, it will return a value of zero. uniqueCount(attribute) Use the uniqueCount( ) function to return the number of unique values recorded for an attribute over the time range specified. Tip To optimize query performance, this function returns approximate results for queries that inspect more than 256 unique values. uniques(attribute [,limit]) Use the uniques( ) function to return a list of unique values recorded for an attribute over the time range specified. When used along with the facet clause, a list of unique attribute values will be returned per each facet value. The limit parameter is optional. When it is not provided, the default limit of 1,000 unique attribute values per facet is applied. You may specify a different limit value, up to a maximum of 10,000. The uniques( ) function will return the first set of unique attribute values discovered, until the limit is reached. Therefore, if you have 5,000 unique attribute values in your data set, and the limit is set to 1,000, the operator will return the first 1,000 unique values that it discovers, regardless of their frequency. The maximum number of values that can be returned in a query result is the product of the uniques( ) limit times the facet limit. In the following query, the theoretical maximum number of values that can be returned is 5 million (5,000 x 1,000). Depending on the data set being queried, and the complexity of the query, memory protection limits may prevent a very large query from being executed. From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 Copy Using tuple If you'd like to know the unique combinations of a handful of attributes, you can structure a query in the format SELECT unique(tuple(x, y, ... z)) ...` to get all the unique tuples of values, to maintain their relationship. In the following query, tuple is used on index and cellName together to find uniques where those two values occur in combination. FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) Copy Type conversion NRQL does not support \"coercion.\" This means that a float stored as a string is treated as a string and cannot be operated on by functions expecting float values. You can convert a string with a numeric value or a boolean with a string value to their numeric and boolean types with these functions: Use the numeric() function to convert a number with a string format to a numeric function. The function can be built into a query that uses math functions on query results or NRQL aggregator functions, such as average(). Use the boolean() function to convert a string value of \"true\" or \"false\" to the corresponding boolean value.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.22705,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> syntax, clauses, and functions",
        "sections": "<em>NRQL</em> syntax, clauses, and functions",
        "tags": "Query your <em>data</em>",
        "body": " <em>NRQL</em> is used for, what <em>data</em> you can query with it, and basic <em>NRQL</em> syntax Examine <em>NRQL</em> queries used to build New Relic charts Learn how to query the Metric <em>data</em> type Simulate SQL JOIN functions Use funnels to evaluate a series of related <em>data</em> Format <em>NRQL</em> for querying with the Event API Query"
      },
      "id": "604456c1196a678db8960f41"
    },
    {
      "sections": [
        "NRQLの構文、句、関数",
        "構文",
        "クエリの構成要素",
        "必要な句",
        "必須：SELECT文",
        "直近1週間の平均レスポンスタイム",
        "必須：FROM句",
        "ひとつのデータタイプのクエリ",
        "複数のデータタイプのクエリ",
        "オプションの句",
        "AS句",
        "数学関数とASを使用したクエリ",
        "ファネルとASを使用したクエリ",
        "COMPARE WITH句",
        "EXTRAPOLATE句",
        "重要",
        "スループットの推定の例",
        "時系列としてのスループットの推定の例",
        "FACET句",
        "count()を使用したファセットクエリ",
        "uniqueCount()を使用したファセットクエリ",
        "時間範囲で結果をグループ化",
        "FACET ... AS句",
        "FACET CASES句",
        "WHEREの基本的な使い方",
        "複数の属性に基づくグループ化",
        "ASを使用したグループのラベル付け",
        "FACET ... ORDER BY 句",
        "ヒント",
        "LIMIT句",
        "LIMITを使用したクエリ",
        "OFFSET 句",
        "ORDER BY 句",
        "SHOW EVENT TYPES句",
        "直近1日間のデータタイプ",
        "SINCE句",
        "SLIDE BY句",
        "SLIDE BYをMAXまたはAUTO間隔と一緒に使用する",
        "TIMESERIES句",
        "設定した間隔を使用する",
        "自動設定した間隔を使用する",
        "MAXインターバルを使用する",
        "UNTIL句",
        "WHERE句",
        "3つの条件を使ったクエリの例",
        "WITH METRIC_FORMAT 句",
        "WITH TIMEZONE句",
        "メトリックデータのクエリを行う",
        "集計関数",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "特定の顧客の Apdexを取得する",
        "特定のトランザクションのApdexを取得する",
        "アプリ全体のApdexを取得する",
        "average(attribute)",
        "buckets(attribute, ceiling \\[,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(\\*)",
        "derivative(attribute \\[,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "earliest(attribute)",
        "PageView からユーザーエージェントごとに最も古い国を取得",
        "eventType()",
        "filter()関数でeventType()を使用する",
        "FACETでeventType()を使用する",
        "filter(function(attribute), WHERE condition)",
        "オファーコードを使用した購入を分析する",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling \\[,number of buckets])",
        "PageViewイベントからのレスポンスタイムのヒストグラム",
        "Prometheusヒストグラムバケット",
        "New Relicディストリビューションメトリック",
        "keyset()",
        "データタイプのすべての属性を表示",
        "latest(attribute)",
        "PageView からユーザーエージェントごとに最新の国を取得",
        "latestrate(attribute, time interval)",
        "PageView期間の最新の変化率を取得する",
        "max(attribute)",
        "median(attribute)",
        "中央値クエリ",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "WHERE句条件内のmod()",
        "FACET句内のmod()",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute \\[, percentile \\[, ...]])",
        "基本的なパーセンタイルのクエリ",
        "predictLinear(attribute, \\[,time interval])",
        "rate(function(attribute) \\[,time interval])",
        "基本的な評価クエリ",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute \\[,limit])",
        "タプルの使用",
        "データ型変換",
        "その他のヘルプ"
      ],
      "title": "NRQLの構文、句、関数",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "86a104da11c2a96cd4c395682c86dc9205a32327",
      "image": "https://docs.newrelic.com/jp/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/images/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-04-11T20:57:35Z",
      "updated_at": "2021-04-06T00:25:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQLは、New Relicデータベースのクエリに使用可能なクエリ言語です。このドキュメントではNRQLの構文、句、構成要素、関数について説明します。 構文 このドキュメントは、NRQLクエリにおいて使用される関数と句の参考資料です。NRQLを理解するためのその他のリソース： NRQLの紹介：どのようなNRQLが使用されるのか、それによってどのようなデータをクエリできるのか、そして基本的なNRQL構文について説明しています。 New Relicチャートの作成に使用するNRQLクエリを検証する SQL JOIN関数をシミュレーション ファネルを使用して一連の関連データを評価する Event APIでクエリを行うためのNRQLをフォーマットする クエリの構成要素 すべてのNRQLクエリはSELECT文または FROM句で始まります。その他すべての句は任意です。以下の句の定義には、NRQLクエリの例も含まれます。 必要な句 必須：SELECT文 SELECT属性... コピー SELECT関数（属性）... コピー SELECTは、属性または関数を指定することによってどの部分のデータタイプをクエリしたいかを指定します。その後、カンマ区切りの1つ以上の引数が続きます。各引数では、以下を実行できます。 ワイルドカードとして*を使用することにより、利用可能なすべての属性の値を取得できます。例えば：SELECT * from Transaction。 指定した属性、または カンマ区切りのリストで指定した複数の属性に関連する値を取得できます。 集約関数を選択することで、指定した属性から集約値を取得できます。 AS句を使って、各引数で返された結果にラベルを付けます。 基本的な数学関数とともにSELECTを使用することもできます。 直近1週間の平均レスポンスタイム このクエリは、直近1週間の平均応答時間を返します。 SELECT average(duration) FROM PageView SINCE 1 week ago コピー 必須：FROM句 SELECT ... FROM data type ... コピー FROM句を使用して、クエリしたいデータタイプを指定します。クエリはFROMまたはSELECTから開始することができます。カンマ区切りのリストを使って、複数のデータタイプにまたがる同じ属性の値をマージすることができます。 ひとつのデータタイプのクエリ このクエリは、直近3日間の APMトランザクション の全件数を返します。 SELECT count(*) FROM Transaction SINCE 3 days ago コピー 複数のデータタイプのクエリ このクエリは、直近3日間の APM トランザクション と Browserイベント の全カウント数を返します。 SELECT count(*) FROM Transaction, PageView SINCE 3 days ago コピー オプションの句 AS句 SELECT ... AS 'label' ... コピー AS句を使用して、シングルクォート区切りの文字列で属性、集計、ファネル内のステップ、または数学関数の結果にラベルを付けます。このラベルは結果のチャートで使用されます。 数学関数とASを使用したクエリ このクエリはセッションごとのページ数を返します。 SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView コピー ファネルとASを使用したクエリ このクエリは、過去1週間でサイトのメインページと採用情報ページの両方を訪れた人の数を返します。 SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago コピー COMPARE WITH句 SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... コピー COMPARE WITH句を使用して、2つの異なる時間範囲の値を比較します。 COMPARE WITHでは、SINCEまたはUNTIL文が必要になります。COMPARE WITHで指定された時間は、SINCEまたはUNTILで指定した時間に相対します。たとえば、SINCE 1 day ago COMPARE WITH 1 day agoは、昨日とその前日を比較します。 COMPARE WITH値の時間範囲は、常にSINCEまたはUNTILで指定されたものと同じになります。たとえば、SINCE 2 hours ago COMPARE WITH 4 hours agoは、午後3時から午後5時の範囲と午後1時から午後3時の範囲を比較します。 COMPARE WITHは、折れ線グラフまたはビルボードのいずれかの形式にすることができます： TIMESERIESを使うと、COMPARE WITHは時系列でマッピングされた比較で折れ線グラフを作成します。 TIMESERIESがない場合、COMPARE WITHは現在値とCOMPARE WITH値からの増減率でビルボードを生成します。 例: このクエリは、過去1時間の95パーセンタイルを1週間前の同じ時間範囲と比較した折れ線グラフでデータを返します。一つ目は単一の値、その次は折れ線グラフです。 SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO コピー EXTRAPOLATE句 この句は以下のデータタイプで使用可能です： Transaction TransactionError APMエージェントのAPIを通じて報告されたカスタムイベント EXTRAPOLATEの目的は、クエリ結果がシステム内のアクティビティ全体をより厳密に表現できるよう、イベントデータのAPMエージェントサンプリングの影響を数学的に補うことです。 この節は、New Relic APMエージェントが余りにも多くのイベントを報告することで、収穫サイクルの報告上限を超過しがちになる際に便利です。その場合、エージェントはイベントのサンプリングを開始します。 EXTRAPOLATEに対応したNRQLクエリでこれを使用した場合、報告されたイベントと合計イベントの比率を基に、合計未サンプルデータの近似を推定します。この句に未対応であるか、サンプルデータを使用していないNRQLでこれを使用した場合、結果に影響を与えません。 重要 EXTRAPOLATEは、（スループットやエラー率など）同種データについて最も有用なことに注意してください。（uniqueCount() や uniques()など）特徴的なことの数を外挿しようとする際には有効ではありません。 この句は、以下のいずれかの集約関数を利用したNRQLクエリでのみ機能します： apdex average count histogram sum percentage （引数として取る関数がEXTRAPOLATEに対応している場合） rate （引数として取る関数がEXTRAPOLATEに対応している場合） stddev スループットの推定の例 interestingApplicationという名前のサービスの推定スループットを示すクエリ。 SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE コピー 時系列としてのスループットの推定の例 トランザクション名ごとに、時系列として表示するinterestingApplicationという名前のサービスの推定スループットを示すクエリ。 SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE コピー FACET句 SELECT ... FACET attribute ... コピー FACETを使用すると、結果を属性値で分割してグループ化できます。例えば、PageViewデータでdeviceType別にFACETを行い、トラフィックの何割が携帯電話、タブレット、およびデスクトップデバイスから発生しているかを把握することができます。 LIMIT句を使用して、表示するファセットの数を指定します（デフォルトは10）。複雑なグループ化には、FACET CASESを使用してください。FACET句は、カンマで区切られた最大5つの属性をサポートします。 ファセットは、SELECT句で指定した最初のフィールドによって降順でソートされます。2,000件以上のユニーク値を持つ属性をファセットに指定した場合、ファセット値のサブセットを選択し、それらをクエリタイプに従って並べ替えます。 min()、max()、またはcount()を選択すると、FACETはこれらの関数を使用してファセットの選択方法とソート方法を決定します。その他の関数を選択すると、FACETはファセット対象の属性の発生頻度に基づいて、ファセットの選択方法とソート方法を決定します。 実際の例を使った複数の属性に対するファセットについては、こちらの New Relicのブログ記事をご覧ください。 count()を使用したファセットクエリ このクエリは、ページビュー数が最も多い都市を表示します。このクエリは、都市ごとのページビューの合計数を使用してファセットの選択方法と並べ替え方法を決定します。 SELECT count(*) FROM PageView FACET city コピー uniqueCount()を使用したファセットクエリ このクエリは、最も多数のユニークURLにアクセスしている都市を表示します。このクエリは、特定の都市が結果に表れる合計回数を使用して、ファセットの選択方法と並べ替え方法を決定します。 SELECT uniqueCount(pageUrl) FROM PageView FACET city コピー 時間範囲で結果をグループ化 高度なセグメンテーションやコホート分析では、バケット機能でファセットすることでデータをより効率的に分割することができます。 コホート分析は、タイムスタンプに基づいて結果をグループ化する方法です。指定範囲日時に対応するバケットに結果を分割することができます。 FACET ... AS句 FACET ... AS 句では、クエリで AS キーワードを使用してファセットに名前を付けます。この句は、結果のファセットに明確な名前または簡略化された名前を追加するのに役立ちます。ネスト構造の集計クエリで、ファセットの名前を変更するためにも使用できます。 FACET ... AS クエリでは、結果のファセット名が変更されますが（たとえば、テーブルのヘッダーとして表示される場合）、実際のファセット名自体は変更されません。 FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' コピー FACET CASES句 SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... コピー FACET CASESを使用して、FACETで可能な範囲を超えた複雑な条件別にデータを取り出します。複数の条件はカンマ,で区切ります。たとえば、PageViewデータをクエリして、1秒未満、1秒から10秒、10秒を上回るといったカテゴリにFACET CASESを行うことができます。ケース内の複数の属性を組み合わせたり、ASセレクタを使ってケースにラベルを付けることができます。データ点は、最大で1つのファセットケースに追加されます。つまり、一致する最初のファセットになります。 属性とともに時間関数も使用できます。 WHEREの基本的な使い方 SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) コピー 複数の属性に基づくグループ化 この例は、トランザクション名にloginが含まれる1つのバケットと、URLにloginが含まれ、かつカスタム属性がユーザーが有料ユーザーであったことを示すもう1つのバケットに結果をグループ化します： SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') コピー ASを使用したグループのラベル付け この例は、結果に目視可能な名前をつけるためにASセレクタを使います： SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') コピー FACET ... ORDER BY 句 NRQL では、デフォルトは SELECT 句の最初の集計で、クエリ内のファセットの選択をガイドします。FACET ... ORDER BY 句では、ORDER BY 修飾子を使用して集計関数を追加し、ファセットの選択方法を指定することで、このデフォルトの動作をオーバーライドできます。具体的には、LIMIT句によって制限される前に、最終結果に含めるファセットの優先度をオーバーライドします。この句はクエリで使用できますが、アラートやストリーミングには使用できません。 この例では、FACET ... ORDER BY を使用してアプリ トランザクションの平均期間を見つける方法を示し、応答サイズが最大のアプリによる上位10（デフォルトの制限）の最大期間を示しています。この場合、FACET ... ORDER BY が使用されていない場合、クエリ結果には、アプリの選択とは関係のない応答サイズで、期間が最も長い上位10件が代わりに表示されます。 FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) コピー ヒント LIMIT 句が適用される前に操作が実行されるため、FACET ... ORDER BYは、最終的なクエリ結果の種類に影響を与えません。これは、非時系列クエリの結果で特に顕著になります。 重要 この場合の ORDER BY 修飾子は、ORDER BY 句とは機能が異なります。FACET attribute1 ORDER BY attribute2 の形式に従うクエリを解析する場合、NewRelic はこれらのクエリを FACET ... ORDER BY クエリとして読み取りますが、ORDER BY が FACET の直後に表示される場合に限定されます。それ以外の場合、ORDER BY は New Relic によって句として解釈されます。 LIMIT句 SELECT ... LIMIT count ... コピー LIMIT句を使用して、FACETクエリで返されるファセット値の最大数あるいはSELECT *クエリで返される項目の最大数を管理します。この句は、単一の整数値を引数に取ります。LIMIT句が指定されないか、値が提供されなかった場合、リミットのデフォルト設定はFACETクエリの場合は10に、SELECT *クエリの場合は100となります。 LIMIT句で許容される最大値は2,000です。 LIMITを使用したクエリ このクエリはセッション数上位20カ国を表示し、各国のWindowsユーザー限定でレスポンスタイムの95 パーセンタイルを提供します。 SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY コピー OFFSET 句 SELECT ... LIMIT count OFFSET count ... コピー OFFSET句とLIMIT句を使用して、SELECT *またはSELECTの列クエリによって返される行の一部を制御します。 LIMIT 句と同様に、 OFFSET は引数として単一の整数値を取ります。 OFFSET は、クエリで選択された行が返される前に、スキップされる行数を設定します。これは LIMIT によって制約されます。 OFFSET 行はスキップされ、直近のレコードから開始されます。 たとえば、SELECT InterestingValue FROM Minute_Report LIMIT 5 OFFSET 1 のクエリは、 Minute_Report から、直近の値を除いて最後の5つの値を返します。 ORDER BY 句 ORDER BY 句を使用すると、行でイベント属性を選択するクエリで結果を並べ替える方法を指定できます。 このクエリは、期間順にトランザクションを並べ替えます。 FROM Transaction SELECT appName, duration ORDER BY duration コピー デフォルトの並べ替え順序は昇順ですが、 ASC または DESC の修飾子を追加することで変更できます。 SHOW EVENT TYPES句 SHOW EVENT TYPES... コピー SHOW EVENT TYPESは、特定の時間範囲内にアカウントに存在するすべてのデータタイプのリストを返します。これは、SELECTの代わりにクエリの最初の句として使用されます。 重要 この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータタイプを指します。 直近1日間のデータタイプ このクエリは、直近1日のすべてのデータタイプを返します。 SHOW EVENT TYPES SINCE 1 day ago コピー SINCE句 SELECT ... SINCE [numerical units AGO | phrase] ... コピー デフォルト 値は 1 時間前です。 SINCE句を使用して、返されたデータに対する時間範囲の開始時点を定義します。NRQLを使用する場合、UTCタイムスタンプまたは相対時間範囲を設定できます。タイムゾーンは結果ではなく、クエリに対して指定できます。NRQLの結果はシステム時間に基づきます。 詳細な情報と例については、ダッシュボードとチャートで時間範囲を設定するをご覧ください。 SLIDE BY句 SLIDE BY 句は、スライディングウィンドウと呼ばれる機能をサポートしています。スライディングウィンドウを使用すると、SLIDE BYデータは、互いに重複する時間の「ウィンドウ」に収集されます。これらのウィンドウは、移動集計（移動平均など）が狭い時間枠からの集計よりも重要である場合に、変動の多い折れ線グラフを滑らかにするのに役立ちます。 SLIDE BYを使用するには、TIMESERIES句の後のクエリにこの句を配置します。たとえば、このクエリは1分のSLIDE BY間隔で5分間のウィンドウにデータをプルします。つまり、各ウィンドウは5分間続きますが、ウィンドウ1は0分後に開始し、ウィンドウ2は1分後に開始し、ウィンドウ3は2分後に開始します。 SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute コピー SLIDE BYをいつ、どのように使用できるかについて詳しくは、スライディングウィンドウを使用してよりスムーズなグラフを作成するをご覧ください。 SLIDE BYをMAXまたはAUTO間隔と一緒に使用する スライディングウィンドウは、MAXまたはAUTOと組み合わせて使用できます。ただし、MAXまたはAUTOをTIMESERIES とSLIDE BYの間に配置することはできません。 このクエリは、SLIDE BYウィンドウ間隔を自動的に決定します。 SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO コピー このクエリは、SLIDEBYウィンドウを最大間隔に設定します。 SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX コピー 重要 AUTOまたはMAXによって決定されるSLIDE BY値は、ウィンドウ サイズよりも大きいステップ間隔を生成する可能性があり、ギャップや予期しない結果を引き起こす可能性があります。 TIMESERIES句 SELECT ... TIMESERIES integer units ... コピー TIMESERIES句を使用して、指定期間単位の時系列としてデータを返します。TIMESERIESは特定のチャートをトリガするために使用されることから、デフォルト値はありません。 時間範囲を指定するには、integer unitsを使用します。例えば： TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds 以下の例に示すように、TIMESERIESをMAX、AUTO、SLIDE BYなどの引数と組み合わせると、クエリ結果をさらに調整できます。 重要 average( )またはpercentile( )などの関数では、集計ウィンドウを大きく設定することで、外れ値に対して大幅なスムージング効果が得られます。これは、クエリがスライディングウィンドウを使用するかどうかに関係なく当てはまります。 設定した間隔を使用する 指定された値は、グラフを分割する単位を示します。たとえば、以下のようにして1日のグラフを30分刻みで表示します。 SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes コピー 自動設定した間隔を使用する TIMESERIESはAUTOに設定することもでき、これによってグラフが適切な数の区分に分割されます。たとえば、1日のチャートは30分間隔で分割され、1週間のチャートは6時間間隔で分割されます。 このクエリは、6時間間隔のデータ点で、1週間のクライアントサイドのトランザクションタイムの50パーセントタイルと90パーセンタイルを示す折れ線グラフを返します。 SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO コピー MAXインターバルを使用する TIMESERIESをMAXに設定することで時間枠が自動的に調整され、指定された期間で許可された間隔数を最大にすることができます。これによって、TIMESERIESバケットを手動で更新することなく時間枠を更新でき、認められた最大インターバル数に時間枠を分割できます。返されるTIMESERIESバケットの最大数は366です。 例えば、以下のクエリでは4分間の間隔を作成していますが、これは1日のチャートの上限となります。 SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX コピー UNTIL句 SELECT ... UNTIL integer units AGO ... コピー デフォルト 値は NOWです。UNTILは、デフォルト以外の終了点を指定するためのみに使用してください。 UNTIL句はデータを返す時間範囲の終了時点を定義します。時間範囲を指定するとデータが保存されるようになり、時間範囲が終了した後に確認することができます。時間は UTC タイムスタンプ または相対時間範囲を指定できます。タイムゾーンは結果ではなく、クエリに対して指定できます。返される結果はシステム時間に基づきます。 詳細な情報と例については、ダッシュボードとチャートで時間範囲を設定するをご覧ください。 WHERE句 WHERE句を使用して、結果をフィルタリングします。NRQLは、句で指定した条件を満たす結果を返します。 SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... コピー 複数の条件を指定する場合は、条件を演算子ANDまたはORで区切ります。 SQLのjoinをシミュレートしたい場合は、WHEREまたはFACET句でカスタム属性を使用します。 WHERE句が受け付ける演算子 説明 =, !=, <, <=, >, >= NRQLは標準的な比較演算子を受け付けます。 例: state = 'WA' AND 2つの条件の論理積を定義するために使用します。 OR 2つの条件の論理和を定義するために使用します。 IS NULL 属性がnull値を持つかどうかを判定します。 IS NOT NULL 属性がnull値を持たないかどうかを判定します。 IN 属性の文字列値が指定したセットに存在するかどうかを判断します。この方法を使うと、複数のWHERE句を組み合わせた場合よりもパフォーマンスが向上します。 例: animalType IN （'cat', 'dog', 'fish'） NOT IN 属性の文字列値が指定したセットに存在しないかどうかを判断します。この方法を使うと、複数のWHERE句を組み合わせた場合よりもパフォーマンスが向上します。 値は括弧で囲み、カンマで区切る必要があります。例えば： SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') コピー LIKE 属性に指定の部分文字列が含まれるかどうかを判断します。 LIKE演算子の文字列引数は、文字列内の任意の位置にワイルドカードとしてパーセント記号（%）を受け付けます。部分文字列が一致対象の文字列で開始（先頭に一致）または終了（末尾に一致）しない場合、ワールドカードを文字列の先頭または末尾に指定する必要があります。 例： userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE 属性に指定の部分文字列が含まれないかどうかを判定します。 RLIKE 属性に特定のRegex 部分文字列が含まれるかどうかを判断します。RE2 構文を使用します。 例： appName RLIKE 'z.*|q.*'' z-app q-app hostname RLIKE 'ip-10-351-[0-2]?[0-9]-.*' ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 重要 注: Regexパターンではスラッシュをエスケープする必要があります。たとえば、\\dは\\\\dとする必要があります。 Regexではデフォルトで文字列全体マッチとなっているため、^と$は暗黙となり、追加する必要はありません。 Regexパターンにキャプチャグループが含まれる場合、そのグループは無視されます。つまり、クエリで後で使用するためにグループはキャプチャされません。 NOT RLIKE 属性に指定のRegex部分文字列が含まれないかどうかを判定します。RE2 構文を使用します。 3つの条件を使ったクエリの例 このクエリは、過去24時間、米国およびカナダ国内のSafariユーザーについて、URLにcheckoutが含まれるページのブラウザレスポンスタイムを返します。 SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago コピー WITH METRIC_FORMAT 句 メトリックデータのクエリに関する情報については、メトリックスのクエリを行うをご覧ください。 WITH TIMEZONE句 SELECT ... WITH TIMEZONE (selected zone) ... コピー デフォルトで、クエリ結果は、現在使用中のブラウザのタイムゾーンで表示されます。 WITH TIMEZONE句を使用して、タイムゾーンが未指定のクエリで日付や時刻のタイムゾーンを選択します。 たとえば、SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'というクエリ句は、東部標準時の月曜日午前12時から東部標準時の火曜日午前12時までに記録されたデータを返します。 利用可能なタイムゾーンの選択 アフリカ/アビジャン アフリカ/アディスアベバ アフリカ/アルジェ アフリカ/ブランタイヤ アフリカ/カイロ アフリカ/ウィントフック 米州/アダック 米州/アンカレッジ 米州/アラグアイナ 米州/アルゼンチン/ブエノスアイレス 米州/ベリーズ 米州/ボゴタ 米州/カンポグランデ 米州/カンクン 米州/カラカス 米州/シカゴ 米州/チワワ 米州/ドーソンクリーク 米州/デンバー 米州/エンセナーダ 米州/グリーンベイ 米州/ゴットホープ 米州/グースベイ 米州/ハバナ 米州/ラパス 米州/ロサンゼルス 米州/ミクロン 米州/モンテビデオ 米州/ニューヨーク 米州/モローニャ 米州/サンティアゴ 米州/サンパウロ 米州/セントジョンズ アジア/アナディル アジア/バンコク アジア/ベイルート アジア/ダマスカス アジア/ダッカ アジア/ドバイ アジア/ガザ アジア/香港 アジア/イルクーツク アジア/エルサレム アジア/カブール アジア/カトマンズ アジア/コルカタ アジア/クラスノヤルスク アジア/マガダン アジア/ノボシビルスク アジア/ヤンゴン アジア/ソウル アジア/タシケント アジア/テヘラン アジア/東京 アジア/ウラジオストク アジア/ヤクーツク アジア/エカテリンブルク アジア/エレバン 大西洋/アゾレス 大西洋/カーポベルデ 大西洋/スタンリー オーストラリア/アデレード オーストラリア/ブリスベン オーストラリア/ダーウィン オーストラリア/ユークラ オーストラリア/ホバート オーストラリア/ロードハウ オーストラリア/パース チリ/イースター島 その他/GMT+10 その他/GMT+8 その他/GMT-11 その他/GMT-12 ヨーロッパ/アムステルダム ヨーロッパ/ベルファスト ヨーロッパ/ベオグラード ヨーロッパ/ブリュッセル ヨーロッパ/ダブリン ヨーロッパ/リスボン ヨーロッパ/ロンドン ヨーロッパ/ミンスク ヨーロッパ/モスクワ 太平洋/オークランド 太平洋/チャタム 太平洋/ガンビエ 太平洋/キリバス 太平洋/マルケサス 太平洋/ミッドウェイ 太平洋/ノーフォーク 太平洋/トンガタプ UTC 詳細な情報と例については、ダッシュボードとチャートで時間範囲を設定するをご覧ください。 メトリックデータのクエリを行う NRQLを使用してメトリックデータのクエリを行うには、次のいくつかの方法があります： メトリックタイムスライスデータをクエリ（New Relic APM、Browser、Mobileによりレポートされます） Metricデータタイプをクエリ（一部のインテグレーションおよびテレメトリーSDKによりレポートされます） New Relicでのメトリックスの理解の詳細については、メトリックデータのタイプをご覧ください。 集計関数 集約関数を使用して、NRQLクエリのデータを絞り込み、集約できます。以下に、集約関数の利用に関する便利な情報を提供します： New Relic UniversityのFilter Queries、Apdex Queries、およびPercentile Queriesのチュートリアル。または、完全なWriting NRQL クエリのオンラインコースにアクセスしてください。 データタイプ「型強制」には対応していません。利用可能なデータ型変換関数の詳細を参照してください。 New Relic Insights の コホート分析 ページでは、コホート分析の関数が表示されます。コホート関数は、時間別にトランザクションを集計します。 以下は、利用可能な集約関数になります。以下の定義には、NRQLクエリの例が含まれます。 例： SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago コピー aggregationendtime() aggregationendtime()関数を使用して、関連する集計の時刻を返します。より具体的には、aggregationendtime()関数は、特定の集計に対して集計の期間終了のタイムスタンプを提供します。たとえば、時系列クエリでは、1時間分のデータを含むデータポイントの場合、関数はその時間の終わりのタイムスタンプを返します。 apdex(attribute, t: ) apdex関数を使用して、単一のトランザクションまたはすべてのトランザクションに対してApdexスコアを返します。属性は、durationやbackendDurationなどのレスポンスタイムに基づいて、任意の属性に指定できます。t: 引数は Apdex T の閾値を秒単位で定義します。 apdex（ ）関数が返すApdexスコアは、実行時間のみに基づくものです。APMエラーは考慮していません。エラーが含まれているにもかかわらず、トランザクションがApdex T以下で完了する場合、そのトランザクションはapdex （ ）関数によって満足と評価されます。 特定の顧客の Apdexを取得する もし 定義済みのカスタム属性 がある場合は、それらの属性に基づいて絞り込むことができます。たとえば、特に重要な顧客のApdexを監視することができます。 SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago コピー 特定のトランザクションのApdexを取得する name属性を使用して特定のトランザクションのスコアを返す、またはnameを省略して総合的なApdexを返します。このクエリは、直近1時間の Controller/notes/index トランザクションのApdexスコアを返します。 SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago コピー apdex関数は、サイトに対するユーザーの満足度を測定するApdexスコアを返します。引数は、秒単位のレスポンスタイムの属性とApdex Tの閾値です。 アプリ全体のApdexを取得する このクエリの例では、直近3週間のアプリケーション全体のApdexを返します。 SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago コピー average(attribute) average( )関数を使用して、属性の平均値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。 buckets(attribute, ceiling \\[,number of buckets]) buckets()関数を使用して、FACET句ごとに分割されたデータを、範囲に基づきバケットに集約します。New Relicデータベースの数値として保存される属性ごとにバケットにまとめることができます。 この関数は 3 つの引数を取ります。 属性名 サンプル範囲の最大値。外れ値は最終バケットに表示されます。 バケットの合計数 詳細と例については、データをバケットに分割をご覧ください。 bucketPercentile(attribute) bucketPercentile( )関数は、Prometheusのhistogram_quantile関数のNRQL版です。ディメンションメトリックデータとともに使用します。分位数の代わりにNew Relicパーセンタイルを返します。これは分位数 * 100です。 bucketPercentile( )関数を使用して、Prometheus形式のヒストグラムデータから分位数を計算します。 バケット名を引数として取得し、バケットの境界とともにパーセンタイルをレポートします： SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago コピー オプションで、引数としてパーセンタイル指定を追加できます： SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago コピー 複数のメトリックスを使用してPrometheusヒストグラムデータを構成しているため、関連する<basename>に関して特定のPrometheusメトリックスのクエリを行う必要があります。 たとえば、PrometheusヒストグラムからNRQLを使用して<basename> prometheus_http_request_duration_secondsによりパーセンタイルの計算を行うには、bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)を使用します。 _ bucketがサフィックスとして<basename>の最後に追加されていることに注意してください。 詳しくは、Prometheus.ioドキュメントを参照してください。 cardinality(attribute) cardinality( )関数を使用して、メトリック上のすべてのディメンション（属性）の組み合わせの数を取得します。 次の3つの引数を取りますが、すべてオプションです： Metric name: ある場合、cardinality( )は指定したメトリックのみを計算します。 Include: ある場合、Includeリストは、濃度計算をこの属性に制限します。 Exclude: ある場合、Excludeリストにより、この属性は濃度計算で使用されなくなります。 SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) コピー count(\\*) count（ ）関数を使用して、利用可能なレコード数を返します。これは単一の引数を受け入れます (*、属性、または一定値のいずれか)。現在、一般的なSQL動作に従って、その引数に対する値を持つすべてのレコードを計上します。 count（*）は特定の属性を示すものではないため、結果はデフォルトの「humanize」形式でフォーマットされます。 derivative(attribute \\[,time interval]) derivative()は、所定のデータセットの変化率を検索します。線形最小二乗回帰を使用して変化率を計算し、微分係数を近似します。この計算では複数のデータポイントの比較が必要であるため、評価範囲にデータポイントが1つしかない場合、解が求められず、結果はnull値になります。 時間間隔は、変化率を計算する期間です。たとえば、derivative(attributeName, 1 minute)は、1分あたりの変化率を返します。 dimensions(include: {attributes}, exclude: {attributes}) dimensions( )関数を使用して、データタイプのすべてのディメンション値を返します。 オプションの引数を使用して、特定の属性を明示的に含めたり除外したりすることができます： Include: ある場合、includeリストは、dimensions( )をそれらの属性に限定します。 Exclude: ある場合、dimensions( )の計算ではそれらの属性を使用しません。 FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() コピー FACET句とともに使用する場合、dimensions( )は、未集計クエリでのPrometheusの動作と同様に、イベントタイプで使用できるすべてのファセットについて一意の時系列を生成します。 earliest(attribute) latest（ ）関数を使用して、指定された時間範囲における属性の最も古い値を返します。 単一の引数を取ります。最初の引数以外は無視されます。 FACETと併用する場合、この関数は得られた各ファセットの属性の最新値を返します。 PageView からユーザーエージェントごとに最も古い国を取得 このクエリは、PageView イベントからユーザーエージェントごとに最も古い国コードを返します。 SELECT earliest(countryCode) FROM PageView FACET userAgentName コピー eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... コピー eventType()関数は、選択したデータタイプ別に結果を取り出すためにFACET句で使用、または特定のデータタイプに結果をフィルタリングするためにWHERE句で使用します。これは filter() や percentage() 関数で特定のデータタイプを対象とする際に特に便利です。 重要 この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータタイプを指します。 filter()関数でeventType()を使用する このクエリは、合計Transactionの結果あたりの合計TransactionErrorの結果の割合を返します。eventType()関数を使用して、filter()関数で特定のデータタイプをターゲットにすることができます。 SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago コピー FACETでeventType()を使用する このクエリは、各データタイプ（TransactionおよびTransactionError）が返すレコードの数を表示します。 SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES コピー filter(function(attribute), WHERE condition) filter（ ）関数を使用して、SELECT文内の集計関数の1つに結果を制限できます。filter()は、FACETまたはTIMESERIESと併用することができます。 オファーコードを使用した購入を分析する filter()は、一連のトランザクションで購入された商品の中で、オファーコードを使用して購入された商品と、オファーコードを使用せずに購入された商品を比較するために使用できます： filter（ ）関数を使用して、SELECT文内の集計関数の1つに結果を制限できます。 funnel(attribute, steps) funnel()関数を使用して、ファネルチャートを生成します。属性を最初に引数に取ります。その後、カンマで区切られた複数のWHERE句（オプションでラベル付け用にAS句を含める）をステップとして指定します。 詳細な情報と例については、 ファネルのドキュメントをご覧ください。 getField(attribute, field) getField()関数を使用して、複雑なメトリックスからフィールドを抽出します。 次の引数を取ります： メトリックのタイプ サポートされたフィールド summary count、total、max、min gauge count、total、max、min、latest distribution count、total、max、min counter count 例： SELECT max(getField(mySummary, count)) from Metric コピー SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 コピー histogram(attribute, ceiling \\[,number of buckets]) histogram（ ）関数を使用して、ヒストグラムを生成します。この関数は 3 つの引数を取ります。 属性名 サンプル範囲の最大値 バケットの合計数 PageViewイベントからのレスポンスタイムのヒストグラム このクエリは 20 バケットにわたって 10 秒以内のレスポンスタイムのヒストグラムを生成します。 SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago コピー Prometheusヒストグラムバケット histogram( )では、Prometheusヒストグラムバケットを受け取ります: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago コピー New Relicディストリビューションメトリック histogram( )ではディストリビューションメトリックを入力として受け取ります: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago コピー keyset() keyset()を使用すると、所定の時間範囲における所定のデータタイプに対するすべての属性を表示できます。この関数は引数を取りません。文字列型キー、数値型キー、ブーリアン型キー、およびすべてのキーをグループ化した JSON 構造体を返します。 データタイプのすべての属性を表示 このクエリは、最後の日からのPageViewイベントで見つかった属性を返します： SELECT keyset() FROM PageView SINCE 1 day ago コピー latest(attribute) latest（ ）関数を使用して、指定された時間範囲における属性の最新値を返します。 単一の引数を取ります。最初の引数以外は無視されます。 FACETと併用する場合、この関数は得られた各ファセットの属性の最新値を返します。 PageView からユーザーエージェントごとに最新の国を取得 このクエリは、PageView イベントからユーザーエージェントごとに最新の国コードを返します。 SELECT latest(countryCode) FROM PageView FACET userAgentName コピー latestrate(attribute, time interval) latestrate( )関数を使用して、最後の2つのデータポイントに基づく値の変化率を返します。問題となる属性を最初の引数として受け取り、結果である変化率の時間の単位を2番目の引数として受け取ります。この関数は、属性の変化/時間間隔の単位で結果を返します。 この関数は、最先端の傾向を確認するために、属性の最新の変化率を提供するのに役立ちます。 PageView期間の最新の変化率を取得する このクエリは、最後の2つのデータポイントに基づいて期間の変化率を返します。 1 SECOND 引数があるため、期間/秒の単位で返されます。 SELECT latestrate(duration, 1 SECOND) FROM PageView コピー max(attribute) max（ ）関数を使用して、指定された時間範囲内に記録された数値属性の最大値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。 median(attribute) median( )関数を利用して、属性の中央値あるいは50パーセンタイルを返します。パーセンタイルクエリの詳細に関しては、percentile()を参照してください。 ヒント median( )クエリは、クエリビルダーを利用する場合にのみ利用できます。 中央値クエリ このクエリは、中央値に関する折れ線グラフを生成します。 SELECT median(duration) FROM PageView TIMESERIES AUTO コピー min(attribute) min（ ）関数を使用して、指定された時間範囲内に記録された数値属性の最小値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。 minuteOf(attribute) minuteOf()関数を使用して、有効なタイムスタンプ値を持つ属性の分の部分（0～59）のみを抽出します。 mod(attribute, divisor) 与えられた数値属性の値（最初の引数、すなわち被除数）を数値（2つ目の引数、すなわち除数）で割った後、mod( )関数を使用してfloor係数を返します。このモジュロ演算は、WHERE句の条件内で使用して結果の任意のサブセットにフィルターしたり、FACET句で結果セットをさらに分割したりする方法として使用できます。 WHERE句条件内のmod() FROM Transaction SELECT * WHERE mod(port, 2) = 1 コピー FACET句内のmod() FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) コピー percentage(function(attribute), WHERE condition) percentage（ ）関数を使用して、いくつかの条件に一致する目的のデータセットの割合を返します。 最初の引数には、目的の属性に対する集計関数が必要です。必ず2つの引数を使用してください（最初の 2 つ以外の引数は無視されます）。属性が数値でない場合、この関数は 100% を値として返します。 percentile(attribute \\[, percentile \\[, ...]]) percentile（ ）関数を使用して、所定の指定パーセンタイルでの属性の概算値を返します。この関数は属性が必須であり、パーセンタイル点を表す引数はいくつでも指定できます。percentile() 関数は、小数点以下3桁までの表示を可能にすることで、より厳密な内容を提供できます。パーセンタイルの閾値は小数点値として指定される場合があるものの、大半のデータセットにおいて、互いに0.1よりも近いパーセンタイルは解決されない点に注意してください。 パーセンタイルの表示例 TIMESERIESを使用して、時系列でマッピングされたパーセンタイルで折れ線グラフを生成します。 TIMESERIESを省略して、パーセンタイルの集計値を示すビルボードと属性シートを生成します。 パーセンタイルが指定されていない場合、デフォルトで 95 パーセンタイルとなります。50パーセンタイル値、つまり中央値のみを返すには、median()を使用することもできます。 基本的なパーセンタイルのクエリ このクエリは 5、50、95 パーセンタイルの折れ線を表示する折れ線グラフを生成します。 SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO コピー predictLinear(attribute, \\[,time interval]) predictLinear()は、derivative()関数の拡張です。同様の方法の最小2乗線形回帰を使用して、データセットの将来値を予測します。 時間間隔は、クエリでどの程度将来まで扱うかを表します。たとえば、predictLinear(attributeName, 1 hour)は、1時間の線形予想をクエリの時間枠の将来に当てはめます。 一般に、predictLinear()は、ディスクスペースのような増加が続く値や大きなトレンドの予想などで有用です。 predictLinear()は線形回帰のため、クエリを行っているデータセットに習熟していると、正確な長期的な予想を行えます。 指数的または対数的、その他の非線形的に増加するデータセットでは、非常に短期的な予想でのみ有効な可能性が高いと言えます。 New Relicでは、TIMESERIESクエリでpredictLinearを使用することを推奨していません。これは、各バケットがクエリ内の相対的な期間に基づき個別に予想を行う、つまり、そうしたクエリは時系列終了以後の予想は示さないためです。 rate(function(attribute) \\[,time interval]) rate ()関数を使用して、時間間隔ごとに所定のクエリの頻度またはレートを視覚化します。たとえば、1 時間の 1 分あたりのページビュー数や 1 日間の 1 時間あたりのサイトのユニークセッション数を把握したい場合があるかもしれません。 TIMESERIESを使用して、時系列でマッピングされたレートで折れ線グラフを生成します。 TIMESERIESを省略して、時系列で平均化された単一のレート値を示すビルボードを生成します。 基本的な評価クエリ このクエリは、過去 6 時間の 10 分あたりの APM トランザクションのスループット評価を示す折れ線グラフを生成します。 SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES コピー round(attribute) round( )関数を使用して、属性の丸め値を返します。 オプションで、round( )は2番目の引数to_nearestを取り、最初の引数を2番目の引数の最も近い倍数に切り上げます。to_nearestは分数でも使用できます。 SELECT round(n [, to_nearest]) コピー stddev(attribute) stddev()関数を使用して、指定された時間範囲内に記録された数値属性の標準偏差値を返します。単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。 stdvar(attribute) stdvar()関数を使用して、指定された時間範囲内に記録された数値属性の標準分散を返します。 単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。 sum(attribute) sum（ ）関数を使用して、指定された時間範囲内に記録された数値属性の合計値を返します。 単一の引数を取ります。最初の引数以外は無視されます。属性が数値でない場合は、ゼロを値として返します。 uniqueCount(attribute) uniqueCount（ ）関数を使用して、指定された時間範囲内に記録された属性のユニーク値の数を返します。 ヒント クエリのパフォーマンスを最適化するため、この関数は256を超えるユニーク値を検査するクエリのおおよその結果を返します。 uniques(attribute \\[,limit]) uniques（ ）関数を使用して、指定された時間範囲内に記録された属性のユニーク値のリストを返します。facet句と共に使用すると、各ファセット値ごとに固有の属性値一覧が返されます。 limitパラメータは任意です。これが提供されない場合、ファセットあたり1,000の固有の属性値がデフォルトリミットとして適用されます。最大10,000までの、別のlimitを指定することもできます。uniques( )関数は、上限に達するまで、発見した固有の属性値の最初の一式を返します。このため、データセットに5,000の固有の属性値があり、上限が1,000に設定されている場合、演算子はその頻度に関わらず、発見した最初の1,000の固有の値を返します。 クエリ結果で返すことのできる最大数は、uniques( )上限とfacet上限を掛け合わせたものになります。以下のクエリでは、論理的に返すことの可能な最大値は500万になります（5,000 x 1,000）。 クエリしたデータセットのほか、クエリの複雑さ次第では、メモリ保護上限の影響で非常に大きなクエリの実行が阻止される可能性があります。 From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 コピー タプルの使用 少数の属性の独自の組み合わせを知りたい場合、SELECT unique(tuple(x, y, ... z)) ...`形式でクエリを構築することで、値の独自のタプルをすべて取得して、それらの関係を維持することができます。以下のクエリでは、tupleがインデックスとcellName両方に対して使用され、これらの2つの値が組み合わせで発生する一意の要素を見つけます。 FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) コピー データ型変換 NRQLは「型強制」をサポートしていません。つまり、文字列として保存された浮動小数点は文字列として取り扱われ、浮動小数点数を要求する関数に渡しても操作できません。 次に示す関数を用いることで、数値を伴う文字列、または文字列を伴うブーリアン値をそれぞれ数またはブーリアン値に変換できます。 numeric() 関数を用いて、文字列形式の数値を数値関数に変換します。この関数は、クエリ結果に数学関数を使用するクエリ、もしくはaverage()などのNRQL 集計関数に組み込むことができます。 boolean()関数を用いることで、「true」もしくは「false」の文字列値を対応するブーリアン値に変換できます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.197815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em>の構文、句、関数",
        "sections": "<em>NRQL</em>の構文、句、関数",
        "tags": "Query your <em>data</em>",
        "body": "<em>NRQL</em>は、New Relicデータベースのクエリに使用可能なクエリ言語です。このドキュメントでは<em>NRQL</em>の構文、句、構成要素、関数について説明します。 構文 このドキュメントは、<em>NRQL</em>クエリにおいて使用される関数と句の参考資料です。<em>NRQL</em>を理解するためのその他のリソース： <em>NRQL</em>の紹介：どのような<em>NRQL</em>が使用されるのか、それによってどのようなデータをクエリできるのか、そして基本的な<em>NRQL</em>構文について説明しています。 New Relicチャートの作成に使用する<em>NRQL</em>クエリを検証する SQL JOIN関数をシミュレーション ファネルを使用して一連の関連データを評価する Event"
      },
      "id": "6053a66828ccbc48e1c2fd19"
    }
  ],
  "/build-apps/ab-test/confirmation-modal": [
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/persist-version/embed/",
      "sections": [
        "Persist the selected version",
        "Course"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:17Z",
      "type": "",
      "external_id": "000f29685ee92dffc2ce7e70539ee1663037ffcb",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a section to end your test, before starting this one. In the previous lesson, you created a section of your application that allows you to pick the most effective design from your A/B test. The goal of this section is to end the test once you’ve selected a winner: When you select a version from this form, the selection does not persist in the Select component. Now, it’s time to implement that behavior. Step 1 of 11 Change to the persist-selected-version directory of the coursework repository: bash Copy $ cd nru-programmability-course/persist-selected-version Step 2 of 11 In end-test.js, initialize EndTestSection.state with a default selectedVersion field: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 3 of 11 Pass the selectedVersion, as a prop, to VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 4 of 11 Supply the selectedVersion to your Select component in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 5 of 11 Create a method, selectVersion(), that updates EndTestSection.state: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy You must bind selectVersion to the EndTestSection component so it can access state. Step 6 of 11 Pass the method to VersionSelector as a prop: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 7 of 11 Set selectVersion as the onChange callback in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 8 of 11 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 9 of 11 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 10 of 11 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 11 of 11 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Voila! When you select a new version as the winner of the A/B test, that version is reflected in the menu. However, when you press End test, nothing happens. In the next lesson, you'll create a confirmation dialog to protect yourself from prematurely ending your A/B test. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Present an end test confirmation modal.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2558.996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". In the next lesson, you&#x27;ll create a <em>confirmation</em> dialog to protect yourself from prematurely ending your A&#x2F;B <em>test</em>. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Present</em> an <em>end</em> <em>test</em> <em>confirmation</em> <em>modal</em>."
      },
      "id": "60730001196a67905864a75f"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/embed/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "Course",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-04-11T14:01:08Z",
      "title": "",
      "updated_at": "2021-04-11T14:01:08Z",
      "type": "",
      "external_id": "43c5fb39b73ee2dbbe5f216a577ff77051fcc513",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Present an end test confirmation modal, before starting this one. In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 View your changes: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 2 of 2 With your nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Customize NRQL data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2031.223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Present</em> an <em>end</em> <em>test</em>"
      },
      "id": "60730124196a6731e464a778"
    },
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/embed/",
      "sections": [
        "Present an end test confirmation modal",
        "Course",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-04-11T13:52:26Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "554a84f8fe2faf9c2b867686538360771e22fc3c",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Persist the selected version, before starting this one. In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 View your application: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. View your application where the modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add NrqlQuery components to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 336.33853,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Present</em> <em>an</em> <em>end</em> <em>test</em> <em>confirmation</em> <em>modal</em>",
        "body": " before ending the <em>test</em> to ensure you don&#x27;t <em>end</em> it prematurely Show and hide your <em>confirmation</em> <em>modal</em> Step 1 of 12 Change to the <em>present</em>-<em>confirmation</em>-<em>modal</em> directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>present</em>-<em>confirmation</em>-<em>modal</em> This directory contains the code your"
      },
      "id": "6072565e64441f34dd9d8548"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:18Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 3014918 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.59242,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Save <em>test</em> information to NerdStorage",
        "body": "={&#x27;A&#x27;}&gt;Version A&lt;&#x2F;SelectItem&gt; &lt;SelectItem value={&#x27;B&#x27;}&gt;Version B&lt;&#x2F;SelectItem&gt; &lt;&#x2F;Select&gt; } } class <em>EndTest</em>Button extends React.Component { constructor() { super(...arguments); this.state = { <em>modal</em>Hidden: true, } this.show<em>Modal</em> = this.show<em>Modal</em>.bind(this); this.close<em>Modal</em> = this.close<em>Modal</em>"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/embed/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Course",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-04-11T13:55:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:55:24Z",
      "type": "",
      "external_id": "f2af52e45942b4cf9499282a654340b132766741",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Access NerdStorage from your nerdlet, before starting this one. Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in .componentDidMount(), you've queried NerdGraph for your api_token data. .componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives .showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your nerdlet's state is the current token that your nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called .componentDidUpdate(). Now, every time your nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers .componentDidUpdate(). In .componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Fetch data from a third-party service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.15463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet&#x27;s index.js file, initialize state in Ab<em>Test</em>NerdletNerdlet with a null token default: import React from &#x27;react&#x27;; import { ChartGroup, Grid, GridItem } from &#x27;nr1&#x27;; import <em>EndTest</em>Section from &#x27;.&#x2F;<em>end</em>-<em>test</em>&#x27;; import"
      },
      "id": "6072ffcd64441f6cc09d8544"
    }
  ],
  "/build-apps/ab-test/install-nr1": [
    {
      "image": "https://developer.newrelic.com/static/555c6dd44f2ffbceff682f7fbc78e01c/ba3ac/demo-service.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/demo-setup/embed/",
      "sections": [
        "Spin up your demo services",
        "Course",
        "Important"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "ec4e6154accdaf3768fc5b029e77e94337973ed8",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Before you build your New Relic One application, you need to spin up your demo services. This coursework depends on two important services: A web service that shows a newsletter signup form. The form's heading text alternates between two versions because you're performing an A/B test to determine which text leads to more high-quality subscriptions. A simulator service that sends steady traffic to the website so that you don't have to manually generate data To spin up your demo services, you first need to install Docker and Docker compose. Spin up your demo services Step 1 of 5 Clone the coursework repository from GitHub: bash Copy $ git clone https://github.com/newrelic-experimental/nru-programmability-course This repository contains code for creating NodeJS New Relic automations. It also contains a an app code directory for each lesson in the course. You'll use these directories to follow along with the course content. Step 2 of 5 Change to the demo directory, called ab-test-app: bash Copy $ cd nru-programmability-course/ab-test-app This directory contains configuration files and READMEs for using the demo. Step 3 of 5 Build and run the web service and simulator containers, using docker-compose: bash Copy $ NEW_RELIC_LICENSE_KEY=<your New Relic license key> docker-compose up -d Important Make sure you replace <your New Relic license key> with your actual license key. Once it's finished, view the website at localhost:3001: Step 4 of 5 Visit New Relic, and navigate to APM in the top navigation menu. Select Newsletter from the list of instrumented services: You may have to wait a minute or two for New Relic to recieve data from your demo services. Once it's ready, you'll see transaction data, such as performance, throughput, and an Apdex score: Step 5 of 5 To spin down your demo services, run docker-compose down from your ab-test-app directory: bash Copy $ docker-compose down Now you're ready to build your New Relic One application! The first step is to install and configure the New Relic One CLI. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Install and configure the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 4176.4873,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to build your <em>New</em> <em>Relic</em> <em>One</em> application! The first step is to <em>install</em> and <em>configure</em> the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> application from the ground up. Continue on to the next lesson: <em>Install</em> and <em>configure</em> the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>."
      },
      "id": "6072ff1928ccbc111f51c16a"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/embed/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-11T13:51:33Z",
      "type": "",
      "external_id": "7487158c521f4cccda9ec299bae4c06242ad07e7",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"Nerdpack\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-Nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"Nerdlet\", \"id\": \"ab-test-Nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet artifact inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2142.9792,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Install</em> and <em>configure</em>"
      },
      "id": "6072fee664441ffa0d9d8546"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 411.65314,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.34552,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use tags to define <em>the</em> workload content",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-12T03:01:08Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.30823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    }
  ],
  "/build-apps/ab-test/end-test": [
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions",
        "Course"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart headings, before starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 7 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 2 of 7 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 3 of 7 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 4 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 5 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 7 of 7 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add a section to end your test.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2296.2688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> version descriptions",
        "body": " competing designs and <em>your</em> charts. In the next lesson, you’ll create a new <em>section</em> of <em>your</em> application from user interface components. This <em>section</em> will be used to <em>end</em> the A&#x2F;B <em>test</em> with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> a <em>section</em> to <em>end</em> <em>your</em> <em>test</em>."
      },
      "id": "6072569228ccbc932d51c172"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/persist-version/embed/",
      "sections": [
        "Persist the selected version",
        "Course"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:17Z",
      "type": "",
      "external_id": "000f29685ee92dffc2ce7e70539ee1663037ffcb",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a section to end your test, before starting this one. In the previous lesson, you created a section of your application that allows you to pick the most effective design from your A/B test. The goal of this section is to end the test once you’ve selected a winner: When you select a version from this form, the selection does not persist in the Select component. Now, it’s time to implement that behavior. Step 1 of 11 Change to the persist-selected-version directory of the coursework repository: bash Copy $ cd nru-programmability-course/persist-selected-version Step 2 of 11 In end-test.js, initialize EndTestSection.state with a default selectedVersion field: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 3 of 11 Pass the selectedVersion, as a prop, to VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 4 of 11 Supply the selectedVersion to your Select component in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 5 of 11 Create a method, selectVersion(), that updates EndTestSection.state: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy You must bind selectVersion to the EndTestSection component so it can access state. Step 6 of 11 Pass the method to VersionSelector as a prop: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 7 of 11 Set selectVersion as the onChange callback in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 8 of 11 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 9 of 11 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 10 of 11 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 11 of 11 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Voila! When you select a new version as the winner of the A/B test, that version is reflected in the menu. However, when you press End test, nothing happens. In the next lesson, you'll create a confirmation dialog to protect yourself from prematurely ending your A/B test. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Present an end test confirmation modal.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1661.2014,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> a <em>section</em> to <em>end</em> <em>your</em>"
      },
      "id": "60730001196a67905864a75f"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/embed/",
      "sections": [
        "Add a section to end your test",
        "Course"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "6c1d9d3997eff7f27d00dbf9c8f451f5bec750d9",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add version descriptions, before starting this one. In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Persist the selected version.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 595.9469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> <em>section</em> <em>to</em> <em>end</em> <em>your</em> <em>test</em>",
        "body": ", but instead of using columnSpan, they use a combination of columnStart and column<em>End</em> to specify which columns they cover. Step 6 of 10 In <em>your</em> Nerdlet&#x27;s index.js file, <em>add</em> <em>EndTestSection</em> to <em>your</em> nerdlet: import React from &#x27;react&#x27;; import { ChartGroup, Grid, GridItem } from &#x27;nr1&#x27;; import <em>EndTestSection</em> from"
      },
      "id": "6072569228ccbc8f6151c174"
    },
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/embed/",
      "sections": [
        "Present an end test confirmation modal",
        "Course",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-04-11T13:52:26Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "554a84f8fe2faf9c2b867686538360771e22fc3c",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Persist the selected version, before starting this one. In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 View your application: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. View your application where the modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add NrqlQuery components to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.04285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Present <em>an</em> <em>end</em> <em>test</em> confirmation modal",
        "body": " component props. This provides <em>your</em> component access to the modalHidden prop that you passed in <em>EndTestSection</em>. Then you provide the value of modalHidden to the Modal component&#x27;s hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 <em>Add</em> and bind two new"
      },
      "id": "6072565e64441f34dd9d8548"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Course",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:18Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Customize NRQL data, before starting this one. In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 3014918 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorageVault from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.95717,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> NerdStorage from <em>your</em> Nerdlet",
        "body": "(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return &lt;Grid className=&quot;<em>endTestSection</em>&quot;&gt; &lt;GridItem columnSpan={12}&gt; &lt;HeadingText className=&quot;<em>endTest</em>Header&quot;&gt; Pick the winner of <em>your</em> A&#x2F;B <em>test</em>: &lt;&#x2F;HeadingText&gt; &lt;&#x2F;GridItem&gt; &lt;GridItem columnStart={5} column<em>End</em>"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    }
  ],
  "/build-apps/ab-test/table-charts": [
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Course",
        "Extra credit"
      ],
      "published_at": "2021-04-11T14:01:09Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add pie charts, before starting this one. In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a chart group.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 657.43787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>tables</em>",
        "body": " of 8 Change to the <em>add</em>-<em>tables</em> directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-<em>tables</em> This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave"
      },
      "id": "60725692196a67b68c64a778"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/embed/",
      "sections": [
        "Add pie charts",
        "Course"
      ],
      "published_at": "2021-04-11T13:55:24Z",
      "title": "",
      "updated_at": "2021-04-11T13:55:23Z",
      "type": "",
      "external_id": "c0f472d2ed9df8035313cd76ee83ec43e75d0a4a",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add your first chart, before starting this one. You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add tables.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 470.75092,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> pie charts",
        "body": " to your application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> <em>tables</em>."
      },
      "id": "6072ffcc28ccbc786651c18a"
    },
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/embed/",
      "sections": [
        "Add a chart group",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "e94780ac131f1a4ce5999771f9bee9650d4f5e9b",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add tables, before starting this one. In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add user interface components to your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 406.4463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a chart group",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>tables</em>, before starting"
      },
      "id": "6072ff19e7b9d25dbba5c689"
    },
    {
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/embed/",
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "published_at": "2021-04-13T01:55:32Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "f6dba06ee883ff39a13eb7090bf3c91f9395d6e2",
      "popularity": 1,
      "body": "Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application. Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component. Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows. As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells. The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.65173,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>tables</em> to your New Relic One application",
        "body": " action to your table! <em>Tables</em> are great, but interactive <em>tables</em> can be better: As a last update, you are going to allow users to act on each data row. <em>Add</em> the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when"
      },
      "id": "6063d633196a6796a1c6f441"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/mysql3.png",
      "url": "https://newrelic.com/blog/how-to-relic/how-to-monitor-mysql",
      "sections": [
        "Key MySQL Metrics to Monitor",
        "Uptime",
        "Connections",
        "Memory usage",
        "Storage speed",
        "Query speed",
        "Query optimization metrics",
        "Temporary Files and Tables",
        "Locks",
        "Missing indexes",
        "Monitoring MySQL with New Relic",
        "Install the agent and integration on an Ubuntu server",
        "Configure the MySQL integration",
        "View MySQL data in New Relic",
        "From integration to observability"
      ],
      "published_at": "2021-04-14T00:08:58Z",
      "title": "Monitoring MySQL Database Performance with New Relic",
      "updated_at": "2021-04-14T00:08:57Z",
      "type": "",
      "external_id": "3094a8de9f54b579f4a2c39828a89388637abf35",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Monitoring MySQL Database Performance with New Relic Aug 24, 2020 • 11 min read By Tomas Fernandez Zavalia MySQL is an open source relational database system that, like Linux, started its history as a personal side project. Over its 25 years of history, MySQL has gained significant traction, and today a broad range of companies, such as Sony and Uber, use it to run their multi-petabyte mission-critical databases. In a way, MySQL has been a victim of its own success. It’s easy enough to run that developers may take it for granted and assume it doesn’t need supervision. In reality, MySQL is a complex system with a delicate balance you must monitor closely. It exposes a lot of useful metrics you can’t afford to miss because they highlight where bottlenecks are, when it’s time to upgrade, and what queries you should optimize. Like most relational databases, MySQL organizes data using databases (also called schemas) and tables. However, MySQL has a unique modular architecture that lets you choose the best low-level storage engine for the job. MySQL exposes its inner workings in all these levels through dozens of metrics. MySQL is also extremely flexible. You can run it as a single instance, as a primary-secondary cluster, thank to replication, or in multi-master mode. And third-party solutions like Vitess allow you to create horizontally-scaled clusters. Key MySQL Metrics to Monitor Let's start by reviewing some of the most important metrics to monitor in any MySQL instance. To view all available metrics, check out our MySQL integration docs (which we’ll walk through setting up below). Uptime It may sound self-evident, but many teams set alerts for server downtime while forgetting to monitor the MySQL process itself. When the database is down, you want to get notified immediately. Connections MySQL sets a hard limit on the number of simultaneous connections. When you reach it, new connections are blocked until someone disconnects. MySQL allows 151 connections by default. Changing the limit is simple: SET GLOBAL max_connections = 200; Bear in mind that each connection needs at least 3MB, so always try to keep the number of connections as small as possible. To determine the optimum number of connections to set, monitor three metrics: net.maxUsedConnections: The maximum number of connections recorded since the database started. Use this value as a reference to set max_connections. net.threadsConnected: The current number of active connections. net.connectionErrorsMaxConnectionsPerSecond: The number of connections failed per second due to the max_connections limit being reached. If the value is higher than zero, you need to either raise the limit, set up connection pools for your applications, or consider installing a load balancer like ProxySQL. Network issues and buggy clients can also affect MySQL connections. Watch net.abortedClientsPerSecond to detect applications not closing connections properly. A high rate usually indicates problems in the network. Memory usage Databases need a lot of memory to work well, so monitoring memory is vital to keep your MySQL in top shape. First, set up monitoring for the server to ensure it has enough RAM: memoryFreeByes memoryUsedBytes memoryTotalByes Then, on the MySQL side, monitor these metrics: db.innodb.bufferPoolPagesTotal: The number of pages in-memory holding data. You want this number to be as high as possible to reduce disk activity and increase performance. db.innodb.bufferPoolReadsPerSecond: The number of pages not found in-memory that need to be retrieved from disk. If the value is more than 5-15% of db.innodb.bufferPoolPagesTotal, the database needs more memory. In that case, check the server RAM and increase the db.innodb_buffer_pool_size setting on MySQL. db.innodb.logWaitsPerSecond: If this value is consistently high, it means that the log buffer is set too low. In that case, increase innodb_log_buffer_size until the problem goes away. Storage speed After memory, disk I/O speed is the most crucial factor for database performance. Even if the system has enough RAM to allocate the complete database, it’ll still need disk I/O to ensure transaction consistency. The main database workload shapes disk activity. For Online Transaction Processing (OLTP) systems (e.g., systems used for online purchase processing), the following metrics should be smooth and steady. Peaks indicate possible bottlenecks and latency for your users. On the other hand, for Online Analytical Processing (OLAP) systems (e.g., systems used for budgeting and forecasting), uneven activity is a lot more common and should be expected. To keep an eye on workload, monitor the following: db.innodb.dataReadsPerSecond: The number of reads per second. db.innodb.dataWritesPerSecond: The number of writes per second. db.innodb.osLogWrittenBytesPerSecond: The transaction log throughput. This value is proportional to how much the data changes over time. Query speed Watch these metrics to monitor query speed and capture a baseline for your database: query.questionsPerSecond: The number of queries sent by clients. query.queriesPerSecond: The total number of queries per second (QPS), including administrative commands and stored procedures. It measures the raw capacity of the database. query.maxExecutionTimeExceededPerSecond: The number of SELECT statements timed out per second. For OLTP workloads, you never want this value to exceed zero. If you find that your queries are timing out, optimize them. Query optimization metrics Query optimization is where you can make the most significant impact on MySQL performance. To identify long-running queries, activate the MySQL slow query log: SET GLOBAL slow_query_log = 1; SET GLOBAL slow_query_log_file = '/var/log/mysql/mysql-slow.log'; Then set a reasonable query time to capture the worst-behaving queries on a first pass: // 3 seconds threshold SET GLOBAL long_query_time = 3; As performance improves, you can reduce the query time and repeat the process. Once the feature is active, monitor query.slowQueriesPerSecond, analyze the log, and use an EXPLAIN statement to find which queries do worse. Depending on the case, you may need to rewrite them, add or modify indexes, or restructure your tables. Here are some additional metrics to monitor while optimizing queries. Temporary Files and Tables MySQL creates temporary files and tables on disk for operations such as GROUP BY, ORDER BY, or UNION that don’t fit in-memory. Since these can cause excessive disk I/O, keep a close watch on these metrics: db.createdTmpDiskTablesPerSecond measures tables. db.createdTmpFilesPerSecond measures temporary files. While it’s not always possible to reduce these values to zero, you can minimize temporary disk activity by adjusting sort_buffer_size and join_buffer_size, and rewriting queries. Locks MySQL uses table- and row-level locks to ensure data consistency. Poorly written queries and some administrative tasks can lead to long-running locks that block other clients. The main metrics for lock activity are db.tablesLocksWaitedPerSecond for tables, and db.innodb.rowLockTimeAvg and db.innodb.rowLockWaitsPerSecond for rows. Missing indexes MySQL uses indexes for filtering, sorting, and joining tables. When queries and table structures don’t line up, MySQL is forced to scan the whole table. This situation uses up a lot of extra memory and causes heavy disk I/O. Monitor these metrics for details: db.selectFullJoinPerSecond and db.selectFullJoinRangePerSecond indicate whether your tables need additional indexes. db.innodb.bufferPoolReadAheadRndPerSecond helps detect inefficient table-level reads. Monitoring MySQL with New Relic Our MySQL integration uses the New Relic Infrastructure agent to collect and send performance metrics from your MySQL database to our platform.  You can see  your database server’s health and analyze metric data so that you can easily find the source of any problems The integration is compatible with MySQL version 5.6 or higher. In the following example, we’ll show you how to set up Infrastructure Monitoring for an  Ubuntu server running MySQL. If you have a different host OS, check the agent documentation for alternative instructions. Note: You can also monitor MySQL as a service running in Kubernetes or ECS. Install the agent and integration on an Ubuntu server From New Relic One, navigate to your account drop-down (in the top-right corner) and select Add more data. Select your operating system (in this case Ubuntu), and follow the prompts to get your license key and select your Ubuntu version. To deploy the Infrastructure agent and the MySQL integration, run the following commands on your server: Import Infrastructure agent GPG Key. curl -s https://download.newrelic.com/infrastructure_agent/gpg/newrelic-infra.gpg | sudo apt-key add - Add the New Relic repository (view all distributions here). printf \"deb [arch=amd64] https://download.newrelic.com/infrastructure_agent/linux/apt bionic main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Install the infrastructure agent (newrelic-infra) and MySQL integration (nri-mysql). sudo apt-get update && sudo apt-get install -y newrelic-infra nri-mysql Configure the MySQL integration Add a monitoring user in MySQL. mysql -e \"CREATE USER 'newrelic'@'localhost' IDENTIFIED BY 'MONITOR_USER_PASSWORD';\" mysql -e \"GRANT REPLICATION CLIENT ON *.* TO 'newrelic'@'localhost';\" Configure the MySQL integration. cd /etc/newrelic-infra/integrations.d sudo cp mysql-config.yml.sample mysql-config.yml sudo nano mysql-config.yml Fill in the password.hostname: hostname: localhost port: 3306 username: newrelic password: MONITOR_USER_PASSWORD Set remote_monitoring to true. Capture extended_metrics and extended_innodb_metrics. extended_metrics: 1 extended_innodb_metrics: 1 If you have MyISAM tables, also set extended_myisam_metrics: extended_myisam_metrics: 1 Restart the infrastructure agent to complete the setup.systemctl restart newrelic-infra A full list of configuration options is available in our MySQL integration documentation. View MySQL data in New Relic From New Relic One, navigate to Infrastructure to see the incoming data about your servers. To start monitoring your MySQL databases, navigate to Infrastructure > Third-party Services > MySQL Dashboard. Here are a few example charts created based on our integration’s configuration: A QPS graph measures the raw efficiency of your database The Slow Queries chart lets you know when it’s time to optimize your database Use the Max Connections graph to fine tune max_connections Use the I/O activity for the network and disk to find bottlenecks in your system To create more advanced charts and custom dashboards, check out the data explorer. From integration to observability If data is the application’s lifeblood, then the database is its heart. Reliable database performance is vital in any business. By monitoring a few key metrics, you can better understand how your MySQL servers are functioning. The MySQL integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. Make our MySQL integration an essential part of your observability stack. Check out our full list of on-host integrations for more. If you are ready to take control of your databases, sign up for 100GB of ingest per month and one Full-Stack Observability user license—free forever!   By Tomas Fernandez Zavalia Tomas started his career as a PHP developer. After graduating, he worked at British Telecom as head of the Web Services department in Argentina. After that, he went to IBM, where he wore many technical hats: DBA, Sysadmin, and DevOps. He's now an independent consultant and writer. He loves to learn and to teach about technology. In his free time, he likes reading, sailing, and board gaming. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.20121,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Temporary Files and <em>Tables</em>",
        "body": ", <em>add</em> or modify indexes, or restructure your <em>tables</em>. Here are some additional metrics to monitor while optimizing queries. Temporary Files and <em>Tables</em> MySQL creates temporary files and <em>tables</em> on disk for operations such as GROUP BY, ORDER BY, or UNION that don’t fit in-memory. Since these can cause"
      },
      "id": "6076329a196a67a65164a773"
    }
  ],
  "/build-apps/ab-test/publish": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T13:58:44Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a nerdpack, launcher, and nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1521.4242,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Subscribe to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Publish</em> <em>your</em> <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/b9344bea39589c73def76207c066da73/e49c0/screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/embed/",
      "sections": [
        "Describe your app for the catalog",
        "Course",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "baf09ac55fe0770a7b7de7102f2a2a7a463d49de",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add navigation to your nerdlet, before starting this one. In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your nerdpack. Step 1 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/describe-app/ab-test. Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create -t catalog This creates a catalog directory with template files for inputting custom information about your application. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory: Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Publish your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1489.2231,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Describe <em>your</em> app for the catalog",
        "body": " nerdlet, before starting this <em>one</em>. In the last lesson, you finished the A&#x2F;B test <em>application</em> you&#x27;ve been building throughout this course. Now, it&#x27;s time to prepare it for publication. When you <em>publish</em> <em>your</em> app to the <em>New</em> <em>Relic</em> <em>One</em> catalog, users can view it and subscribe to it. You can help <em>your</em> users"
      },
      "id": "606e63d8e7b9d201e9bfa819"
    },
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/publish/embed/",
      "sections": [
        "Publish your New Relic One application",
        "Course",
        "Versions and tags",
        "Tip",
        "Publish your first application",
        "Technical detail",
        "View your application in the catalog",
        "Submit catalog information",
        "Update your version tag"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:17Z",
      "type": "",
      "external_id": "41ee1ef02494dc82084533ad141ff3202f8ae2d4",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Describe your app for the catalog, before starting this one. In the last lesson, you created catalog information for the A/B test app you've been building throughout this course. Now, it's time to publish your app to the New Relic One catalog and submit those catalog details. Versions and tags Publishing an application requires two key pieces of information: version tag An application's version identifies the code it contains and is stored in the nerdpack's root-level package.json file. Every time you modify code in your nerdpack and are ready to release it, you'll update the version in package.json. For example, if you fix some bugs in the first major version your application code, you might publish the changes under version 1.0.1. An app version's tags describe its state. For example, version 0.0.1 of a work-in-progress application might be published with a DEV tag to indicate that it's in development. Tip There are some rules governing how you can use tags and you can read about those in our tags documentation. Publish your first application Step 1 of 6 Change to the publish directory of the coursework repository: bash Copy $ cd nru-programmability-course/publish This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/publish/ab-test. Step 3 of 6 Generate your own app UUID: bash Copy $ nr1 nerdpack:uuid -gf The UUID is used to identify your app in the New Relic One app registry. Because you're using code that we developed for this course, an application with the existing UUID already exists in the registry. By generating your own, you're now able to publish this application. Technical detail The UUID also ties your app to your account and, therefore, allows the application to make Nerdgraph requests on behalf of the account that installed it. Step 4 of 6 In package.json, set version to 1.0.0: { \"private\": true, \"name\": \"ab-test\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"2d923ba6-d231-4dd3-830f-b1923577a422\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } Copy New Relic One uses semantic versioning and, under this convention, 1.0.0 signals the first major release. Now, you're ready to publish! Step 5 of 6 Publish your New Relic One application: bash Copy $ nr1 nerdpack:publish -t DEV That's it! You published your application to New Relic's registry. The -t parameter specifies a tag for your published version. Among other logs, you should see the following confirmation in your console: bash Copy Publishing Nerdpack AbTest (9da77738-9cf6-43c7-9ba0-e3a8c6ac7380) ✔ Nerdpack published successfully! ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as DEV. For now, you've tagged the 1.0.0 release as DEV because it's still a work in progress. Step 6 of 6 View your app's registry information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 4 Version Date Tags ------- ------------- ------ 1.0.0 5 minutes ago DEV The results of this command detail the information stored in New Relic's registry for your application, including its UUID, version, and account ID. View your application in the catalog Now that your application is published and tagged, you can view it in the New Relic One app catalog. Step 1 of 3 Go to New Relic. Notice that you're not using the ?nerdpacks=local querystring parameter. You don't need it anymore because you're not serving your app locally. Step 2 of 3 From the homepage, navigate to Apps: From here, you can see your application under New Relic One catalog: Notice that this is different than when you locally served your app. Local apps and published apps you're subscribed to show under Your apps instead. Step 3 of 3 Click on your app to see more details: Notice the release date and app version. This page should show the information you created in the last lesson. It doesn't yet, because you haven't submitted that information to the catalog, and publishing your app doesn't do that for you. Submit catalog information Even though you've published your application, there are some things that the catalog doesn't know about. These are the descriptions, screenshots, and metadata you created in the last lesson. nr1 catalog is used to submit and view this information. Step 1 of 3 Submit your catalog information: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for AbTest 1.0.0 If everything goes right, you should see a success message notifying you that the screenshots and metadata were updated. You may, however, get an error when submitting this information to the catalog: bash Copy Uploading screenshots... › Error: 1 error while updating AbTest 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN If you do, try again in a minute or two. It can take a few seconds for the catalog to update with the new version of your application. If that doesn't work, make sure you published your app with nr1 nerdpack:publish. Step 2 of 3 View your catalog information: bash Copy $ nr1 catalog:info description: Nerdpack ab-test details: Display test data for our newsletter subscription A/B test displayName: AbTest icon.url: https://nr3.nr-ext.net/artifact-index-production/a685fec2-29fb-40b0-9f65-4178... previews.0.url: https://application-catalog-production.s3.us-east-2.amazonaws.com/nerdpacks/a... releaseDate: 2021-03-12T15:46:09.600138Z repository: https://github.com/newrelic-experimental/nru-programmability-course tagline: Win @ newsletter subscriptions version: 1.0.0 whatsNew.changes: Initial release! Includes: - A variety of charts for understanding the test r... whatsNew.version: 1.0.0 All the information from catalog shows here. Step 3 of 3 View your app in the catalog: Notice the tagline on the app's catalog entry. Click on the app to see more: Here, you see app details, a documentation tab, release notes, and screenshots. Update your version tag Your app looks great in the catalog, complete with metadata, images, and documentation. Before, you tagged the app as DEV because all of the information wasn't ready for public consumption. Now, it is. It's time to update your version tag. Step 1 of 2 Update your 1.0.0 app version from DEV to STABLE: bash Copy $ nr1 nerdpack:tag -t STABLE ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as STABLE. Without specifying a version, nr1 uses the version specified in package.json. You can specify a version with the -V command. Learn more about nerdpack:tag with the nr1 nerdpack:tag --help command. Step 2 of 2 View your app information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ------------- ------ 1.0.0 30 minutes ago STABLE The app is now tagged with STABLE, indicating it's ready for public use. Technical detail Even though the app is ready for public use, it's still only visible to users of your account. Other accounts can't see apps created by other private accounts unless those apps are added to the public New Relic One catalog. Now that your app is published and its metadata is submitted, you can subscribe your account to the app from the catalog. In the next lesson, you'll learn the ways to subscribe and unsubscribe to your new application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Subscribe to your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 945.2867,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Publish</em> <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "body": " for the catalog, before starting this <em>one</em>. In the last lesson, you created catalog information for the A&#x2F;B test app you&#x27;ve been building throughout this course. Now, it&#x27;s time to <em>publish</em> <em>your</em> app to the <em>New</em> <em>Relic</em> <em>One</em> catalog and submit those catalog details. Versions and tags Publishing an <em>application</em>"
      },
      "id": "60730001e7b9d2de18a5c660"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 404.90317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", no matter how complex. You can: Use our APIs to get data into <em>New</em> <em>Relic</em> from any source. Visualize that data in <em>your</em> custom applications. <em>one</em>.newrelic.com: Here’s an example of a custom <em>application</em> built on <em>New</em> <em>Relic</em> <em>One</em>. This <em>application</em> gives a highly detailed analysis of a website, using"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.5893,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    }
  ],
  "/build-apps/ab-test/subscribe": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/publish/embed/",
      "sections": [
        "Publish your New Relic One application",
        "Course",
        "Versions and tags",
        "Tip",
        "Publish your first application",
        "Technical detail",
        "View your application in the catalog",
        "Submit catalog information",
        "Update your version tag"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:17Z",
      "type": "",
      "external_id": "41ee1ef02494dc82084533ad141ff3202f8ae2d4",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Describe your app for the catalog, before starting this one. In the last lesson, you created catalog information for the A/B test app you've been building throughout this course. Now, it's time to publish your app to the New Relic One catalog and submit those catalog details. Versions and tags Publishing an application requires two key pieces of information: version tag An application's version identifies the code it contains and is stored in the nerdpack's root-level package.json file. Every time you modify code in your nerdpack and are ready to release it, you'll update the version in package.json. For example, if you fix some bugs in the first major version your application code, you might publish the changes under version 1.0.1. An app version's tags describe its state. For example, version 0.0.1 of a work-in-progress application might be published with a DEV tag to indicate that it's in development. Tip There are some rules governing how you can use tags and you can read about those in our tags documentation. Publish your first application Step 1 of 6 Change to the publish directory of the coursework repository: bash Copy $ cd nru-programmability-course/publish This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/publish/ab-test. Step 3 of 6 Generate your own app UUID: bash Copy $ nr1 nerdpack:uuid -gf The UUID is used to identify your app in the New Relic One app registry. Because you're using code that we developed for this course, an application with the existing UUID already exists in the registry. By generating your own, you're now able to publish this application. Technical detail The UUID also ties your app to your account and, therefore, allows the application to make Nerdgraph requests on behalf of the account that installed it. Step 4 of 6 In package.json, set version to 1.0.0: { \"private\": true, \"name\": \"ab-test\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"2d923ba6-d231-4dd3-830f-b1923577a422\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } Copy New Relic One uses semantic versioning and, under this convention, 1.0.0 signals the first major release. Now, you're ready to publish! Step 5 of 6 Publish your New Relic One application: bash Copy $ nr1 nerdpack:publish -t DEV That's it! You published your application to New Relic's registry. The -t parameter specifies a tag for your published version. Among other logs, you should see the following confirmation in your console: bash Copy Publishing Nerdpack AbTest (9da77738-9cf6-43c7-9ba0-e3a8c6ac7380) ✔ Nerdpack published successfully! ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as DEV. For now, you've tagged the 1.0.0 release as DEV because it's still a work in progress. Step 6 of 6 View your app's registry information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 4 Version Date Tags ------- ------------- ------ 1.0.0 5 minutes ago DEV The results of this command detail the information stored in New Relic's registry for your application, including its UUID, version, and account ID. View your application in the catalog Now that your application is published and tagged, you can view it in the New Relic One app catalog. Step 1 of 3 Go to New Relic. Notice that you're not using the ?nerdpacks=local querystring parameter. You don't need it anymore because you're not serving your app locally. Step 2 of 3 From the homepage, navigate to Apps: From here, you can see your application under New Relic One catalog: Notice that this is different than when you locally served your app. Local apps and published apps you're subscribed to show under Your apps instead. Step 3 of 3 Click on your app to see more details: Notice the release date and app version. This page should show the information you created in the last lesson. It doesn't yet, because you haven't submitted that information to the catalog, and publishing your app doesn't do that for you. Submit catalog information Even though you've published your application, there are some things that the catalog doesn't know about. These are the descriptions, screenshots, and metadata you created in the last lesson. nr1 catalog is used to submit and view this information. Step 1 of 3 Submit your catalog information: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for AbTest 1.0.0 If everything goes right, you should see a success message notifying you that the screenshots and metadata were updated. You may, however, get an error when submitting this information to the catalog: bash Copy Uploading screenshots... › Error: 1 error while updating AbTest 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN If you do, try again in a minute or two. It can take a few seconds for the catalog to update with the new version of your application. If that doesn't work, make sure you published your app with nr1 nerdpack:publish. Step 2 of 3 View your catalog information: bash Copy $ nr1 catalog:info description: Nerdpack ab-test details: Display test data for our newsletter subscription A/B test displayName: AbTest icon.url: https://nr3.nr-ext.net/artifact-index-production/a685fec2-29fb-40b0-9f65-4178... previews.0.url: https://application-catalog-production.s3.us-east-2.amazonaws.com/nerdpacks/a... releaseDate: 2021-03-12T15:46:09.600138Z repository: https://github.com/newrelic-experimental/nru-programmability-course tagline: Win @ newsletter subscriptions version: 1.0.0 whatsNew.changes: Initial release! Includes: - A variety of charts for understanding the test r... whatsNew.version: 1.0.0 All the information from catalog shows here. Step 3 of 3 View your app in the catalog: Notice the tagline on the app's catalog entry. Click on the app to see more: Here, you see app details, a documentation tab, release notes, and screenshots. Update your version tag Your app looks great in the catalog, complete with metadata, images, and documentation. Before, you tagged the app as DEV because all of the information wasn't ready for public consumption. Now, it is. It's time to update your version tag. Step 1 of 2 Update your 1.0.0 app version from DEV to STABLE: bash Copy $ nr1 nerdpack:tag -t STABLE ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as STABLE. Without specifying a version, nr1 uses the version specified in package.json. You can specify a version with the -V command. Learn more about nerdpack:tag with the nr1 nerdpack:tag --help command. Step 2 of 2 View your app information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ------------- ------ 1.0.0 30 minutes ago STABLE The app is now tagged with STABLE, indicating it's ready for public use. Technical detail Even though the app is ready for public use, it's still only visible to users of your account. Other accounts can't see apps created by other private accounts unless those apps are added to the public New Relic One catalog. Now that your app is published and its metadata is submitted, you can subscribe your account to the app from the catalog. In the next lesson, you'll learn the ways to subscribe and unsubscribe to your new application. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Subscribe to your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1089.2102,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "body": ". In the next lesson, you&#x27;ll learn the ways to <em>subscribe</em> and unsubscribe to <em>your</em> <em>new</em> <em>application</em>. Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. Continue on to the next lesson: <em>Subscribe</em> to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>."
      },
      "id": "60730001e7b9d2de18a5c660"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 411.65314,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", no matter how complex. You can: Use our APIs to get data into <em>New</em> <em>Relic</em> from any source. Visualize that data in <em>your</em> custom applications. <em>one</em>.newrelic.com: Here’s an example of a custom <em>application</em> built on <em>New</em> <em>Relic</em> <em>One</em>. This <em>application</em> gives a highly detailed analysis of a website, using"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.34552,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use tags <em>to</em> define the workload content",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-12T03:01:08Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.30823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 407.29294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/ab-test/serve-app": [
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-charts/embed/",
      "sections": [
        "Add chart components to your A/B test application",
        "Course"
      ],
      "published_at": "2021-04-11T13:51:33Z",
      "title": "",
      "updated_at": "2021-04-08T01:59:52Z",
      "type": "",
      "external_id": "c6c3610a3267705c0888958509095a737b8c7f7e",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Serve your New Relic One application, before starting this one. The New Relic One application that you're building throughout this course allows developers to A/B test their websites. To run a successful A/B test, site owners need to be able to analyze the results. Without knowing how each design performs, how will developers determine which design to use? Here is a mockup for the A/B test application you're building: Your application displays data for two competing versions. With various charts and tables, your users will be able to analyze the results of their test and make informed decisions on which design will work best to achieve their goals. You’ll refer back to this mockup many times throughout this course. It shows you what charts to create, how to organize them, and what kind of data to provide them. In the next four sections, you learn how to create every chart that your A/B test application needs to operate effectively. After that, you’ll arrange the charts to match the mockup’s design and supply New Relic data collected from the demo applications you spun up earlier. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add your first chart.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1454.8445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add chart components to <em>your</em> A&#x2F;B test <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Serve</em> <em>your</em> <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "606e639828ccbc82c1542179"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/embed/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-11T13:51:33Z",
      "type": "",
      "external_id": "7487158c521f4cccda9ec299bae4c06242ad07e7",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"Nerdpack\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-Nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"Nerdlet\", \"id\": \"ab-test-Nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet artifact inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 991.80884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Return to submit. nerdpack ❯ nerdlet - create a&#x2F;an Nerdlet artifact inside <em>your</em> Nerdpack. launcher catalog visualization In the next lesson, you&#x27;ll learn how to <em>serve</em> <em>your</em> Nerdpack locally and see <em>your</em> app in action! Course This lesson is part of a course that teaches you how to build a <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> from the ground up. Continue on to the next lesson: <em>Serve</em> <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>."
      },
      "id": "6072fee664441ffa0d9d8546"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-12T02:56:45Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 404.90317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", no matter how complex. You can: Use our APIs to get data into <em>New</em> <em>Relic</em> from any source. Visualize that data in <em>your</em> custom applications. <em>one</em>.newrelic.com: Here’s an example of a custom <em>application</em> built on <em>New</em> <em>Relic</em> <em>One</em>. This <em>application</em> gives a highly detailed analysis of a website, using"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.5893,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-12T03:01:08Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.5526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    }
  ],
  "/build-apps/ab-test/create-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/embed/",
      "sections": [
        "Create a Nerdpack",
        "Course",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-11T13:51:33Z",
      "type": "",
      "external_id": "7487158c521f4cccda9ec299bae4c06242ad07e7",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Install and configure the New Relic One CLI, before starting this one. A Nerdpack is a package that contains all the files that make up a New Relic One application. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"Nerdpack\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-Nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"Nerdlet\", \"id\": \"ab-test-Nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet artifact inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action! Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Serve your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1137.9275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Create</em> <em>a</em> <em>Nerdpack</em>",
        "body": " the New Relic One CLI, before starting this one. A <em>Nerdpack</em> is a package that contains all the files that make up a New Relic One application. Nerdpacks include files for metadata, Nerdlets, assets, and more. To <em>create</em> a <em>Nerdpack</em>, use the New Relic One CLI: bash Copy $ nr1 <em>create</em> --type <em>nerdpack</em> When nr1"
      },
      "id": "6072fee664441ffa0d9d8546"
    },
    {
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/embed/",
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "edab33e46fbc9f8e054670c52397176ce989ae3a",
      "popularity": 1,
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type nerdpack --name my-first-viz $ cd my-first-viz $ nr1 create --type visualization --name custom-viz The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ nr1 nerdpack:serve Then visit New Relic and navigate to Apps > Custom Visualizations > CustomViz to see it in action: Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack artifacts, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1063.148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to present that data, you might need to <em>create</em> something entirely unique. With the New Relic One SDK, we&#x27;ve provided you all the tools you&#x27;ll need to <em>create</em> your own visualizations. Build your custom visualization With the New Relic One SDK, you can <em>create</em> a <em>Nerdpack</em>, which houses your visualization code"
      },
      "id": "607105a064441fa6da9d8530"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:16Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: You use this key to associate your New Relic account with the CLI. The CLI then uses the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name>, the <User key>, and the region (either us or eu) with real values. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1054.062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install <em>and</em> configure the New Relic One CLI",
        "body": ", before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To <em>create</em> a <em>Nerdpack</em> , you&#x27;ll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its <em>create</em> command. Install and configure the CLI Step 1"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "https://developer.newrelic.com/static/0642dd0fbf77f167e4757a87aee06996/0086b/select-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/serve-app/embed/",
      "sections": [
        "Serve your New Relic One application",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:51:33Z",
      "title": "",
      "updated_at": "2021-04-11T13:51:33Z",
      "type": "",
      "external_id": "1a2cfa887902435c407fbdf71157b81a01a14513",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Create a Nerdpack, before starting this one. When you build a New Relic One application, it's valuable to view it on the platform. This helps you design, implement, and debug your application in the environment it will eventually be published to. With nr1, you can launch a development server that hosts your application so that New Relic One can present it to you. Step 1 of 4 From inside the Nerdpack's root directory, run nerdpack:serve: bash Copy $ nr1 nerdpack:serve When the Nerdpack has succeeded building and your application is ready to view, you'll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! Notice the appended query parameter nerdpacks=local. This query parameter tells New Relic to show locally served Nerdpacks. Tip If you don't see your application on the New Relic platform, make sure you've included nerdpacks=local in your querystring! Step 2 of 4 Navigate to the provided url. From the home page, select Apps to view New Relic One applications: Step 3 of 4 Under the Your apps section, find your launcher, called \"A/B Test Launcher\": Step 4 of 4 Select your launcher to see your root Nerdlet and its default welcome message: Congratulations, you've served your first New Relic One application! Notice, in the nerdpack:serve output, that the server reloads when you change files in your Nerdpack. Give it a try by updating nerdlets/ab-test-nerdlet/index.js: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>A/B test results</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Your app automatically refreshes to show the new heading: Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add chart components to your A/B test application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 923.55396,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Serve your New Relic One <em>application</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Create</em> a <em>Nerdpack</em>, before"
      },
      "id": "6072fee564441fe6699d8585"
    },
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T13:58:44Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a nerdpack, launcher, and nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 797.402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Subscribe to your New Relic One <em>application</em>",
        "body": " Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you&#x27;ve built a New Relic One application from the ground up. You&#x27;ve used the nr1 CLI to <em>create</em> a <em>nerdpack</em>"
      },
      "id": "60730094196a67d7d464a7b5"
    }
  ],
  "/build-apps/ab-test/navigation": [
    {
      "image": "https://developer.newrelic.com/static/b9344bea39589c73def76207c066da73/e49c0/screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/embed/",
      "sections": [
        "Describe your app for the catalog",
        "Course",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "baf09ac55fe0770a7b7de7102f2a2a7a463d49de",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add navigation to your nerdlet, before starting this one. In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your nerdpack. Step 1 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/describe-app/ab-test. Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create -t catalog This creates a catalog directory with template files for inputting custom information about your application. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory: Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Publish your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2180.6309,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Describe <em>your</em> app for the catalog",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>navigation</em> to <em>your</em>"
      },
      "id": "606e63d8e7b9d201e9bfa819"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/embed/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:16Z",
      "type": "",
      "external_id": "58de68bd963cdd2062e88db55cb90ad124055eb6",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to take use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy PlatformStateContext.Consumer provides access to the platform's URL state. This state contains two important values for you to use in this context: accountId timeRange Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your nerdlet, you can use accountId from the platform URL state. Step 3 of 10 Use platformState.accountId in your NrqlQuery: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Next, notice that your query uses a SINCE clause, which identifies the historical timeframe your query should fetch data from. Step 4 of 10 Utilize platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. Tip While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery is now using the account ID, which it got from platform state. It's also using the platform state's time range, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1381.854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " place in New Relic. You&#x27;ll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>navigation</em> to <em>your</em> <em>nerdlet</em>."
      },
      "id": "6073000164441f84ce9d853d"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course"
      ],
      "published_at": "2021-04-11T14:00:18Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to lookup the application user's account ID and the time range they selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your nerdlet. You can also use navigation for other nerdlets and launchers. Step 1 of 10 Change to the add-navigation directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now openApmEntity() knows that entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you've created a button and configured it to call .openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row but the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application: Click App performance: Now you see the stacked entity! Congratulations! You're finished writing all the code you'll write for you New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo application that is running an A/B test. You've created several charts, buttons, and other UI elements. You've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and out of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to deploy and subscribe to your New Relic application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.07709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>navigation</em> <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " platform: <em>navigation</em>. The <em>navigation</em> component lets you open entities, navigate to entities, and build Location objects for entities from <em>your</em> <em>nerdlet</em>. You can also use <em>navigation</em> for other nerdlets and launchers. Step 1 of 10 Change to the <em>add</em>-<em>navigation</em> directory of the coursework repository: bash"
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Security1.png",
      "url": "https://newrelic.com/blog/how-to-relic/new-relic-one-security-team-dashboards",
      "sections": [
        "Escaping our “black box”",
        "From dashboard to app",
        "Step 1: Store search parameter values in the state",
        "Step 2: Craft NRQL queries on the fly",
        "Step 3: Craft the final NRQL queries and set some temporary values for the text fields",
        "Step 4: Render the filter functionality",
        "Step 5: Render the charts using our finalized queries",
        "What’s next?"
      ],
      "published_at": "2021-04-14T00:03:23Z",
      "title": "How Our Security Team Uses New Relic One for Prevention",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "5eea1bf9b3c298f54f9468d89e766a82bdc198b9",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic How Our Security Team Uses New Relic One for Prevention Aug 14, 2020 • 8 min read By Scott Cutler Way back in 2016, the New Relic Security team discussed how we used New Relic Insights to monitor for potential threats and security events. Four years later, we introduced some major changes to the New Relic platform, so we've decided to make our security dashboards more user-friendly and flexible by converting them to Nerdlets using the New Relic One SDK. That’s exactly what we’ll explain in this post.  We documented our process and have made the source code available, so you can try it, too. Escaping our “black box” Until recently, we were using an early version of the Network Telemetry Integration. The integration sends sFlow and IPFIX data to New Relic, where we used the data in several dashboards built from long, complex NRQL queries. The dashboards showed metrics like traffic over time, anomalous traffic types, and sources by location. We even successfully used them to identify and troubleshoot at least one security incident. The dashboard and underlying queries survived multiple iterations of team members until it became a “black box”—we knew it worked but weren’t sure how. With an ever-changing infrastructure, our queries became obsolete and our dashboard unusable. We realized if we wanted to continue tracking anomalous data, we needed a revamp. From dashboard to app In our previous iteration, we had a set of static queries we used to create each dashboard. To replace the static queries, we wrote a Nerdlet from scratch that lets us filter and create our own queries. It’s important to note that our Nerdlet relies on New Relic Database data produced from the Network Telemetry Integration. This is what we came up with: In this instance, we’re able to use the text fields at the top row to add filter values—such as removing a specific IP address or protocol number. We can also remove the filters by pressing the X next to each filter value at the top. And each time we press the + or X, the rest of the Nerdlet is re-rendered with the correct results. Once we have a “filter set” that we like, we can copy and paste the NRQL query at the bottom and use it in an alert or dashboard. In this case, our next step is to start creating alerts focused on bandwidth usage for specific protocols we know aren’t used very often, and for network segments that shouldn’t be generating large amounts of traffic. Now, let’s take a look at how we created this Nerdlet. We broke it down into five steps, and if you want to try something similar, you can grab the code from this gist. Step 1: Store search parameter values in the state In our state object, we store several arrays, one for each filter type on the top row: Step 2: Craft NRQL queries on the fly Once we have the values in the arrays, we can start building NRQL queries with simple string concatenation tricks. In the example of IP Protocol numbers, we add WHERE protocolIdentifier = <number> when we want to filter for a specific protocol number. You may also notice that this method will introduce several WHERE clauses. Thankfully NRQL interprets this behavior as multiple AND clauses. Step 3: Craft the final NRQL queries and set some temporary values for the text fields In the beginning of our render function we set up two main things: our tempTextBoxValues object, which will hold the user-inputted values, and the final NRQL queries. Step 4: Render the filter functionality We created a few helper functions to render our filter bar at the top. The key was taking advantage of the fact that JavaScript will pass JSON objects by reference rather than value, allowing the onChange lambda to modify the tempTextBoxValues from step three. In our render portion of the code, we called it with one line: { this.populateTopToolbarStack(tempTextBoxValues) } Step 5: Render the charts using our finalized queries In our render block, we can now create grid items with chart objects that mirror the NR1 workshop examples but reference our finishedNrqlQueries object. When the user clicks a filter button, the autoSetFilters() function is called and will update the state object and trigger React to re-render the page. What’s next? What we really want is for the New Relic One platform to become our own security information and event management (SIEM), but we’re not quite there yet. For now, we plan to add pre-processing logic on logs before sending them to New Relic. This pre-processing could serve as our implementation for correlation and look for logs that occur across different event types. It seems like this may be possible in a New Relic One application, but we are still working on the idea of processing data outside the context of a browser session. If you’re looking for ways to get more out of New Relic One, check out our catalog of available apps and accompanying blog post series. By Scott Cutler Scott Cutler is a Senior Application Security Engineer at New Relic. He has been interested in security since he went to his first DefCon conference in 2004. He graduated with an Information and Computer Science degree from UC Irvine in 2009, took his first security job in 2012, and now works on the New Relic Threat Detection team. While engaging with the larger security community is fun (RainSec, OWASP, Twitter, CTFs), he also enjoys hiking, photography, and video games (DoTA 2 and Satisfactory are currently his go-tos). He has been living in North Portland for about four years and will always appreciate a food or drink recommendation for anywhere around Portland! Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.80975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "From dashboard <em>to</em> app",
        "body": " in Sign up Main <em>navigation</em> menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog <em>navigation</em> menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog"
      },
      "id": "6076314be7b9d2ad1da5c64b"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:23:32Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.419,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro <em>to</em> New Relic One SDK",
        "body": " Nerdpack&#x2F;<em>Nerdlet</em> templates—(a Nerdpack is a package containing all the files needed by an application; a <em>Nerdlet</em> is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks <em>Add</em> screenshots and metadata"
      },
      "id": "607627f464441f7e2b9d8537"
    }
  ],
  "/build-apps/ab-test/add-charts": [
    {
      "image": "https://developer.newrelic.com/static/0642dd0fbf77f167e4757a87aee06996/0086b/select-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/serve-app/embed/",
      "sections": [
        "Serve your New Relic One application",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:51:33Z",
      "title": "",
      "updated_at": "2021-04-11T13:51:33Z",
      "type": "",
      "external_id": "1a2cfa887902435c407fbdf71157b81a01a14513",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Create a Nerdpack, before starting this one. When you build a New Relic One application, it's valuable to view it on the platform. This helps you design, implement, and debug your application in the environment it will eventually be published to. With nr1, you can launch a development server that hosts your application so that New Relic One can present it to you. Step 1 of 4 From inside the Nerdpack's root directory, run nerdpack:serve: bash Copy $ nr1 nerdpack:serve When the Nerdpack has succeeded building and your application is ready to view, you'll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! Notice the appended query parameter nerdpacks=local. This query parameter tells New Relic to show locally served Nerdpacks. Tip If you don't see your application on the New Relic platform, make sure you've included nerdpacks=local in your querystring! Step 2 of 4 Navigate to the provided url. From the home page, select Apps to view New Relic One applications: Step 3 of 4 Under the Your apps section, find your launcher, called \"A/B Test Launcher\": Step 4 of 4 Select your launcher to see your root Nerdlet and its default welcome message: Congratulations, you've served your first New Relic One application! Notice, in the nerdpack:serve output, that the server reloads when you change files in your Nerdpack. Give it a try by updating nerdlets/ab-test-nerdlet/index.js: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>A/B test results</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Your app automatically refreshes to show the new heading: Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add chart components to your A/B test application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 5153.7554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Serve <em>your</em> New Relic One <em>application</em>",
        "body": " from &#x27;react&#x27;; export default class Ab<em>Test</em>NerdletNerdlet extends React.Component { render() { return &lt;h1&gt;A&#x2F;<em>B</em> <em>test</em> results&lt;&#x2F;h1&gt;; } } nerdlets&#x2F;ab-<em>test</em>-nerdlet&#x2F;index.js Copy <em>Your</em> app automatically refreshes to show the new heading: Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. Continue on to the next lesson: <em>Add</em> <em>chart</em> <em>components</em> to <em>your</em> A&#x2F;<em>B</em> <em>test</em> <em>application</em>."
      },
      "id": "6072fee564441fe6699d8585"
    },
    {
      "image": "https://developer.newrelic.com/static/733ffe1b10df224863d5c0b4f69894ce/0086b/first-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/first-chart/embed/",
      "sections": [
        "Add your first chart",
        "Course"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:17Z",
      "type": "",
      "external_id": "a6647ae7e6f32626783c432c4c7a2d4e0d896f8d",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart components to your A/B test application, before starting this one. In this course, you’re building an A/B test application for the New Relic platform. Previously, you learned about the New Relic One SDK and its component library. Now, It’s time for you to start building your application focusing first on chart components. Before you write any code, consult your design guide to remember what the application will look like when you finish: There are several charts you need to create, which may seem overwhelming at first, but take it one step at a time. The topmost chart, and the first you’ll create, is a line chart that shows the number of users who sign up for your newsletter and what version of your website they were shown. Step 1 of 8 Change to the add-your-first-chart directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-your-first-chart This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named newsletter-signups.js: bash Copy $ touch newsletter-signups.js Step 3 of 8 In this new file, create a component called NewsletterSignups to hold your first LineChart and some mock data: import React from 'react'; import { LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <LineChart data={[versionASignups, versionBSignups]} fullWidth /> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you’ve created two arbitrary data series which represent versions A and B of your test. Right now, you're using manually-crafted data points. In the future, you'll replace these with data queried from New Relic. Notice that you’ve specified a color for each series in the chart. The color metadata attribute takes any CSS-acceptable color format. Setting viz: 'main' means that you want to render the LineChart series as a line, the component's default display style. For the data prop in the LineChart component, you passed the two series in an array so that both are represented together. Finally, you used the chart’s fullWidth prop to stretch the chart’s width to fill the view. Step 4 of 8 In your Nerdlet's index.js file, import your new component and replace the default heading in your Nerdlet's render() method with your new component: import React from 'react'; import NewsletterSignups from './newsletter-signups'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-your-first-chart/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the LineChart displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. In seven steps, you’ve breathed life into your New Relic One application. Instead of a bland “Hello world” message, your application now shows a colorful line chart with two mocked data series. These data series represent server-side traffic for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another chart type. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add pie charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 3174.7024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>your</em> first <em>chart</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>chart</em> <em>components</em> to <em>your</em>"
      },
      "id": "607256c964441f74479d8559"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/embed/",
      "sections": [
        "Add pie charts",
        "Course"
      ],
      "published_at": "2021-04-11T13:55:24Z",
      "title": "",
      "updated_at": "2021-04-11T13:55:23Z",
      "type": "",
      "external_id": "c0f472d2ed9df8035313cd76ee83ec43e75d0a4a",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add your first chart, before starting this one. You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add tables.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.74554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> pie <em>charts</em>",
        "body": " starting this one. You’ve begun building <em>your</em> A&#x2F;<em>B</em> <em>test</em> <em>application</em>. So far, it consists of a single line <em>chart</em>, which represents the number of subscriptions <em>your</em> newsletter receives from each version of <em>your</em> website. To understand what you’ll build in this lesson, review the design guide"
      },
      "id": "6072ffcc28ccbc786651c18a"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-04-11T13:57:58Z",
      "title": "",
      "updated_at": "2021-04-11T13:57:58Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 300.02368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> user interface <em>components</em> <em>to</em> <em>your</em> <em>application</em>",
        "body": " for ending <em>your</em> A&#x2F;<em>B</em> <em>test</em>. Before you <em>add</em> user any UI <em>components</em> to <em>your</em> <em>application</em>, remind yourself of how <em>your</em> <em>application</em> will look when you finish: In the next lesson, you arrange <em>your</em> charts to look like they do in <em>your</em> design guide. Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> a grid."
      },
      "id": "6073006628ccbce73151c12f"
    },
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/embed/",
      "sections": [
        "Add a chart group",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "e94780ac131f1a4ce5999771f9bee9650d4f5e9b",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add tables, before starting this one. In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add user interface components to your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.40973,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> <em>chart</em> group",
        "body": " this one. In previous lessons, you added a variety of charts to <em>your</em> A&#x2F;<em>B</em> <em>test</em> <em>application</em>. These charts presented different facets of information about <em>your</em> A&#x2F;<em>B</em> <em>test</em>, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize"
      },
      "id": "6072ff19e7b9d25dbba5c689"
    }
  ],
  "/build-apps/ab-test/first-chart": [
    {
      "image": "https://developer.newrelic.com/static/733ffe1b10df224863d5c0b4f69894ce/0086b/first-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/first-chart/embed/",
      "sections": [
        "Add your first chart",
        "Course"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:17Z",
      "type": "",
      "external_id": "a6647ae7e6f32626783c432c4c7a2d4e0d896f8d",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart components to your A/B test application, before starting this one. In this course, you’re building an A/B test application for the New Relic platform. Previously, you learned about the New Relic One SDK and its component library. Now, It’s time for you to start building your application focusing first on chart components. Before you write any code, consult your design guide to remember what the application will look like when you finish: There are several charts you need to create, which may seem overwhelming at first, but take it one step at a time. The topmost chart, and the first you’ll create, is a line chart that shows the number of users who sign up for your newsletter and what version of your website they were shown. Step 1 of 8 Change to the add-your-first-chart directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-your-first-chart This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named newsletter-signups.js: bash Copy $ touch newsletter-signups.js Step 3 of 8 In this new file, create a component called NewsletterSignups to hold your first LineChart and some mock data: import React from 'react'; import { LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <LineChart data={[versionASignups, versionBSignups]} fullWidth /> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you’ve created two arbitrary data series which represent versions A and B of your test. Right now, you're using manually-crafted data points. In the future, you'll replace these with data queried from New Relic. Notice that you’ve specified a color for each series in the chart. The color metadata attribute takes any CSS-acceptable color format. Setting viz: 'main' means that you want to render the LineChart series as a line, the component's default display style. For the data prop in the LineChart component, you passed the two series in an array so that both are represented together. Finally, you used the chart’s fullWidth prop to stretch the chart’s width to fill the view. Step 4 of 8 In your Nerdlet's index.js file, import your new component and replace the default heading in your Nerdlet's render() method with your new component: import React from 'react'; import NewsletterSignups from './newsletter-signups'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-your-first-chart/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the LineChart displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. In seven steps, you’ve breathed life into your New Relic One application. Instead of a bland “Hello world” message, your application now shows a colorful line chart with two mocked data series. These data series represent server-side traffic for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another chart type. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add pie charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1425.1252,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>your</em> <em>first</em> <em>chart</em>",
        "body": " <em>chart</em> that shows the number of users who sign up for <em>your</em> newsletter and what version of <em>your</em> website they were shown. Step 1 of 8 Change to the <em>add</em>-<em>your</em>-<em>first</em>-<em>chart</em> directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-<em>your</em>-<em>first</em>-<em>chart</em> This directory contains the code"
      },
      "id": "607256c964441f74479d8559"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-charts/embed/",
      "sections": [
        "Add chart components to your A/B test application",
        "Course"
      ],
      "published_at": "2021-04-11T13:51:33Z",
      "title": "",
      "updated_at": "2021-04-08T01:59:52Z",
      "type": "",
      "external_id": "c6c3610a3267705c0888958509095a737b8c7f7e",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Serve your New Relic One application, before starting this one. The New Relic One application that you're building throughout this course allows developers to A/B test their websites. To run a successful A/B test, site owners need to be able to analyze the results. Without knowing how each design performs, how will developers determine which design to use? Here is a mockup for the A/B test application you're building: Your application displays data for two competing versions. With various charts and tables, your users will be able to analyze the results of their test and make informed decisions on which design will work best to achieve their goals. You’ll refer back to this mockup many times throughout this course. It shows you what charts to create, how to organize them, and what kind of data to provide them. In the next four sections, you learn how to create every chart that your A/B test application needs to operate effectively. After that, you’ll arrange the charts to match the mockup’s design and supply New Relic data collected from the demo applications you spun up earlier. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add your first chart.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1201.3805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>chart</em> components to <em>your</em> A&#x2F;B test application",
        "body": " to operate effectively. After that, you’ll arrange the charts to match the mockup’s design and supply New Relic data collected from the demo applications you spun up earlier. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>your</em> <em>first</em> <em>chart</em>."
      },
      "id": "606e639828ccbc82c1542179"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/embed/",
      "sections": [
        "Add pie charts",
        "Course"
      ],
      "published_at": "2021-04-11T13:55:24Z",
      "title": "",
      "updated_at": "2021-04-11T13:55:23Z",
      "type": "",
      "external_id": "c0f472d2ed9df8035313cd76ee83ec43e75d0a4a",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add your first chart, before starting this one. You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add tables.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1045.1738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> pie <em>charts</em>",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>your</em> <em>first</em> <em>chart</em>, before"
      },
      "id": "6072ffcc28ccbc786651c18a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Delayed-Jobs-New-Relic-1024x837.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/monitoring-delayedjob",
      "sections": [
        "Related Topics"
      ],
      "published_at": "2021-04-14T00:06:04Z",
      "title": "Monitoring DelayedJob",
      "updated_at": "2021-04-14T00:06:04Z",
      "type": "",
      "external_id": "2e9c1f784c773aa1fa509a112bcd338cac37c70e",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Monitoring DelayedJob Sep 12, 2012 • 6 min read By Bill Kayser Like many Ruby shops we use the DelayedJob job runner to run many of our background tasks. The New Relic agent has had some basic DelayedJob instrumentation for a while now but until recently you were limited to a few metrics which could only be viewed using the somewhat limited and unwieldy custom charts. But no longer! In the latest release of the Ruby Agent we are sending much richer, useful metrics for DelayedJob workers, and the recently released Custom Dashboards allows you to to build a truly useful view for monitoring and troubleshooting your jobs. Here's what it looks like: This is a Custom Dashboard we built for our DelayedJobs workers running in production. Below, I'll show you the steps to create this in your own New Relic account. But first let me explain what we are looking at. There are four graphs with data reported by the agent running in the DelayedJob worker. Job Queue Length shows the number of jobs waiting to be executed at any given time, based on one minute samples. We break out these numbers by priority since we manage separate workers in three different priority levels. In the graph above, you can see that our highest priority worker maintains a pretty healthy queue while we get a few spikes in our low priority worker every now and then, since the jobs in the low priority queue tend to run a little longer. In our configuration, we destroy jobs when they've run successfully and leave the failed ones. The agent polls the failed jobs and reports the count which we graph in the Failed Jobs chart. We pay particular attention to this chart during a deploy to look for any jump in failing jobs caused by a regression. Locked Jobs is particularly interesting. Jobs are locked while executing, so the number of jobs locked at any given time should not exceed the number of workers. With idle workers, the count will be low. With workers fully utilized, the number will approach the total number of workers. We find you do have to be careful as some jobs occasionally fail without clearing their lock, so you have to manually clear those out. But you can use the Locked Jobs graph as a gauge of your overall worker utilization. The Average Job Execution time graph is simply a graph of the average response time of the DelayedJob transactions. Creating a Custom Dashboard for DelayedJobs Let's walk through the steps to get this set up in a typical account. The first thing you need is the current version of the Ruby Agent gem. You must be running at least version 3.4.2. Then follow these steps in the New Relic application: 1) Select the application where DelayedJob is running. In our case it's \"Background Jobs\". 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and \"Grid\" chart type. 3) Choose Add chart to add the first chart to your dashboard.  Fill in the basic properties, including the titles and chart type, which is \"Stacked Area.\" 4) Select the DelayedJob queue lengths for the graph. Start typing in Workers/. Initially it will say the metric doesn't exist, but when you enter the slash it will display the list of available metrics in the Workers namespace. Keep typing Workers/DelayedJob/queue_length/priority/*.  The metrics will auto-complete as you enter each segment. The asterisk at the end indicates that you want to break down the graph by priority. If you don't use priorities you can chart a single line for the queue length using the metric name Workers/DelayedJob/queue_length/all. 5. That's generally good enough to display the chart, but there are a couple of other properties you can customize. In our case, we removed the limit on the number of different priorities it will show, added \"jobs\" to the y-axis labels, and fixed the application to \"RPM Background\" where the DelayedJob agent reports to. Here's what it looks like: 6. Add the Failed Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking failed jobs: Workers/DelayedJob/failed_jobs. 7. Add the Locked Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking locked jobs: Workers/DelayedJob/locked_jobs. 8. Add the Job Execution Time chart. Repeat steps 3 - 5 but enter the metric for the response time of delayed jobs:  OtherTransaction/DelayedJob/all. We show execution time in milliseconds so we chose To Milliseconds for the Number Format and \"ms\" as the y-axis unit label. We also hide the legend. That's enough to get you started with a good dashboard for monitoring your DelayedJob workers. But you don't have to stop there. You can add a table showing you the summary metrics for each job or a breakdown chart of all the jobs. In addition to showing the response time of jobs, you could chart the throughput. We combine our staging and production servers onto one dashboard by duplicating the charts and picking a different application. Custom Dashboards now makes it easy to configure the charts for the exact data you want to display. If you haven't already, try New Relic today to see how you can improve the performance of your Ruby applications. And as always, we welcome your feedback on this post. Let us know what you think of Custom Dashboards and how you're using them to monitor your applications. Related Topics APM By Bill Kayser Bill has been with New Relic from the beginning as both a developer and a data scientist. Having worked in application performance management for nearly two decades, his role now entails discovering new ways of exploring and interpreting data as well as prototyping innovative new features. Follow the author Bill Kayser on Twitter Bill Kayser on GitHub Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 390.36,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " in the New Relic application: 1) Select the application where DelayedJob is running. In our case it&#x27;s &quot;Background Jobs&quot;. 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and &quot;Grid&quot; <em>chart</em> type. 3) Choose <em>Add</em> <em>chart</em> to <em>add</em> the <em>first</em> <em>chart</em> to <em>your</em> dashboard.  Fill"
      },
      "id": "607631ece7b9d201aea5c63a"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Course",
        "Extra credit"
      ],
      "published_at": "2021-04-11T14:01:09Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add pie charts, before starting this one. In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a chart group.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.10483,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> tables",
        "body": " <em>your</em> <em>first</em> Table<em>Chart</em> and some mock data: import React from &#x27;react&#x27;; import { Table<em>Chart</em> } from &#x27;nr1&#x27;; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version"
      },
      "id": "60725692196a67b68c64a778"
    }
  ],
  "/build-apps/ab-test/add-ui": [
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/embed/",
      "sections": [
        "Add a chart group",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-11T13:52:25Z",
      "type": "",
      "external_id": "e94780ac131f1a4ce5999771f9bee9650d4f5e9b",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add tables, before starting this one. In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add user interface components to your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2308.822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a chart group",
        "body": " of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. When you&#x27;re ready, continue on to the next lesson: <em>Add</em> <em>user</em> <em>interface</em> <em>components</em> to <em>your</em> <em>application</em>."
      },
      "id": "6072ff19e7b9d25dbba5c689"
    },
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/embed/",
      "sections": [
        "Add a grid",
        "Course",
        "Technical detail"
      ],
      "published_at": "2021-04-11T14:01:08Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "bfd5e04da0f000d6970b16677cd5faf8c3b2f461",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add user interface components to your application, before starting this one. In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add chart headings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2211.677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a grid",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>user</em> <em>interface</em>"
      },
      "id": "6072565d28ccbc6baf51c18b"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application",
        "Course"
      ],
      "published_at": "2021-04-11T13:57:58Z",
      "title": "",
      "updated_at": "2021-04-11T13:57:58Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add a chart group, before starting this one. If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. When you're ready, continue on to the next lesson: Add a grid.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.73714,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>user</em> <em>interface</em> <em>components</em> <em>to</em> <em>your</em> <em>application</em>",
        "body": " starting this one. If an <em>application</em> is organized, it is more readable and more understandable. In <em>your</em> A&#x2F;B test <em>application</em>, you have a lot of charts, but no organization. In the next few lessons, you’ll use <em>user</em> <em>interface</em> <em>components</em> to bring some organization to <em>your</em> <em>application</em> and provide new"
      },
      "id": "6073006628ccbce73151c12f"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions",
        "Course"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T01:53:22Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add chart headings, before starting this one. With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 7 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 2 of 7 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 3 of 7 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 4 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 5 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 7 of 7 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add a section to end your test.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.23405,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> version descriptions",
        "body": " competing designs and <em>your</em> charts. In the next lesson, you’ll create a new section of <em>your</em> <em>application</em> from <em>user</em> <em>interface</em> <em>components</em>. This section will be used to end the A&#x2F;B test with the click of a button. Course This lesson is part of a course that teaches you how to build a New Relic One <em>application</em> from the ground up. Continue on to the next lesson: <em>Add</em> a section to end <em>your</em> test."
      },
      "id": "6072569228ccbc932d51c172"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:23:32Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.81937,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro <em>to</em> New Relic One SDK",
        "body": " <em>components</em> for fetching and storing New Relic data Platform APIs that enable <em>your</em> <em>application</em> to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build <em>your</em> applications"
      },
      "id": "607627f464441f7e2b9d8537"
    }
  ],
  "/build-apps/ab-test/nrql": [
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/embed/",
      "sections": [
        "Customize NRQL data",
        "Course",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T14:01:47Z",
      "type": "",
      "external_id": "f51f9d86d3b873b24e967c687d5408eb9918a33f",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add NrqlQuery components to your nerdlet, before starting this one. In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your nerdpack served locally, view your application to see your charts serving real data: In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Access NerdStorage from your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1405.7347,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Customize <em>NRQL</em> data",
        "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven&#x27;t already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you&#x27;ve completed the last lesson, <em>Add</em> <em>NrqlQuery</em> <em>components</em>"
      },
      "id": "6073014b28ccbc70b651c134"
    },
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/embed/",
      "sections": [
        "Present an end test confirmation modal",
        "Course",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-04-11T13:52:26Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "554a84f8fe2faf9c2b867686538360771e22fc3c",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Persist the selected version, before starting this one. In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 View your application: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. View your application where the modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add NrqlQuery components to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 638.20825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Show and hide <em>your</em> confirmation modal",
        "body": " for <em>your</em> users to interact with the test. Now, you need some real data. In the next lesson, you&#x27;ll replace the mocked data in <em>your</em> charts with real data from <em>your</em> backend service. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: <em>Add</em> <em>NrqlQuery</em> <em>components</em> to <em>your</em> <em>nerdlet</em>."
      },
      "id": "6072565e64441f34dd9d8548"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/embed/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Course",
        "Tip"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-11T13:56:16Z",
      "type": "",
      "external_id": "58de68bd963cdd2062e88db55cb90ad124055eb6",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Fetch data from a third-party service, before starting this one. In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to take use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy PlatformStateContext.Consumer provides access to the platform's URL state. This state contains two important values for you to use in this context: accountId timeRange Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your nerdlet, you can use accountId from the platform URL state. Step 3 of 10 Use platformState.accountId in your NrqlQuery: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Next, notice that your query uses a SINCE clause, which identifies the historical timeframe your query should fetch data from. Step 4 of 10 Utilize platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. Tip While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery is now using the account ID, which it got from platform state. It's also using the platform state's time range, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: When you're finished, stop serving your New Relic One application by pressing CTRL+C in the terminal window where you're serving your application. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Add navigation to your nerdlet.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 618.1953,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " in this context: accountId timeRange Notice that <em>NrqlQuery</em> uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in <em>your</em> <em>nerdlet</em>, you can use accountId from the platform URL state. Step 3 of 10 Use platformState.accountId in <em>your</em> <em>NrqlQuery</em>: import React from &#x27;react&#x27;; import"
      },
      "id": "6073000164441f84ce9d853d"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/embed/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "Course",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-04-11T14:01:08Z",
      "title": "",
      "updated_at": "2021-04-11T14:01:08Z",
      "type": "",
      "external_id": "43c5fb39b73ee2dbbe5f216a577ff77051fcc513",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Present an end test confirmation modal, before starting this one. In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 View your changes: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account id. Step 2 of 2 With your nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Customize NRQL data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 585.35486,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>NrqlQuery</em> <em>components</em> <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " <em>NRQL</em> queries. Next, you learn how to pass <em>your</em> <em>NRQL</em> <em>query</em> to <em>your</em> Newsletter subscriptions per version chart. Step 1 of 7 Change to the <em>add</em>-<em>nrql</em>-<em>components</em> directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-<em>nrql</em>-<em>components</em> This directory contains the code that we"
      },
      "id": "60730124196a6731e464a778"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Course"
      ],
      "published_at": "2021-04-11T14:00:18Z",
      "title": "",
      "updated_at": "2021-04-11T01:52:29Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Add PlatformStateContext to your nerdlet, before starting this one. In the last lesson, you used PlatformStateContext from the New Relic One SDK to lookup the application user's account ID and the time range they selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your nerdlet. You can also use navigation for other nerdlets and launchers. Step 1 of 10 Change to the add-navigation directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Now openApmEntity() knows that entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you've created a button and configured it to call .openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={platformState.accountId} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row but the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application: Click App performance: Now you see the stacked entity! Congratulations! You're finished writing all the code you'll write for you New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo application that is running an A/B test. You've created several charts, buttons, and other UI elements. You've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and out of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to deploy and subscribe to your New Relic application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Describe your app for the catalog.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 569.99445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": "={platformState.accountId} <em>query</em>=&quot;SELECT count(*) FROM subscription FACET page_version TIMESERIES&quot; timeRange={platformState.timeRange} pollInterval={60000} &gt; { ({ data }) =&gt; { return &lt;LineChart data={data} fullWidth &#x2F;&gt;; } } &lt;&#x2F;<em>NrqlQuery</em>&gt; } } &lt;&#x2F;PlatformStateContext.Consumer&gt; &lt;&#x2F;div&gt; } } nerdlets&#x2F;ab-test-<em>nerdlet</em>"
      },
      "id": "6072565e196a67927a64a797"
    }
  ],
  "/build-apps/add-visualizations-to-dashboard": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Course",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-11T13:58:44Z",
      "title": "",
      "updated_at": "2021-04-11T13:58:44Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Publish your New Relic One application, before starting this one. In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a nerdpack, launcher, and nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes. Course This lesson is the final part of a course that teaches you how to build a New Relic One application from the ground up. Congratulations on making it to the end!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 477.70966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Subscribe to your New Relic <em>One</em> application",
        "body": " Account access, deselect the account you want to unsubscribe from the app, and select Update <em>1</em> account: If you navigate back to Apps, you will see your app in the <em>catalog</em>. Throughout this course, you&#x27;ve built a New Relic <em>One</em> application from the ground up. You&#x27;ve used the <em>nr1</em> <em>CLI</em> to create a nerdpack"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Course",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-11T14:01:47Z",
      "title": "",
      "updated_at": "2021-04-11T01:54:16Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. If you haven't already, check out the course introduction. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Spin up your demo services, before starting this one. One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: You use this key to associate your New Relic account with the CLI. The CLI then uses the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name>, the <User key>, and the region (either us or eu) with real values. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI. Course This lesson is part of a course that teaches you how to build a New Relic One application from the ground up. Continue on to the next lesson: Create a Nerdpack.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 375.55484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic <em>One</em> <em>CLI</em>",
        "body": " this by checking your SDK version: bash Copy $ <em>nr1</em> --version Tip It’s important to distinguish between the newrelic <em>CLI</em> and the <em>nr1</em> <em>CLI</em>. newrelic is for managing entities in your New Relic account. <em>nr1</em> is for managing New Relic <em>One</em> applications. Step 3 of 3 Associate your New Relic account as a <em>CLI</em> profile. Use"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-11T13:51:34Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.61505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to New Relic <em>One</em> SDK",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "image": "https://developer.newrelic.com/static/28a19f070d3ae2b215793dd163851d7c/0086b/click-add-to-dashboard.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/embed/",
      "sections": [
        "Add custom visualizations to your dashboards",
        "Before you begin",
        "Note",
        "Add your custom visualization to a dashboard",
        "Manage your dashboard visualizations",
        "Summary",
        "Additional resources"
      ],
      "published_at": "2021-04-12T01:54:51Z",
      "title": "",
      "updated_at": "2021-04-10T01:54:48Z",
      "type": "",
      "external_id": "230f853d85188e6617cfa0014204b34fcb2e5c70",
      "popularity": 1,
      "body": "This lesson builds off of the previous Customize visualizations with configuration lesson. If you haven't followed that lesson, please start there as this lesson assumes you have the code you built there to get started. If you don't have a visualization to follow the examples in this gude, a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using nr1.json configuration, in the following steps, you will configure and add your custom visualization to a New Relic dashboard. Before you begin To get started, follow the Customize visualizations with configuration lesson. Then, publish and subscribe to your Nerdpack. Note To publish a Nerdpack you must be a Full user and granted the Nerdpacks “modify” privilege (which is granted by default). Read our documentation to learn more about Nerdpacks privileges. Add your custom visualization to a dashboard Once you've published your custom visualization to your account, in the following steps you'll configure your visualization and add it to a dashboard. You can add a visualization to a new or existing dashboard within your New Relic account. Step 1 of 6 To find the My Awesome Visualization that you have deployed, you need to look for your visualization in the app catalog. From the New Relic One homepage, select the Apps button in the top right navigation bar: Step 2 of 6 Once on the Apps page, click the Custom Visualizations launcher: Note If you don't see the Custom Visualizations tile, use the search to locate it. Step 3 of 6 In Custom Visualizations, you will see all of the visualization that have been deployed to your account and any visualizations you are serving locally. Select the My Awesome Visualization to add to a dashboard and then enable it: Step 4 of 6 In the previous lesson, you reconfigured your visualization to use the platform configurations panel. Use the configuration options to select your desired chart, select your account, insert a NRQL query, and any other configurations you desire. As you make your selections, the visualization will update with your changes: Step 5 of 6 Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name: Step 6 of 6 Click Add to dashboard, then click the link to your dashboard to see the custom visualization: Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations. Summary Congratulations on completing this final lesson and adding your custom visualization to a New Relic dashboard. In the previous lessons, you've used the tools in the New Relic SDK to create a new custom visualization, configured the visualization using the SDK and using the platform configuration panel. Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.42001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add custom <em>visualizations</em> to your dashboards",
        "body": ", a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using <em>nr1</em>.json configuration"
      },
      "id": "60710568196a6793b864a754"
    },
    {
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/embed/",
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "edab33e46fbc9f8e054670c52397176ce989ae3a",
      "popularity": 1,
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type nerdpack --name my-first-viz $ cd my-first-viz $ nr1 create --type visualization --name custom-viz The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ nr1 nerdpack:serve Then visit New Relic and navigate to Apps > Custom Visualizations > CustomViz to see it in action: Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack artifacts, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.59094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Introduction to custom <em>visualizations</em>",
        "body": " Relic <em>One</em> SDK and make sure you have the latest version: bash Copy $ <em>nr1</em> update Create a Nerdpack and a visualization: bash Copy $ <em>nr1</em> create --type nerdpack --name my-first-viz $ cd my-first-viz $ <em>nr1</em> create --type visualization --name custom-viz The visualization you created in the my-first-viz"
      },
      "id": "607105a064441fa6da9d8530"
    }
  ],
  "/explore-docs/custom-viz": [
    {
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/embed/",
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "edab33e46fbc9f8e054670c52397176ce989ae3a",
      "popularity": 1,
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type nerdpack --name my-first-viz $ cd my-first-viz $ nr1 create --type visualization --name custom-viz The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ nr1 nerdpack:serve Then visit New Relic and navigate to Apps > Custom Visualizations > CustomViz to see it in action: Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack artifacts, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 455.81842,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Introduction to <em>custom</em> <em>visualizations</em>",
        "body": " Relic One <em>SDK</em> and make sure you have the latest version: bash Copy $ <em>nr1</em> update Create a <em>Nerdpack</em> and a visualization: bash Copy $ <em>nr1</em> create --type <em>nerdpack</em> --name my-first-viz $ cd my-first-viz $ <em>nr1</em> create --type visualization --name <em>custom</em>-viz The visualization you created in the my-first-viz"
      },
      "id": "607105a064441fa6da9d8530"
    },
    {
      "image": "https://developer.newrelic.com/static/28a19f070d3ae2b215793dd163851d7c/0086b/click-add-to-dashboard.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/embed/",
      "sections": [
        "Add custom visualizations to your dashboards",
        "Before you begin",
        "Note",
        "Add your custom visualization to a dashboard",
        "Manage your dashboard visualizations",
        "Summary",
        "Additional resources"
      ],
      "published_at": "2021-04-12T01:54:51Z",
      "title": "",
      "updated_at": "2021-04-10T01:54:48Z",
      "type": "",
      "external_id": "230f853d85188e6617cfa0014204b34fcb2e5c70",
      "popularity": 1,
      "body": "This lesson builds off of the previous Customize visualizations with configuration lesson. If you haven't followed that lesson, please start there as this lesson assumes you have the code you built there to get started. If you don't have a visualization to follow the examples in this gude, a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using nr1.json configuration, in the following steps, you will configure and add your custom visualization to a New Relic dashboard. Before you begin To get started, follow the Customize visualizations with configuration lesson. Then, publish and subscribe to your Nerdpack. Note To publish a Nerdpack you must be a Full user and granted the Nerdpacks “modify” privilege (which is granted by default). Read our documentation to learn more about Nerdpacks privileges. Add your custom visualization to a dashboard Once you've published your custom visualization to your account, in the following steps you'll configure your visualization and add it to a dashboard. You can add a visualization to a new or existing dashboard within your New Relic account. Step 1 of 6 To find the My Awesome Visualization that you have deployed, you need to look for your visualization in the app catalog. From the New Relic One homepage, select the Apps button in the top right navigation bar: Step 2 of 6 Once on the Apps page, click the Custom Visualizations launcher: Note If you don't see the Custom Visualizations tile, use the search to locate it. Step 3 of 6 In Custom Visualizations, you will see all of the visualization that have been deployed to your account and any visualizations you are serving locally. Select the My Awesome Visualization to add to a dashboard and then enable it: Step 4 of 6 In the previous lesson, you reconfigured your visualization to use the platform configurations panel. Use the configuration options to select your desired chart, select your account, insert a NRQL query, and any other configurations you desire. As you make your selections, the visualization will update with your changes: Step 5 of 6 Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name: Step 6 of 6 Click Add to dashboard, then click the link to your dashboard to see the custom visualization: Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations. Summary Congratulations on completing this final lesson and adding your custom visualization to a New Relic dashboard. In the previous lessons, you've used the tools in the New Relic SDK to create a new custom visualization, configured the visualization using the SDK and using the platform configuration panel. Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 410.52338,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>visualizations</em> to your dashboards",
        "body": ", a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using <em>nr1</em>.json configuration"
      },
      "id": "60710568196a6793b864a754"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.22253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-workload-geoops.git cd <em>nr1</em>-workload-geoops <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure, and deploy an account"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:50Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.22186,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-attributory.git cd <em>nr1</em>-attributory <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure, and deploy an account-specific instance of Attributory"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:49:51Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 355.4845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-container-explorer.git cd <em>nr1</em>-container-explorer <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure"
      },
      "id": "60762e1f196a673d0a64a782"
    }
  ],
  "/explore-docs/custom-viz/configuration-options": [
    {
      "image": "https://developer.newrelic.com/static/28a19f070d3ae2b215793dd163851d7c/0086b/click-add-to-dashboard.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/embed/",
      "sections": [
        "Add custom visualizations to your dashboards",
        "Before you begin",
        "Note",
        "Add your custom visualization to a dashboard",
        "Manage your dashboard visualizations",
        "Summary",
        "Additional resources"
      ],
      "published_at": "2021-04-12T01:54:51Z",
      "title": "",
      "updated_at": "2021-04-10T01:54:48Z",
      "type": "",
      "external_id": "230f853d85188e6617cfa0014204b34fcb2e5c70",
      "popularity": 1,
      "body": "This lesson builds off of the previous Customize visualizations with configuration lesson. If you haven't followed that lesson, please start there as this lesson assumes you have the code you built there to get started. If you don't have a visualization to follow the examples in this gude, a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using nr1.json configuration, in the following steps, you will configure and add your custom visualization to a New Relic dashboard. Before you begin To get started, follow the Customize visualizations with configuration lesson. Then, publish and subscribe to your Nerdpack. Note To publish a Nerdpack you must be a Full user and granted the Nerdpacks “modify” privilege (which is granted by default). Read our documentation to learn more about Nerdpacks privileges. Add your custom visualization to a dashboard Once you've published your custom visualization to your account, in the following steps you'll configure your visualization and add it to a dashboard. You can add a visualization to a new or existing dashboard within your New Relic account. Step 1 of 6 To find the My Awesome Visualization that you have deployed, you need to look for your visualization in the app catalog. From the New Relic One homepage, select the Apps button in the top right navigation bar: Step 2 of 6 Once on the Apps page, click the Custom Visualizations launcher: Note If you don't see the Custom Visualizations tile, use the search to locate it. Step 3 of 6 In Custom Visualizations, you will see all of the visualization that have been deployed to your account and any visualizations you are serving locally. Select the My Awesome Visualization to add to a dashboard and then enable it: Step 4 of 6 In the previous lesson, you reconfigured your visualization to use the platform configurations panel. Use the configuration options to select your desired chart, select your account, insert a NRQL query, and any other configurations you desire. As you make your selections, the visualization will update with your changes: Step 5 of 6 Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name: Step 6 of 6 Click Add to dashboard, then click the link to your dashboard to see the custom visualization: Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations. Summary Congratulations on completing this final lesson and adding your custom visualization to a New Relic dashboard. In the previous lessons, you've used the tools in the New Relic SDK to create a new custom visualization, configured the visualization using the SDK and using the platform configuration panel. Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 847.1063,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>visualizations</em> to <em>your</em> dashboards",
        "body": ", in the following steps, you will <em>configure</em> and add <em>your</em> <em>custom</em> <em>visualization</em> to a New Relic dashboard. Before you begin To get started, follow the Customize visualizations with configuration lesson. Then, publish and subscribe to <em>your</em> Nerdpack. Note To publish a Nerdpack you must be a Full user and granted"
      },
      "id": "60710568196a6793b864a754"
    },
    {
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/embed/",
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "published_at": "2021-04-11T13:52:25Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "edab33e46fbc9f8e054670c52397176ce989ae3a",
      "popularity": 1,
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type nerdpack --name my-first-viz $ cd my-first-viz $ nr1 create --type visualization --name custom-viz The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ nr1 nerdpack:serve Then visit New Relic and navigate to Apps > Custom Visualizations > CustomViz to see it in action: Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack artifacts, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.3755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build <em>your</em> <em>custom</em> <em>visualization</em>",
        "body": ") Configuring <em>custom</em> visualizations for dashboards (Video) Use <em>your</em> <em>custom</em> <em>visualization</em> During development, you can serve <em>your</em> <em>visualization</em> locally. Under Apps &gt; <em>Custom</em> Visualizations, you can view and <em>configure</em> <em>your</em> <em>visualization</em> to see how <em>your</em> data looks, but you can&#x27;t instantiate that chart and use"
      },
      "id": "607105a064441fa6da9d8530"
    },
    {
      "image": "https://developer.newrelic.com/static/25bfa8bc13b72a76caaf0744cc55a703/9730c/configurable-props.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/configuration-options/embed/",
      "sections": [
        "Configure your custom visualization",
        "Edit your visualization's metadata",
        "Declare your visualization's configurable properties",
        "boolean",
        "string",
        "number",
        "json",
        "enum",
        "nrql",
        "account-id",
        "namespace",
        "collection",
        "Use nr1.json"
      ],
      "published_at": "2021-04-11T13:56:17Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "63535453e3cfb5729cadf7bdbc306cefdd09a2aa",
      "popularity": 1,
      "body": "Customize your visualization's configurable properties to make it reusable. In this document, you'll learn what information your visualization's nr1.json file contains, how you can modify it, and how it's used to make your visualization more flexible. Edit your visualization's metadata nr1.json is a metadata file that lives in your visualization directory and looks something like this: { \"schemaType\": \"VISUALIZATION\", \"id\": \"fun-visualization\", \"displayName\": \"FunVisualization\", \"description\": \"\", \"configuration\": [] } nr1.json Copy It contains the following top-level keys: schemaType: Nerdpack artifacts all have nr1.json metadata files. The schemaType describes the artifact's schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization's string identifier. This must be unique within a given Nerdpack, but it doesn't need to be unique across all Nerdpacks. displayName: The human-readable name that New Relic displays in Custom Visualizations description: The description that New Relic displays in Custom Visualizations configuration: A list of configurable properties for your visualization. You can edit these properties in the web UI and their values are passed to your visualization component. Declare your visualization's configurable properties To declare your visualization's configurable properties, you list them under the configuration key in nr1.json: \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"number\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] Copy In this example, nrqlQueries is a collection of query objects. Each query object consists of an accountId and a query. As a collection, you can have multiple query objects in this visualization. fill and stroke are strings that define a color to be used when rendering the visualization. This example configuration results in the following fields in the visualization's setup UI: Notice the + next to NRQL Queries, which you can use to add query objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it's field's description, if it has one. In your React code, you can access the values of these fields in your visualization component's props: export default class MyCustomVisualization extends React.Component { render() { const { nrqlQueries, stroke, fill } = this.props; return <div> <p>Fill color: { fill }</p> <p>Stroke color: { stroke }</p> <p>First query account ID: { nrqlQueries[0].accountId }</p> <p>First query: { nrqlQueries[0].query }</p> </div> } Copy All configuration objects have the following optional keys: name: The React component prop name title: The UI display name description: An tooltip description All configuration objects require a type key that references the field's data type. Each data type is unique in how it's configured and presented. boolean A boolean property is rendered in the UI as a toggle and represents a true or false state. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"showLabels\", \"title\": \"Show labels\", \"description\": \"Toggles the visibility of the chart's labels.\", \"type\": \"boolean\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { showLabels } = this.props; const label = showLabels ? { fill: '#666' } : false return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar label={label} background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy string A string property is rendered in the UI as a text field and represents a character string. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"title\", \"title\": \"Chart title\", \"description\": \"The chart's title.\", \"type\": \"string\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { HeadingText } from 'nr1'; import { RadialBarChart, RadialBar, Legend, Label } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { title } = this.props; return ( <div> <HeadingText className=\"chart-heading\"> {title} </HeadingText> <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> </div> ) } } index.js Copy number A number property is rendered in the UI as a text field and represents a number. number props take three extra optional keys: min: The minimum value the text field can take max: The maximum value the text field can take step: The interval between valid values While these keys are available, they are not enforced. They are purely for UI purposes. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconSize } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={iconSize} /> </RadialBarChart> ) } } index.js Copy json A json property is rendered in the UI as a text box and represents a JSON object. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"description\": \"The data in the chart\", \"type\": \"json\" } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={JSON.parse(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy enum An enum property is rendered in the UI as a drop-down menu and represents a pre-defined list of choices. An enum takes an array of items, each with its own title and value. An item's title is its UI display title. Its value is its React component prop name. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconType } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconType={iconType} /> </RadialBarChart> ) } } index.js Copy nrql A nrql property is rendered in the UI as a text box and represents a NRQL query. You can use the NrqlQuery component from the nr1 component library to query New Relic's database. You may need to transform the data to fit your visualization's needs. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"query\", \"title\": \"Query\", \"description\": \"The query for chart data.\", \"type\": \"nrql\" } ] } nr1.json Copy import React from 'react'; import inputData from './data'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { query } = this.props; return ( <NrqlQuery accountId={inputData.accountId} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy account-id An account-id property is rendered in the UI as a drop-down menu and represents a New Relic account. From the menu, you can search for and select an account. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"account\", \"title\": \"Account\", \"description\": \"Select the appropriate New Relic account\", \"type\": \"account-id\" } ] } nr1.json Copy import React from 'react'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { account } = this.props; const query = \"SELECT count(*) FROM Public_APICall FACET `http.method`\" return ( <NrqlQuery accountId={account} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy namespace A namespace groups properties in the UI under a single heading. A namespace has items which are accessed in code, by name, as attributes of the namespace prop. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"legend\", \"title\": \"Legend\", \"type\": \"namespace\", \"items\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" }, { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { legend } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={legend.iconSize} iconType={legend.iconType} /> </RadialBarChart> ) } } index.js Copy collection A collection is a group of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection's child items. When you configure a collection in the UI, you can increase or decrease the amount of child items in the collection. In code, you access the collection prop as an array of items. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"type\": \"collection\", \"items\": [ { \"name\": \"name\", \"title\": \"Age group\", \"description\": \"The age range of the group.\", \"type\": \"string\" }, { \"name\": \"val\", \"title\": \"Amount\", \"description\": \"The amount of people in the age group.\", \"type\": \"number\", \"min\": 0 }, { \"name\": \"fill\", \"title\": \"Bar color\", \"description\": \"The color of the chart bar.\", \"type\": \"string\" } ] } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy Use nr1.json You can freely edit nr1.json, but unlike index.js your locally served visualization requires a restart to see its changes. So, if you're serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 nerdpack:serve If your visualization is already published, you need to update your Nerdpack's version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.7514,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Configure</em> <em>your</em> <em>custom</em> <em>visualization</em>",
        "body": ". displayName: The human-readable name that New Relic displays in <em>Custom</em> Visualizations description: The description that New Relic displays in <em>Custom</em> Visualizations configuration: A list of configurable properties for <em>your</em> <em>visualization</em>. You can edit these properties in the web UI and their values are passed"
      },
      "id": "607105a164441f96d19d857f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/cloud-migration-quickstart-2.png",
      "url": "https://newrelic.com/blog/how-to-relic/dashboards-and-custom-visualizations",
      "sections": [
        "Visualize your data from scratch or a quickstart",
        "Extend capabilities with the dashboards API and customizations UI",
        "Let’s build together"
      ],
      "published_at": "2021-04-13T23:29:41Z",
      "title": "New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil",
      "updated_at": "2021-04-13T23:29:41Z",
      "type": "",
      "external_id": "5d1ed7d2f89c24024b85aac381ce3940605bd0e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil Feb 25, 2021 • 4 min read By Sebastian Galiano Molina If you’re like most engineers, you may find yourself parsing through data from more sources than ever before. Chances are that you need a way to visualize and customize all the data to fit your organization’s needs, and report and efficiently communicate your analysis to different stakeholders. Starting from scratch isn’t the most efficient way. The good news is that you don’t have to start from scratch. As a New Relic One user, you can begin accessing new dashboards and custom visualization capabilities today that give you access to a library of dashboards, third-party custom visualization capabilities, and quickstart visualizations, based on common use cases in the New Relic One Catalog and the New Relic One Dashboard API. Visualize your data from scratch or a quickstart If you would like a custom visualization, you can create smaller-scale custom widgets and pin them to a dashboard. Is there a visualization you like in a popular JavaScript charting library like D3 or Recharts? You can now use it in your custom visualization connected to the data already in the Telemetry Data Platform. Are you looking for maps, heat maps, and traffic lights to visualize your system movements? We have you covered. Sample charts you can generate using the D3 or Recharts charting library.   To make it even easier to find the template you want, you can access a Quickstarts Library, a community repository of New Relic dashboards, alerts, and installation instructions. Deploy the app in your account to quickly find the template you want and start using it in your account. Best of all? We built this all in open source, which means you can provide feedback and suggestions on use cases you’re looking to solve. Create an issue or send a pull request—we’re building this library for you and your needs. Sample cloud migration quickstart. Extend capabilities with the dashboards API and customizations UI New Relic One dashboards provide custom visualizations that can be automated through templates and a full dashboard CRUD API, with custom chart widgets built with React.js, the ability to pull in third-party library widgets, and a library of templates to get started fast—and all of it in open source. With the recent customization updates, you can now quickly add widgets directly to dashboards simply by clicking “add to dashboards” in the Query Builder. You can also customize existing widgets to display data as you need it: Number and time formatter: Define decimals (e.g., number of 9s in your SLO) and formatting your dates and timestamps (e.g., US format or EU format) Customize y-axis: You can now define how you want your y-axis to behave by setting it to a specific value and ignore outliers Customize y-axis min/max   Format date and time to fit your needs.   Format numbers to appropriate decimal places for more precision.   As a busy engineer, reducing toil is a must. You can use the API to deploy a standard set of dashboards for every new service you create. And if you need inspiration, a large inventory of pre-built custom dashboards reflect observability best practices. You’ll find a range of subject areas, including infrastructure monitoring, cloud, browser, and mobile monitoring. Let’s build together We designed these new capabilities to help you innovate. We’re continuously listening to your feedback and adding more templates, resources, and visualizations to our libraries. Because we’re invested in working in the “open source way” and providing you transparency, our visualization builder pulls from the open source ecosystem, so you can visualize data in any way that you prefer. If you have feedback or suggestions, please feel free to submit it through New Relic One. We’re building an extensive library and we encourage you to join us. Check out developer.newrelic.com to learn more. By Sebastian Galiano Molina Sebastian Galiano Molina is a Senior Product Manager Data Visualization, Data Exploration and Dashboards at New Relic, based in Barcelona. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.86401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Dashboards and <em>Custom</em> <em>Visualizations</em>: Flexibility with Less Toil",
        "sections": "<em>Visualize</em> <em>your</em> data from scratch or a quickstart",
        "body": " cases in the New Relic One Catalog and the New Relic One Dashboard API. Visualize <em>your</em> data from scratch or a quickstart If you would like a <em>custom</em> <em>visualization</em>, you can create smaller-scale <em>custom</em> widgets and pin them to a dashboard. Is there a <em>visualization</em> you like in a popular JavaScript charting"
      },
      "id": "60762965196a677f8464a77b"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-03/Fee_No%C4%8Dnica-01.png?h=a01e8acb&itok=UlU_gNqe",
      "url": "https://newrelic.com/blog/nerdlog/nerdlog-aiops-and-custom-dashboards",
      "sections": [
        "Finding anomalies with New Relic AIOps",
        "Using AI to find correlated failures",
        "Smart alert muting on New Relic",
        "Custom data visualizations",
        "Related Topics"
      ],
      "published_at": "2021-04-13T23:23:32Z",
      "title": "Nerdlog Roundup: AIOps and Customizing Your Data",
      "updated_at": "2021-04-13T23:23:32Z",
      "type": "",
      "external_id": "f02fd7a53ed1069f0c126104e26c67a25f1d3371",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit AIOps Nerdlog Roundup: AIOps and Customizing Your Data Mar 4, 2021 • 4 min read By Nočnica Fee Technology changes fast, and that’s doubly true when your business is adding observability to technology. That’s why we make the Nerdlog. Follow us on Twitch and tune in every Thursday at noon PT (8 p.m. UTC) to learn about the latest New Relic observability features from the product managers and engineers who built them. You can get step-by-step tutorials, give feedback, and ask questions live. If you missed last week’s Nerdlog episode 3, check out the recap below. Finding anomalies with New Relic AIOps Throughout the day, lots of New Relic users put up anomaly detection to keep a general eye on the state of their system overall. In a quick demo, Devin shows how our anomalies feed can help give you a great overview of what’s happening within your system. You can slice and dice your anomalies by category, app name, time, configuration (groups of apps that you’ve configured to be monitored by Proactive Detection), and state. These capabilities are super powerful. By default, the detected anomalies are available within the New Relic interface. You can also send notifications to many integrations. For example, users like to send notifications to a private Slack channel to preview how anomaly detection would notify their teams as they configure the tool. Using AI to find correlated failures Managing alerts remains a challenge for teams as they grow. Nate Heinrich has been working for the last few months to improve the Incident Intelligence system within Applied Intelligence, an AIOps-assisted tool for showing how your alerts connect. Correlation is a fancy term for “things happening around the same time.” With these tools, you can use automation to find correlations, and configure correlations based on  your services’ attributes. This capability makes it easy to see things like “show me patterns from our services that are part of the infrastructure team” or “show me data that covers enterprise customers.” The correlation preview shows how multiple events would be correlated in future incidents. Toward the end of the segment, Nate ponders the future of AIOps: no system will get to full automation and diagnose every problem. But in the future, tools like Applied Intelligence will use their broad scope of data to give better and better clues, test hypotheses automatically, and make things easier for humans. Smart alert muting on New Relic It’s funny to get excited about muting, but Brian Goleno, a product manager in our Applied Intelligence group, makes a clear case for it: “Very often, teams have planned maintenance, or regular long-running jobs, that they know will trigger alerts that shouldn’t wake anyone up,” says Brian. Muting lets you set criteria, including a time window, for muting alerts and notifications. You can filter by tags or other attributes, finding only those violations that shouldn’t trigger alerts. Alerting doesn’t mean disabling monitoring: while this tool will stamp incidents with muted = true, they’ll still be visible in Applied Intelligence. This is helpful if an engineer is wondering why the service is down during maintenance: she can still see the Applied Intelligence notification, without getting paged for downtime during maintenance. Watch to see Brian go deep on giving your on-call engineers peace and quiet. Custom data visualizations Jewels Nocera, senior software engineer and fashion icon, shares how you can build custom New Relic One visualizations with our programmability tools. Starting with customizing dashboard charts, she shows how to add and remove attributes, scale charts, and otherwise tweak pre-made visualizations to make dashboards more readable. I’ve written before that your time to resolution is directly related to how easy it is to read your dashboard. The ability to carefully scale, scope, and control custom dashboards can improve by those critical minutes. In the second half of the segment, Jewels shows how our new feature for custom visualizations lets you fully customize the way your data is displayed. With a local development environment, you can build complete visualizations using your real New Relic data. Even better, you can create a configuration for your custom visualization. Other users within your team don’t have to update your code, but can use visual configuration toggles just like they do with custom dashboards. Related Topics AIOps By Nočnica Fee Nočnica Fee is a Dev Advocate for New Relic specializing in serverless. She's a frequent contributor to The New Stack and Dev.to. In her downtime, she enjoys drum machines and woodworking. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.73543,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Nerdlog Roundup: AIOps and <em>Customizing</em> <em>Your</em> Data",
        "sections": "<em>Custom</em> data <em>visualizations</em>",
        "body": " is displayed. With a local development environment, you can build complete visualizations using <em>your</em> real New Relic data. Even better, you can create a configuration for <em>your</em> <em>custom</em> <em>visualization</em>. Other users within <em>your</em> team don’t have to update <em>your</em> code, but can use <em>visual</em> configuration toggles just like"
      },
      "id": "607627f464441f73919d8566"
    }
  ]
}