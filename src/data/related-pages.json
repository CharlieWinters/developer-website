{
  "/build-apps/add-time-picker-guide": [
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/embed/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "58de68bd963cdd2062e88db55cb90ad124055eb6",
      "popularity": 1,
      "body": "In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform's URL state. This context contains an important value you'll use in your app, called timeRange. Notice that your NrqlQuery uses a SINCE clause that identifies the historical timeframe your query should fetch data from. Right now, that SINCE clause is set to 30 MINUTES AGO. With timeRange, you can use the platform's time picker to make this timeframe adjustable. Step 4 of 10 Utilize the platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-platform-state-context/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery now uses the platform state's timeRange, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your Nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.71713,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>PlatformStateContext</em> to your Nerdlet",
        "body": " of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform&#x27;s URL state. This context contains an important value you&#x27;ll use in your <em>app</em>, called <em>time</em>Range. Notice that your NrqlQuery"
      },
      "id": "6073000164441f84ce9d853d"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application and click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.17717,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "In the last lesson, you used <em>PlatformStateContext</em> from the New Relic One SDK to look up the <em>time</em> range that the user selected from the <em>app</em>&#x27;s <em>time</em> <em>picker</em>. Now, you&#x27;ll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities"
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "image": "https://developer.newrelic.com/static/7f679da4c4ffce5fa547a04b27ac700d/0086b/add-timepicker.png",
      "url": "https://developer.newrelic.com/build-apps/add-time-picker-guide/embed/",
      "sections": [
        "Add a time picker",
        "Before you begin",
        "Important",
        "Prepare the time picker sample code",
        "Import the PlatformStateContext component",
        "Add the time to the queries",
        "Summary"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "852014728d86d0fcfc4345d6402f7533d9ca5e2e",
      "popularity": 1,
      "body": "This guide steps you through the process of adding access to our time picker in the sample transaction overview application. The sample application provides an overview of the telemetry data showing your account's transactions by application, average response time, HTTP response codes, and transaction errors. When you enable the time picker, users can specify the time range of data to view. We also have a 12 minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1–4 of the CLI quick start. In step 1, be sure to make a copy of the number preceding your account name. This is your accound ID, and you’ll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the time picker sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 7 If you haven't already done so, clone the example applications from our how-to GitHub repo. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 7 Change to the directory nr1-howto-add-time-picker-nerdlet: bash Copy $ cd nr1-how-to/add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet Step 3 of 7 In your preferred text editor, open index.js. Step 4 of 7 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 7 Change to the add-time-picker directory: bash Copy $ cd /nr1-how-to/add-time-picker Step 6 of 7 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 7 of 7 Once the sample application is successfully served, go to the local version of New Relic One (https://one.newrelic.com/?nerdpacks=local) click Apps, and click Add Time Picker. After launching the Add Time Picker application, you see a dashboard that gives an overview of the transactions in your New Relic account: By default, the application shows your data within the last 60 minutes. If you toggle the time picker, it doesn't update the charts because the transaction overview application isn't connected to the New Relic One platform. It has no access to the data from the time picker. In the following sections, you'll add the time picker to the example application and add the time to the queries. Import the PlatformStateContext component The first step in adding the time picker is to import the PlatformStateContext component. Important If you need more details about the PlatformStateContext example that follows, see the APIs and components page Here's what the PlatformStateContext component does: Wraps all of the code within the return statement of the render method Makes a function call passing in the New Relic platform state Returns all of the code within our current return statement Complete these steps: Step 1 of 5 In a text editor, open /add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet/index.js. Step 2 of 5 Add the PlatformStateContext component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, PlatformStateContext, } from 'nr1'; Copy Step 3 of 5 Just below the current return insert this code for the PlatformStateContext component: <PlatformStateContext.Consumer> {(platformState) => { return ( // ADD THE CURRENT RETURN CODE HERE ) }} </PlatformStateContext.Consumer> Copy Step 4 of 5 Move the current application code so it is under the return of the PlatformState function call. The return statement should now look like this: return ( <PlatformStateContext.Consumer> {(PlatformState) => { return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); Copy Step 5 of 5 Add a console.log statement to make sure you are seeing appropriate data. Insert the following code inside the PlatformState return statement just before the opening tag for the <Grid> component: /* Taking a peek at the PlatformState */ console.log(PlatformState); Copy After you complete these steps, your browser console displays something like this: Add the time to the queries In your console, you should see some data from the New Relic platform state. Now you're ready to add timeRange data to update the charts in the transaction overview application. This step requires you to import the timeRangeToNrql utility method from the New Relic One community library. Important You can get more details on the New Relic One community library from our GitHub repo. This helper method takes your PlatformState.timeRange duration data, formats it from milliseconds, and returns a formatted SINCE statement to add to your NRQL. Step 1 of 4 Import the timeRangeToNrql method by inserting this line of code below the other import sections: Important You don't need to include the AccountDropdown from the community import example. import { timeRangeToNrql } from '@newrelic/nr1-community'; Copy Step 2 of 4 Pass the PlatformState to the timeRangeToNrql helper, and save its output as a since statement for later use: const since = timeRangeToNrql(PlatformState); Copy Step 3 of 4 After creating the since variable, go through the code in the PlatformStateContext return statement and concatenate the since variable in each of the existing chart component queries. Here's a TableChart example: <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} />; Copy Step 4 of 4 After you update all of the chart components, confirm that the final index.js file looks similar to this: Important This completed sample code is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, } from 'nr1'; import { timeRangeToNrql } from '@newrelic/nr1-community'; export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props) { super(props); this.accountId = 1; } render() { const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <PlatformStateContext.Consumer> {(PlatformState) => { /* Taking a peek at the PlatformState */ console.log(PlatformState); const since = timeRangeToNrql(PlatformState); console.log(since); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount + since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); } } Copy Summary When you completed all the steps in this example, you successfully implemented the time picker in your application by importing the PlatformStateContext component and accessing its timePicker data object.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.47531,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add a <em>time</em> <em>picker</em>",
        "body": ", you&#x27;ll add the <em>time</em> <em>picker</em> to the example application and add the <em>time</em> to the queries. Import the <em>PlatformStateContext</em> component The first step in adding the <em>time</em> <em>picker</em> is to import the <em>PlatformStateContext</em> component. Important If you need more details about the <em>PlatformStateContext</em> example"
      },
      "id": "6063d5f464441fcf580c8bbd"
    },
    {
      "image": "https://developer.newrelic.com/static/futurestack-registration-86e612c0605fb3c49cfd28f35977135d.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Futurestack: Master Observability",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-04-16T01:37:39Z",
      "title": "New Relic Developers",
      "updated_at": "2021-04-16T01:37:39Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Data Nerds, get ready to hack the future. Level Up your observability game at Futurestack 2021. Rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 29 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.24332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an <em>app</em> to show page view data on a map Add a <em>time</em> <em>picker</em> to your <em>app</em> 20 min Add a <em>time</em> <em>picker</em> to a sample application Add custom attributes   Use custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-16T02:10:56Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.1749,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ": <em>PlatformStateContext</em>: provides read access to the platform URL state variables. Example: <em>time</em>Range in the <em>time</em> <em>picker</em>. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state."
      },
      "id": "60652884196a67886047e800"
    }
  ],
  "/automate-workflows/5-mins-tag-resources": [
    {
      "image": "https://developer.newrelic.com/static/futurestack-registration-86e612c0605fb3c49cfd28f35977135d.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Futurestack: Master Observability",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-04-16T01:37:39Z",
      "title": "New Relic Developers",
      "updated_at": "2021-04-16T01:37:39Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Data Nerds, get ready to hack the future. Level Up your observability game at Futurestack 2021. Rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 29 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.48117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/embed/",
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:07:54Z",
      "title": "",
      "updated_at": "2021-04-04T01:53:18Z",
      "type": "",
      "external_id": "ddf0ca28ab311ff372e8955f2ef022de99716131",
      "popularity": 1,
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.57402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " application. You should copy it or write it down. Step 6 of 10 Add a simple <em>tag</em> to your application. Now that you have the GUID, you can point the <em>New</em> <em>Relic</em> <em>CLI</em> directly at your application. Adding a <em>tag</em> is the simplest way to try out the <em>CLI</em> capabilities (don&#x27;t worry, <em>tags</em> can be deleted by using"
      },
      "id": "60691c0ee7b9d2f79094463b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/embed/",
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:07:53Z",
      "title": "",
      "updated_at": "2021-04-02T01:54:45Z",
      "type": "",
      "external_id": "c42a52759fcbe676670d61e60c9aa5e269edcccd",
      "popularity": 1,
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.86526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": "<em>Tags</em> help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the <em>New</em> <em>Relic</em> <em>CLI</em> is a good candidate for automation. In this 5-minute guide, you use the <em>New</em> <em>Relic</em> <em>CLI</em> to add multiple <em>tags</em> to one"
      },
      "id": "60667965196a67a9c347e810"
    },
    {
      "sections": [
        "newrelic_get_browser_timing_header (PHP agent API)",
        "Syntax",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples",
        "Instrument a webpage",
        "For more help"
      ],
      "title": "newrelic_get_browser_timing_header (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "949a5fff6610beee2a4d4f1d7bbe3286e7438903",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_get_browser_timing_header/",
      "published_at": "2021-04-16T06:57:40Z",
      "updated_at": "2021-04-16T06:57:40Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_get_browser_timing_header([bool $include_tags]) Copy Returns a browser monitoring snippet to inject in the head of your HTML output. Description Returns a JavaScript string to inject in the <head> of your HTML output. Use this call with newrelic_get_browser_timing_footer to manually add browser monitoring to a webpage. If possible, New Relic recommends instead enabling browser monitoring via the New Relic UI or copy/pasting the JavaScript snippet. For instructions on using these options, see browser monitoring and PHP. Tip Compare newrelic_disable_autorum, which disables the browser script on a page. Parameters Parameter Description $include_tags data type Optional. Defaults to true. If true or omitted, the JavaScript string is enclosed in a <script> element for easy inclusion into the page's HTML. Return values Returns the browser agent's JavaScript header string. Examples Instrument a webpage function example(){ if (extension_loaded('newrelic')) { // Ensure PHP agent is available $newrelic_header = newrelic_get_browser_timing_header(); } ... // Output to page if (extension_loaded('newrelic')) { // Ensure PHP agent is available $newrelic_footer = newrelic_get_browser_timing_footer(); } } Copy For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.78802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>newrelic_get_browser_timing_header</em> (PHP agent API)",
        "sections": "<em>newrelic_get_browser_timing_header</em> (PHP agent API)",
        "body": " add browser monitoring to a webpage. If possible, <em>New</em> <em>Relic</em> recommends instead enabling browser monitoring via the <em>New</em> <em>Relic</em> UI or copy&#x2F;pasting the JavaScript snippet. For instructions on using these options, see browser monitoring and PHP. Tip Compare newrelic_disable_autorum, which disables"
      },
      "id": "603e9fbbe7b9d27bb52a080b"
    },
    {
      "sections": [
        "newrelic_get_browser_timing_footer (PHP agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples",
        "Instrument a webpage",
        "For more help"
      ],
      "title": "newrelic_get_browser_timing_footer (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "0eadf6444b46c63ed8cf96527e1f210cd854fec9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_get_browser_timing_footer/",
      "published_at": "2021-04-16T06:57:41Z",
      "updated_at": "2021-04-16T06:57:40Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_get_browser_timing_footer([bool $include_tags]) Copy Returns a browser monitoring snippet to inject at the end of the HTML output. Requirements Compatible with all agent versions. Description Returns a JavaScript string to inject at the very end of the HTML output. Use this call with newrelic_get_browser_timing_header() to manually add browser monitoring to a webpage. If possible, New Relic recommends instead enabling browser monitoring via the New Relic UI or copy/pasting the JavaScript snippet. For instructions on using these options, see Browser monitoring and the PHP agent. Tip Compare newrelic_disable_autorum(), which disables the browser monitoring script on a page. Parameters Parameter Description $include_tags boolean Optional. Defaults to true. If true or omitted, the string is enclosed in a <script> element for easy inclusion in the page's HTML. Return values Returns the browser monitoring JavaScript footer string. Examples Instrument a webpage function example(){ if (extension_loaded('newrelic')) { // Ensure PHP agent is available $newrelic_header = newrelic_get_browser_timing_header(); } ... // Output to page if (extension_loaded('newrelic')) { // Ensure PHP agent is available $newrelic_footer = newrelic_get_browser_timing_footer(); } } Copy For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.78802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>newrelic_get_browser_timing_footer</em> (PHP agent API)",
        "sections": "<em>newrelic_get_browser_timing_footer</em> (PHP agent API)",
        "body": " with newrelic_get_browser_timing_header() to manually add browser monitoring to a webpage. If possible, <em>New</em> <em>Relic</em> recommends instead enabling browser monitoring via the <em>New</em> <em>Relic</em> UI or copy&#x2F;pasting the JavaScript snippet. For instructions on using these options, see Browser monitoring and the PHP agent"
      },
      "id": "603eb61928ccbcb895eba792"
    }
  ],
  "/terms": [
    {
      "image": "https://newrelic.com/sites/default/files/styles/og_image/public/2021-03/OG_futurestack.png?h=2240b8e9&itok=0hjut0k7",
      "url": "https://newrelic.com/futurestack",
      "sections": [
        "FutureStack 2021",
        "Register Now to Win Big",
        "Master Observability. Level Up Your Game.",
        "1 Worldwide Event",
        "50 Sessions",
        "2 Keynotes",
        "12 Workshops",
        "Data Nerds, get ready to hack the future",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-16T04:19:54Z",
      "title": "FutureStack | New Relic",
      "updated_at": "2021-04-14T01:38:52Z",
      "type": "",
      "external_id": "050e730cc61f8ae8d1ed88c6505dde5a804a1835",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item FutureStack 2021 Virtually Everywhere Online | May 25 - 27, 2021 Register Register Now to Win Big We're leveling up FutureStack registration with swag, only until 4/30. Be one of the first 1,500 to register to qualify. Terms and conditions apply. Register Now Master Observability. Level Up Your Game. Get ready to rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. 1 Worldwide Event F2P anywhere with online sessions, workshops, and fun. 50 Sessions Get inside Observability cheat codes from Nerd visionaries. 2 Keynotes See live from both Hemispheres, or on-demand recording. 12 Workshops Build your skills with hands-on, tech deep dives to level-up fast. Data Nerds, get ready to hack the future Level Up your observability game at FutureStack 2021. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 502.68237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " FutureStack registration with swag, only until 4&#x2F;30. Be one of the first 1,500 to register to qualify. <em>Terms</em> and <em>conditions</em> apply. Register Now Master Observability. Level Up Your Game. Get ready to rack up your experience points with new tools, new skills, and whole new ways to play with your data"
      },
      "id": "5b34447a0755236b91a8591a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/Natalie_Serrino%20FS21.jpg?h=2e0f227d&itok=xI5aRyVf",
      "url": "https://newrelic.com/futurestack/speakers/natalie-serrino",
      "sections": [
        "Natalie Serrino",
        "Sessions with Natalie Serrino",
        "Kubernetes-Native Observability Without Instrumentation",
        "Meet Our Speakers",
        "Paras Wadehra",
        "Jonathan Karon",
        "Dan Rufener",
        "Jonathan Thurman",
        "JD Weiner",
        "Aaron Judy",
        "Scot Gorman",
        "Anthony Pounds-Cornish",
        "Jemiah Sius",
        "Danny Roessner",
        "Sam Aaron",
        "Matt Shandera",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-16T04:26:28Z",
      "title": "Natalie Serrino | New Relic",
      "updated_at": "2021-04-16T04:26:28Z",
      "type": "",
      "external_id": "b07751ac88fb8968451d9e1aed356d4ff8b4e0e6",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Natalie Serrino Principal Software Engineer, New Relic Sessions with Natalie Serrino 10:15 am - 11:15 am PT | Wednesday, May 26 | Hands-on Workshop Kubernetes-Native Observability Without Instrumentation Learn how to get visibility into your Kubernetes cluster and apps with no-instrumentation data collection, allowing you to debug in minutes. No need to update, recompile, or deploy your apps - it just works. (Join this session for live chat OR watch on-demand immediately after) Meet Our Speakers Paras Wadehra New Relic Learn more Jonathan Karon New Relic Learn more Dan Rufener New Relic Learn more Jonathan Thurman New Relic Learn more JD Weiner Forbes Media LLC Learn more Aaron Judy Maricopa County Clerk of the Superior Court Learn more Scot Gorman Chegg Learn more Anthony Pounds-Cornish Cognitran Learn more Jemiah Sius New Relic Learn more Danny Roessner WellSky Learn more Sam Aaron Sonic Pi Learn more Matt Shandera New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 486.8321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "6042d15ce7b9d2c6cc579a0e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-04/Yopes_Thomas_Headshot.jpg?h=0f3f3a77&itok=x4unEit0",
      "url": "https://newrelic.com/futurestack/speakers/thomas-yopes",
      "sections": [
        "Thomas Yopes",
        "Sessions with Thomas Yopes",
        "New Relic: Startup Observability No-brainer and Stepping Stone To Cloud Unit Costs",
        "Meet Our Speakers",
        "Sandeep Parmar",
        "Dave Soloway",
        "Rishi Mukhopadhyay",
        "Andy Baio",
        "Bill Staples",
        "Joanna Leidy",
        "Phil Weber",
        "Nočnica Fee",
        "Lew Cirne",
        "Naveen Chittoor",
        "Henry Jewkes",
        "Jonan Scheffler",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-16T04:26:11Z",
      "title": "Thomas Yopes | New Relic",
      "updated_at": "2021-04-16T04:26:11Z",
      "type": "",
      "external_id": "a35f4e0695700f830c2076e4459c25559edd931d",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Thomas Yopes Co-Founder, cloudthread Sessions with Thomas Yopes 10:35 am - 10:55 am PT | Thursday, May 27 | Snackable New Relic: Startup Observability No-brainer and Stepping Stone To Cloud Unit Costs Early stage startups have unique needs and constraints when it comes to choosing an observability platform - we’re excited to share Cloudthread’s path to choosing New Relic. Furthermore, while New Relic facilitates our internal application monitoring, it's also a fundamental part of our analytics platform, unlocking cloud unit costs for our customers and empowering cost conscious engineering teams. (Join this session for live chat OR watch on-demand immediately after) Meet Our Speakers Sandeep Parmar New Relic Learn more Dave Soloway Blackhawk Network Learn more Rishi Mukhopadhyay New Relic Learn more Andy Baio Skittish Learn more Bill Staples New Relic Learn more Joanna Leidy New Relic Learn more Phil Weber New Relic Learn more Nočnica Fee New Relic Learn more Lew Cirne New Relic Learn more Naveen Chittoor Cox Communications Inc Learn more Henry Jewkes Split.io Learn more Jonan Scheffler New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 486.82504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "New Relic: Startup Observability No-brainer <em>and</em> Stepping Stone To Cloud Unit Costs",
        "body": " with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "607311a8e7b9d24171a5c681"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-04/Goleno_Brian.jpg?h=d37e06c6&itok=h3DuMtiZ",
      "url": "https://newrelic.com/futurestack/speakers/brian-goleno",
      "sections": [
        "Brian Goleno",
        "Meet Our Speakers",
        "Henry Jewkes",
        "Samer Rashdan",
        "Natalie Serrino",
        "Matt Shandera",
        "Thomas Yopes",
        "Dan Rufener",
        "Dave Soloway",
        "Rishi Mukhopadhyay",
        "Sagar Thirumala",
        "Matthew Culmone",
        "Phil Weber",
        "Aaron Judy",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-15T22:36:10Z",
      "title": "Brian Goleno | New Relic",
      "updated_at": "2021-04-15T22:36:10Z",
      "type": "",
      "external_id": "247b4a7212b56a6848ceef01ab1b899192df7e7f",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Brian Goleno Sr. Product Manager, AIOps, New Relic Brian Goleno is a Most Supreme Product Manager in New Relic’s Applied Intelligence team. With a current focus on incident detection, he is maniacally focused on improving the quality of life for our brothers and sisters who sacrifice their evenings and weekends to keep our techno-fabulous world running. Brian has been around the high scale Internet services block for quite some time. As a product manager for the last decade, he has been building tools to help developers build and scale Internet experiences at Akamai, Sumo Logic, and now New Relic. Before becoming a product manager, he served several tours of duty in various Internet consulting firms that no longer exist, and transitioning out of consulting as an enterprise architect for Macys.com. Meet Our Speakers Henry Jewkes Split.io Learn more Samer Rashdan Pearson Education Learn more Natalie Serrino New Relic Learn more Matt Shandera New Relic Learn more Thomas Yopes cloudthread Learn more Dan Rufener New Relic Learn more Dave Soloway Blackhawk Network Learn more Rishi Mukhopadhyay New Relic Learn more Sagar Thirumala Cox Communications Inc Learn more Matthew Culmone New Relic Learn more Phil Weber New Relic Learn more Aaron Judy Maricopa County Clerk of the Superior Court Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 478.3718,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "6078bfda64441fe05f9d8584"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-04/Haus_Ev_Headshot.jpeg?h=171b3bca&itok=ezwneaB4",
      "url": "https://newrelic.com/futurestack/speakers/ev-haus",
      "sections": [
        "Ev Haus",
        "Sessions with Ev Haus",
        "Using New Relic to Segment Data by User Activity",
        "Meet Our Speakers",
        "Naveen Chittoor",
        "Simon Wistow",
        "Brian Goleno",
        "Nicole van der Hoeven",
        "Jonathan Thurman",
        "Sandeep Parmar",
        "Sergio Rabiela",
        "Matt Shandera",
        "Bashayir Said",
        "Eugene Kovshilovsky",
        "Daniele Packard",
        "Nilson Pontello",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-15T22:34:29Z",
      "title": "Ev Haus | New Relic",
      "updated_at": "2021-04-15T22:34:29Z",
      "type": "",
      "external_id": "364a85e1828d0770428ac2e0331dc3893555cefe",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Ev Haus Head Of Technology at ZenHub, ZenHub Sessions with Ev Haus 11:35 am - 11:55 am PT | Thursday, May 27 | Snackable Using New Relic to Segment Data by User Activity The engineering team at ZenHub recently experienced a slew of abnormal spikes in errors during off-peak times. Follow Ev on this short journey to understand the reasons behind the problem, and how the team was able to use New Relic to segment the monitoring data based on the activity of users on the platform. This is a technical deep dive into using New Relic as a tool for troubleshooting real-world production problems. Meet Our Speakers Naveen Chittoor Cox Communications Inc Learn more Simon Wistow Fastly Learn more Brian Goleno New Relic Learn more Nicole van der Hoeven k6.io Learn more Jonathan Thurman New Relic Learn more Sandeep Parmar New Relic Learn more Sergio Rabiela Beyond Finance, Inc Learn more Matt Shandera New Relic Learn more Bashayir Said New Relic Learn more Eugene Kovshilovsky CarParts.com Learn more Daniele Packard cloudthread Learn more Nilson Pontello Banco Inter Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 478.33237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "606a934ce7b9d23b099445ea"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "sections": [
        "newrelic_add_custom_span_parameter (PHP agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Report a variable as the value",
        "For more help"
      ],
      "title": "newrelic_add_custom_span_parameter (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "48cad5c438588b2bd11a248848423ac96751d13d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelicaddcustomspanparameter-php-agent-api/",
      "published_at": "2021-04-16T07:05:55Z",
      "updated_at": "2021-04-16T07:05:55Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_add_custom_span_parameter(string $key, scalar $value) Copy Attaches a custom attribute (key/value pair) to the current span. Requirements Agent version 9.12.0.268 or higher. Description Add a custom attribute (a key and a value data pair) to the current span. (The call name is newrelic_add_custom_span_parameter because \"custom attributes\" were previously called \"custom parameters.\") For example, you can add a customer's full name from your customer database. This attribute appears in any span. You can also query the Span for your custom attributes. Important On spans, attributes added with newrelic_add_custom_span_parameter will take precedence over attributes added with newrelic_add_custom_parameter. Important If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL. Parameters Parameter Description $key string Required. The name of the custom attribute. Only the first 255 characters are retained. $value scalar Required. The value to associate with this custom attribute. If the value given is a float with a value of NaN, Infinity, denorm or negative zero, the behavior of this function is undefined. For other floating point values, the agent may discard 1 or more bits of precision (ULPs) from the given value. Return values Returns true if the parameter was added successfully. Examples Report a variable as the value ... if (extension_loaded('newrelic')) { // Ensure PHP agent is available // Record custom data about this web transaction newrelic_add_custom_span_parameter ('user_email', $user_email); } ... Copy - -> For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.67146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", <em>attributes</em> added with newrelic_add_<em>custom</em>_span_parameter will take precedence over <em>attributes</em> added with newrelic_add_<em>custom</em>_parameter. Important If you want to use your <em>custom</em> <em>attributes</em>, avoid using any of the reserved terms used by <em>NRQL</em>. Parameters Parameter Description $key string Required. The name"
      },
      "id": "603e97c364441f09bb4e8895"
    },
    {
      "sections": [
        "newrelic_add_custom_parameter (PHP agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Report a variable as the value",
        "For more help"
      ],
      "title": "newrelic_add_custom_parameter (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "9f562ac35bc082317e33be4164651edf38016ccd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_parameter/",
      "published_at": "2021-04-16T06:04:54Z",
      "updated_at": "2021-04-16T06:04:54Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_add_custom_parameter(string $key, scalar $value) Copy Attaches a custom attribute (key/value pair) to the current transaction and the current span (if enabled). Requirements Agent version 4.4.5.35 or higher. Description Add a custom attribute (a key and a value data pair) to the current web transaction. (The call name is newrelic_add_custom_parameter because \"custom attributes\" were previously called \"custom parameters.\") For example, you can add a customer's full name from your customer database. This attribute appears in any transaction trace that results from this transaction. You can also query the Transaction event for your custom attributes. Important Security recommendation—Review your Transaction attributes configuration. Any attribute include or exclude settings specific to Transaction events, should be applied to your Span attributes configuration or your Global Attributes configuration. Important If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL. Parameters Parameter Description $key string Required. The name of the custom attribute. Only the first 255 characters are retained. $value scalar Required. The value to associate with this custom attribute. If the value given is a float with a value of NaN, Infinity, denorm or negative zero, the behavior of this function is undefined. For other floating point values, the agent may discard 1 or more bits of precision (ULPs) from the given value. Return values Returns true if the parameter was added successfully. Examples Report a variable as the value ... if (extension_loaded('newrelic')) { // Ensure PHP agent is available // Record custom data about this web transaction newrelic_add_custom_parameter ('user_email', $user_email); } ... Copy - -> For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.39061,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Global <em>Attributes</em> configuration. Important If you want to use your <em>custom</em> <em>attributes</em>, avoid using any of the reserved terms used by <em>NRQL</em>. Parameters Parameter Description $key string Required. The name of the <em>custom</em> attribute. Only the first 255 characters are retained. $value scalar Required. The value"
      },
      "id": "6043c95064441f61fd378eef"
    },
    {
      "sections": [
        "Guide to using the PHP agent API",
        "Tip",
        "Notice or ignore errors",
        "Enhance the metadata of a transaction",
        "Name reporting app",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Instrument asynchronous work",
        "Send custom event and metric data from your app",
        "Instrument calls to external services",
        "Monitor specific browser pages",
        "For more help"
      ],
      "title": "Guide to using the PHP agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "API guides"
      ],
      "external_id": "c1e218a22dcfaec484847c97b50bc452b6155a5a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/api-guides/guide-using-php-agent-api/",
      "published_at": "2021-04-16T09:19:32Z",
      "updated_at": "2021-04-16T09:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's PHP agent provides an API for customizing agent behavior. The agent automatically instruments many popular PHP frameworks, but you can use the PHP API to instrument activity that the agent doesn't already instrument by default. This guide describes PHP API calls for several common tasks; for example: Notice or ignore specific errors. Name a transaction. Rename the application reporting the data. Tip You can also set many of these options per directory or in newrelic.ini. If setting via API, the API takes precedence over the other methods. Notice or ignore errors Usually, the agent detects errors automatically. However, you can manually mark an error with the agent. If you want to... Do this... Report an error the agent does not report automatically See newrelic_notice_error(). Ignore an error Edit error_collector.ignore_exceptions or error_collector.ignore_errors in thenewrelic.ini file. Enhance the metadata of a transaction Sometimes the code you target is visible in New Relic, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add custom attributes to your transactions or spans so you can filter them with NRQL queries. Use these methods when you want to change how New Relic instruments a transaction that's already visible in New Relic: If you want to... Do this... Change the name of a transaction See newrelic_name_transaction(). Add metadata (such as your customer's account name or subscription level) to your transactions or spans Use custom attributes. For custom attributes which will be added to transactions and spans (if enabled), see newrelic_add_custom_parameter(). For custom attributes which will be added only to spans, see newrelic_add_custom_span_parameter(). Mark a transaction as a background job See newrelic_background_job(). Prevent a transaction from affecting your Apdex score See newrelic_ignore_apdex(). Name reporting app The New Relic UI organizes data by how you name your application. Each name appears as a different app. You can rename the reporting app for any part of your code to better help you: Organize and analyze your data on New Relic UI pages (for example, APM's Applications index page, the Summary page, the Transactions page, etc.). Query your data. Create alert policies. This is especially useful if you have a multi-site application or distinct sets of application code using the same PHP installation. Alternatively, you can set the app name at a higher level instead via the newrelic.appname config value, via Apache, or via PHP-FPM. If you want to... Do this... Rename the reporting app for a specific part of your code Set the app name. See newrelic_set_appname(). Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. For more information about transactions, see transaction and transaction trace. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Start timing a method New Relic is not instrumenting automatically Start a transaction. See newrelic_start_transaction(). Stop timing a method after its work is completed Stop a transaction. See newrelic_end_transaction(). Prevent a transaction from reporting to New Relic Ignore the transaction. See newrelic_ignore_transaction(). Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. Use this methods when you want to instrument a method within an existing transaction: If you want to... Do this... Time a particular method See newrelic_add_custom_tracer(). Instrument asynchronous work The only async work the PHP agent instruments is Guzzle, which is instrumented by default. Send custom event and metric data from your app New Relic includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in New Relic Create a custom event. See Insert custom events via APM agent (PHP). Tag your events with metadata to filter and facet them Add custom attributes. See newrelic_add_custom_parameter(). Report custom performance data Create a custom metric. See newrelic_custom_metric(). Instrument calls to external services Use these methods to collect data about your app's connections to other apps or datastores: If you want to... Do this... Time a call to a datastore not instrumented by default See newrelic_record_datastore_segment(). See the path that a request takes as it travels through a distributed system For PHP agent versions lower than 9.8, see these API calls: newrelic_create_distributed_trace_payload() newrelic_accept_distributed_trace_payload() newrelic_accept_distributed_trace_payload_httpsafe() For PHP agent versions 9.8 or higher, see these API calls: newrelic_insert_distributed_trace_headers() newrelic_accept_distributed_trace_headers() For examples, see the documentation to manually instrument distributed tracing. Monitor specific browser pages You can install the browser agent by automatically adding it to your pages or by deploying it on specific pages by copying and pasting our JavaScript snippet. You can also control the browser agent by using APM agent API calls. For more information, see Browser monitoring and the PHP agent. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.00131,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Send <em>custom</em> event and metric data from your app",
        "body": " in thenewrelic.ini file. Enhance the metadata of a transaction Sometimes the code you target is visible in New Relic, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add <em>custom</em> <em>attributes</em> to your transactions"
      },
      "id": "60441c1ee7b9d2aa685799c5"
    },
    {
      "sections": [
        "Node.js agent API",
        "Request names",
        "Tip",
        "Requirements",
        "Avoid metric grouping issues",
        "Guidelines",
        "URL pattern matching",
        "Load the request naming API",
        "Request API calls",
        "newrelic.setTransactionName(name)",
        "newrelic.setControllerName(name, \\[action])",
        "Custom instrumentation API calls",
        "newrelic.instrument(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentDatastore(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentLoadedModule(moduleName, moduleInstance)",
        "Important",
        "newrelic.instrumentMessages(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentWebframework(moduleName, onRequire \\[, onError])",
        "newrelic.startWebTransaction(url, handle)",
        "newrelic.startBackgroundTransaction(name, \\[group], handle)",
        "newrelic.getTransaction()",
        "newrelic.endTransaction()",
        "newrelic.startSegment(name, record, handler, callback)",
        "Custom metrics API calls",
        "newrelic.recordMetric(name, value)",
        "newrelic.incrementMetric(name, \\[amount])",
        "Custom events API calls",
        "newrelic.recordCustomEvent(eventType, attributes)",
        "Recording a custom event",
        "Transaction handle methods",
        "transactionHandle.end(\\[callback])",
        "transactionHandle.ignore()",
        "transactionHandle.insertDistributedTraceHeaders(headers)",
        "Generating distributed trace headers",
        "transactionHandle.acceptDistributedTraceHeaders(transportType, headers)",
        "Accept incoming distributed trace headers",
        "transactionHandle.createDistributedTracePayload()",
        "Caution",
        "Link a nested background transaction",
        "Place payload on an outgoing request",
        "transactionHandle.acceptDistributedTracePayload(payload)",
        "transactionHandle.isSampled()",
        "Other API calls",
        "newrelic.addCustomAttribute(name, value)",
        "Add custom attribute",
        "newrelic.addCustomAttributes(attributes)",
        "Adding custom attributes",
        "newrelic.addCustomSpanAttribute(name, value)",
        "Add custom span attribute",
        "newrelic.addCustomSpanAttributes(attributes)",
        "Add custom span attributes",
        "newrelic.getBrowserTimingHeader()",
        "newrelic.setIgnoreTransaction(ignored)",
        "newrelic.noticeError(error, \\[customParameters])",
        "newrelic.shutdown(\\[options], callback)",
        "newrelic.getLinkingMetadata()",
        "newrelic.getTraceMetadata()",
        "Rules for naming and ignoring requests",
        "rules.name",
        "Optional rules attributes [#optional-rules]",
        "Testing your naming rules [#testing-rules]",
        "Naming rule examples [#examples-rules]",
        "Match full URL",
        "Replace first match in URL",
        "Replace all matches in any URL",
        "Match group references",
        "rules.ignore",
        "Naming rule example",
        "Ignoring rule example",
        "API calls for rules",
        "newrelic.addNamingRule(pattern, name)",
        "newrelic.addIgnoringRule(pattern)"
      ],
      "title": "Node.js agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "API guides"
      ],
      "external_id": "dd0838adbfafc7e5988ed77ad3ad039cdce29ec0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/api-guides/nodejs-agent-api/",
      "published_at": "2021-04-16T05:29:42Z",
      "updated_at": "2021-04-16T05:29:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several tools to help obtain the information needed to provide useful metrics about your Node.js application. These include: Reading the route names (if used) from the Express and Restify routers Using the API to name the current request, either with simple names or groups of controllers with actions Support rules that are stored in your agent's configuration that can mark requests to be renamed or ignored based on regular expressions matched against the request's raw URLs (also available as API calls) The number of names that New Relic tracks needs to be small enough so that the user experience is robust. It also needs to be large enough to provide the right amount of information (without overwhelming you with data) so that you can identify problem spots in your applications more easily. For more information, see the Node.js agent configuration documentation and the Node.js agent API documentation on Github. Request names The Node.js agent captures the HTTP method along with a potentially parameterized path (such as /user/:id) or a regular expression (such as /^/user/([-0-9a-f]+)$/). These pieces of information become part of the request name. If you have support for slow transaction traces and have enabled capture_params in your config file, the transaction trace will also have the request's parameters and their values attached to it. If you are dissatisfied with the request names that the Node.js agent uses, you can use API calls to create more descriptive names. Tip If grouping your requests under the generic name, then /* is sufficient, and you do not need to customize your configuration file or API calls. Requirements New Relic uses request names to group requests for many charts and tables. The value of these visualizations will drop as the number of different request names increases. For example, do not include potentially dynamic data like GUIDs, numerical IDs, or timestamps in the request names you create. If your request is slow enough to generate a transaction trace, that trace will contain the original URL. If you enable parameter capture, the parameters will also be attached to the trace. Tip Avoid having more than 50 different transaction names. For example, if you have more than a couple hundred different request names, rethink your naming strategy. Avoid metric grouping issues The request naming API helps New Relic avoid problems with trying to handle too many metrics, which sometimes is referred to as \"metric explosion.\" New Relic has several strategies to deal with these issues; the most severe is simply to add offending applications to your deny list. The main reason for you to be careful in using these request-naming tools is to prevent that from happening to your applications. For more information, see Metric grouping issues. Guidelines Define your configuration rules from the most specific to the most general. The first rules listed in your config file or added with the Node.js transaction naming API will be applied first and should be narrowly targeted. More general \"fall-through\" rules should be added toward the end of the list, because they will be evaluated in the order they were configured or added using the Node.js transaction naming API. URL pattern matching An online retailer has a URL pattern like this: /user/customers/all/prospects /user/customers/all/current /user/customers/all/returning /user/customers/John /user/customers/Jane Copy The retailer could create rules like this: // newrelic.js exports.config={ //other configuration rules:{ name:[ { pattern: \"/user/customers/all/prospects/\", name: \"/user/customers/all/prospects\" }, { pattern: \"/user/customers/all/.*\", name: \"/user/customers/all\" }, { pattern: \"/user/customers/.*\", name: \"/user/customers/:customer\" } ] } } Copy With these rules, the retailer would create three transaction names: /user/customers/:customer /user/customers/all /user/customers/all/prospects If the retailer reversed the order, the rules would catch all transactions in :customer, which would not be as useful. Load the request naming API Make sure that loading the New Relic module is the first thing your application does, as it needs to bootstrap itself before the rest of your application loads: var newrelic = require('newrelic'); Copy This returns the request naming API. You can safely require the module from multiple modules in your application, as it only initializes itself once. Request API calls Here is a summary of the Request API calls for New Relic's Node.js agent. newrelic.setTransactionName(name) newrelic.setTransactionName(name) Copy Name the current request, following the request naming requirements. You can call this function anywhere within the context of an HTTP request handler, at any time after handling of the request has started, but before the request has finished. In general, if the request and response objects are in scope, you can set the name. Explicitly calling newrelic.setTransactionName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. newrelic.setControllerName(name, \\[action]) newrelic.setControllerName(name, \\[action]) Copy Name the current request using a controller-style pattern, optionally including the current controller action. If the action is omitted, New Relic will include the HTTP method (GET, POST, etc.) as the action. The rules for when you can call newrelic.setControllerName() are the same as they are for newrelic.setTransactionName(), including the request naming requirements. Explicitly calling newrelic.setControllerName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. Custom instrumentation API calls Use these API calls to expand your instrumentation with custom instrumentation. newrelic.instrument(moduleName, onRequire \\[, onError]) newrelic.instrument(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a specific module. The provided onRequire callback will be fired when the given module is loaded with require. The moduleName parameter should be the string that will be passed to require; for example, 'express' or 'amqplib/callback_api'. The optional onError callback is called if the onRequire parameters throws an error. This is useful for debugging your instrumentation. Use this method to: Add instrumentation for modules not currently instrumented by New Relic. Instrument your own code. Replace the Node.js agent's built-in instrumentation with your own. For more information, see New Relic's Node.js instrumentation tutorial on Github. newrelic.instrumentDatastore(moduleName, onRequire \\[, onError]) newrelic.instrumentDatastore(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a datastore module. This method is just like newrelic.instrument(), except it provides a datastore-specialized shim. For more information, see New Relic's Node.js datastore instrumentation tutorial on Github. newrelic.instrumentLoadedModule(moduleName, moduleInstance) newrelic.instrumentLoadedModule(moduleName, moduleInstance) Copy The instrumentLoadedModule method allows you to add stock instrumentation to specific modules in situations where it's impossible to have require('newrelic'); as the first line of your app's main module. // load the agent const newrelic = require('newrelic') // module loaded before newrelic const expressModule = require('express') // instrument express _after_ the agent has been loaded newrelic.instrumentLoadedModule( 'express', // the module's name, as a string expressModule // the module instance ); Copy Important This method cannot instrument any arbitrary module. Its purpose is to add modules that were missed because the agent was not loaded as the first thing in your program. The instrumentLoadedModule method can only instrument modules the agent would normally instrument. You can see a list of these modules in the agent's lib/instrumentations module. newrelic.instrumentMessages(moduleName, onRequire \\[, onError]) newrelic.instrumentMessages(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a message service client module. This method is just like newrelic.instrument(), except it provides a message-service-specialized shim. For more information, see New Relic's Node.js message service instrumentation tutorial on Github. newrelic.instrumentWebframework(moduleName, onRequire \\[, onError]) newrelic.instrumentWebframework(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a web framework module. This method is just like newrelic.instrument(), except it provides a web-framework-specialized shim. For more information, see New Relic's Node.js web framework instrumentation tutorial on Github. newrelic.startWebTransaction(url, handle) newrelic.startWebTransaction(url, handle) Copy Instrument the specified web transaction. Using this API call, you can instrument transactions that New Relic does not automatically detect. The url defines the transaction name and needs to be static. Do not include variable data such as user ID. The handle defines the function you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startWebTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relic’s error tracking. This needs to be done manually with noticeError(). newrelic.startBackgroundTransaction(name, \\[group], handle) newrelic.startBackgroundTransaction(name, \\[group], handle) Copy Instrument the specified background transaction. Using this API call, you can expand New Relic's instrumentation to capture data from background transactions. The name defines the transaction name and needs to be static. Do not include variable data such as user ID. The group is optional, and it allows you to group similar jobs together via the transaction type in the user interface. Like name, the group needs to be static. The handle defines a function that includes the entire background job you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startBackgroundTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relic’s error tracking. This needs to be done manually with noticeError(). newrelic.getTransaction() newrelic.getTransaction() Copy Returns a handle on the currently executing transaction. This handle can then be used to interact with a given transaction safely from any context. It is best used with newrelic.startWebTransaction() and newrelic.startBackgroundTransaction(). Please refer to the transaction handle section for more details. newrelic.endTransaction() newrelic.endTransaction() Copy End the current web or background custom transaction. This method requires being in the correct transaction context when called. This API call takes no arguments. newrelic.startSegment(name, record, handler, callback) newrelic.startSegment(name, record, handler, callback) Copy Instrument a particular method to improve visibility into a transaction, or optionally turn it into a metric. The name defines a name for the segment. This name will be visible in transaction traces and as a new metric in the New Relic UI. The record flag defines whether the segment should be recorded as a metric. The handler is the function you want to track as a segment. The optional callback is a function passed to the handler to fire after its work is done. The agent begins timing the segment when startSegment is called. The segment is ended when either the handler finishes executing, or callback is fired, if it is provided. Custom metrics API calls Use these API calls to record additional arbitrary metrics: newrelic.recordMetric(name, value) newrelic.recordMetric(name, value) Copy Use recordMetric to record an event-based metric, usually associated with a particular duration. The name must be a string following standard metric naming rules. The value will usually be a number, but it can also be an object. When value is a numeric value, it should represent the magnitude of a measurement associated with an event; for example, the duration for a particular method call. When value is an object, it must contain count, total, min, max, and sumOfSquares keys, all with number values. This form is useful to aggregate metrics on your own and report them periodically; for example, from a setInterval. These values will be aggregated with any previously collected values for the same metric. The names of these keys match the names of the keys used by the platform API. newrelic.incrementMetric(name, \\[amount]) newrelic.incrementMetric(name, \\[amount]) Copy Use incrementMetric to update a metric that acts as a simple counter. The count of the selected metric will be incremented by the specified amount, defaulting to 1. Custom events API calls Use these API calls to record additional events: newrelic.recordCustomEvent(eventType, attributes) newrelic.recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. Recording a custom event The following example demonstrates recording a custom event with multiple attributes. const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.recordCustomEvent('MessagingEvent', attributes) Copy Transaction handle methods This section details the methods provided by the TransactionHandle class instance that can be obtained through newrelic.getTransaction(). Use these methods to interact directly with the current transaction: transactionHandle.end(\\[callback]) transactionHandle.end(\\[callback]) Copy Use transactionHandle.end to end the transaction referenced by the handle instance. The callback is invoked when the transaction has fully ended. The finished transaction passed to the callback as the first argument. transactionHandle.ignore() transactionHandle.ignore() Copy Use transactionHandle.ignore to ignore the transaction referenced by the handle instance. transactionHandle.insertDistributedTraceHeaders(headers) transactionHandle.insertDistributedTraceHeaders(headers) Copy Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call acceptDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.insertDistributedTraceHeaders is used to implement distributed tracing. It modifies the headers map that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with distributed_tracing.exclude_newrelic_header: true in the config. This method replaces the deprecated createDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Generating distributed trace headers In the following example, by calling insertDistributedTraceHeaders with an empty object, the appropriate Distributed Trace headers and W3C Trace Context headers will be generated for the transaction. // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() // This could be a header object from an incoming request as well const headersObject = {} newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // generate the headers transaction.insertDistributedTraceHeaders(headersObject) }) Copy transactionHandle.acceptDistributedTraceHeaders(transportType, headers) transactionHandle.acceptDistributedTraceHeaders(transportType, headers) Copy Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call insertDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by insertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated (and now removed as of version 7.0.0) acceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. transportType should be one of the following strings: AMQP HTTP HTTPS IronMQ JMS Kafka Other Queue Unknown headers should be an object containing all the headers in the incoming request. The keys must be lowercase. Accept incoming distributed trace headers The following example demonstrates adding distributed trace headers retrieved from a Kafka message. In this example, we assume that the incoming Kafka message has Distributed Trace headers inserted. // incoming Kafka message headers const headersObject = message.headers // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // accept the headers transaction.acceptDistributedTraceHeaders('Kafka', headersObject) }) Copy transactionHandle.createDistributedTracePayload() transactionHandle.createDistributedTracePayload() Copy Caution This method is deprecated and was removed in version 7.0.0! Please use insertDistributedTraceHeaders. Important This API requires distributed tracing to be enabled. For instructions on how to use this call, along with its partner call acceptDistributedTracePayload, see Enable distributed tracing with agent APIs. This call is used to implement distributed tracing. It generates a payload that is read by the receiving application with acceptDistributedTracePayload. Important Note: In order to maintain proper ordering of spans in a trace, you must generate the payload in the context of the span that sends it. The DistributedTracePayload object has two available methods used for generating the payload in different formats: DistributedTracePayload#text: returns a JSON representation of the payload. Link a nested background transaction // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() var jsonPayload = payload.text() newrelic.startBackgroundTransaction('background task', function executeTransaction() { var backgroundHandle = newrelic.getTransaction() // Link the nested transaction by accepting the payload with the background transaction's handle backgroundHandle.acceptDistributedTracePayload(jsonPayload) }) Copy DistributedTracePayload#httpSafe: returns a base64 encoded JSON representation of the payload. Place payload on an outgoing request // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() // Place the base64 encoded value on an outbound request header. req.headers[myTracingHeader] = payload.httpSafe() Copy transactionHandle.acceptDistributedTracePayload(payload) transactionHandle.acceptDistributedTracePayload(payload) Copy Caution This method is deprecated and was removed in version 7.0.0! Please use acceptDistributedTraceHeaders. Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call createDistributedTracePayload, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTracePayload is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting the payload generated by createDistributedTracePayload. transactionHandle.isSampled() transactionHandle.isSampled() Copy Returns whether this trace is being sampled. Other API calls New Relic's Node.js agent includes additional API calls. newrelic.addCustomAttribute(name, value) newrelic.addCustomAttribute(name, value) Copy Set a custom attribute value to be displayed along with the transaction trace in the New Relic UI. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in New Relic APM's transaction trace detail view and in errors for the transaction. Add custom attribute newrelic.addCustomAttribute('attribute1', 'value1') Copy Caution If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomAttributes(attributes) newrelic.addCustomAttributes(attributes) Copy Set multiple custom attribute values to be displayed along with the transaction trace in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in the transaction trace detail view and in errors for the transaction. Adding custom attributes const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.addCustomAttributes(attributes) Copy Caution If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttribute(name, value) newrelic.addCustomSpanAttribute(name, value) Copy Set a custom span attribute value to be displayed along with a transaction trace span in the New Relic UI. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attribute newrelic.addCustomSpanAttribute('attribute1', 'value') Copy Important This API requires distributed tracing and span events to be enabled. Caution If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttributes(attributes) newrelic.addCustomSpanAttributes(attributes) Copy Set multiple custom span attribute values to be displayed along with the transaction trace spans in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attributes const attributes = { attribute1: 'value1', attribute2: 'value2' } newrelic.addCustomSpanAttributes(attributes) Copy Important This API requires distributed tracing and span events to be enabled. Caution If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.getBrowserTimingHeader() newrelic.getBrowserTimingHeader() Copy Returns the HTML snippet to be inserted into the header of HTML pages to enable New Relic Browser. The HTML will instruct the browser to fetch a small JavaScript file and start the page timer. newrelic.setIgnoreTransaction(ignored) newrelic.setIgnoreTransaction(ignored) Copy Tell the module whether or not to ignore a given request. This allows you to explicitly filter long-polling, irrelevant routes or requests you know will be time-consuming. This also allows you to gather metrics for requests that otherwise would be ignored. To ignore the transaction, set the parameter to true will ignore the transaction. To prevent a transaction from being ignored with this function, pass the parameter false. Passing null or undefined will not change whether the transaction is ignored. Caution This method is deprecated and was removed in version 7.0.0. Please use transactionHandle.ignore() newrelic.noticeError(error, \\[customParameters]) newrelic.noticeError(error, \\[customParameters]) Copy Use this call if your app is doing its own error handling with domains or try/catch clauses, but you want all of the information about how many errors are coming out of the app to be centrally managed. Unlike other Node.js calls, this can be used outside of route handlers, but it will have additional context if called from within transaction scope. Caution Errors recorded using this method do not obey the ignore_status_codes configuration value. newrelic.shutdown(\\[options], callback) newrelic.shutdown(\\[options], callback) Copy Use this method to gracefully shut down the agent. options options.collectPendingData - type boolean - Tell the agent whether to send any pending data to the New Relic collector before shutting down. options.timeout - type number (ms) - The default time before forcing a shutdown. When collectPendingData is true, the agent will wait for a connection before shutting down. This timeout is useful for short lived processes, like AWS Lambda, in order to keep the process from staying open too long, while trying to connect. Example: newrelic.shutdown({collectPendingData: true, timeout: 3000}, (error) => { process.exit() }) Copy newrelic.getLinkingMetadata() newrelic.getLinkingMetadata() Copy Returns key/value pairs which can be used to link traces or entities. It will only contain items with meaningful values. For instance, if distributed tracing is disabled, trace.id will not be included. newrelic.getTraceMetadata() newrelic.getTraceMetadata() Copy Returns and object containing the current trace ID and span ID. Important This API requires distributed tracing to be enabled or an empty object will be returned. Rules for naming and ignoring requests If you do not want to put calls to the New Relic module directly into your application code, you can use pattern-based rules to name requests. There are two sets of rules: one for renaming requests, and one to mark requests to be ignored by New Relic's instrumentation. Here is the structure for rules in New Relic's Node.js agent. rules.name A list of rules of the format {pattern : \"pattern\", name : \"name\"} for matching incoming request URLs to pattern and naming the matching New Relic transaction's name. This acts as a regex replace, where you can set the pattern either as a string, or as a JavaScript regular expression literal, and both pattern and name are required. When passing a regex as a string, escape backslashes, as the agent does not keep them when given as a string in a pattern. Define your configuration rules from the most specific to the most general, as the patterns will be evaluated in order and are terminal in nature. For more information, see the naming guidelines. This can also be set with the environment variable NEW_RELIC_NAMING_RULES, with multiple rules passed in as a list of comma-delimited JSON object literals: NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}' Copy Optional rules attributes [#optional-rules] Additional optional attributes are available: Optional rules attributes Description terminate_chain Default: true When set to true (default), no further rules will be evaluated if this rule is a match. Setting this to false is useful when multiple rules should be used together. For example, one rule could be replacing a common pattern in many different URLs, while subsequent rule(s) would be more specific. replace_all Default: false When set to true, all matches of the pattern will be replaced. Otherwise, only the first match will be replaced. Using the g flag with regular expression literal will have the same effect. For example: pattern: '[0-9]+', replace_all: true Copy This has the same effect as pattern: /[0-9]+/g. precedence By default the rules are evaluated in order, from first to last. If you prefer to have complete control over the order, you can give each rule a precedence attribute. The precedence is an integer number, and rules are evaluated in ascending order. If precedence is not explicitly defined, it will be set to 500 by default. Additional attributes are ignored. Testing your naming rules [#testing-rules] The Node.js agent comes with a command-line tool for testing naming rules. For more information, run the following command in terminal window in a directory where your app is installed: node node_modules/.bin/newrelic-naming-rules Copy Naming rule examples [#examples-rules] Here are some examples of naming rules and the results. Match full URL pattern: \"^/items/[0-9]+$\", name: \"/items/:id\" Copy will result in: /items/123 => /items/:id /orders/123 => /orders/123 (not replaced since the rule is a full match) Copy Replace first match in URL pattern: \"[0-9]+\", name: \":id\" Copy will result in: /orders/123 => /orders/:id /items/123 => /items/:id /orders/123/items/123 => /orders/:id/items/123 Copy Replace all matches in any URL pattern: \"[0-9]+\", name: \":id\", replace_all: true Copy will result in: /orders/123/items/123 => /orders/:id/items/:id Copy Match group references Using regular expression match group references: pattern: '^/(items|orders)/[0-9]+$', name: '/\\\\1/:id' Copy will result in: /orders/123 => /orders/:id /items/123 => /items/:id Copy rules.ignore This can also be set via the environment variable NEW_RELIC_IGNORING_RULES, with multiple rules passed in as a list of comma-delimited patterns. Currently there is no way to escape commas in patterns. NEW_RELIC_IGNORING_RULES='^/socket\\.io/\\*/xhr-polling,ignore_me' Copy Here are full examples of how rules are included in the configuration file: Naming rule example // newrelic.js exports.config = { // other configuration rules : { name : [ { pattern: \"/tables/name-here\", name: \"/name-hererule1\" } ] } Copy Ignoring rule example If you are using socket.io, you will have a use case for ignoring rules right out of the box. To keep socket.io long-polling from dominating your response-time metrics and affecting the Apdex metrics for your application, add a rule such as: // newrelic.js exports.config = { // other configuration rules : { ignore : [ '^\\/socket\\.io\\/.*\\/xhr-polling' ] } }; Copy API calls for rules Here are the API calls for naming and ignoring rules with New Relic's Node.js agent. newrelic.addNamingRule(pattern, name) Programmatic version of rules.name. Once naming rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. Both parameters are required. newrelic.addIgnoringRule(pattern) Programmatic version of rules.ignore. Once ignoring rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. This parameter is required.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.50021,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Adding <em>custom</em> <em>attributes</em>",
        "body": " newrelic.add<em>Custom</em>Attribute(&#x27;attribute1&#x27;, &#x27;value1&#x27;) Copy Caution If you want to use your <em>custom</em> <em>attributes</em>, avoid using any of the reserved terms used by <em>NRQL</em> when naming them. newrelic.add<em>CustomAttributes</em>(<em>attributes</em>) newrelic.add<em>CustomAttributes</em>(<em>attributes</em>) Copy Set multiple <em>custom</em> attribute values"
      },
      "id": "6043daa7196a67e488960f4f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/Rabiela_Sergio_Headshot_0.jpg?h=0e4e36f5&itok=WRvHEC-i",
      "url": "https://newrelic.com/futurestack/speakers/sergio-rabiela",
      "sections": [
        "Sergio Rabiela",
        "Sessions with Sergio Rabiela",
        "Custom Attributes and Events for Business Health",
        "Meet Our Speakers",
        "Sam Aaron",
        "Tom Doherty",
        "Rishi Mukhopadhyay",
        "Sandeep Parmar",
        "Dan Rufener",
        "Nočnica Fee",
        "Simon Wistow",
        "Justin Eveland",
        "Ev Haus",
        "Daniele Packard",
        "Thomas Yopes",
        "Mike Neville-O'Neill",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-15T22:32:43Z",
      "title": "Sergio Rabiela | New Relic",
      "updated_at": "2021-04-15T22:32:43Z",
      "type": "",
      "external_id": "7e17badde1356bebb9a7b345bd326e66912aaf65",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Sergio Rabiela Vice President of Technology, Beyond Finance, Inc on LinkedIn Sessions with Sergio Rabiela 10:15 am - 11:15 am PT | Wednesday, May 26 | Hands-on Workshop Custom Attributes and Events for Business Health Custom Attributes and Events let you push metrics that inform business KPIs in real-time. We'll run through how to use custom attributes and events to allow a broader set of people to monitor business functions and troubleshoot issues in your apps. (Join this session for live chat OR watch on-demand immediately after) Meet Our Speakers Sam Aaron Sonic Pi Learn more Tom Doherty New Relic Learn more Rishi Mukhopadhyay New Relic Learn more Sandeep Parmar New Relic Learn more Dan Rufener New Relic Learn more Nočnica Fee New Relic Learn more Simon Wistow Fastly Learn more Justin Eveland New Relic Learn more Ev Haus ZenHub Learn more Daniele Packard cloudthread Learn more Thomas Yopes cloudthread Learn more Mike Neville-O'Neill New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.62694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Custom</em> <em>Attributes</em> and Events for Business Health",
        "body": ":15 am PT | Wednesday, May 26 | Hands-on Workshop <em>Custom</em> <em>Attributes</em> and Events for Business Health <em>Custom</em> <em>Attributes</em> and Events let you push metrics that inform business KPIs in real-time. We&#x27;ll run through how to use <em>custom</em> <em>attributes</em> and events to allow a broader set of people to monitor business"
      },
      "id": "6042d15c28ccbce4462c6079"
    }
  ],
  "/terraform/terraform-modules": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-16T04:24:42Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.95209,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Linking a <em>notification</em> <em>channel</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-16T02:11:53Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "70555c1d24e8e54b46763d57010901e206ef2ccb",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.3565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6066782e64441f3610617ac3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-15T21:03:41Z",
      "title": "",
      "updated_at": "2021-04-01T01:51:55Z",
      "type": "",
      "external_id": "5e43fb43faa36807fc9f1eb660748303373fa8dd",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.70705,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6065273be7b9d2336c944613"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-04-16T14:38:31Z",
      "updated_at": "2021-04-06T07:43:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirements: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.33855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "sections": [
        "Test alert notification channels",
        "Request the test",
        "Troubleshoot the test results",
        "Tip"
      ],
      "title": "Test alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "c001fca5128a2fb8128ff655c44f9d51b6d5fa2a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/test-alert-notification-channels/",
      "published_at": "2021-04-16T14:39:15Z",
      "updated_at": "2021-03-16T06:45:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must save a new notification channel or any changes to an existing notification channel before testing it. Alerts will then send a test message to your chosen destination. Request the test To test a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Follow standard procedures to add a new notification channel or to update an existing notification channel, and save it. Select a notification channel, and then click Send a test notification. Review the test confirmation message, and then click Got it. Troubleshoot the test results A confirmation message will automatically show up in the user interface that indicates where the test was sent (for example, email) and whether it was successful. Also, the test notification message itself includes detailed information, including: The person who requested the test Links to policies for the channel Links to all notification channels and policies for the account Tip When troubleshooting problems, review the test notification message, and verify the setup requirements for the type of notification channel you selected. If necessary, make additional changes to your notification channel, and test it again as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.77826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "You must save a new <em>notification</em> <em>channel</em> or any changes to an existing <em>notification</em> <em>channel</em> before testing it. <em>Alerts</em> will then send a test message to your chosen destination. Request the test To test a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click"
      },
      "id": "603ec9ffe7b9d25b3d2a07a7"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "image": "https://developer.newrelic.com/static/futurestack-registration-86e612c0605fb3c49cfd28f35977135d.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Futurestack: Master Observability",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-04-16T01:37:39Z",
      "title": "New Relic Developers",
      "updated_at": "2021-04-16T01:37:39Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Data Nerds, get ready to hack the future. Level Up your observability game at Futurestack 2021. Rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 29 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.41113,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/embed/",
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:07:54Z",
      "title": "",
      "updated_at": "2021-04-04T01:53:18Z",
      "type": "",
      "external_id": "ddf0ca28ab311ff372e8955f2ef022de99716131",
      "popularity": 1,
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 281.49277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": "Access the <em>New</em> <em>Relic</em> platform from the comfort of your terminal. You can use the <em>New</em> <em>Relic</em> <em>CLI</em> to manage <em>entity</em> <em>tags</em>, define workloads, record <em>deployment</em> <em>markers</em>, and much more. In short, you can use the <em>CLI</em> to automate common tasks in your DevOps workflow. This guide walks you through"
      },
      "id": "60691c0ee7b9d2f79094463b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/embed/",
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:07:53Z",
      "title": "",
      "updated_at": "2021-04-02T01:54:45Z",
      "type": "",
      "external_id": "c42a52759fcbe676670d61e60c9aa5e269edcccd",
      "popularity": 1,
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.69351,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " of your entities. Before you begin For this guide you need a <em>New</em> <em>Relic</em> user <em>key</em>: You can view and create them in the <em>API</em> keys UI. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including"
      },
      "id": "60667965196a67a9c347e810"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:25:05Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.04411,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Most Popular <em>New</em> <em>Relic</em> One Applications (Round up #3)",
        "sections": "<em>Deployment</em> Analyzer",
        "body": " as related access to <em>New</em> <em>Relic</em> One. What are you waiting for? <em>Deploy</em> these apps now! To <em>deploy</em> any of these apps you need: Access to <em>New</em> <em>Relic</em> One (Requires a paid <em>New</em> <em>Relic</em> account and use of a supported browser) The <em>New</em> <em>Relic</em> One <em>CLI</em> A personal <em>New</em> <em>Relic</em> <em>API</em> <em>key</em>  Node v10 or higher A GitHub account  Once"
      },
      "id": "60762e1f196a673d0a64a782"
    },
    {
      "sections": [
        "Report Zipkin-format traces via Trace API",
        "Zipkin version requirements",
        "Overview of using the Trace API",
        "Send sample Zipkin trace payload",
        "Send Zipkin-format payload",
        "Send data from existing Zipkin instrumentation",
        "Transformation of Zipkin data",
        "Add other tags/attributes"
      ],
      "title": "Report Zipkin-format traces via Trace API",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Trace API"
      ],
      "external_id": "dba8334d1f068236c741ff04c13ecc2be2c184fc",
      "image": "https://docs.newrelic.com/static/96e69137f0dd86b313ec72d5f0c1ad83/119c7/Screen-Shot-2020-08-13-at-1.26.17-PM.png",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/trace-api/report-zipkin-format-traces-trace-api/",
      "published_at": "2021-04-16T01:27:27Z",
      "updated_at": "2021-04-10T16:18:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to create your own tracing implementation, you can use our Trace API. This doc explains how to send Zipkin-format trace data to our Trace API. (For our general data format, see New Relic format.) Zipkin version requirements The Trace API supports data from Zipkin JSON v2 (or higher) without any modification. For details on this version, see Zipkin v2 release details and the Zipkin v2 schema. Overview of using the Trace API Using our Trace API is as simple as: Sending trace data in the expected format (in this case, zipkin format). Sending that data to the appropriate endpoint Our send-data instructions have options for enabling Infinite Tracing. To learn more about this, see Intro to Infinite Tracing and Sampling considerations. To get started using the Trace API, choose an option: Send a sample trace: This shows a curl example of sending a trace to New Relic. This is useful for understanding how the Trace API works, and to verify you're seeing data in New Relic. Report data from existing Zipkin instrumentation: if you have an existing Zipkin implementation, you can simply change the endpoint of where your data gets sent. Send sample Zipkin trace payload This section describes how to send a simple Zipkin-format trace to our Trace API via curl request. You might choose to do this in order to learn how our API works and to verify that data is showing up in New Relic before doing in-depth instrumentation. To get started sending a sample payload: (Optional, to enable Infinite Tracing) First, you must set up a trace observer. That procedure includes instructions for sending a sample trace using our general new-relic format. When you get to that step, return here to instead learn how to send a Zipkin-format trace. Send a Zipkin-format payload following the instructions below. Send Zipkin-format payload To send a sample Zipkin-format trace: Get an Insights insert key: Go to the API keys UI and select Insights insert keys. If you don't already have a key, create a new one by selecting Insert keys +. You'll be executing a curl request, below. Notes on this: Replace the insert key placeholder with your insert key. If you're using Infinite Tracing, use the YOUR_TRACE_OBSERVER_URL value in place of the standard endpoint. If you want to send more than one post, change the trace ID to a different value. Sending the same payload or span id multiple times for the same traceId may result in fragmented traces in the UI. curl -i -H 'Content-Type: application/json' \\ -H 'Api-Key: $NEW_RELIC_INSERT_KEY' \\ -H 'Data-Format: zipkin' \\ -H 'Data-Format-Version: 2' \\ -X POST \\ -d '[ { \"traceId\": \"test-zipkin-trace-id-1\", \"id\": \"3e0f5885710776cd\", \"kind\": \"CLIENT\", \"name\": \"post\", \"duration\": 508068, \"localEndpoint\": { \"serviceName\": \"service-1\", \"ipv4\": \"127.0.0.1\", \"port\": 8080 }, \"tags\": { } }, { \"traceId\": \"test-zipkin-trace-id-1\", \"parentId\": \"3e0f5885710776cd\", \"id\": \"asdf9asdn123lkasdf\", \"kind\": \"CLIENT\", \"name\": \"service 2 span\", \"duration\": 2019, \"localEndpoint\": { \"serviceName\": \"service-2\", \"ipv4\": \"127.0.0.1\", \"port\": 8080 }, \"tags\": { \"error.message\": \"Invalid credentials\" } } ]' 'https://trace-api.newrelic.com/trace/v1' Copy Within a minute, the trace should be available in the our distributed tracing UI. To find it, run a query for the trace.id. In this example, it was test-zipkin-trace-id-1. Note that you search by the transformed attribute of trace.id (not traceId). To learn more: Learn where Trace API data shows up in the UI. Send data from an existing Zipkin instrumentation. Learn how to decorate spans by adding tags. This helps you customize how traces are displayed in our UI for a richer, more helpful experience. Learn about general endpoint information (data limits, required metadata, and response validation). Learn about how Zipkin data is transformed and stored in our format. If you don't see your trace data, see Troubleshooting. Send data from existing Zipkin instrumentation Preliminary notes: If you want to enable Infinite Tracing, you first must set up a trace observer. It can be helpful to first send a sample payload to verify things are working properly. To report data from an existing Zipkin instrumentation, you'll point the Zipkin tracer at the appropriate Trace API endpoint with some required request metadata. You can send the required metadata as headers or query parameters (some Zipkin tracer versions don't allow specifying HTTP headers). Here's an example of what it might look like to create a Zipkin OkHttpSender in Java configured for the Trace API: OkHttpSender.create(\"https://trace-api.newrelic.com/trace/v1?Api-Key=NEW_RELIC_INSERT_API_KEY&Data-Format=zipkin&Data-Format-Version=2\"); Copy Note that if you were using Infinite Tracing, or had an EU-region New Relic account, the endpoint would be different. For an explanation of Api-Key and the other metadata, see Request metadata. Transformation of Zipkin data To create a consistent search/query experience, some Zipkin data will be transformed to match New Relic attribute naming. For more on how we store and structure trace data, see How distributed tracing works. Zipkin tag Stored in New Relic as... Details traceId trace.id Unique identifier for a trace. id id Unique identifier for a span. parentId parent.id Identifier of the upstream span that called the service. kind kind Either Client or Server. name name Name of span. duration duration.ms Zipkin v2 spans must have durations specified in microseconds, and will be converted to milliseconds. localEndpoint: serviceName service.name We use the Zipkin v2 service name to identify the entity that created this span. localEndpoint: port localEndpoint.port All values in the localEndpoint object will be flattened to a span attribute called localEndpoint.key tags reported as attributes Key:value pairs in the tags object in Zipkin v2 will be written as span attributes. annotations not supported We do not currently support annotations in the Trace API. Spans will not be rejected if they contain annotations, but the annotations data will not be written. Add other tags/attributes You can add any tags you want to the tags block, with the exception of the restricted tags. For example, you might want to add attributes like customer.id or user.id to help you analyze your trace data. Tags will be converted to New Relic attributes. To learn how to control how spans appear in New Relic (for example, adding errors or setting a span as a datastore span), see Decorate spans.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.99887,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report Zipkin-format traces via Trace <em>API</em>",
        "sections": "Add other <em>tags</em>&#x2F;attributes",
        "tags": "Trace <em>API</em>",
        "body": " for the same traceId may result in fragmented traces in the UI. curl -i -H &#x27;Content-Type: application&#x2F;json&#x27; \\ -H &#x27;<em>Api</em>-<em>Key</em>: $<em>NEW_RELIC_INSERT_KEY</em>&#x27; \\ -H &#x27;Data-Format: zipkin&#x27; \\ -H &#x27;Data-Format-Version: 2&#x27; \\ -X POST \\ -d &#x27;[ { &quot;traceId&quot;: &quot;test-zipkin-trace-id-1&quot;, &quot;id&quot;: &quot;3e0f5885710776cd&quot;, &quot;kind&quot;: &quot;CLIENT"
      },
      "id": "6071cfc864441fa88f9d8530"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "sections": [
        "NerdGraph tagging API tutorial",
        "Read tags for an entity",
        "Add tags for an entity",
        "Remove a tag from an entity",
        "Delete specific tag values for an entity",
        "Replace all tag values for an entity"
      ],
      "title": "NerdGraph tagging API tutorial",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "b62313b6fa10ab235c031feae23d6fe52163b703",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial/",
      "published_at": "2021-04-16T14:51:53Z",
      "updated_at": "2021-03-16T07:06:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can add tags to your data to help improve data organization and findability. Learn more about tagging at New Relic. This doc explains how to use our NerdGraph API to add and manage tags. For a guide to automating tags using our CLI tool, see our developer site. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to find the entity and then fetch its tags. Use NerdGraph's tag API to read the existing tags and their values. In this example, our entity is a browser app called Cookie Checkout: { actor { entitySearch (query: \"name like 'Cookie Checkout'\") { results { entities { tags { key values } } } } } } Copy The actual values vary depending on your data. Use the New Relic GraphiQL explorer to experiment with queries. Add tags for an entity To add new tags for an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity you want to tag. Use the taggingAddTagsToEntity mutation to add a tag with a value to the entity. In this example, we have a browser application called Cookie Checkout owned by a UI team. We want to add a team tag with a ui value to this instance. Once the tag is added, we can filter by the tag team:ui and find the Cookie Checkout app in the New Relic One UI. mutation { taggingAddTagsToEntity ( guid: \"ENTITY_GUID\", tags: { key: \"team\", values: [\"ui\"]}) { errors { message } } } Copy Remove a tag from an entity To delete a tag and all of its associated values from an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagFromEntity mutation. The following example mutation removes the team tag from an entity: mutation { taggingDeleteTagFromEntity ( guid: \"ENTITY_GUID\", tagKeys: [\"team\"]) { errors { message } } } Copy Delete specific tag values for an entity Instead of deleting an entire tag and all of its values, you can delete a single tag value. Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagValuesFromEntity mutation. The following example mutation deletes the ui value from the tag key: mutation { taggingDeleteTagValuesFromEntity ( guid: \"ENTITY_GUID\", tagValues : [{key: \"team\" value: \"ui\"}]) { errors { message } } } Copy Because tagValues is an array, you can delete multiple specific values from a single entity in one mutation. Replace all tag values for an entity To replace the entity’s entire set of tags with the provided tag set: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingReplaceTagsOnEntity mutation. In this example, the Cookie Checkout browser application was transferred from the ui team to the cookie-dev team. You can replace the tag values for team with the following mutation: mutation { taggingReplaceTagsOnEntity ( guid: \"ENTITY_GUID\", tags: {key: \"team\" values: [\"cookie-dev\"]}) { errors { message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.15806,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph <em>tagging</em> API tutorial",
        "sections": "NerdGraph <em>tagging</em> API tutorial",
        "body": " the <em>taggingDeleteTag</em>FromEntity mutation. The following example mutation removes the team <em>tag</em> from an entity: mutation { <em>taggingDeleteTag</em>FromEntity ( guid: &quot;ENTITY_GUID&quot;, <em>tag</em>Keys: [&quot;team&quot;]) { errors { message } } } Copy Delete specific <em>tag</em> values for an entity Instead of deleting an <em>entire</em> <em>tag</em> and all of its values, you can"
      },
      "id": "603ec1c6196a67eeada83d9a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/canary_watch_4_best_practices.png",
      "url": "https://newrelic.com/blog/best-practices/best-practices-automating-monitoring",
      "sections": [
        "Automate it #1: Install monitoring agents in application builds",
        "Automate it #2: Add markers and tags in your deploy system",
        "Automate it #3: Bootstrap applications and monitoring",
        "Automate it #4: Use APIs and DSLs for dashboards and alerting",
        "Monitoring should reduce toil"
      ],
      "published_at": "2021-04-16T04:26:29Z",
      "title": "Automate It! 4 Best Practices for Scalable Monitoring",
      "updated_at": "2021-04-14T05:20:45Z",
      "type": "",
      "external_id": "0414be031cb241bfc7f42149f257cc353f1cbf3f",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices Automate It! 4 Best Practices for Scalable Monitoring Feb 7, 2019 • 11 min read By Kevin Scaldeferri Operating applications at scale means we have to be thoughtful and vigilant about our monitoring strategies, so we monitor everything consistently. As applications scale, it becomes increasingly important—and increasingly complicated— to effectively monitor the entire software lifecycle, from code deployment through build and deploy to alerting. So how does a fast-growing organization do it? At New Relic, it’s all about automation. As we’ve grown to more than 50 engineering teams around the globe regularly pushing new code to production, we’ve gone from infrastructure as code to “monitoring as code,” embracing four key best practices: Install monitoring agents in application builds Add markers and tags in your deploy system Bootstrap applications and monitoring Use APIs and DSLs for dashboarding and alerting Let’s take a closer look at each one. Automate it #1: Install monitoring agents in application builds Let’s start with build systems. Modern build tools, like Gradle, can do almost anything, and you should take advantage of that power. At New Relic, we automate our build processes using the full power and expressiveness of the programming languages in which we write our applications. We use APIs and code against them within our build systems. For example, to install the New Relic agent into a Java app, you have to download the agent, add the New Relic API as a dependency, generate a YAML config file, modify our run command, and include all that in a deployable artifact. Ok: How do we automate that? We could write a build script that captures all the dependencies and tasks to complete the agent install, but we’d have to copy/paste this boilerplate script for every application we deploy. We’d never write actual application code like this, so why do so with build scripts? This is where build plugins come into play. Consider this example build.gradle file: apply plugin: ‘application’ apply plugin: ‘newrelic-agent-plugin’ apply plugin: … application { name 'my_app' mainClass 'com.example.MyAppMain' } newrelic { version ‘4.10.0’ includeAgentApi true distribution { configFilePath 'config/newrelic.yml' agentJarPath 'agent/newrelic.jar' } } … This is workable, but it’s still not ideal. We’d still need this boilerplate in all our applications, and if we wanted to, say, change something about our monitoring configurations, we’d have to update the config blocks in hundreds of build files. So why not reach toward the nirvana of “zero-configuration builds?” apply plugin: ‘company-java-service’ dependencies { … } Here we’ve written a “mega-plugin” that pulls in all the other plugins we want to use, and provides them with sensible default configurations. From here, an individual service can apply this plugin and its build dependencies, and that’s it—including monitoring is now a zero-effort default in the application’s build. Automate it #2: Add markers and tags in your deploy system Most modern software teams have a common, automated deploy system. Not necessarily a continuous deployment system, but a standard, centralized way to get code into production. But you have to know when you’ve deployed that code. When something changes in your monitored data, the first question anyone asks is, “Was this related to a deploy?” There are two ways to track this information: deploy markers and version tags. Both are useful, so this isn’t an either/or choice but a both/and situation. Markers and tags provide the critical information you need to scale and automate monitoring of your deployments Deploy markers are event logs that get recorded somewhere off to the side of your primary monitoring telemetry. They provide a chronological record of everything that’s changed across all your systems. If you want to record deploy markers, it’s usually just a matter of making a REST API call as part of your deploy process. From there, you can use a charting library or New Relic to automatically display the markers on your dashboards. But deploy markers do have some shortcomings. As techniques like canary deploys, phased rollouts, and blue-green deploys gain popularity, it’s increasingly hard to know exactly what a deploy marker is marking. Is it marking the start of a deploy, or the end of one? What happens if you’re halfway through a deploy and you detect a problem and need to abort and roll it back? In such situations, version tags are more useful. At New Relic, our deploy system injects the version number into the application as an environment variable. Here’s an example of a dashboard where all our telemetry data has been tagged with the version number of the application. Monitoring applications by version tag. By tracking the number of instances reporting each version (in the Router count chart) we can see that this was a phased rollout over the course of 90 minutes. And while that’s happening, we can compare performance between the versions (in the Query 95th Percentile chart) and see that, outside of a bit of Java virtual machine (JVM) warmup in the first canaries, the two versions track very close to one another, even though from minute to minute things jump around a bit based on changing workload. We use tags to track other types of information as well. When we’re responding to an incident or a support request, we frequently need to know how to scope the problem—is the issue restricted to a single instance, or is it widespread? Often we need to compare or restrict data based on clusters or cells, or by region and availability zone, or by what team owns an application—all of which can be done with tags. Additionally, in the containerized world, applications typically don’t know what host machine they’re running on, which can be a problem if we need to shut down a misbehaving instance. For this reason, we have our deploy system tell the container where it is running when it’s launched, so we know exactly where to look should we encounter a problem. Your deploy system is a powerful tool, and it gives you all the information you need to know exactly where your monitoring data is coming from: which version of which application is running on which machines in which region, and so on. Automate it #3: Bootstrap applications and monitoring We’ve looked at how we automate the installation of monitoring agents in our application builds and monitor our deploys, so now we can look at how we automate monitoring in our applications themselves. Earlier, I said it’s important to eliminate as much boilerplate code as you can, but the truth is you can never get rid of it all. If you have to copy/paste boilerplate code to create a new service, at least make a machine do it for you using a uniform template-based build system, like Apache Maven Archetype. When you define an organization-wide best practice to use templates to bootstrap new services, you’re taking proactive steps to ensure uniformity in your microservices architecture. As mentioned, the New Relic deploy system injects environment variables into our applications that describe exactly what the applications are and where they’re running. But this information is of limited value unless we actually do something with it. To this end, we wrote simple wrapper libraries that allow us to attach attributes such as our applications’ names, versions, and hostnames to all the data we collect when monitoring them: public void recordEvent(String eventType, Map<String, Object> attributes) { // Add standard attributes Map<String, String> envVars = System.getenv(); attributes.put(\"appName\", envVars.getOrDefault(\"NEW_RELIC_APP_NAME\", \"unknown\")); attributes.put(\"version\", envVars.getOrDefault(\"GC_VERSION\", \"unknown\")); attributes.put(\"jvmId\", ManagementFactory.getRuntimeMXBean().getName()); attributes.put(\"ipPort\", envVars.getOrDefault(\"CF_PRIMARY_IP_PORT\", \"unknown\")); attributes.put(\"hostname\", envVars.getOrDefault(\"CF_FQDN\", \"unknown\")); attributes.put(\"region\", envVars.getOrDefault(\"CF_REGION\", \"unknown\")); attributes.put(\"zone\", envVars.getOrDefault(\"CF_ZONE\", \"unknown\")); attributes.put(\"subnet\", envVars.getOrDefault(\"CF_SUBNET_ID\", \"unknown\")); NewRelic.recordCustomEvent(eventType, attributes); } With this in place, we’re able to slice and dice the monitoring data from all of our applications along a consistent set of dimensions, even as they continue to scale. Automate it #4: Use APIs and DSLs for dashboards and alerting So now you’re building and deploying monitoring all your services—but that doesn’t do you much good if no one is paying attention. With a monolithic application architecture, it may be enough to simply start creating dashboards and setting up alerts. But large microservices architectures operate at scale, and manual GUI-driven dashboard and alerting configurations are too repetitive, too error prone, and too easy to abandon. This is why modern software teams embrace APIs as first-class alternatives to GUIs. New Relic gives you APIs to create dashboards, APIs to define synthetic monitors, APIs to set up alert conditions, and so on. But you need to decide how you’ll interact with those APIs—obviously you don’t want people manually typing out JSON payloads and cURL commands; that would barely be an improvement over making changes in a GUI. The good news, though, is that you have choices for how to approach this. Recently, for example, IBM open-sourced a command-line tool it uses to automate management of its New Relic tasks and resources (for example, creating, editing, and deleting alert policies). This is the kind of tool you’d want to build more complicated workflows on top of; for example, you could use it to download all your existing dashboard configurations and manage those configs programmatically, essentially as templates. In fact, this is how we manage our synthetic monitoring scripts at New Relic. New Relic Synthetics monitors are just JavaScript programs, but if you’re monitoring several clusters providing a single service, you need to update those scripts if the clusters have different URLs. With such questions in mind, we turned our Synthetics scripts into embedded Ruby (ERB) templates so that we can loop over all of our clusters and generate a unique version of the script for each cluster. For other tasks, we embrace Domain Specific Languages (DSLs). The term “DSL” can mean a lot of things, but I’m talking about a templating or configuration language that is capable of driving an API in an automated way. At New Relic, for example, we manage our alert policies via a Ruby-based DSL: policy \"Unified Data Streams CF Alerts” do rollup 'condition’ team_low_priority_channels condition \"WARNING Service(s) OOMing\" do type 'nrql’ query \"SELECT count(*) FROM cf_docker_event where action = 'oom’” since 2.minutes value 'single_value’ critical above: 0, for: 1.minutes end end Because this is all Ruby code, we can add loops and function calls—which makes things a little more interesting. In the example below, we loop over clusters and use the cluster identity in a few different ways: We inject the cluster name into the alert policy, and select notification channels per cluster. Notifications from the production clusters go to PagerDuty, but notifications from pre-production clusters go to email. This ensures the right people are notified for the right reasons, and no one gets woken up in the middle of the night unnecessarily. clusters.each do |cluster| policy \"#{cluster} MyApp Lag\" do rollup 'condition' team_alert_channels(cluster) condition \"#{sev_and_cluster('SEV3’, cluster)} MyApp\" do entities [config[cluster][‘lag_monitor_app_name']] metric 'Custom/ConsumerLag/appendSecondsLag/my_topic/my_app' value 'max' critical above: 60, for: 5.minutes end end end The critical part of these configuration choices is making the right thing the easy thing. Your engineers are going to configure alert policies hundreds or thousands of times, which creates a lot of opportunities for them to take shortcuts or make mistakes. Limit those opportunities with automated management of your alert configurations—there are countless ways to do that, so find what works best for your organization. Nothing will keep your dev and ops teams up at night like wondering if something might be silently breaking and having no alerts from which to find out. Monitoring should reduce toil At New Relic, we obviously have plenty of opinions about monitoring modern software. But we also know that microservices architectures come with the risk of increasing toil and uncertainty in your operations. Your monitoring strategies don’t have to contribute to that toil. Using techniques like these will help you get ahead—and stay ahead—of the game as your applications and infrastructure continue to grow. By Kevin Scaldeferri Kevin Scaldeferri is a Principal Software Engineer and Architect for the New Relic Database system. He likes math and distributed systems, and probably says “monoid” too much. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.250725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> It! 4 Best Practices for Scalable Monitoring",
        "sections": "<em>Automate</em> it #2: Add markers and <em>tags</em> in <em>your</em> deploy system",
        "body": " Add markers and tags in <em>your</em> deploy system Bootstrap applications and monitoring Use APIs and DSLs for dashboarding and alerting Let’s take a closer look at each one. <em>Automate</em> it #1: Install monitoring agents in application builds Let’s start with build systems. Modern build tools, like Gradle, can"
      },
      "id": "60767bad64441f3ae79d8596"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/Karon_Jonathan.jpg?h=3ea3ad8f&itok=6wPgCiNi",
      "url": "https://newrelic.com/futurestack/speakers/jonathan-karon",
      "sections": [
        "Jonathan Karon",
        "Sessions with Jonathan Karon",
        "The CMDB is Dead; Long Live the CMDB.",
        "Meet Our Speakers",
        "Gwen Hurd",
        "Nočnica Fee",
        "Mason Jones",
        "Natalie Serrino",
        "Eric Mittelhammer",
        "Daniele Packard",
        "Brian Goleno",
        "Nilson Pontello",
        "Eugene Kovshilovsky",
        "Ari Zilka",
        "Danny Roessner",
        "Dan Rufener",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-15T22:33:37Z",
      "title": "Jonathan Karon | New Relic",
      "updated_at": "2021-04-15T22:33:37Z",
      "type": "",
      "external_id": "71c88809388b55e2f1545f5a643013f44163f4a8",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Jonathan Karon Director of Venture Development, New Relic on LinkedIn Sessions with Jonathan Karon 11:35 am - 11:55 am PT | Wednesday, May 26 | Snackable The CMDB is Dead; Long Live the CMDB. Modern software changes fast, and old IT practices like CMDB can't hope to keep up. Learn how clever use of tagging can turn NR1 into a real time CMDB / microservice catalog that will make your whole engineering org better, faster, and safer. (Join this session for live chat OR watch on-demand immediately after) Meet Our Speakers Gwen Hurd New Relic Learn more Nočnica Fee New Relic Learn more Mason Jones Credit Karma Learn more Natalie Serrino New Relic Learn more Eric Mittelhammer New Relic Learn more Daniele Packard cloudthread Learn more Brian Goleno New Relic Learn more Nilson Pontello Banco Inter Learn more Eugene Kovshilovsky CarParts.com Learn more Ari Zilka New Relic Learn more Danny Roessner WellSky Learn more Dan Rufener New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.53614,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "{Future}<em>Stack</em> is coming. May 25 - 27, 2021",
        "body": " | Wednesday, May 26 | Snackable The CMDB is Dead; Long Live the CMDB. Modern software changes fast, and old IT practices like CMDB can&#x27;t hope to keep up. Learn how clever use of <em>tagging</em> can turn NR1 into a real time CMDB &#x2F; microservice catalog that will make <em>your</em> whole engineering org better"
      },
      "id": "60502d4f196a67d3a82d162b"
    },
    {
      "sections": [
        "New Relic Flex: 独自のインテグレーションを構築する",
        "Flexとは?",
        "要件",
        "Flexの動作のしくみ",
        "設定の例",
        "詳細情報",
        "その他のヘルプ"
      ],
      "title": "New Relic Flex: 独自のインテグレーションを構築する",
      "type": "docs-jp",
      "tags": [
        "Full-Stack Observability",
        "Instrument everything",
        "Develop your own integrations"
      ],
      "external_id": "97d59bd52c8219850d6ea5ae34a226698b84d022",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/integrations/host-integrations/host-integrations-list/flex-integration-tool-build-your-own-integration/",
      "published_at": "2021-04-16T16:40:48Z",
      "updated_at": "2021-04-06T10:51:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicは、多くの一般的なサービスやフレームワーク向けのインテグレーションを提供しています。New Relicを使用しており、インテグレーションの対象外のサービスからデータのレポートを行う場合、次のいくつかの方法でNew Relicにより独自のインテグレーションを作成できます。 New Relic インフラストラクチャモニタリングを使用して、軽量のFlexツール（以下で推奨、文書化）を使用できます。完全なインフラストラクチャオンホストインテグレーションを構築するには、Integrations SDKをご覧ください。 テレメトリー（メトリックス、トレース）モニターソリューション：当社のテレメトリーSDKを使用します。 独自のJavaScript UI機能を使用する、カスタムのNew Relic Oneアプリケーションを構築します。 Flexとは? New Relic Flexは、アプリケーションに依存しないすべてを兼ね備えたツールで、このツールを使用して広範なサービスからメトリックデータを収集できます。Flexはインフラストラクチャエージェントとバンドルで提供されます。標準形式（例：JSONまたはプレーンテキスト）で標準プロトコル（HTTP、ファイル、シェル）にメトリックスを露呈するアプリをインストゥルメントできます：YAML設定ファイルを作成し、Infrastructureエージェントを開始し、データをNew Relicにレポートします。 Flexは、広範なソースから、New Relicにイベントとメトリックデータを送信できます。簡単なYAML設定ファイルを使用して、HTTP/HTTPSリクエストを実行し、シェルコマンドを実行し、ファイルコンテンツのパースを行えます。また、標準の正規表現を使用して、この入力から収集したデータのカスタマイズと制御も行えます。設定の例をご覧ください。 データの収集とクリーンアップを行った後、New RelicでFlexデータのクエリを行い、カスタムチャートを作成し、そのデータをダッシュボードで使用できます。 要件 Flexはインフラストラクチャエージェントとバンドルで提供されます。Flexを使用するには、次のものが必要です。 LinuxまたはWindows、Kubernetesで実行している、Infrastructureエージェントバージョン1.10.7以上（アップデート | チェックバージョン）。 Flexの動作のしくみ Flexはインフラストラクチャエージェントを使用して、レポートするデータを生成するコマンドを実行します。データのレポートでのFlexのしくみの概要は次のとおりです。 インフラストラクチャエージェントパッケージにある、YAML設定ファイルでレポートするデータを定義します。設定の例をご覧ください： 設定の例 LinuxサーバーのアップデートをモニターするためのFlex設定の例は次のとおりです。この設定は、flex-uptime.ymlという名前のファイルにあります。この設定は、/etc/newrelic-infra/integrations.d/flex-uptime.ymlにある、インフラストラクチャエージェントのインテグレーション設定セクションにあります。 integrations: - name: nri-flex config: name: linuxUptimeIntegration apis: - name: Uptime commands: - run: 'cat /proc/uptime' split: horizontal split_by: \\s+ set_header: [uptimeSeconds,idletimeSeconds] コピー この設定で行うことについての注： runでは、実行するコマンドを定義します。 名前: アップタイムで示される名前には、UptimeSampleと呼ばれるイベントを生成するためのサンプルが付けられます。 名前の先頭には、ESXまたはPCFプレフィックスを付けないでください。 split_by: \\s+は、空白文字に基づきフィールドを分割します。 このコマンドは、UptimeSampleイベントに添付された属性を生成します。属性の名前はuptimeSecondsおよびidletimeSecondsとなります。 インフラストラクチャエージェントは、独自の設定（デフォルト：30秒おき）に基づく頻度でFlexを実行し、データをNew Relicに送信します。 その後データのクエリを行い、そのデータを使用してカスタムチャートを作成し、データをダッシュボードに追加できます。 詳細情報 Flexインテグレーションは、インフラストラクチャエージェントとバンドルで提供されます。要件の詳細を表示する。 詳細については、GitHubのドキュメント： READMEをご覧ください チュートリアル その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.0679,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Full-<em>Stack</em> Observability"
      },
      "id": "60533092196a67649e2d166a"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Use tags to filter the UI",
        "Custom queries and charts"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-04-12T02:59:19Z",
      "updated_at": "2021-03-29T20:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). And you can also add your own custom tags. You can use tags in the UI to filter down to relevant data, as shown here: Here you can see an accountId tag being used to filter workloads for a specific account. You can use tags to: Help organize data coming from a large number of sources and/or to a large number of New Relic accounts Identity teams, roles, environment, or regions to know who’s responsible for what (see example use cases) Better organize and search dashboards and workloads Tags are useful for organizing data at a high level. If you wanted to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events would be a better solution. Tip At New Relic, tags were previously called \"labels.\" You may sometimes see \"label\" used in our code; for example, some of our APM agent config files use a label config option for tags. Keep reading to learn more about tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, read the best practices below to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Be consistent with capitalization. For example, avoid using both env: staging and env: Staging (although tag searching is case-insensitive in the UI and API) Tips on cross-team implementation: One reason for using tags is to improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Keep this reference manual up-to-date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can apply tags via the UI and API or you can add tags using APM agent configuration: C SDK: not available Go .NET Node.js PHP Python Ruby Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries and charts As explained in Tag sources, some attributes are available as tags. You can query attributes and create custom charts using NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.67204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>tags</em> to help organize and find <em>your</em> data",
        "sections": "Use <em>tags</em> to help organize and find <em>your</em> data",
        "body": " reports that identify entities that are non-compliant with <em>your</em> <em>tagging</em> standards. <em>Tag</em> examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible"
      },
      "id": "603ebd1228ccbc6278eba754"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/collect-data-from-any-source/embed/",
      "sections": [
        "Collect data from any source",
        "Agent APIs",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API",
        "Log API"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "",
      "updated_at": "2021-03-31T01:51:31Z",
      "type": "",
      "external_id": "8e707490926e30080cc8b28594f32c1bc40ef393",
      "popularity": 1,
      "body": "New Relic products report a lot of data “out of the box.” When you use products like APM, Browser, Mobile, Infrastructure monitoring, or an integration, by default you receive performance data. But you may want to bring data into New Relic that isn't collected by default. Maybe you want an API-based solution that doesn't require install of an agent. Maybe you want to bring telemetry data from another analysis service into New Relic. This page describes several ways to get data into New Relic. Step 1 of 6 Agent APIs If you use our APM, Browser, or Mobile agents to report data, you can use their associated APIs to report custom data. For example, if you monitor your application with the our APM Python agent, you can use the Python agent API to set up custom instrumentation. See the agent APIs. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language wrappers for our Trace API and Metric API (and eventually our Log API and Event API). These SDKs let you easily send metrics and trace data to New Relic without needing to install an agent. For customers, we offer open-source exporters and integrations that use the Telemetry SDKs to send metrics and trace data: Istio adaptor Prometheus OpenMetrics (for Docker | for Kubernetes) OpenCensus exporter (for Go | for Python) DropWizard exporter Micrometer exporter Want to build your own solution? See our Telemetry SDK docs. Step 3 of 6 Trace API Our Trace API lets you send distributed tracing data to New Relic and consolidate tracing data from multiple sources in one place. We accept trace data in two formats: Zipkin format New Relic format (if you don’t have Zipkin-format data, you’d use this) bash Copy $ curl -i -X POST https://trace-api.newrelic.com/trace/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -H 'Data-Format: newrelic' \\ > -H 'Data-Format-Version: 1' \\ > -d '[ $ { $ \"common\": { $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host123.test.com\" $ } $ }, $ \"spans\": [ $ { $ \"trace.id\": \"123456\", $ \"id\": \"ABC\", $ \"attributes\": { $ \"duration.ms\": 12.53, $ \"name\": \"/home\" $ } $ }, $ { $ \"trace.id\": \"123456\", $ \"id\": \"DEF\", $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host456.test.com\", $ \"duration.ms\": 2.97, $ \"name\": \"/auth\", $ \"parent.id\": \"ABC\" $ } $ } $ ] $ } $ ]' Step 4 of 6 Metric API You can use our Metric API to send metric data to New Relic from any source. bash Copy $ curl -i -X POST https://metric-api.newrelic.com/metric/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"metrics\": [ $ { $ \"name\": \"memory.heap\", $ \"type\": \"gauge\", $ \"value\": 2.3, $ \"timestamp\": 1531414060739, $ \"attributes\": { $ \"host.name\": \"dev.server.com\" $ } $ } $ ] $ } $ ]' Step 5 of 6 Event API For sending arbitrary events to New Relic, you can use our Event API. We save these events as a new event type, which can then be queried via NRQL. (Eventually, the Telemetry SDKs will support the Event API.) bash Copy $ curl -i -X POST https://insights-collector.newrelic.com/v1/accounts/$ACCOUNT_ID/events \\ > -H \"Content-Type: application/json\" \\ > -H \"x-insert-key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"eventType\": \"LoginEvent\", $ \"service\": \"login-service\", $ \"customerId\": \"xyz\" $ } $ ]' Step 6 of 6 Log API If our existing logging integrations don’t meet your needs, you can use our Log API to send any arbitrary log data to New Relic. (Eventually, the Telemetry SDKs will support the Log API.) bash Copy $ curl -i -X POST https://log-api.newrelic.com/log/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ \"logs\": [ $ { $ \"timestamp\": 1593538496000, $ \"message\": \"User xyz logged in\", $ \"service\": \"login-service\", $ \"hostname\": \"login.example.com\" $ } $ ] $ ]'",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.79343,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> <em>APIs</em>",
        "body": " their associated APIs to report custom data. For example, if you monitor your application with the our APM Python <em>agent</em>, you can use the Python <em>agent</em> <em>API</em> to set up custom instrumentation. See the <em>agent</em> APIs. Step 2 of 6 <em>Telemetry</em> <em>SDK</em> Our <em>Telemetry</em> SDKs are language wrappers for our <em>Trace</em> <em>API</em> and <em>Metric</em>"
      },
      "id": "6063d5a3e7b9d297a1703743"
    },
    {
      "sections": [
        "FedRAMP-compliant endpoints",
        "Customer FedRAMP obligations",
        "Overview of data sources",
        "Agents",
        "APM agents",
        "Mobile agents",
        "Infrastructure monitoring",
        "Infrastructure agent versions below 1.15.0",
        "Browser agent",
        "Data-ingest APIs",
        "Metric API",
        "Telemetry integrations",
        "Telemetry SDKs",
        "Event API",
        "Log API",
        "Log forwarders",
        "Trace API"
      ],
      "title": "FedRAMP-compliant endpoints",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Compliance"
      ],
      "external_id": "ffce8ad6f802717392aca80e0965c9f3fe77ffdf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/compliance/fedramp-compliant-endpoints/",
      "published_at": "2021-04-12T10:50:08Z",
      "updated_at": "2021-04-05T21:48:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides information on FedRAMP-compliant endpoints in New Relic. For more information about our security accreditation for the Federal Risk and Authorization Management Program (FedRAMP), see our data encryption documentation. Customer FedRAMP obligations New Relic customers must meet all of the following requirements for New Relic’s FedRAMP environment: New Relic-approved customers: New Relic’s FedRAMP-Moderate authorized environment is only available to New Relic-approved customers. For more information, contact your New Relic account representative. Order form: Customer’s order form with New Relic must include customer’s eligibility for FedRAMP. Subscription level: Customer must have a current and valid subscription to New Relic Full-Stack Observability Enterprise or New Relic-approved subscription. Authorized New Relic endpoints: Customer must send its data only to New Relic’s FedRAMP-designated endpoints. Authorized services and features: Customer must use only FedRAMP audited and authorized New Relic services and features (see below). Overview of data sources There are multiple ways to get data into New Relic. This doc has two sections: Agent settings: for our APM agents, infrastructure agent, browser agent, and mobile agent. Data-ingest APIs: for our Metric API, Event API, Trace API, and Log API, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents, and browser agent. Setting these agents to send FedRAMP-compliant data involves setting a configuration setting to use the relevant FedRAMP endpoint. APM agents To ensure FedRAMP compliance, all APM agent configurations must report to gov-collector.newrelic.com rather than the default. Depending on the agent, you can either use code-based configuration or an environment variable. Here are details on enabling this: Language Code or environment variable C SDK In code: strcpy(_newrelic_app_config_t->redirect_collector, \"gov-collector.newrelic.com\"); Copy Environment variable: none Go In code: app, err = newrelic.NewApplication( newrelic.ConfigAppName(\"App Name\"), newrelic.ConfigLicense(os.Getenv(\"NEW_RELIC_LICENSE_KEY\")), func(cfg *newrelic.Config) { cfg.Host = \"gov-collector.newrelic.com\" }, ) Copy Environment variable: NEW_RELIC_HOST Java In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Or set a system property of: newrelic.config.host Copy Environment variable: NEW_RELIC_HOST .NET In your XML config next to the license key: <service licenseKey=\"YOUR_LICENSE_KEY\" host=\"gov-collector.newrelic.com\"/> Copy Environment variable: NEW_RELIC_HOST Node.js In newrelic.js: host: 'gov-collector.newrelic.com' Copy Environment variable: NEW_RELIC_HOST PHP In newrelic.ini: newrelic.daemon.collector_host = gov-collector.newrelic.com Copy Environment variable: none Python In newrelic.ini: [newrelic] host = gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Ruby In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Elixir (open source agent) In config.exs: config :new_relic_agent, host: \"gov-collector.newrelic.com\" Copy Environment variable: NEW_RELIC_HOST For more on configuring APM agents, see APM configuration. Mobile agents To ensure FedRAMP compliance when using our mobile monitoring agents, all agent configurations must report to gov-mobile-collector.newrelic.com rather than the default. You must use code-based configuration. Environment variables are not available. Framework-specific configurations: Agent Code or environment variable Android In code: NewRelic.withApplicationToken({APP_TOKEN}) .usingCollectorAddress(\"gov-mobile-collector.newrelic.com\") .usingCrashCollectorAddress(\"gov-mobile-crash.newrelic.com\") .start(this.getApplication()); Copy Environment variable: none iOS In code: [NewRelic startWithApplicationToken:@\"{APP_TOKEN}\" andCollectorAddress:@\"gov-mobile-collector.newrelic.com\" andCrashCollectorAddress:@\"gov-mobile-crash.newrelic.com\"]; Copy Environment variable: none Infrastructure monitoring If you have infrastructure agent version 1.15.0 or higher, simply enable the FedRAMP configuration option. If you have an older agent version, use the following values to edit your YAML configuration: Infrastructure agent versions below 1.15.0 If you have an infrastructure agent version below 1.15.0, you must change three of the endpoints used for reporting. To set these endpoints, you can change your YAML configuration or use environment variables. YAML config field Endpoint URL collector_url https://gov-infra-api.newrelic.com Copy identity_url https://gov-identity-api.newrelic.com Copy command_channel_url https://gov-infrastructure-command-api.newrelic.com Copy To edit environment variables, use these values: Environment variable Endpoint URL NRIA_COLLECTOR_URL https://gov-infra-api.newrelic.com Copy NRIA_IDENTITY_URL https://gov-identity-api.newrelic.com Copy NRIA_COMMAND_CHANNEL_URL https://gov-infrastructure-command-api.newrelic.com Copy Browser agent To configure the browser agent to use a FedRAMP-compliant endpoint, you must use the copy-paste method method (other browser agent install methods are not supported) and edit the browser code’s script element tag so that the domain is gov-bam.nr-data.net for both beacon and error_beacon, like this: window.NREUM||(NREUM={});NREUM.info={\"beacon\":\"gov-bam.nr-data.net\",\"errorBeacon\":\"gov-bam.nr-data.net\"... Copy Data-ingest APIs Below are details about the FedRAMP endpoint for our ingest APIs: Metric API, the Event API, the Log API, and the Trace API. Metric API To ensure FedRAMP compliance when using the Metric API, instead of sending metric data to the default Metric API endpoint of https://metric-api.newrelic.com/metric/v1, it must be sent to https://gov-metric-api.newrelic.com/metric/v1. The Metric API can be used directly but it's mainly used by various New Relic tools. Below are instructions showing where to edit the configuration for setting the FedRAMP endpoint. Telemetry integrations Here are instructions for our open source telemetry integrations that report metric data: Dropwizard: use the overrideUri configuration. Kamon: use the metric-ingest-url configuration. See Override endpoints. Micrometer: override the public String uri() method on your NewRelicRegistryConfig to return the new endpoint. See an example. Prometheus: Prometheus OpenMetrics: if you are using our nri-prometheus helm chart, you can change the endpoint in your values.yml file, like in this example. If you're using the nri-bundle chart, you need to nest this value under the nri-prometheus key to propagate it to the sub-chart. Remote write integration: not available. Telemetry SDKs Here are instructions for our Telemetry SDKs that report metric data: Go: use the MetricsURLOverride configuration. Java: in the MetricBatchSender section, configure the endpoint. See an example. .NET: use the MetricUrlOverride configuration. Node.js: edit the METRIC_HOST = 'metric-api.newrelic.com' configuration. Python: edit the HOST = \"metric-api.newrelic.com\" configuration. Event API To ensure FedRAMP compliance for the Event API, all traffic reporting to insights-collector.newrelic.com must instead report to gov-insights-collector.newrelic.com. The Event API endpoint is configurable for the following Telemetry SDKs. The Telemetry SDKs are used by our open-source telemetry integrations. Language Solution Java Telemetry SDK In code: SenderConfiguration configuration = SenderConfiguration .builder( \"gov-insights-collector.newrelic.com\", EventBatchSender.EVENTS_PATH) .build(); EventBatchSender eventBatchSender = EventBatchSender.create(configuration); Copy Python Telemetry SDK In code: event_client = EventClient(host=\"gov-insights-collector.newrelic.com\") Copy For more information, see our Telemetry API documentation in GitHub. Log API To ensure FedRAMP compliance for data sent via the Log API, the solution for almost all our logging tools is to replace the https://log-api.newrelic.com/log/v1 endpoint with https://gov-log-api.newrelic.com/log/v1. Here are details for various tools: Log forwarders Here are details on changing the endpoint for our log forwarders: AWS Firelens: Add the endpoint property to the options field of the logConfiguration, similar to to the EU account endpoint change shown in these Firelens endpoint configuration instructions. Fluentbit: Use our Fluentbit endpoint configuration. Fluentd: Use our Fluentd endpoint instructions. Infrastructure agent: See FedRAMP for infrastructure. Kubernetes: Our Kubernetes integration logs are based on fluentbit’s output plugin. Use these endpoint instructions. Logstash: Use our Logstash endpoint configuration. Syslog: For configuring syslog clients, see TCP endpoint configuration. S3: Not available. Vector: Not available. To use the Log API directly, you'd edit the Log API endpoint configuration. Trace API FedRAMP is not yet available for the Trace API itself, but note that some of our agents report trace data and you can enable FedRAMP for some of those agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.63078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Metric</em> <em>API</em>",
        "body": " APM agents, infrastructure <em>agent</em>, browser <em>agent</em>, and mobile <em>agent</em>. Data-ingest APIs: for our <em>Metric</em> <em>API</em>, <em>Event</em> <em>API</em>, <em>Trace</em> <em>API</em>, and Log <em>API</em>, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents"
      },
      "id": "603e945164441f64384e8872"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Tip",
        "Requirements and compatibility",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "4cc9878a6fd53a3602eedd978303457aab82ac4e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-manage-data/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-04-12T11:18:58Z",
      "updated_at": "2021-03-16T15:37:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Tip To use our Telemetry SDKs and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Requirements and compatibility To build with the Telemetry SDKs, you will need an Insights insert key. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.07593,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "sections": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "tags": "<em>Telemetry</em> Data Platform",
        "body": "Our <em>Telemetry</em> SDKs are an open source set of <em>API</em> client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the <em>Metric</em> <em>API</em>, <em>Trace</em> <em>API</em>, Log <em>API</em>, and <em>Event</em> <em>API</em>. We offer open-source integrations for <em>telemetry</em> tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Report custom event data",
        "Important",
        "Value from custom events and attributes",
        "Avoid rate limits",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "title": "Report custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9c787cb83d5d7d1722bcbec25f4eb8698f5be6e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-custom-event-data/",
      "published_at": "2021-04-16T11:54:20Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. New Relic products report a variety of default event data to your account. This document explains how to report your own custom events and attributes. Value from custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. By reporting custom events, you can create more useful and customized queries and charts of your data. This is a key part of optimizing how New Relic works for you. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.99188,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>event</em> data",
        "sections": "Report custom <em>event</em> data",
        "tags": "<em>Event</em> data sources",
        "body": " of custom data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em> <em>API</em> Extend data retention To learn how to extend how long events are retained in your account, see our documentation about <em>event</em> data retention."
      },
      "id": "6043f0b1196a67451d960f86"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Agent APIs",
        "Telemetry SDKs",
        "APIs for sending metrics, traces, logs, and events",
        "New Relic One applications"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "3fa26c40c4e8304f45c465d5565f6b428ba085da",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data-new-relic/getting-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-04-11T21:28:37Z",
      "updated_at": "2021-03-16T18:25:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. To browse all New Relic-built tools and solutions, see New Relic integrations. Agent APIs Some of our monitoring solutions come with APIs and/or SDKs that allow you to customize the data reported and how it reports. For more information, see the relevant product: APM agent APIs Browser API Mobile API Infrastructure monitoring: the Flex integration tool Telemetry SDKs If our more curated solutions don't work for you, our open source Telemetry SDKs let you build your own solution. These SDKs are language wrappers for our data-ingest APIs (below) that let you send telemetry data to New Relic without requiring install of an agent. APIs for sending metrics, traces, logs, and events If our more curated solutions don't work for you, we also have data-ingest APIs: Trace API Event API Metric API Log API To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open source New Relic One apps, or share your own with the open source community. For details, see New Relic One applications.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.59882,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APIs</em> for sending <em>metrics</em>, <em>traces</em>, logs, and <em>events</em>",
        "tags": "<em>Telemetry</em> Data Platform",
        "body": " also have data-ingest APIs: <em>Trace</em> <em>API</em> <em>Event</em> <em>API</em> <em>Metric</em> <em>API</em> Log <em>API</em> To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open source New Relic One apps, or share your own with the open source community. For details, see New Relic One applications."
      },
      "id": "603eae7b196a671ea3a83dc7"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.15324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #6)",
        "sections": "<em>Subscribe</em> to <em>apps</em> in the New Relic One Catalog",
        "body": " to your New Relic account using the following commands: nr1 nerdpack:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;nr1-attributory.git cd nr1-attributory nr1 nerdpack:<em>publish</em> nr1 nerdpack:<em>deploy</em> -c STABLE nr1 nerdpack:<em>subscribe</em> -c STABLE Then go to the homepage of one.newrelic.com and select the <em>app’s</em> launcher"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/Natalie_Serrino%20FS21.jpg?h=2e0f227d&itok=xI5aRyVf",
      "url": "https://newrelic.com/futurestack/speakers/natalie-serrino",
      "sections": [
        "Natalie Serrino",
        "Sessions with Natalie Serrino",
        "Kubernetes-Native Observability Without Instrumentation",
        "Meet Our Speakers",
        "Paras Wadehra",
        "Jonathan Karon",
        "Dan Rufener",
        "Jonathan Thurman",
        "JD Weiner",
        "Aaron Judy",
        "Scot Gorman",
        "Anthony Pounds-Cornish",
        "Jemiah Sius",
        "Danny Roessner",
        "Sam Aaron",
        "Matt Shandera",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-16T04:26:28Z",
      "title": "Natalie Serrino | New Relic",
      "updated_at": "2021-04-16T04:26:28Z",
      "type": "",
      "external_id": "b07751ac88fb8968451d9e1aed356d4ff8b4e0e6",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Natalie Serrino Principal Software Engineer, New Relic Sessions with Natalie Serrino 10:15 am - 11:15 am PT | Wednesday, May 26 | Hands-on Workshop Kubernetes-Native Observability Without Instrumentation Learn how to get visibility into your Kubernetes cluster and apps with no-instrumentation data collection, allowing you to debug in minutes. No need to update, recompile, or deploy your apps - it just works. (Join this session for live chat OR watch on-demand immediately after) Meet Our Speakers Paras Wadehra New Relic Learn more Jonathan Karon New Relic Learn more Dan Rufener New Relic Learn more Jonathan Thurman New Relic Learn more JD Weiner Forbes Media LLC Learn more Aaron Judy Maricopa County Clerk of the Superior Court Learn more Scot Gorman Chegg Learn more Anthony Pounds-Cornish Cognitran Learn more Jemiah Sius New Relic Learn more Danny Roessner WellSky Learn more Sam Aaron Sonic Pi Learn more Matt Shandera New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.4282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", May 26 | Hands-on Workshop Kubernetes-Native Observability Without Instrumentation Learn how to get visibility into your Kubernetes cluster and <em>apps</em> with no-instrumentation data collection, allowing you to debug in minutes. No need to update, recompile, or <em>deploy</em> your <em>apps</em> - it just works. (Join"
      },
      "id": "6042d15ce7b9d2c6cc579a0e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Figure8-e1570028252480.png",
      "url": "https://newrelic.com/blog/best-practices/what-is-serverless-architecture",
      "sections": [
        "What is serverless architecture?",
        "What are the advantages of using serverless architecture?",
        "Decomposing drives better observability",
        "Serverless is event-based",
        "Faster deployments, greater flexibility, and accelerated innovation",
        "Reducing architecture costs",
        "Focusing more on UX",
        "What are the limitations of using serverless architecture?",
        "Long-running application inefficiencies",
        "Third-party dependency",
        "Cold starts",
        "Is serverless architecture for you?",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:29Z",
      "title": "What Is Serverless Architecture? Key Benefits and Limitations",
      "updated_at": "2021-04-13T23:36:03Z",
      "type": "",
      "external_id": "e2071d6d8b01e362ac308565b88598fce2d04ac3",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Cloud What Is Serverless Architecture? Key Benefits and Limitations Aug 28, 2020 • 6 min read By Nočnica Fee As organizations and their technology ecosystems mature, they often find that managing architecture is a challenge. Rather than becoming professionals at managing a platform, software teams would rather devote their time and resources to applications and development. The new alternative is serverless architecture. But what is serverless architecture? And is it the right move for you? What is serverless architecture? Serverless architecture describes a way for companies to build and run applications but not have to manage infrastructure. It provides a way to remove architecture responsibilities from your workload, including provisioning, scaling, and maintenance. Scaling can be automatic, and you only pay for what you use. Since the development of this new technology, we’ve seen substantial growth through Amazon Web Services (AWS). A recent O’Reilly survey found that 40 percent of organizations adopted serverless architecture. The main reasons behind the adoption include reduced costs, scalability, developer productivity, and more, per the chart below. Image courtesy of OReilly.com. Not everyone is ready to go all-in with serverless. The study found concerns around security, fear of the unknown, and not having the right staff. That last concern deserves to be highlighted: even though serverless should be “easier,” it still takes team expertise to be competent in a new tool. Let’s look specifically at the benefits and limitations of serverless architecture. What are the advantages of using serverless architecture? The leading advantage is that your developers can focus their attention on product development. They no longer have to account for managing and operating servers. Components like network configuration or the physical security of your servers are handled by the vendor rather than your team. Many other benefits come from serverless architecture as well. Decomposing drives better observability With serverless, you break down applications into smaller and smaller pieces, known as decomposition. By doing so, you’ll gain better observability across the application. With smaller pieces, the knowledge necessary to make changes or create fixes is smaller. Serverless is event-based Serverless uses an event-based system versus stream-based. With event-based architecture, each subpart of the application is independent. Events trigger one another. In stream-based, there are connections to each service. If there is a failure, it just impacts that event, not the entire log. Faster deployments, greater flexibility, and accelerated innovation Speed is often a contributing factor in choosing to use a serverless architecture. You can rapidly deploy apps in hours because there’s no infrastructure construction to weigh you down. With faster deployments also comes ease in scalability. By using such an agile architecture, you can be very flexible in your releases. Because it’s a quicker process, you can accelerate innovation. This flexibility is especially valuable in situations where pivoting is urgent. These types of scenarios are playing out all over the world in response to the pandemic. Organizations have to change their focus to meet emerging needs. This could be internal with a move to remote work. Another example is the adoption of customer-facing applications like those of retailers and restaurants. Reducing architecture costs Being serverless, an organization is essentially outsourcing server and database management. You are no longer responsible for the huge investments required for internal architecture administration. Ultimately your use case will define how much you can save. Focusing more on UX If your applications have end users, which they probably do, they have high expectations around digital experiences. If architecture is no longer a concern, it leaves more time to work on the user experience (UX). You can’t afford to not invest in the user interface, so serverless can provide you with a way to reallocate resources. What are the limitations of using serverless architecture? Serverless architecture isn’t perfect. It’s still an evolving architecture, leaving some not ready to adopt. Long-running application inefficiencies Running workloads, which are long-running, could be more costly on serverless. Using a dedicated server is often more efficient. Third-party dependency Serverless architecture requires you to be reliant on your provider. You don’t have full control, and changes may impact you without notice. The platform’s availability is subject to its terms. Cold starts A “cold start” occurs when a platform must initiate internal resources. It may take some time for your serverless architecture to handle that first function request. You can avoid a “cold start” by ensuring the function remains in an active state. You do this by sending requests to it periodically. Is serverless architecture for you? Serverless architecture is just one more option for deploying applications. Being able to monitor and troubleshoot serverless is also critical. Explore how we make this possible with New Relic Serverless for AWS Lambda. Get a serverless overview and a free trial. Related Topics Cloud By Nočnica Fee Nočnica Fee is a Dev Advocate for New Relic specializing in serverless. She's a frequent contributor to The New Stack and Dev.to. In her downtime, she enjoys drum machines and woodworking. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 42.747047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Faster <em>deployments</em>, greater flexibility, and accelerated innovation",
        "body": ", not the entire log. Faster deployments, greater flexibility, and accelerated innovation Speed is often a contributing factor in choosing to use a serverless architecture. You can rapidly <em>deploy</em> <em>apps</em> in hours because there’s no infrastructure construction to weigh you down. With faster deployments also"
      },
      "id": "60762ae3196a675ccd64a76a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/deployment_marker_service_map.jpg",
      "url": "https://newrelic.com/blog/best-practices/distributed-monolith-vs-microservices",
      "sections": [
        "Question 1: Does a change to one microservice require changes to or deployments of other microservices?",
        "Question 2: Are your microservices overly chatty?",
        "Question 3: Do several microservices share a datastore?",
        "Question 4: Do my services scale dynamically?",
        "Be honest in your answers",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:29Z",
      "title": "Distributed Monolith vs. Microservices Architecture: 4 Ways New Relic Can Tell You Which Is Which",
      "updated_at": "2021-04-14T00:47:16Z",
      "type": "",
      "external_id": "f0804c58a20b23addd0db35e199e9b1e0dbd27fa",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Cloud Distributed Monolith vs. Microservices Architecture: 4 Ways New Relic Can Tell You Which Is Which Jun 19, 2018 • 7 min read By Chris McCarthy As more and more software organizations adopt DevOps processes and culture, a major initiative they commonly undertake is breaking their monoliths into microservices. However, even after organizations have put in a considerable amount of work, it sometimes turns out that these monoliths weren’t actually turned into collections of microservices so much as they became “distributed monoliths.” In You’re Not Actually Building Microservices (a post that inspired me to write this one), SimpleThread’s Justin Etheredge writes that a distributed monolith is the “worst of all worlds. You’ve taken the relative simplicity of a single monolithic codebase, and you’ve traded it in for a deeply intertwined distributed system.\" So, how do you tell if you actually have a true microservices architecture or just a distributed monolith? Let’s walk through four questions to see how New Relic can help you find out. Keep in mind, though, that while these questions will give you insight into the true nature of your systems, the final answer may not always be clear-cut exceptions—after all, modern software is nothing if not complicated. Question 1: Does a change to one microservice require changes to or deployments of other microservices? A major benefit of microservices is the decoupling of development and deployment. In a true microservices architecture, a team can make changes (within reason) to the service they own without having to communicate those changes to other upstream or downstream teams responsible for other services. If your team does synchronized deployments or creates pull requests across multiple services to make a change to your service, you’re not really running decoupled microservices. A examination of your deployment processes or version control strategy can provide an immediate answer to this question. You can also get a good idea of service interdependencies by looking at deployment markers in New Relic service maps. Application deployment markers shown in a service map If you see deployment markers lining up across the multiple services in your map, you haven’t effectively decoupled your services. To monitor deployment dependencies in New Relic Insights, record your deployments as custom events using the New Relic rest API (v2) and insert those custom events via the Insights API. Then build an NRQL query to create a widget for your Insights dashboard. If your widget shows spikes of many deploys occurring simultaneously, that’s a sign of poor decoupling. Ideally, in a microservice architecture, you deploy apps using continuous integration and continuous delivery (CI/CD), in which case the graphs in your widget will appear chaotic, rather than organized. Question 2: Are your microservices overly chatty? Each microservice should have a clearly defined purpose that it can execute with minimal communication with other services. If you see a service that has to send many back-and-forth requests to the same downstream services, that’s a red flag. Use New Relic APM to look at the central service in question and examine its interaction with external services. APM external services page A distributed monolith can actually perform pretty well, and may never experience significant issues with response times. With that in mind, we typically want to examine services by highest throughput. If the number of calls per minute (cpm) for a given external service is greater than the throughput of the application itself by a large factor, you most likely have not decoupled your services. You can also investigate this on a per-transaction level in APM. The same logic applies here—if the average calls per transaction is greater than 2 or 3 calls per external service, that’s a good sign of “chattiness” and poor decoupling. APM Breakdown table showing per-transaction external calls For larger and more complex environments, use New Relic Insights to monitor external call counts across all your applications. To create a widget to track external calls made by each of your applications over time, use this NRQL query: SELECT average(externalCallCount) FROM Transaction FACET appName SINCE 1 week ago TIMESERIES To create a widget to track all external calls made by each of your applications, use this NRQL query: SELECT max(externalCallCount) FROM Transaction FACET appName SINCE 1 week ago It’s important to remember that some microservices (such as payment gateways) can record a lot of external calls because of the function they perform. If you identify such services in your environment, just filter them out in the NRQL queries for these widgets: SELECT max(externalCallCount) FROM Transaction WHERE appName != “name-of-payment-gateway” FACET appName SINCE 1 week ago Question 3: Do several microservices share a datastore? Even a set of microservices that appears to be well separated can fall prey to this problem. It’s typical that most of a monolith’s services will use the same datastore. But this should not be the case in a distributed microservices architecture. In a microservices architecture, shared datastores create deployment problems and database contention issues; and schema changes can create problems for the services communicating with the database. Therefore, each service should have its own datastore. As with tracking interdependent deployments for services, you can use service maps to discover the dependencies between services and datastores. Service map showing one datastore per app In this case, we see that each service in our WebPortal app has its own datastore. This greatly simplifies deployment and data management for each service. With New Relic, you can monitor your databases using New Relic Infrastructure on-host integrations. If, for example, your application is running in Amazon Web Services (AWS) and uses the Amazon Relational Database Service (RDS), you can use New Relic’s AWS RDS integration to monitor this information and create a widget using this NRQL query: SELECT uniqueCount(appName)/uniqueCount(entityName) as 'Applications per Datastore' FROM DatastoreSample,Transaction SINCE 1 week ago (Note that the DataStoreSample datatype in this example is unique to AWS RDS. If you’re hosting your services in Microsoft Azure, for example, you could use an Azure monitoring integration and the AzureSqlDatabaseSample datatype. Or see the Infrastructure integrations documentation for other databases we integrate with.) Question 4: Do my services scale dynamically? One of the main reasons to use microservices is to isolate bottlenecks to small units that may be scaled independently as needed, rather than having to scale your entire architecture. A healthy microservices deployment should be very dynamic, with throughput swings resulting in non-uniform scaling across the services. For example, for a spike in global throughput, I’d expect to see certain applications (the bottlenecks) scaling up more rapidly than, say, a payment gateway service that serves as a request router and includes little logic. You can use Insights to determine if your services do scale dynamically. A couple of widgets that monitor throughput per application and hosts per application are a good way to start. To create a widget to track throughput per application, use this NRQL query: SELECT count(*) FROM Transaction FACET appName TIMESERIES since 1 month ago To create a widget to track hosts per application, use this NRQL query: SELECT count(*) FROM Transaction FACET host TIMESERIES since 1 month ago In a full microservices architecture, you should see spikes in services populating on hosts correspond to spikes in throughput on individual services, which would indicate dynamic scaling of services. If instead you see corresponding spikes across all services and hosts, this is good indication that your services aren’t truly decoupled. Be honest in your answers If your system is able to cleanly pass all these checks, it may very well be a fully functioning microservices architecture. If one or more of these questions raise red flags for you, however, it may be time to re-evaluate or redesign your approach to properly tame the complexity of microservices. This programatic shift requires that you not only build this architecture piece by piece but that you also never stop developing it. Related Topics Cloud By Chris McCarthy Chris McCarthy is a solutions engineer at New Relic. He began his career as a backend and performance engineer and now uses his background to advise New Relic customers in their cloud migrations or their cultural shifts to DevOps. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 36.265785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Question 1: Does a change to one microservice require changes to or <em>deployments</em> of other microservices?",
        "body": ", that’s a sign of poor decoupling. Ideally, in a microservice architecture, you <em>deploy</em> <em>apps</em> using continuous integration and continuous delivery (CI&#x2F;CD), in which case the graphs in your widget will appear chaotic, rather than organized. Question 2: Are your microservices overly chatty? Each"
      },
      "id": "60763b94196a67d93664a76b"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 36.190956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #5)",
        "sections": "<em>Subscribe</em> to <em>applications</em> with the New Relic One Catalog",
        "body": " Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to <em>subscribe</em> applications to accounts and subaccounts. Click <em>Add</em> the <em>app</em> to <em>add</em> the application to the account you wish to grant access. If your team changes, and you need"
      },
      "id": "60762e1f64441fbf2e9d856e"
    }
  ],
  "/collect-data/custom-events": [
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "Important",
        "General requirements",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "ee49e0ca9bf17447e8349123bfb470ff9964c4fe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-04-16T15:03:36Z",
      "updated_at": "2021-03-30T06:37:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.3504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "sections": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " <em>Event</em> <em>API</em> (There are additional requirements when using the <em>Event</em> <em>API</em>.) Browser monitoring <em>agent</em> <em>APIs</em> (There are additional requirements with the <em>custom</em> PageAction <em>event</em>.) Mobile monitoring SDK General requirements When reporting <em>custom</em> <em>events</em> and attributes, follow these general requirements"
      },
      "id": "6043ef69e7b9d2da1f5799f8"
    },
    {
      "sections": [
        "Report custom event data",
        "Important",
        "Value from custom events and attributes",
        "Avoid rate limits",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "title": "Report custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9c787cb83d5d7d1722bcbec25f4eb8698f5be6e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-custom-event-data/",
      "published_at": "2021-04-16T11:54:20Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. New Relic products report a variety of default event data to your account. This document explains how to report your own custom events and attributes. Value from custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. By reporting custom events, you can create more useful and customized queries and charts of your data. This is a key part of optimizing how New Relic works for you. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.31218,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>custom</em> <em>event</em> data",
        "sections": "Value from <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " policy. Send <em>custom</em> <em>events</em> and attributes Methods for sending <em>custom</em> <em>events</em> and attributes include: Source How to send <em>custom</em> data APM <em>agent</em> Use APM <em>agent</em> <em>APIs</em> to report <em>custom</em> <em>events</em> and <em>custom</em> attributes. Browser monitoring <em>agent</em> Add <em>custom</em> attributes to the PageView <em>event</em> via the Browser <em>API</em> call"
      },
      "id": "6043f0b1196a67451d960f86"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Important",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9a5edf6068acc3b7187d217bd7932f0478e5467c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-04-16T15:03:37Z",
      "updated_at": "2021-03-30T06:37:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.64064,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " using the <em>Event</em> <em>API</em> (without need for APM). However, be aware that <em>custom</em> <em>events</em> sent with the <em>agent</em> <em>APIs</em> are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding <em>custom</em> data with the APM <em>agent</em> <em>API</em>. Or, go directly to the full online course"
      },
      "id": "603ecece28ccbcc865eba7a0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Important",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute Browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "cabf27e5367fcf6473d105983c030b653e3bd9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-04-16T14:02:57Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the Browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Subscription level This feature requires a Browser Pro subscription. The instrumentation level setting for an application does not affect the availability of JavaScript API functions. Agent version Your New Relic Browser agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 60 events per 30-second harvest cycle, per browser. After the 60-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the Browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default Browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute Browser API call To add a custom attribute to the PageView event via the Browser agent, use the setCustomAttribute Browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual Browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.0553,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " add to the PageView <em>event</em> are also automatically added to the PageAction <em>event</em>. There are two ways to add <em>custom</em> attributes to the PageView <em>event</em>: Use set<em>Custom</em>Attribute Browser <em>API</em> call To add a <em>custom</em> attribute to the PageView <em>event</em> via the Browser <em>agent</em>, use the set<em>Custom</em>Attribute Browser <em>API</em>"
      },
      "id": "6043ebbee7b9d227105799b2"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Important",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations",
        "Deprecated methods"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "dba656da4a2978b01b6647a4a0011d08e6b9c4a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-04-16T15:40:11Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default Mobile events using the New Relic Mobile SDK. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple Mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the Mobile crash event trail. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default Mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations. Deprecated methods As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create custom events. The recordEvent methods for Android and iOS are deprecated. The deprecated recordEvent events do not have their own event type; they are recorded as a Mobile event type with a category attribute value of custom. recordCustomEvent creates an event with an eventType you can assign. But the eventType should only be used for one or two high-level event types, not for naming events. For example, you might have one event type Gestures, with many different names under that one type. For more context on this, see the recordCustomEvent query example.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.0553,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " and MobileHandledException <em>events</em>. These <em>events</em> are available for querying and also displayed in the Mobile crash <em>event</em> trail. For more on creating <em>custom</em> attributes and <em>custom</em> <em>events</em>, see: Android SDK <em>API</em> guide iOS SDK <em>API</em> guide NRQL query examples MobileRequestError examples MobileRequest examples Limits"
      },
      "id": "6043ee0de7b9d21975579a25"
    }
  ],
  "/try-our-apis": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/graphql_aws_services-1024x593.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/graphql-api",
      "sections": [
        "Using GraphQL in New Relic",
        "Example 1: Querying Infrastructure cloud integrations with NerdGraph",
        "Example 2: Modifying integration configurations with NerdGraph",
        "Transfering NerdGraph data to the terminal",
        "New Relic and GraphQL—easing the path for developers"
      ],
      "published_at": "2021-04-16T04:24:43Z",
      "title": "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "381e6b1a3bca81ebc8b6efc8199d2b75983befca",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read By Mark Weitzel As you build observability into your workflows and processes, you need the ability to quickly retrieve, sort, and process all kinds of telemetry through APIs. With New Relic, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous API operations. With the NerdGraph API explorer—built on GraphQL—you can more easily query the data you need, without over-or under-fetching, and reduce manual toil in your data analysis workflows. More specifically, in New Relic you can use NerdGraph to: Query all the entities associated with your account Query, create, and update the workloads associated with your account Create, manage, and add tags to entities Query distributed tracing data Fetch data when building a New Relic One application Understand upstream and downstream relationships with your services Configure your New Relic Infrastructure cloud integrations Query event data and custom event data with NRQL In this post, I’ll walk through two examples using NerdGraph to query information about New Relic Infrastructure cloud integrations and update their configuration values. But first a bit of history. Using GraphQL in New Relic Unlike typical REST APIs that often require loading from multiple endpoints, GraphQL provides a single endpoint that can manage complex queries so developers can get all the data their app needs from many services in one request. GraphQL is strongly typed, which allows developers to explicitly declare what information is available via queries to the GraphQL service. This declaration is done via a GraphQL schema. Schemas give developers the flexibility they need to express information about the data they return. For example, each field has a description, which developers can use to indicate the proper usage of the data. Schemas also provide the API blueprint developers need to build tools for properly constructing queries and guiding proper usage of any returned data. For example, developers can use the schema to indicate if a field has been deprecated so tools like IDEs can surface this fact and discourage use of that data. And “schema stitching”—creating a single schema from several underlying GraphQL APIs—allows developers to deliver a unified access experience across all of their APIs, as we’ve done at New Relic: The New Relic GraphQL implementation includes several underlying GraphQL APIs—including accounts, Infrastructure, and the New Relic database (for constructing NRQL queries). For more information on GraphQL, the following examples of querying cloud integration configuration data use GraphQL queries and mutations: Queries: GraphQL requests that only fetch data Mutations: GraphQL requests that modify and fetch data NerdGraph has a single endpoint: https://api.newrelic.com/graphiql. This launches (after authenticating the user) the NerdGraph API interface—an interactive, browser-based IDE for running GraphQL requests. In the NerdGraph API explorer, you build and run your query on the left, and the result is returned on the right. You can click into fields to drill into their definitions. For example, if you drill into actor, you’ll see it contains fields for user and accounts: { actor { user { name email } accounts { id name } } } The fields under actor expose data from different downstream services that are unified in the GrahQL schema delivered by the GraphQL server. When you issue a query, the GraphQL server pulls apart the query and invokes a resolver for each of the services. When the queries complete (or time out or encounter errors), the GraphQL server assembles the result and returns it to you. In the example above, we get information about the user and all the accounts that they have access to. Let’s walk through our examples to show the full power of GraphQL’s data collection capabilities. Example 1: Querying Infrastructure cloud integrations with NerdGraph In my first example, I’ll use NerdGraph to query for various data about the AWS integrations that are running in my New Relic account. I’ll use the data I gather in this example to update some specific settings in the next section. Tip: If you’re planning on following along, make sure you generate an API key that you can use with New Relic’s GraphQL API. In fact, you can generate one directly from NerdGraph. Let's start with a list of the AWS integrations I have available in New Relic Infrastructure: AWS integrations installed in New Relic Infrastructure. Next, let's retrieve some information about these AWS services via a GraphQL query. I’m going to query for the cloud provider (in this case, AWS) that’s linked to my account and the set of integrations from AWS that I’ve installed. To do this, I need to pass the ID of the account I want to query—this is the account(id: MY ACCOUNT ID) part of the query. Notice that I’m “nesting” requests to get information about the cloud provider and the integrations I’m using. If I were using a REST API, this would require multiple calls, but with the GraphQL API, I can gather this information with just one query.   { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { id name slug } integrations { id name service { id slug name createdAt updatedAt provider { name id } } } } } } } } When the query completes, the GraphQL server assembles the results about the AWS integrations I’ve installed, as shown below (note that I’ve truncated the example): { \"data\": { \"actor\": { \"account\": { \"cloud\": { \"linkedAccounts\": [ { \"authLabel\": \"arn:aws:iam::8xxxxxxx7:role/NewRelicInfrastructure-Integrations-Origami\", \"externalId\": \"8xxxxxxx7\", \"id\": 3542, \"integrations\": [ { \"id\": 75540, \"name\": \"RDS\", \"service\": { \"createdAt\": 1470991744, \"id\": 3, \"name\": \"RDS\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"rds\", \"updatedAt\": 1534242454 } }, { \"id\": 14233, \"name\": \"S3\", \"service\": { \"createdAt\": 1470991745, \"id\": 4, \"name\": \"S3\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"s3\", \"updatedAt\": 1534242454 } }, { \"id\": 12223, \"name\": \"Lambda\", \"service\": { \"createdAt\": 1477910055, \"id\": 14, \"name\": \"Lambda\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"lambda\", \"updatedAt\": 1534242454 } }, { \"id\": 172534, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 } }, } } ] } } } } } But what if I want more specific information about one of the integrations? Specifically, I want to see what tags (user-defined metadata) I’ve applied to a particular integration as well as its metrics polling interval (how often New Relic polls the integration for data), and when these settings were last updated. To do this, I’ll need to use one of the more nuanced features of GraphQL—interfaces, an abstract type that represents a collection of common fields that other object types can implement. So in my original query, I’ll add two new clauses: ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } Now, if my query hits a result that is of type CloudDynamodbIntegration or CloudReshiftIntegration, it also return the fields metricsPollingInterval, tagKey, tagValue, and updatedAt. Here's what my (truncated) query will like now: { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { ... } integrations { id name service { ... } } ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } } } } } } In the result, notice that the DynamoDb and Redshift configuration information contain the extra fields that I specified in the query using their interfaces. { \"id\": 173397, \"metricsPollingInterval\": 900, \"name\": \"Redshift\", \"service\": { \"createdAt\": 1497364366, \"id\": 21, \"name\": \"Redshift\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"redshift\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1544435410 }, { \"id\": 112183, \"metricsPollingInterval\": 900, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1549499902 }, OK! I’ve successfully queried information about my AWS integrations in New Relic Infrastructure, and I’ve used an interface to get additional information about a specific integration. Now, I’ll use the GraphQL API to update the metrics data polling intervals in one of these integrations. Example 2: Modifying integration configurations with NerdGraph In GraphQL, when you modify data with a write operation, it’s called a mutation. In this example, I’ll build a mutation to update the polling intervals of an AWS integration. First, though, I’ll set a polling interval so that we'll notice when I change it with NerdGraph. Here are the configuration options for my AWS DynamoDB integration: DynamoDB integration configuration options in New Relic Infrastructure. As you can see, I’ve set the metrics data and inventory data polling intervals to every 5 minutes, and I’ve also toggled Collect tags to ON. Now I’ll build the mutation query. First, I'll start with the keyword mutation, and like any GraphQL API request, enclose it in a pair of curly braces,{ }. Next, I want to specify that I’m configuring a cloud integration; so I’ll add cloudConfigureIntegration, which takes two arguments: accountId and integrations. For accountId, I’ll use the same account id from the first example to get information about the Infrastructure-linked accounts. The second argument is the integrations that I want to update. Again, integrations are specified by cloud provider, so here I want to include aws. So far my mutation looks like this: mutation{ cloudConfigureIntegration( accountId:MY ACCOUNT ID integrations:{aws I want to specify that I’m updating the configuration for DynamoDB, so I’ll pass in an object with dynamodb as the key and an array that contains objects with the values I want to to set. Remember, for our mutation, we want to update the metricsPollingInterval (valid values are 300, 900, 1800, and 3600 seconds) and add a tagKey (metadata about the function of the integration). The final part of the mutation adds a set of fields to return if my request is successful and a set of fields to return if there are any errors. Here's the full query: mutation{ cloudConfigureIntegration( accountId:630060 integrations:{aws:{ dynamodb:[ { linkedAccountId:4912 metricsPollingInterval:1800 tagKey:\"mdw-test\" }] } } ) { integrations{ id name updatedAt ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } errors{ linkedAccountId message integrationSlug } } } And here’s the result, which shows no errors and indicates DynamoDB’s configuration was successfully updated: { \"data\": { \"cloudConfigureIntegration\": { \"errors\": [], \"integrations\": [ { \"id\": 177184, \"metricsPollingInterval\": 1800, \"name\": \"DynamoDB\", \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1551139957 } ] } } } I can now return to New Relic Infrastructure and refresh the DynamoDB configuration page: Refreshing the DynamoDB configuration in New Relic Infrastructure. Our mutation changed the metric polling interval from 300 seconds (5 minutes) to 1800 seconds (30 minutes), and entered tag key value of mdw-test. That's it! I've successfully updated the configuration of a New Relic Infrastructure integration using NerdGraph. Transfering NerdGraph data to the terminal So, now you know how to explore the New Relic data available to you in NerdGraph, and you know how to create queries and mutations, but how do you transfer this data to your code? To capture code-ready queries and mutations, select the Tools drop down in the NerdGraph explorer. To copy a curl statement with the in-scope query to your clipboard, select Copy as CURL. Paste this code snippet into your terminal, or use it to populate an HTTP request in your code. If you’re working with the New Relic CLI, select Copy as New Relic CLI from the drop down to generate a command-line ready query or mutation. New Relic and GraphQL—easing the path for developers As these examples show, GraphQL is extremely flexible and lightweight, and dramatically reduces the overhead of working with your New Relic data. If you want to challenge yourself even more, create some more complex queries in the Query Builder. For example, can you create a query to grab the count of all of your reporting entities? Hint: check out NerdGraph’s entity search field. We’re passionate about making life for developers as easy as possible. Check out the resources available at developer.newrelic.com, and engage in the discussion with fellow developers on the Explorer’s Hub. By Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 573.88025,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Started With <em>NerdGraph</em>—The <em>New</em> <em>Relic</em> <em>GraphQL</em> <em>API</em> Explorer",
        "sections": "Using <em>GraphQL</em> in <em>New</em> <em>Relic</em>",
        "body": " to quickly retrieve, sort, and process all kinds of <em>telemetry</em> through <em>APIs</em>. With <em>New</em> <em>Relic</em>, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous <em>API</em> operations. With the <em>NerdGraph</em> <em>API</em> explorer—built on <em>GraphQL</em>"
      },
      "id": "6076314c64441f483e9d8576"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/16x9_600w/public/2021-04/iStock-842120096-2-min_6.jpg?h=77039d24&itok=FcAtK923",
      "url": "https://newrelic.com/blog/authors/mark-weitzel",
      "sections": [
        "Mark Weitzel",
        "All Posts From Author",
        "New Capabilities to Extend Development On New Relic One",
        "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
        "New Relic One: The First Programmable Observability Platform"
      ],
      "published_at": "2021-04-16T04:25:53Z",
      "title": "Mark Weitzel | New Relic",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "af07ee0bdcb27ea325c9c5262f7f935b4865f7cd",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. All Posts From Author Extend New Relic New Capabilities to Extend Development On New Relic One Mar 30, 2020 • 4 min read Read the article How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read Read the article Extend New Relic New Relic One: The First Programmable Observability Platform Sep 19, 2019 • 9 min read Read the article Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 479.00458,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mark Weitzel | <em>New</em> <em>Relic</em>",
        "sections": "Getting Started With <em>NerdGraph</em>—The <em>New</em> <em>Relic</em> <em>GraphQL</em> <em>API</em> Explorer",
        "body": " the article How to <em>Relic</em> Getting Started With <em>NerdGraph</em>—The <em>New</em> <em>Relic</em> <em>GraphQL</em> <em>API</em> Explorer Jun 11, 2020 • 12 min read Read the article Extend <em>New</em> <em>Relic</em> <em>New</em> <em>Relic</em> One: The First Programmable Observability <em>Platform</em> Sep 19, 2019 • 9 min read Read the article Company Careers and Culture Partner Program Investor"
      },
      "id": "60762e1e64441fc25b9d854d"
    },
    {
      "sections": [
        "NerdGraph cloud integrations API tutorial",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph cloud integrations API tutorial",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-04-16T14:50:03Z",
      "updated_at": "2021-04-12T04:27:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to https://api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } }</integration_slug></provider_slug> Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } }</integration_slug></provider_slug> Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 475.92142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> cloud integrations <em>API</em> tutorial",
        "sections": "<em>NerdGraph</em> cloud integrations <em>API</em> tutorial",
        "tags": "<em>APIs</em>",
        "body": "This document provides examples of how to use <em>New</em> <em>Relic</em> <em>NerdGraph</em> to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud <em>Platform</em> (GCP). Using the <em>NerdGraph</em> Graphi<em>QL</em> explorer, you can also query NRQL data. These examples for querying"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/muting_alerts4-1024x788.png",
      "url": "https://newrelic.com/blog/nerdlog/muting-rule-new-relic-alerts",
      "sections": [
        "What is a muting rule?",
        "How muting rules work",
        "How to set up a muting rule",
        "Creating complex rule filters",
        "Creating and managing muting rules with NerdGraph",
        "Try it now!"
      ],
      "published_at": "2021-04-16T04:26:20Z",
      "title": "Muting Rules Now Available in New Relic Alerts",
      "updated_at": "2021-04-13T23:56:45Z",
      "type": "",
      "external_id": "dbbcbffafdf0cbc54b4bd8b29149919115187a5f",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog Muting Rules Now Available in New Relic Alerts Jun 8, 2020 • 7 min read By Brian Goleno During times of planned system disruptions, a steady stream of noisy, unnecessary alerts can be a major distraction. You need to find a balance that allows you to filter out the noise yet still maintain observability and alerting on the rest of your system. With muting rules in New Relic Alerts, you can silence notifications during planned disruptions like maintenance windows, deployments, and testing. By applying muting rules, you’ll minimize the risks of overmuting by creating rules that identify violations using all of the contextual metadata we know about the entity and signal, which provides more depth than merely enabling or disabling alert conditions. This way, you can target your system’s specific subsets that are being affected by planned disruptions. Additionally, by keeping alert conditions running but silent during these periods, you can continue to observe when entities have recovered from maintenance and have returned to a healthy state. You create and manage muting rules using either New Relic Alerts UI or the NerdGraph API explorer. What is a muting rule? A muting rule overrides alert policies and conditions you’ve defined in New Relic, so you can suppress notifications during times of known system disruptions. A muting rule contains a set of conditions that match a large number of attributes and tags present in a violation event, including: Alert policy and condition names Application and service names Host names AWS tags Kubernetes tags Any other tags associated with your entities or open telemetry How muting rules work Muting rules tell New Relic how to identify individual violations after they are created, but before an incident is opened. They override the default life cycle of an alert to indicate that it should not send notifications. With muting rules, your normal alert incident life cycle is maintained; the only change is whether or not an incident triggers a notification. Violations and incidents are still opened, and health indicators show the current state of your entities as you progress through your maintenance window. When the conditions defined in a muting rule match a violation event, the violation is marked as “muted.” When a violation is muted, the incident life cycle is modified in the following ways: When a muted violation opens an incident, an “open incident” notification will not be sent. If any other violation that is not muted is associated with that incident, then an “open incident” notification will be sent. If an incident sends an “open incident” notification, then all subsequent events will trigger notifications. If an incident never sent an “open incident” notification, then subsequent events will not trigger notifications. (Tip: You can find a detailed workflow chart in the docs.) Enterprise-scale issue detection and incident management require flexibility and automation. Muting notifications is the first in a series of life cycle override actions that we will be releasing this year, including allowing you to schedule muting. All of these controls will be manageable through our API and UI. How to set up a muting rule Muting rules are available to everyone using New Relic. To set up a muting rule: Navigate to  New Relic One > Applied Intelligence. From the left-hand navigation, select Muting rules. The Muting rules page in New Relic One. Note: Since New Relic One is a cross-account experience, the Muting rules page lists all muting rules that exist across all of the accounts to which you have access. However, a muting rule currently only operates in one account at a time. Set up your rule: Click Add a Rule. Choose a name and description, and select the appropriate account. Build a violation filter to set conditions that describe the criteria used to match the attributes of a violation object. Enable the rule when you are ready for it to be active. Set up your muting rule and enable it when you are ready for it to be active   You can view violations and incidents that have been muted in New Relic Alerts. Creating complex rule filters Use complex rule filters for greater precision when muting alerts. For example, if your maintenance only touches specific hosts within a cluster, a subset of services on a host, or if you’re making updates to a data center or availability zone that affects a large number of separately monitored services, complex rule filters can help ensure you only mute the relevant alerts. Create complex rule filters by combining sets of matching conditions. Filters can either use operators like or or and to combine conditions, and most attribute evaluations can accept an array of possible values. Creating a complex filter for a muting rule. Creating and managing muting rules with NerdGraph NerdGraph is an interactive, browser-based IDE for running GraphQL requests. With NerdGraph, you can create and manage muting rules, and perform the same advanced functions available in the UI, including creating muting rules for specific hosts or products and fetching rules for a specific account. Find multiple NerdGraph API examples in the documentation. Try it now! The ability to mute notifications is one way we give you more control over your monitoring and help reduce alert fatigue. If you’re ready to give it a try, sign up for a trial and get started for free. By Brian Goleno Brian Goleno is a Sr. Product Manager in the Applied Intelligence group at New Relic. Brian has been a product manager in the SaaS-based monitoring and observability space for over five years, and has been with New Relic for the past two years. Brian is currently focused on accelerating New Relic’s issue detection capabilities and supporting the New Relic One platform. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 471.37415,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting Rules Now Available in <em>New</em> <em>Relic</em> Alerts",
        "sections": "Creating and managing muting rules with <em>NerdGraph</em>",
        "body": " either <em>New</em> <em>Relic</em> Alerts UI or the <em>NerdGraph</em> <em>API</em> explorer. What is a muting rule? A muting rule overrides alert policies and conditions you’ve defined in <em>New</em> <em>Relic</em>, so you can suppress notifications during times of known system disruptions. A muting rule contains a set of conditions that match a large"
      },
      "id": "60762fbd196a6709bb64a784"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/docs_code1.png",
      "url": "https://newrelic.com/blog/how-to-relic/docs-as-code-docs-in-code",
      "sections": [
        "When words in code are forgotten",
        "How the Product Language team contributes to docs in code",
        "Help us do docs in code"
      ],
      "published_at": "2021-04-16T00:17:38Z",
      "title": "Docs As the Code, Docs In the Code At New Relic",
      "updated_at": "2021-04-14T00:08:55Z",
      "type": "",
      "external_id": "b02a91dc068f658f050710d3a7b63284fa9e8f2b",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Docs As the Code, Docs In the Code At New Relic Aug 25, 2020 • 6 min read By Fabrizio Ferri-Benedetti func (c *Command) Run() (string, error) { // set the locale BLAAARGH — An old comment in our source code   Software is made of words. Some words, such as UI text or command-line messages, are for human-computer interaction; some, like API calls and error codes, target other software; and some form the documentation—README files, user guides, online help, and more. The vast majority of words in software, though, are its source code: those words that make it run. Code, too, contains human-readable text. Consider any piece of software: Whatever the programming language (except maybe Malbolge and its esoteric companions), chances are that you'll find plenty of meaningful and useful words in the source: Embedded reference docs, which can be used to build docs automatically (for example, GoDoc, Javadoc, GraphQL, and OpenAPI) String literals, from log messages to errors to input prompts Examples and comments in configuration files Names of CLI commands, variables, functions, and methods Comments in the source code (like the one I quoted above) Now that we’ve made our software open source, the idea of docs in our code has even greater importance to us. When words in code are forgotten If code isn't documented, it doesn't exist. In many cases, code may lack embedded documentation, making it hard for developers to understand how it works or is intended to be used. But that's not the only thing that can go wrong: Undocumented API schemas result in poor user experiences when loaded into API explorers; configuration files without comments are hard to tweak, and badly-written errors can make troubleshooting needlessly difficult. Plenty can go wrong when software lacks embedded documentation. At the end of the day, our software is also measured by the quality of its words, the way it speaks to users, and how well it’s documented. Great docs unlock a great developer experience. If we expect our dev community to pull our code and enrich it, we should ensure it’s well commented and documented. How the Product Language team contributes to docs in code It’d be a long blog post if I detailed every bit of our work, so here are a few recent examples of docs-in-code work that the Product Language team has accomplished: In preparation for the open source release of the Infrastructure agent, we reviewed the entire code base for typos, formatting issues, forbidden words, and sensitive information in code comments. At the same time, we fixed capitalization issues and grammar in the CLI and debug messages, and edited the README. We regularly edit NerdGraph GraphQL schemas for embedded documentation. Docs in schemas are key to good GraphQL experiences; see, for example, the screenshot below: All fields have basic reference documentation. The same applies to OpenAPI specifications for REST APIs. We also write and edit comments in sample configuration files that help users install our agents and integrations faster. The sample configuration file for the Windows services integration, for instance, provides a brief explanation that builds on the existing documentation, so that users in a hurry can still get some guidance even if they skip our docs. # To include services, create a list of filters to be applied to the service names. # Services that find a match with any of the matching lists are included. By default, # no service is included. # # Currently, only windowsService.name metadata is supported for filtering. # Prepend \"regex\" to indicate that the pattern is a regular expression. # include_matching_entities: windowsService.name: # - regex \"^*$\" # - \"ServiceNameToBeIncluded\" Help us do docs in code We’re dedicated to bringing clear, concise, and thoughtful documentation to our open source projects—from our agents to New Relic One applications to our open source and developer sites. If you have any questions or needs concerning the docs you encounter in our code, don't hesitate to reach out to us in the appropriate repo with a comment or pull request. Happy docs-as-coding! By Fabrizio Ferri-Benedetti Fabrizio Ferri-Benedetti is a Senior Product Language Writer based in Barcelona, Spain. He loves writing and technology. A cognitive psychologist by training, he jokingly refers to himself as “computer shrink.” Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 465.4004,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Docs As the Code, Docs In the Code At <em>New</em> <em>Relic</em>",
        "body": " in the CLI and debug messages, and edited the README. We regularly edit <em>NerdGraph</em> <em>GraphQL</em> schemas for embedded documentation. Docs in schemas are key to good <em>GraphQL</em> experiences; see, for example, the screenshot below: All fields have basic reference documentation. The same applies to Open<em>API</em>"
      },
      "id": "60763298196a67968464a7ba"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/adilson-somensari.jpg?h=2a479378&itok=1PmRmD7k",
      "url": "https://newrelic.com/blog/how-to-relic/new-relic-cli-ibm",
      "sections": [
        "Manage New Relic tasks and resources from the CLI",
        "Example use case 1: Create a Synthetics monitor",
        "Example use case 2: Daily backup of a Synthetics monitor",
        "A great addition for your New Relic toolbox"
      ],
      "published_at": "2021-04-16T04:25:42Z",
      "title": "Automate Your New Relic Tasks With the New Relic CLI From IBM",
      "updated_at": "2021-04-14T02:03:44Z",
      "type": "",
      "external_id": "84956b18d97b9ff7e418a703ede61342a4d315f5",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Automate Your New Relic Tasks With the New Relic CLI From IBM Nov 16, 2018 • 5 min read By Adilson Somensari Editor’s note: The New Relic CLI tool was developed by IBM. It is open sourced under the Apache License 2.0. Helping our customers go faster with confidence is a key tenet of the New Relic ethos. We provide visibility into vital data, statistics, and key performance indicators (KPIs) to help teams increase their deployment speed and cadence. But modern software teams also see automation and continuous integration and continuous delivery (CI/CD) processes as must-haves to support their Agile practices and DevOps teams. Teams want to apply the same automation concepts and tools to operate New Relic as they do other parts of their pipeline. However, writing all the standard boilerplate code to work with New Relic’s REST API (read configuration files, connect to endpoints, send payloads, receive responses, and parse them) can be a toilsome burden and a needless distraction. Fortunately, the IBM Cloud Monitoring team, a New Relic partner, noticed that multiple internal teams were spending too much time managing boilerplate code to automate their New Relic workflows, so they created a solution to solve that problem—a New Relic CLI (command line interface) tool. Manage New Relic tasks and resources from the CLI New Relic CLI, open sourced and available on GitHub from IBM, is a command line tool you can use to manage New Relic resources, such as New Relic Synthetics monitors, New Relic Alerts policies and conditions, and user accounts. You can also use the CLI to backup your New Relic configuration data and restore it as needed. Currently, you can use the New Relic CLI to manage these resources: New Relic resource Management action New Relic Synthetics Create, edit, and delete Synthetics monitors #rowspan# Back up and restore Synthetics monitors New Relic Alerts Create, edit, and delete alert conditions #rowspan# Create, edit, and delete alert policies #rowspan# Create, edit, and delete notification channels #rowspan# Back up and restore alert policies and conditions New Relic Insights dashboards Get dashboards #rowspan# Back up and restore dashboards Users List users Example use case 1: Create a Synthetics monitor This example shows you how to use the New Relic CLI to create a Synthetics monitor: Set the New Relic admin API key (NEW_RELIC_APIKEY) for your environment. This will vary depending on your operating system, but in Linux, you’d use the export command:Export NEW_RELIC_APIKEY=xxxx-xxxxxxx-xxxxx-xxxxxx Tip: Refer to the New Relic docs for instructions on locating your admin API key. Create a basic definition of the monitor in JSON format (for example test.json). { \"name\": \"Test monitorURI\", \"type\": \"SIMPLE\" \"frequency\": 5, \"uri\": \"monitorURI\", \"locations\": [ \"AWS_AP_SOUTH_1\", \"AWS_EU_WEST_3\", \"AWS_US_WEST_1\" ], \"status\": \"ENABLED\", \"slaThreshold\": 3, \"options\": { } Tip: See the documentation for a full list of public minion locations. Run a text substitution to replace the monitorURI with the actual URL you want to test, and generate a new file (in this example, result.json). .awk '{gsub(/monitorURI/,\"<URL TO BE TESTED>\")}1' test.json > result.json To create the new monitor, run ./nr-cli create monitor -f result.json. From this point, you can start working with the new monitor as needed. Example use case 2: Daily backup of a Synthetics monitor You can also use the NewRelic CLI to create daily backups of your Synthetics monitors. Using a simple shell script and a cron job, you can quickly set up a process to back up all your monitors in a safe repository. These four steps describe how to use the New Relic CLI to set up a daily backup job that will back up all monitors into a separate folder every day: Download the shell scripts file for backup monitors (backup_monitors.sh) from the New Relic CLI repo. Add a proper path to the script, and set it as an executable: $ chmod a+x backup_monitors.sh. Create a new cron job in your OS to schedule the shell script you just created. Use crontab -e to add new schedule job. 0 0 */1 * * <YOUR NEW_RELIC_APIKEY=\"xxx-xxxx-xxx>\" /<your_path>/backup-monitors.sh NOTE: Replace xxx-xxxx-xxx with your own NewRelic admin API key. (Optional) If you don't want to set the NR API key in your cron job’s configuration, you can set the key inbackup_monitors.sh. Comment out the Export NEW_RELIC_APIKEY=\"xxx-xxxx-xxx\" entry, replace the value with your API key. The cron job should now run and back up on your monitors based on the schedule you created. A great addition for your New Relic toolbox The New Relic CLI also lets you easily save New Relic settings to source-control tools like Github or BitBucket; and share central configuration and settings across multiple teams and projects. For example, if your target machine can’t connect to New Relic directly, you can configure the CLI tool to use a proxy. You can also configure retries to cope with timeouts. The CLI also includes return codes, which can be very useful for CI/CD automation. For more details on developing for the New Relic CLI, see the repo on Github. By Adilson Somensari Adilson Somensari is a senior solutions architect on the New Relic Expert Services team. An experienced APM professional, with multiple certifications in the APM industry, he has a passion for helping customers succeed with modern monitoring architectures. Adilson started his career as a Java developer, delivering distributed applications to a diverse set of industries (Auto, Banking, Telecom, Transportation) in multiple countries (United States, Canada, Portugal, Brazil), and pivoted to APM after learning that there is more to life than reading logs and stack traces. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 838.2612,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Automate Your <em>New</em> <em>Relic</em> Tasks With the <em>New</em> <em>Relic</em> <em>CLI</em> From IBM",
        "sections": "Manage <em>New</em> <em>Relic</em> tasks and resources from the <em>CLI</em>",
        "body": " navigation menu, 4 items How to <em>Relic</em> Best Practices Nerd Life Nerdlog Search the blog Submit How to <em>Relic</em> Automate Your <em>New</em> <em>Relic</em> Tasks With the <em>New</em> <em>Relic</em> <em>CLI</em> From IBM Nov 16, 2018 • 5 min read By Adilson Somensari Editor’s note: The <em>New</em> <em>Relic</em> <em>CLI</em> tool was developed by IBM. It is open sourced under"
      },
      "id": "60764d8028ccbca8f951c14e"
    },
    {
      "image": "https://developer.newrelic.com/static/futurestack-registration-86e612c0605fb3c49cfd28f35977135d.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Futurestack: Master Observability",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-04-16T01:37:39Z",
      "title": "New Relic Developers",
      "updated_at": "2021-04-16T01:37:39Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Data Nerds, get ready to hack the future. Level Up your observability game at Futurestack 2021. Rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 29 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 660.8425,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/embed/",
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "published_at": "2021-04-16T02:11:53Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "6475f68b17fa018b4557ec6d4699b8b3ed06c460",
      "popularity": 1,
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic decode - Use the decode url command to print out information encrypted within the URL newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.8829,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> commands Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> command docs in GitHub. Options bash Copy"
      },
      "id": "6063d5f364441ff6590c8ba1"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: Copy the key you created. You'll use it to associate your New Relic account with the CLI. The CLI will then use the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name> with an arbirary name, the <User key> with the key you copied in Step 1, and the region with either us or eu. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 623.6251,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the <em>New</em> <em>Relic</em> One <em>CLI</em>",
        "body": "One of the primary elements of the <em>New</em> <em>Relic</em> One SDK is the command line interface (<em>CLI</em>). To create a Nerdpack , you&#x27;ll need to install the SDK, configure the <em>CLI</em> to work with your <em>New</em> <em>Relic</em> account, and then utilize its create command. Install and configure the <em>CLI</em> Step 1 of 3 Select or create"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/embed/",
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:07:54Z",
      "title": "",
      "updated_at": "2021-04-04T01:53:18Z",
      "type": "",
      "external_id": "ddf0ca28ab311ff372e8955f2ef022de99716131",
      "popularity": 1,
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 618.14185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": "Access the <em>New</em> <em>Relic</em> platform from the comfort of your terminal. You can use the <em>New</em> <em>Relic</em> <em>CLI</em> to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the <em>CLI</em> to automate common tasks in your DevOps workflow. This guide walks you through"
      },
      "id": "60691c0ee7b9d2f79094463b"
    }
  ],
  "/terraform/terragrunt-configuration": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-16T04:24:42Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.95209,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Linking a <em>notification</em> <em>channel</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-16T02:11:53Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "70555c1d24e8e54b46763d57010901e206ef2ccb",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.3565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6066782e64441f3610617ac3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-15T21:03:41Z",
      "title": "",
      "updated_at": "2021-04-01T01:51:55Z",
      "type": "",
      "external_id": "5e43fb43faa36807fc9f1eb660748303373fa8dd",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.70705,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6065273be7b9d2336c944613"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-04-16T14:38:31Z",
      "updated_at": "2021-04-06T07:43:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirements: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.33855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "sections": [
        "Test alert notification channels",
        "Request the test",
        "Troubleshoot the test results",
        "Tip"
      ],
      "title": "Test alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "c001fca5128a2fb8128ff655c44f9d51b6d5fa2a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/test-alert-notification-channels/",
      "published_at": "2021-04-16T14:39:15Z",
      "updated_at": "2021-03-16T06:45:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must save a new notification channel or any changes to an existing notification channel before testing it. Alerts will then send a test message to your chosen destination. Request the test To test a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Follow standard procedures to add a new notification channel or to update an existing notification channel, and save it. Select a notification channel, and then click Send a test notification. Review the test confirmation message, and then click Got it. Troubleshoot the test results A confirmation message will automatically show up in the user interface that indicates where the test was sent (for example, email) and whether it was successful. Also, the test notification message itself includes detailed information, including: The person who requested the test Links to policies for the channel Links to all notification channels and policies for the account Tip When troubleshooting problems, review the test notification message, and verify the setup requirements for the type of notification channel you selected. If necessary, make additional changes to your notification channel, and test it again as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.77826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "You must save a new <em>notification</em> <em>channel</em> or any changes to an existing <em>notification</em> <em>channel</em> before testing it. <em>Alerts</em> will then send a test message to your chosen destination. Request the test To test a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click"
      },
      "id": "603ec9ffe7b9d25b3d2a07a7"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/embed/",
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "f6dba06ee883ff39a13eb7090bf3c91f9395d6e2",
      "popularity": 1,
      "body": "Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application. Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component. Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows. As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells. The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1099.9548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>tables</em> to your New <em>Relic</em> One <em>application</em>",
        "body": " the following components to the import statement at the top of the file so that it looks like the example: <em>Table</em> <em>TableHeader</em> <em>TableHeaderCell</em> <em>TableRow</em> <em>TableRowCell</em> import { <em>Table</em>, <em>TableHeader</em>, <em>TableHeaderCell</em>, <em>TableRow</em>, <em>TableRowCell</em>, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart"
      },
      "id": "6063d633196a6796a1c6f441"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Extra credit"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 488.67117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>tables</em>",
        "body": " to hold your first <em>Table</em>Chart and some mock data: import React from &#x27;react&#x27;; import { <em>Table</em>Chart } from &#x27;nr1&#x27;; export default class VersionTotals extends React.<em>Component</em> { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name"
      },
      "id": "60725692196a67b68c64a778"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/embed/",
      "sections": [
        "Customize NRQL data",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "f51f9d86d3b873b24e967c687d5408eb9918a33f",
      "popularity": 1,
      "body": "In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Tip If something doesn't work, use these debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your Nerdpack served locally, view your application to see your charts serving real data: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 397.01935,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Experiment with data <em>in</em> the Data explorer",
        "body": " constructor() and the React lifecycle method <em>component</em>DidMount() in VersionTotals: import React from &#x27;react&#x27;; import { HeadingText, NrqlQuery, <em>Table</em>Chart, } from &#x27;nr1&#x27;; export default class VersionTotals extends React.<em>Component</em> { constructor() { super(...arguments); this.state = { <em>table</em>"
      },
      "id": "6073014b28ccbc70b651c134"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:39Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings/ab-test Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.0096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", <em>Table</em>Chart } from &#x27;nr1&#x27;; export default class PastTests extends React.<em>Component</em> { render() { const historicalData = { metadata: { id: &#x27;past-tests&#x27;, name: &#x27;Past tests&#x27;, columns: [&#x27;endDate&#x27;, &#x27;versionADescription&#x27;, &#x27;versionBDescription&#x27;, &#x27;winner&#x27;], }, data: [ { &quot;endDate&quot;: &quot;12-15-2020&quot;, &quot;versionADescription"
      },
      "id": "6072ff1928ccbc140b51c16e"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/embed/",
      "sections": [
        "Add pie charts"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "c0f472d2ed9df8035313cd76ee83ec43e75d0a4a",
      "popularity": 1,
      "body": "You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 303.9174,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-cancellations.js Step 3 of 9 In total-subscriptions.js, create a <em>component</em>, called TotalSubscriptions, which renders mocked subscription data: import React from &#x27;react&#x27;; import { PieChart } from &#x27;nr1&#x27;; export default class TotalSubscriptions extends React.<em>Component</em> { render() { const subscriptionsA"
      },
      "id": "6072ffcc28ccbc786651c18a"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/SynthKub1.png",
      "url": "https://newrelic.com/blog/how-to-relic/deploy-synthetics-from-kubernetes-environments",
      "sections": [
        "Benefits of connecting New Relic Synthetics and Kubernetes",
        "How to get started with New Relic Synthetics and Kubernetes",
        "To monitor the CPM using the Kubernetes cluster explorer",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:24:33Z",
      "title": "Deploy Synthetics from Kubernetes Environments to Monitor Employee-Facing Applications",
      "updated_at": "2021-04-13T23:54:47Z",
      "type": "",
      "external_id": "fe7c715c1417af64bd4c5ffc1871739a673484f8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring Deploy Synthetics from Kubernetes Environments to Monitor Employee-Facing Applications May 13, 2020 • 7 min read By Mat Ball Kubernetes helps increase the velocity of deployments, improve infrastructure durability, and automate the building, running, and maintaining of applications throughout your production environments. To optimize performance, New Relic released the Kubernetes cluster explorer so you can quickly understand the health of your rapidly-scaling environments of pods, containers, and applications. Synthetic testing and monitoring allows you to proactively test the availability and performance of your critical endpoints.  We launched containerized private minions to help you easily incorporate uptime monitoring into the build process as you tested employee facing applications behind the firewall. For these reasons, we’re excited to announce that New Relic users can now add private minions into their Kubernetes environments. This new feature offers our customers the ability to automatically deploy synthetic private locations and run monitors alongside them as part of a Kubernetes deployment. In short, New Relic Synthetics is meeting you where you are—within the systems you’re using—to automate and manage your build and deployment processes. You now have an easier way to automate and ensure that your critical endpoints are available and performant as you rapidly change and scale your systems. Benefits of connecting New Relic Synthetics and Kubernetes We’ve made Synthetics compatible with your Kubernetes orchestration software, enabling you to use Kubernetes to monitor availability and performance from Synthetic’s private locations, such as those behind a firewall or not exposed to the public. Leveraging Kubernetes to automate and manage these private locations helps developers save time and reduce manual efforts. Use the private minion Helm charts to easily include a private location in your next Kubernetes deployment. Once the location is created, add it to your existing Synthetics monitors, and you’ll be up and running in minutes. Leave the scaling and reliability concerns to Kubernetes. We have designed our private minion so that Kubernetes has full control over the resources and containers. The Helm charts allow you to use our recommended default resources or provide you with the ability to define the resource allocation per synthetics check. This helps you focus more on remediating latency and improving reliability, and less on configuration and instrumentation. Even more, we offer additional visibility of the Kubernetes host itself. Using the New Relic Kubernetes cluster explorer you can quickly see the health and status of your private location, alongside the other containers running in your Kubernetes environment. You can also easily view stats and errors about your private location, and understand how widespread issues might be across other applications running on the same cluster. This way, New Relic customers leveraging Kubernetes can simultaneously deploy a new version of their application alongside APM and Synthetics. The feature makes it easy by leveraging Helm charts on Kubernetes, which automatically provide reference configurations, steps for deployment, and resource requirements. If an application experiences issues and is re-deployed per the Kubernetes automated deployment process, Synthetics is also redeployed with no additional configuration needed. How to get started with New Relic Synthetics and Kubernetes Confirm you meet the Kubernetes container orchestration system environment requirements. Locate your private location key.  Go to synthetics.newrelic.com > Private locations.In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Set up a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com/charts If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Install the CPM using the Helm charts: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY To update an existing CPM installation: helm update YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YO Next, connect into New Relic’s Kubernetes cluster explorer. To monitor the CPM using the Kubernetes cluster explorer Locate your license key. Find your cluster name: kubectl config current-context Confirm you have kube-state-metrics installed: kubectl get deployment --all-namespaces | grep kube-state-metrics Select the cluster for the agent installation: kubectl config set-cluster DESIRED_CLUSTER Add the Helm charts: helm repo add stable https://kubernetes-charts.storage.googleapis.com/ Install the Kubernetes integration using the Helm charts, depending on whether you're using Helm 2 or Helm 3 Look up the Synthetics minion in your Kubernetes cluster explorer. For employee-facing applications, or any application not exposed to the public or behind the firewall, availability, and performance is critical to efficiency. Kubernetes orchestration software allows teams to quickly automate change and more easily manage the build and deploy process. Incorporating synthetic monitoring into Kubernetes software gives software engineers the ability to easily detect, isolate, and communicate problems of availability and performance for critical application endpoints. To learn more about how you can enable teams to proactively detect and resolve incidents faster by finding problems before they impact customers, check out New Relic Synthetics. Related Topics Kubernetes Monitoring By Mat Ball Mat Ball is a product marketing manager at New Relic focused on the impact of frontend web applications to business and customer experience outcomes. Previously, Mat worked for SOASTA, where he marketed their data science product. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.99435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Benefits of connecting <em>New</em> <em>Relic</em> Synthetics and Kubernetes",
        "body": " the key associated with the private location with the key icon. <em>Set</em> <em>up</em> a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the <em>Helm</em> <em>charts</em> from the <em>New</em> <em>Relic</em> <em>Helm</em> repo. If you are copying the <em>charts</em> for the first time: <em>helm</em> repo add YOUR_REPO_NAME https:&#x2F;&#x2F;<em>helm</em>"
      },
      "id": "60762f4864441f45329d854f"
    },
    {
      "image": "https://developer.newrelic.com/static/12d81f6bc920b8e4d1f3fdff919ce7e2/209c2/k8s-cluster-explorer.png",
      "url": "https://developer.newrelic.com/automate-workflows/kubernetes-helm-deployment/embed/",
      "sections": [
        "Set up New Relic using Helm charts",
        "Before you begin",
        "Adding the New Relic Helm repository",
        "Install the New Relic Helm chart",
        "Use the New Relic Kubernetes cluster explorer",
        "Try it out now",
        "Some tips to use the on-line tutorial window:",
        "Important",
        "What’s next?"
      ],
      "published_at": "2021-04-16T02:05:47Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "98352926cd24eeccfd7abe49dc20e8b6ed6ad039",
      "popularity": 1,
      "body": "Helm is like a package manager for Kubernetes. Helm charts help define, install and upgrade your Kubernetes applications. In this guide you'll learn how to set up New Relic with the official New Relic Helm charts. The Helm charts will deploy everything you need to get full observability of your Kubernetes environment. Before you begin This walk through assumes you’ve already deployed a Kubernetes cluster. Or you can simply use our test environment, by following the interactive tutorial at the bottom of this page. To use this guide, you should have some basic knowledge of both New Relic and Kubernetes. To complete the full exercise, you’ll need to: Get your New Relic license key Install Helm 3 Step 1 of 3 Adding the New Relic Helm repository First, add the official New Relic Helm repository bash Copy $ helm repo add newrelic https://helm-charts.newrelic.com You should see something similar to the following: bash Copy \"newrelic\" has been added to your repositories Step 2 of 3 Install the New Relic Helm chart Follow the instructions to get your New Relic license key Replace YOUR_NEW_RELIC_LICENSE_KEY and CLUSTER_NAME before running the following command: bash Copy $ helm install newrelic-bundle newrelic/nri-bundle \\ > --set global.licenseKey=YOUR_NEW_RELIC_LICENSE_KEY \\ > --set global.cluster=CLUSTER_NAME \\ > --namespace=default \\ > --set newrelic-infrastructure.privileged=true \\ > --set ksm.enabled=true \\ > --set prometheus.enabled=true \\ > --set kubeEvents.enabled=true \\ > --set logging.enabled=true You should see something similar to the following: bash Copy NAME: newrelic-bundle LAST DEPLOYED: Wed Aug 19 09:04:52 2020 NAMESPACE: default STATUS: deployed REVISION: 1 TEST SUITE: None Check if the New Relic agents have been deployed: bash Copy $ kubectl get daemonsets,pods This should look similar to: bash Copy NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/newrelic-bundle-newrelic-infrastructure 1 1 1 1 1 <none> 2m53s daemonset.apps/newrelic-bundle-newrelic-logging 1 1 1 1 1 <none> 2m53s NAME READY STATUS RESTARTS AGE pod/newrelic-bundle-kube-state-metrics-69ff8cfb74-rgjc5 1/1 Running 0 2m53s pod/newrelic-bundle-newrelic-infrastructure-z8ddb 1/1 Running 0 2m53s pod/newrelic-bundle-newrelic-logging-wp22p 1/1 Running 0 2m53s pod/newrelic-bundle-nri-kube-events-f9d5bb944-kcxxf 2/2 Running 0 2m53s pod/newrelic-bundle-nri-metadata-injection-66d76c868b-xrcq8 1/1 Running 0 2m53s pod/newrelic-bundle-nri-metadata-injection-job-rszw5 0/1 Completed 0 2m53s pod/newrelic-bundle-nri-prometheus-569689b7cb-pnddg 1/1 Running 0 2m53s Step 3 of 3 Use the New Relic Kubernetes cluster explorer Open the Kubernetes cluster explorer in New Relic One You should see something like: Want to know more? Learn how to navigate the Kubernetes cluster explorer Try it out now We can have a Kubernetes test cluster ready for you in a few minutes. By following this on-line tutorial, you will learn how to deploy the New Relic Helm charts. Some tips to use the on-line tutorial window: Accept the cookies, so you can see the menu bar. Click anywhere in the tutorial window to start. It will take a few minutes for your environment to be ready. Press CTRL-l or type clear to clear the terminal window Click on the finish flag icon in the bottom menu to hide or show the instructions Good luck! Important Some browsers automatically disable the use of iframes. If the module isn't loading please check your browser settings. Your browser does not support iframes. What’s next? Nice work — now you can easily deploy New Relic with the official New Relic Helm charts and you can start using the Kubernetes cluster explorer. The Kubernetes cluster explorer brings full observability to your k8s environment, so you can troubleshoot faster by correlating logs, metrics, events and traces all within the same user experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.37003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>",
        "body": "<em>Helm</em> is like a package manager for Kubernetes. <em>Helm</em> <em>charts</em> help define, install and upgrade your Kubernetes applications. In this guide you&#x27;ll learn how to <em>set</em> <em>up</em> <em>New</em> <em>Relic</em> with the official <em>New</em> <em>Relic</em> <em>Helm</em> <em>charts</em>. The <em>Helm</em> <em>charts</em> will deploy everything you need to get full observability of your"
      },
      "id": "6063d633196a676102c6f465"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/openshift5.png",
      "url": "https://newrelic.com/blog/how-to-relic/what-is-kubernetes",
      "sections": [
        "OK, but why all the buzz? Why is Kubernetes so popular?",
        "So, how does Kubernetes work?",
        "The Kubernetes master",
        "Nodes",
        "Deployments and replicas",
        "Namespaces",
        "Labels",
        "Stateful sets and persistent storage volumes",
        "Other useful components",
        "Kubernetes DNS",
        "Cluster-level logs",
        "Helm: managing Kubernetes applications",
        "Kubernetes and Istio: a popular pairing",
        "Challenges to Kubernetes adoption",
        "New Relic can support your Kubernetes journey",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:38:48Z",
      "title": "What Is Kubernetes? An Introduction to the Wildly Popular Container Orchestration Platform",
      "updated_at": "2021-04-14T00:02:30Z",
      "type": "",
      "external_id": "1e800a620cd7bce03e30dd9a74ee244fc2e5ad6a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring What Is Kubernetes? An Introduction to the Wildly Popular Container Orchestration Platform Aug 15, 2019 • 14 min read By Ali Gerrard This is an update of a post originally published in July, 2018. Container-based microservices architectures have profoundly changed the way development and operations teams test and deploy modern software. Containers help companies modernize by making it easier to scale and deploy applications, but containers have also introduced new challenges and more complexity by creating an entirely new infrastructure ecosystem. Large and small software companies alike are now deploying thousands of container instances daily, and that’s a complexity of scale they have to manage. So how do they do it? Enter the age of Kubernetes. Originally developed by Google, Kubernetes is an open-source container orchestration platform designed to automate the deployment, scaling, and management of containerized applications. In fact, Kubernetes has established itself as the defacto standard for container orchestration and is the flagship project of the Cloud Native Computing Foundation (CNCF), backed by key players like Google, AWS, Microsoft, IBM, Intel, Cisco, and Red Hat. Kubernetes makes it easy to deploy and operate applications in a microservice architecture. It does so by creating an abstraction layer on top of a group of hosts, so that development teams can deploy their applications and let Kubernetes manage: Controlling resource consumption by application or team Evenly spreading application load across a host infrastructure Automatically load balancing requests across the different instances of an application Monitoring resource consumption and resource limits to automatically stop applications from consuming too many resources and restarting the applications again Moving an application instance from one host to another if there is a shortage of resources in a host, or if the host dies Automatically leveraging additional resources made available when a new host is added to the cluster Easily performing canary deployments and rollbacks See also: Docker vs. Kubernetes: It’s Not About One or the Other OK, but why all the buzz? Why is Kubernetes so popular? As more and more organizations move to microservice and cloud native architectures that make use of containers, they’re looking for strong, proven platforms. Practitioners are moving to Kubernetes for four main reasons: 1. Kubernetes helps you move faster. Indeed, Kubernetes allows you to deliver a self-service Platform-as-a-Service (PaaS) that creates a hardware layer abstraction for development teams. Your development teams can quickly and efficiently request the resources they need. If they need more resources to handle additional load, they can get those just as quickly, since resources all come from an infrastructure shared across all your teams. No more filling out forms to request new machines to run your application. Just provision and go, and take advantage of the tooling developed around Kubernetes for automating packaging, deployment, and testing, such as Helm (more below). 2. Kubernetes is cost efficient. Kubernetes and containers allow for much better resource utilization than hypervisors and VMs do; because containers are so light weight, they require less CPU and memory resources to run. 3. Kubernetes is cloud agnostic. Kubernetes runs on Amazon Web Services (AWS), Microsoft Azure, and the Google Cloud Platform (GCP), and you can also run it on-premise. You can move workloads without having to redesign your applications or completely rethink your infrastructure—which lets you to standardize on a platform and avoid vendor lock-in. In fact, companies like Kublr, Cloud Foundry, and Rancher provide tooling to help you deploy and manage your Kubernetes cluster on-premise or on whatever cloud provider you want. 4. Cloud providers will manage Kubernetes for you. As noted earlier, Kubernetes is currently the clear standard for container orchestration tools. It should come as no surprise, then, that major cloud providers are offering plenty of Kubernetes-as-a-Service-offerings. Amazon EKS, Google Cloud Kubernetes Engine, Azure Kubernetes Service (AKS), Red Hat Openshift, and IBM Cloud Kubernetes Service all provide a full Kubernetes platform management, so you can focus on what matters most to you—shipping applications that delight your users. So, how does Kubernetes work? The central component of Kubernetes is the cluster. A cluster is made up of many virtual or physical machines that each serve a specialized function either as a master or as a node. Each node hosts groups of one or more containers (which contain your applications), and the master communicates with nodes about when to create or destroy containers. At the same time, it tells nodes how to re-route traffic based on new container alignments. The following diagram depicts a general outline of a Kubernetes cluster: The Kubernetes master The Kubernetes master is the access point (or the control plane) from which administrators and other users interact with the cluster to manage the scheduling and deployment of containers. A cluster will always have at least one master, but may have more depending on the cluster’s replication pattern. The master stores the state and configuration data for the entire cluster in ectd, a persistent and distributed key-value data store. Each node has access to ectd and through it, nodes learn how to maintain the configurations of the containers they’re running. You can run etcd on the Kubernetes master, or in standalone configurations. Masters communicate with the rest of the cluster through the kube-apiserver, the main access point to the control plane. For example, the kube-apiserver makes sure that configurations in etcd match with configurations of containers deployed in the cluster. The kube-controller-manager handles control loops that manage the state of the cluster via the Kubernetes API server. Deployments, replicas, and nodes have controls handled by this service. For example, the node controller is responsible for registering a node and monitoring its health throughout its lifecycle. Node workloads in the cluster are tracked and managed by the kube-scheduler. This service keeps track of the capacity and resources of nodes and assigns work to nodes based on their availability. The cloud-controller-manager is a service running in Kubernetes that helps keep it “cloud-agnostic.” The cloud-controller-manager serves as an abstraction layer between the APIs and tools of a cloud provider (for example, storage volumes or load balancers) and their representational counterparts in Kubernetes. Nodes All nodes in a Kubernetes cluster must be configured with a container runtime, which is typically Docker. The container runtime starts and manages the containers as they’re deployed to nodes in the cluster by Kubernetes. Your applications (web servers, databases, API servers, etc.) run inside the containers. Each Kubernetes node runs an agent process called a kubelet that is responsible for managing the state of the node: starting, stopping, and maintaining application containers based on instructions from the control plane. The kubelet collects performance and health information from the node, pods and containers it runs and shares that information with the control plane to help it make scheduling decisions. The kube-proxy is a network proxy that runs on nodes in the cluster. It also works as a load balancer for services running on a node. The basic scheduling unit is a pod, which consists of one or more containers guaranteed to be co-located on the host machine and can share resources. Each pod is assigned a unique IP address within the cluster, allowing the application to use ports without conflict. You describe the desired state of the containers in a pod through a YAML or JSON object called a Pod Spec. These objects are passed to the kubelet through the API server. A pod can define one or more volumes, such as a local disk or network disk, and expose them to the containers in the pod, which allows different containers to share storage space. For example, volumes can be used when one container downloads content and another container uploads that content somewhere else. Since containers inside pods are often ephemeral, Kubernetes offers a type of load balancer, called a service, to simplify sending requests to a group of pods. A service targets a logical set of pods selected based on labels (explained below). By default, services can be accessed only from within the cluster, but you can enable public access to them as well if you want them to receive requests from outside the cluster. Deployments and replicas A deployment is a YAML object that defines the pods and the number of container instances, called replicas, for each pod. You define the number of replicas you want to have running in the cluster via a ReplicaSet, which is part of the deployment object. So, for example, if a node running a pod dies, the replica set will ensure that another pod is scheduled on another available node. A DaemonSet deploys and runs a specific daemon (in a pod) on nodes you specify. They’re most often used to provide services or maintenance to pods. A daemon set, for example, is how New Relic Infrastructure gets the Infrastructure agent deployed across all nodes in a cluster. Namespaces Namespaces allow you to create virtual clusters on top of a physical cluster. Namespaces are intended for use in environments with many users spread across multiple teams or projects. They assign resource quotas and logically isolate cluster resources. Labels Labels are key/value pairs that you can assign to pods and other objects in Kubernetes. Labels allow Kubernetes operators to organize and select subset of objects. For example, when monitoring Kubernetes objects, labels let you quickly drill down to the information you’re most interested in. Stateful sets and persistent storage volumes StatefulSets give you the ability to assign unique IDs to pods in case you need to move pods to other nodes, maintain networking between pods, or persist data between them. Similarly, persistent storage volumes provide storage resources for a cluster to which pods can request access as they’re deployed. Other useful components These Kubernetes components are useful but not required for regular Kubernetes functionality: Kubernetes DNS Kubernetes provides this mechanism for DNS-based service discovery between pods. This DNS server works in addition to any other DNS servers you may use in your infrastructure. Cluster-level logs If you have a logging tool, you can integrate it with Kubernetes to extract and store application and system logs from within a cluster, written to standard output and standard error. If you want to use cluster-level logs, it’s important to note that Kubernetes does not provide native log storing; you must provide your own log storage solution. Helm: managing Kubernetes applications Helm is an application package management registry for Kubernetes, maintained by the CNCF. Helm “charts” are pre-configured software application resources you can download and deploy and in your Kubernetes environment. According to a 2018 CNCF survey, 68% of respondents said Helm was the preferred package management tool for Kubernetes applications. Helm charts can help DevOps teams come up to speed more quickly with managing applications in Kubernetes; it allows them leverage existing charts that they can share, version, and deploy into their dev and production environments. Kubernetes and Istio: a popular pairing In a microservices architecture like those that run in Kubernetes, a service mesh is an infrastructure layer that allows your service instances to communicate with one another. The service mesh also lets you configure how your service instances perform critical actions such as service discovery, load balancing, data encryption, and authentication and authorization. Istio is one such service mesh, and current thinking from tech leaders, like Google and IBM, suggests they’re increasingly becoming inseparable. The IBM Cloud team, for example, uses Istio to address the control, visibility, and security issues it has encountered while deploying Kubernetes at massive scale. More specifically, Istio helps IBM: Connect services together and control the flow of traffic Secure interactions between microservices with flexible authorization and authentication policies Provide a control point so IBM can manage services in production Observe what’s happening in their services, via an adapter that sends Istio data to New Relic—allowing it to monitor microservice performance data from Kubernetes alongside the application data it's already gathering. Challenges to Kubernetes adoption Kubernetes clearly has come a long way in the first five years of life. That kind of rapid growth, though, also involves occasional growing pains. Here are a few challenges with Kubernetes adoption: 1. The Kubernetes technology landscape can be confusing. One thing developers love about open-source technologies, like Kubernetes is the potential for fast-paced innovation. But sometimes too much innovation creates confusion, especially when the central Kubernetes code base moves faster than users can keep up with it. Add a plethora of platform and managed service providers, and it can be hard for new adopters to make sense of the landscape. 2. Forward-thinking dev and IT teams don’t always align with business priorities. When budgets are only allocated to maintain the status quo, it can be hard for teams to get funding to experiment with Kubernetes adoption initiatives, as such experiments often absorb a significant amount of time and team resources. Additionally, enterprise IT teams are often adverse to risk and slow to change. 3. Teams are still acquiring the skills required to leverage Kubernetes. It wasn’t until a few years ago that developers and IT operations folks had to readjust their practices to adopt containers—and now, they have to adopt container orchestration, as well. Enterprises hoping to adopt Kubernetes need to hire professionals who can code, as well as knowing how to manage operations and understand application architecture, storage, and data workflows. 4. Kubernetes can be difficult to manage. In fact, you can read any number of Kubernetes horror stories—everything from DNS outages to “a cascading failure of distributed systems”— in the Kubernetes Failure Stories GitHub repo. New Relic can support your Kubernetes journey To fully understand what’s going on in your environment, you need to see into all its layers, including inside your containers. That means holistic, application-centric and infrastructure-centric monitoring. Monitoring application performance in Kubernetes is important, but you also need visibility into your Docker and Kubernetes infrastructure. New Relic's Kubernetes cluster explorer, which is part of New Relic Infrastructure , addresses this need. It leverages an on-host integration for Kubernetes that provides deep monitoring for backend and frontend applications and for hosts running in your clusters. The rollout of New Relic's Kubernetes cluster explorer was one highlight among many during a year packed with innovative upgrades to the New Relic Platform Using Kubernetes cluster explorer, teams can expect total visibility, alerting, and dashboards for all Kubernetes entities—metadata for nodes, namespaces, neployments, ReplicaSets, pods, and containers—that host your applications. This integration can be used with provider offerings as well. For example, teams using Red Hat OpenShift can link New Relic APM data with OpenShift data. This step provides deep application performance monitoring (with code instrumentation and distributed tracing) for the applications running in a cluster. After linking your applications, click any of the hexagons in the cluster explorer—each of which represents a pod in a cluster—to open a detailed view of that pod. From there, you can analyze the performance of applications running in that pod. Examine New Relic APM data about the applications running in your OpenShift clusters. You can even dive into New Relic distributed tracing to inspect the distributed traces captured for the application running in that pod. If you click on an individual span in a distributed trace, you can quickly see the relevant Kubernetes attributes for that application; for example you can find out which pod, cluster, and deployment an individual span belongs to. Get distributing tracing data from the applications running in your OpenShift cluster. Using New Relic to take advantage of the power of Kubernetes is essential for modern software companies looking to move faster with confidence. Learn how to get started monitoring containers yin our Kubernetes environment in the New Relic documentation. Related Topics Kubernetes Monitoring By Ali Gerrard Ali Gerrard is a product marketing manager at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.25743,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> can support your Kubernetes journey",
        "body": "Skip to main content We&#x27;re leveling <em>up</em> FutureStack registration with swag, only until 4&#x2F;30. Terms &amp; conditions apply. Register Now Dismiss alert <em>New</em> <em>Relic</em> logo Search Submit Products Products <em>New</em> <em>Relic</em> One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence"
      },
      "id": "6076311628ccbc612e51c156"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/istio_adapter_trace.png",
      "url": "https://newrelic.com/blog/how-to-relic/how-to-monitor-istio-service-mesh",
      "sections": [
        "How the newrelic-istio-adapter works",
        "Istio metrics data",
        "Istio trace data",
        "Getting started with the newrelic-istio-adapter",
        "Contributing to the newrelic-istio-adapter",
        "Related Topics"
      ],
      "published_at": "2021-04-16T00:15:37Z",
      "title": "How To Monitor Istio With New Relic",
      "updated_at": "2021-04-14T00:55:13Z",
      "type": "",
      "external_id": "0b1e64e8faf5a47499cffe287aeac4cf869ce727",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Observability How To Monitor Istio With New Relic Nov 6, 2019 • 7 min read By Tyler Yahn A central component of the New Relic One observability platform is an adherence to open instrumentation. Many open systems and frameworks for software development have built-in metrics, events, logs, and traces that they emit in common formats. For observability, you need to collect telemetry data from both open and proprietary sources, and combine it in one place. Istio is a popular service mesh that lets you connect, monitor, and secure microservices deployed on-premise, in the cloud, or with orchestration platforms like Kubernetes. Istio is an excellent example of a system that emits useful telemetry data about its health and function. In fact, this was one of the primary reasons the New Relic Service Mesh team chose to build New Relic’s next-generation service mesh on the Istio platform. To run our mesh on Istio, we had to build an adapter to directly integrate with Istio's telemetry engine, Mixer. Our adapter leverages Mixer’s extensible architecture to send curated and customizable telemetry for any service-to-service communication within the service mesh to New Relic, all without the need of an agent. Once we built the adapter, though, we knew we couldn’t keep it to ourselves. So, as part of our open instrumentation initiative, we open sourced the newrelic-istio-adapter, available now on GitHub. Read on to learn more about how it works. How the newrelic-istio-adapter works We built the newrelic-istio-adapter using the new go-telemetry-sdk, an open source set of API client libraries that send your metric and trace data to the New Relic platform. Using the SDK we were able to integrate with Mixer to gather two types of telemetry data: Istio's metric telemetry to send that open source metric data to New Relic Istio's trace telemetry to send spans of distributed traces traversing the service mesh to New Relic The newrelic-istio-adapter sits alongside Istio in an isolated environment to ensure no interference with the core service mesh functionality of Istio. Once the adapter is up and running, you configure Mixer to send telemetry about events within the service mesh to the adapter. The adapter transforms and delivers this telemetry data as curated open source (multi-dimensional) metrics—essentially, metrics with multiple key-value pairs—to New Relic. The newrelic-istio-adapter gathers telemetry data from the Istio service mesh in a Kubernetes environment. Istio metrics data The ability to send open source dimensional metrics data to New Relic is a real game changer for any New Relic user. With a high volume of information-rich data, you can query and visualize that data with a high degree of resolution and filter it in meaningful ways through actionable dashboards, alerts, and New Relic One programmable applications. For example, the newrelic-istio-adapter has a default configuration that sends metrics representing the \"four golden signals\" for all services within the service mesh: error rates, latency, request volume, and throughput. The “four golden signals” from the Istio service mesh captured in a New Relic dashboard. Any service running in the service mesh is monitored for these critical, customer-centric signals. You won’t need to reconfigure any service or install a New Relic agent. Istio trace data The good news doesn’t stop there: Any service within the service mesh that supports Zipkin (b3-propagation) traces can have spans sent to New Relic using the newrelic-istio-adapter. Even services you haven’t instrumented with New Relic agents (i.e., open source components of a system) can be included in New Relic’s distributed tracing simply by operating within the service mesh. Traces from services running in the Istio service mesh can tracked in New Relic’s distributed tracing. Getting started with the newrelic-istio-adapter The newrelic-istio-adapter GitHub repository has all the information you need to start gathering metrics and traces from Istio. For more information on how Istio Mixer telemetry is created and collected, refer to this overview on the Mixer configuration model. Key requirements include: A Kubernetes cluster A working kubectl installation A working Helm installation An Istio deployment, including an installed and configured Istio Mixer server A New Relic Insert API Key An APM Pro account Note: Metrics and traces exported from this adapter to New Relic are rate limited. See the New Relic documentation for Trace API general requirements and limits and Metric API limits and restricted attributes for more information. Instructions for deploying the adapter with Helm, as well as for enabling distributed tracing to send trace spans from services within the Istio service mesh to New Relic, are available in the GitHub repo. We’ve also provided a dashboard template that charts Istio metrics from our default configuration. The template is designed to be imported with the Insights Dashboard API. The dashboards are available in New Relic Insights and as New Relic One dashboards. Contributing to the newrelic-istio-adapter We welcome contributions to the newrelic-istio-adapter or any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our contributor licensing agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Related Topics Observability By Tyler Yahn Tyler Yahn is a Senior Software Engineer at New Relic. He is currently based in Portland, Oregon. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.65062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How To Monitor Istio With <em>New</em> <em>Relic</em>",
        "sections": "How the <em>newrelic</em>-istio-adapter works",
        "body": " on GitHub. Read on to learn more about how it works. How the newrelic-istio-adapter works We built the newrelic-istio-adapter <em>using</em> the <em>new</em> go-telemetry-sdk, an open source <em>set</em> of API client libraries that send your metric and trace data to the <em>New</em> <em>Relic</em> platform. <em>Using</em> the SDK we were able to integrate"
      },
      "id": "60763d7164441fc4a69d8578"
    },
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "Tip",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-ed6795cfdb010c5eabb1cfe9c83a82a9.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-04-12T10:59:10Z",
      "updated_at": "2021-03-16T17:42:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. Tip To use CPMs and synthetic monitoring, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a Scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a Simple Browser or Scripted Browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a Runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and Memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com/charts Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.952515,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and <em>update</em> CPM versions",
        "body": " environment. The CPM will auto-detect its environment to select the appropriate operating mode. Tip To <em>use</em> CPMs and synthetic monitoring, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign <em>up</em> to create your free account in only a few seconds. Then ingest <em>up</em> to 100GB of data"
      },
      "id": "603ea47f28ccbcf987eba775"
    }
  ],
  "/terraform/get-started-terraform": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-16T04:24:42Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 349.47632,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Step 3: Provision <em>alert</em> conditions based on the four <em>golden</em> <em>signals</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four <em>golden</em> <em>signals</em> of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-16T02:11:53Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "70555c1d24e8e54b46763d57010901e206ef2ccb",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.32532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6066782e64441f3610617ac3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-15T21:03:41Z",
      "title": "",
      "updated_at": "2021-04-01T01:51:55Z",
      "type": "",
      "external_id": "5e43fb43faa36807fc9f1eb660748303373fa8dd",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.92786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6065273be7b9d2336c944613"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-04-16T14:38:31Z",
      "updated_at": "2021-04-06T07:43:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirements: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.33855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/proactive_detection6-1024x765.png",
      "url": "https://newrelic.com/blog/nerdlog/new-capabilities-proactive-detection",
      "sections": [
        "Automatic analysis of every anomaly",
        "See all anomalies in a single view",
        "Alert, query, and leverage the power of anomalies in NRDB",
        "The full power of New Relic AI: anomalies integrated into Incident Intelligence",
        "Related Topics"
      ],
      "published_at": "2021-04-16T00:19:16Z",
      "title": "Enhancing New Relic AI With New Capabilities For Proactive Detection",
      "updated_at": "2021-04-13T23:31:44Z",
      "type": "",
      "external_id": "47801e8f396395e32a3da28b34d08b92af08bacb",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit AIOps Enhancing New Relic AI With New Capabilities For Proactive Detection May 4, 2020 • 6 min read By Annette Sheppard The rate of change within your software is faster than ever, and with this pace comes the risk that your team may miss issues, or lose critical time trying to diagnose the causes of errors. Proactive Detection, an essential part of our recently released AIOps solution, New Relic AI, helps DevOps teams avoid such problems and drive faster mean time to resolution (MTTR) by proactively detecting and analyzing anomalies using data from New Relic APM. Whether it’s alerts you didn’t know you needed to set up or dependent systems you may not even own, New Relic AI Proactive Detection surfaces and analyzes anomalies, bringing attention to potential problems before they become bigger issues—all within your team’s existing incident response workflows. Easy to set up, Proactive Detection simply needs a configuration name and a list of the applications to be monitored to begin discovering and analyzing anomalies in your system. Today we’re announcing four key enhancements to Proactive Detection: An in-depth analysis of each anomaly via the Analysis page A complete list of all anomalies in your environment with the Anomaly overview Integration with the New Relic Database (NRDB), so you can create dashboards and alerts based on anomaly data Integration with New Relic AI Incident Intelligence—via NRQL alerts—for deeper context into incidents Automatic analysis of every anomaly Not only does Proactive Detection flag and notify you of anomalies in your system, it also analyzes each anomaly to help you speed troubleshooting. The Analyze page automatically surfaces queries and context to help explain the cause of an anomaly. Each Proactive Detection notification delivered in Slack provides a link to the Analyze page, allowing you to easily investigate an anomaly or switch between anomalies as you dive deeper into issues. Anomalies delivered to your team via Slack quickly link to the Analyze page for deeper analysis The Analyze page provides an overview of the anomaly itself, as well as details and recent activity for an entity. When available, Proactive Detection automatically suggests attributes that help explain the cause of the anomaly and provide paths for further troubleshooting, as shown in the Key Attributes section: The three key attributes surrounding an error spike are visualized to provide you with multiple paths for troubleshooting. Proactive Detection uses APM event data to suggest queries that explain the anomaly, based either on statistical differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “golden signals” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream or downstream of the initial anomaly. Sparklines include anomalies related to the SRE “golden signals” and additional anomalies in related upstream or downstream applications All of this gives your team a holistic view of the events leading up to the anomaly, helping you better identify what is happening in your application and environment. See all anomalies in a single view The Analyze page provides the context surrounding one anomaly, but the Anomaly overview page gives you a broader view of what's happening in your environment. You’ll have a full view of all detected anomalies, with the ability to instantly view more details for each one. If you want to dive in and learn even more about a specific anomaly, simply use the Analyze link. The Anomaly overview page gives you an overview of all anomalies detected in your environment. Alert, query, and leverage the power of anomalies in NRDB Since all anomalies are automatically written to the NRDB, you can use anomaly data to build dashboards, or create alerts. Query any Proactive Detection event from any configured application. For example, use Proactive Detection data in NRQL alerts to notify you when clusters of anomalies occur. Any anomaly can be plotted in a dashboard to discover trends and patterns. You can even build your dashboards to show anomalous events that are relevant to the specific applications you’re monitoring for anomalies in Proactive Detection. Be notified when clusters of anomalies occur. The full power of New Relic AI: anomalies integrated into Incident Intelligence Proactive Detection and Incident Intelligence are New Relic AI’s critical set of capabilities that help teams detect issues early, eliminate alert noise, and drive toward even faster MTTR. Incident Intelligence uses AI and machine learning (ML) to suppress alerts you don’t care about and correlate related incidents and events into single issues, without excessive configuration, training, or onboarding. Stronger together, you can now link anomalies detected with Proactive Detection to Incident Intelligence—via NRQL alerts—to receive enhanced context inside of your Incident Intelligence to gain the full power of New Relic AI. New Relic AI Proactive Detection has a free tier that you can start using today: If you’re new to New Relic, sign up for your free account. Already using New Relic? Get started with Proactive Detection in under 10 minutes by visiting http://one.newrelic.com > New Relic AI > Proactive Detection. Interested in learning more about New Relic AI, check out these resources: Accelerate Incident Response with AIOps: An introduction to AIOps best practices with New Relic AI (eBook) Accelerate Incident Response with AIOps (Webinar) New Relic AI documentation Request a demo   Related Topics AIOps By Annette Sheppard Annette Sheppard is a Senior Product Marketing Manager at New Relic. She is focused on AIOps and is always looking to learn something new. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.84161,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Alert</em>, query, and leverage the power of anomalies in NRDB",
        "body": " differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “<em>golden</em> <em>signals</em>” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream"
      },
      "id": "607629e028ccbc02d751c161"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.26105,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.49353,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.4714,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.46234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.46234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    }
  ],
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/embed/",
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "67c529a70a60d530860fbe80be795d214798dfd9",
      "popularity": 1,
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 214.2062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em>",
        "body": ", account, or user level. This guide explains how to <em>add</em> <em>data</em> and documents to <em>NerdStorage</em>. For an introduction to what <em>NerdStorage</em> is and how it works, see Intro to <em>NerdStorage</em>. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your"
      },
      "id": "6066782e64441f577f617a9d"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.98296,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Access <em>NerdStorage</em> from your Nerdlet",
        "body": " learn that, you need to know something about our mock <em>data</em> service: it requires an Authorization header! In this lesson, you learned how to use <em>NerdStorage</em> to <em>query</em> and <em>mutate</em> <em>data</em> in your application&#x27;s own <em>data</em> store. While <em>NerdStorage</em> is a great place for many categories of <em>data</em>, it&#x27;s not appropriate for sensitive <em>data</em>, like a token you would pass in an Authorization header to an external service. For that, you&#x27;d use NerdStorageVault."
      },
      "id": "607256cae7b9d2df5ba5c67c"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/embed/",
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "published_at": "2021-04-16T02:13:38Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:56Z",
      "type": "",
      "external_id": "31fc09fc1a4af441ce6fa9a9ea59fa2216dd2058",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.46779,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to <em>NerdStorage</em>",
        "body": ". Documents: A document is formed by an identifier (documentId) and a set of <em>data</em> associated with it. <em>Data</em> associated with a document: <em>NerdStorage</em> accepts any sort of <em>data</em> associated to a documentId. <em>Query</em> and mutation components that are provided work by serializing and deserializing JSON. Caution"
      },
      "id": "6063d63428ccbcff4e43fa92"
    },
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.05291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Query</em> your <em>data</em>"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.05291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Query</em> your <em>data</em>"
      },
      "id": "6053433228ccbcdc10c2fd60"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/embed/",
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "published_at": "2021-04-16T02:13:38Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:56Z",
      "type": "",
      "external_id": "31fc09fc1a4af441ce6fa9a9ea59fa2216dd2058",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 303.57452,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>NerdStorage</em> in your <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use <em>NerdStorage</em> SDK <em>components</em>. Use <em>NerdStorage</em> in your <em>apps</em> <em>NerdStorage</em> is used to store and retrieve simple sets of <em>data</em>, including users&#x27; configuration settings"
      },
      "id": "6063d63428ccbcff4e43fa92"
    },
    {
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/embed/",
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "67c529a70a60d530860fbe80be795d214798dfd9",
      "popularity": 1,
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.5425,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "body": " on <em>New</em> <em>Relic</em> <em>One</em>. Load the URL. Click <em>Apps</em> and under Your <em>apps</em> you&#x27;ll see the Use <em>Nerdstorage</em> <em>app</em> listed. Click to launch the <em>app</em>. Add <em>data</em> to <em>NerdStorage</em> Once the <em>app</em> is up and running on <em>New</em> <em>Relic</em> <em>One</em>, you can prepare the <em>app</em> and start adding <em>data</em>. On the How To Use <em>NerdStorage</em> <em>app</em> screen, there&#x27;s"
      },
      "id": "6066782e64441f577f617a9d"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.50372,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> <em>NerdStorage</em> from your Nerdlet",
        "body": " <em>RELIC</em> ACCOUNT ID&gt; in your project with your actual <em>New</em> <em>Relic</em> account ID When you&#x27;re finished, stop serving your <em>New</em> <em>Relic</em> <em>One</em> application by pressing CTRL+C in your local server&#x27;s terminal window. Great work! You now have experience using the <em>NerdStorage</em> query and mutation <em>components</em>. However, there&#x27;s"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.71509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or <em>data</em> from another service or API. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>. If you want to get started building quickly, first read the requirements. Tip To use our developer site and <em>New</em> <em>Relic</em> <em>One</em>, as well as the rest of our"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.67401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 362.98065,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.17804,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.15573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.14658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.14658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/embed/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2021-04-16T02:12:51Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "9f3c1bee195dc75bc1fc2d96b7bdeec591e35449",
      "popularity": 1,
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 605.96564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "body": " our other <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> docs for <em>commands</em> specific to <em>Nerdpack</em> set-up, <em>Nerdpack</em> subscriptions, <em>CLI</em> configuration, plugins, or catalogs. <em>Command</em> details nr1 help See <em>commands</em> and get details Shows all nr1 <em>commands</em> by default. To get details about a specific <em>command</em>, run nr1 help <em>COMMAND</em>_NAME. Usage"
      },
      "id": "6063d63464441f3d6b0c8bee"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.26105,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.49353,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.4714,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.46234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:24Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 830.5978,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers Guide Roundup",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>",
        "body": " The <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em> provides the necessary <em>components</em> you need to build <em>New</em> <em>Relic</em> <em>One</em> applications. <em>Components</em> of the <em>SDK</em> include: React <em>UI</em> <em>components</em> for controlling text and layout in a <em>New</em> <em>Relic</em> <em>One</em> application <em>Chart</em> <em>components</em> for representing different types of charts <em>Query</em> and <em>storage</em>"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-16T02:10:56Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 805.5991,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Query</em> <em>and</em> <em>storage</em> <em>components</em>",
        "body": ". <em>Components</em> of the <em>SDK</em> <em>SDK</em> <em>components</em> are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 <em>components</em> can be divided into several categories: <em>UI</em> <em>components</em> <em>Chart</em> <em>components</em> <em>Query</em> and <em>storage</em> <em>components</em> <em>Platform</em> APIs <em>UI</em> <em>components</em> The <em>UI</em> <em>components</em>"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/mobile_ui_react_folder_structure-546x1024.png",
      "url": "https://newrelic.com/blog/best-practices/mobile-ui-react",
      "sections": [
        "The new and improved New Relic Mobile UI architecture",
        "Managing state",
        "Running async services",
        "Plugged in NRQL models",
        "Bonus content: project folder structure",
        "Building more than just a UI"
      ],
      "published_at": "2021-04-16T04:23:43Z",
      "title": "How We Architected the New Relic Mobile Web UI in React",
      "updated_at": "2021-04-14T06:37:40Z",
      "type": "",
      "external_id": "e3d67df0a38b9980728a89cac2fb64cddc1708b1",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices How We Architected the New Relic Mobile Web UI in React Jan 3, 2018 • 7 min read By Frank Linehan An ongoing curiosity in JavaScript development communities is the question of how to build complex UI applications in React. This open source JavaScript library, maintained by Facebook, makes it easier than ever to write efficient, component-based projects in JavaScript. React has been around for about four years now, but the JavaScript community is still learning how to take full advantage of its powers. The web UI for New Relic Mobile has several points of integration with components, services, and container objects built by different UI engineers across New Relic. Historically it’s been a challenge to cleanly integrate all the pieces. Additionally, we now have more non-frontend engineers than ever contributing to the UI, so it’s become very important for us to have a clean architecture that everyone can easily navigate and contribute to. To make it easier for engineers who contribute code to the UI, we’ve created a flexible system, written in React. And since we’ve built this layered architecture from modules, we’ve been able to decouple the different domains of the UI application from each other, thus easing the burdens of contributors. We wanted to share some of the design behind this complex React project because it’s led us to some seriously great outcomes. The new and improved New Relic Mobile UI architecture Consider this diagram of the new architecture: The top three layers are made up of our framework-specific UI views, containers, and components (which I’ll give a bit more detail for when I discuss the folder structure of our project). Where possible we favor composition over inheritance since React classes are great for this design pattern. For example, we use this pattern in the Handled exceptions sidebar container that has three child UI components: a search input, an occurrence count, and a bar chart component. The sidebar composes these child UI components by passing needed properties to its children (for example, data to render the bar chart). This allows us to reuse these smaller components throughout the application and to handle layout and configuration through the larger container components. We like to think of these UI components as “Lego pieces:” they can be used in multiple ways to build dozens of combinations. The UI views and containers, on the other hand, are much less modular and are more like jigsaw puzzle pieces in that they fit together only one specific way. The bottom layer is composed of three collections of modules in which a significant portion of the Mobile UI application code base lives. These collections handle state management, asynchronous services, and store NRQL models (the latter of which powers the New Relic Query Language functionality in the UI). Managing state In React, state is an object that can change over time; for example, UI text changing to red in the case of an emergency is controlled by state. State can be managed—or held—in stores. In New Relic Mobile, some UI components manage their own internal state (dropdown components keep track of when they are open or closed), but other components, such as the filter list, filter picker, and time picker, use state containers (or bundles of state) that allow state to be easily shared across components. To store the state React renders, we use the MobX library. In the New Relic Mobile UI, the top-level stores that manage application state use singleton patterns. These singletons use object composition to reference the other store singletons in the project. For example, as shown in diagram below, the App store, which handles the UI’s high-level application state, has references to our Router store, Nav store, Time store, Filters store, and Account store. So, for example, when a user clicks and “brushes” a graph (i.e., selects a data point in a graph that is then highlighted in another graph), we need to update our time window and route for the change. When the “brush” action is called, the App store mutates our router state and timestore state, which then triggers updates to all the components that observe those states. The API interface between our State store and the graph component is lightweight and simple, and this part of the UI is flexible if we ever require changes. Running async services This set of core modules are for a few asynchronous services that retrieve data from different places in the New Relic Mobile application. These store objects use the fetch API to make HTTP requests, and they manage the state of data as it loads. These async store objects inherit from our HTTP request store (which is one of the few places where we use inheritance). The HTTP request store is a finite state machine that has some helper methods for handling loading, errors, and data. We chose inheritance for these objects because they all have the same HTTP request pattern (for example, fetch, is loading, has data, has error). By moving that shared behavior to the HTTP request object and inheriting off of it, we removed hundreds of lines of redundant code from our project. Plugged in NRQL models The New Relic Query Language models are modules of code that generate NRQL queries used by the UI components, containers, and views. These models are pretty specific to the structure of the New Relic UI, so a close examination of them isn’t necessary here. Bonus content: project folder structure Finally, no discussion of a JavaScript project is complete without a look at the project’s folder structure. Obviously, there is no “perfect folder structure,” but this is what has worked well for our team in this project. Application code lives in the src folder and styling lives in our scss folder. Both of these folders are bundled up by webpack and turned into UI assets. Our src folder has the following structure: The component folder holds React components that are given sets of properties and render widgets on the screen. These are our “Lego pieces” that can be composed into different combinations in the UI. The containers folder is for components that compose other components. The containers are our puzzle pieces that fit only one way when used in the UI. Then we have our views folder that holds our views components. The views components compose our containers. This folder combines all of our smaller pieces into one big picture, and since most of the team is experienced with some form of the model, view, controller (MVC) architecture, having a views folder gives us all a familiar entry point into the application. The models folder contains the aforementioned NRQL models used to build queries consumed by our graph components and other containers. The configs folder is where we store static variables that are used to configure views and containers. The libs, services, utils, andtransforms folders are where we keep smaller reusable pieces of code that format data or talk to APIs; these can even be used by our other components. Last but not least we have our stores folder, which holds our state containers. As noted, we’re using MobX to store our state and actions. Our end goal was to have as flat a folder structure as possible, since flat is always better than nested. We also made sure the folder names were easily readable since team members need to be able to identify what lives where and what it does. Building more than just a UI In addition to being a successful experiment in architecting a complex JavaScript project in React, we’ve found that this architecture has led to some critical outcomes: Predictable state management: By breaking state into discrete objects, it’s easier for us to see which actions are mutating state in our components. Easy for non-UI-focused team members to contribute: Building our UI architecture with object-oriented programming allows our less experienced UI devs to quickly contribute to the project. Explicitness: Because we’ve decoupled state, UI components, and the underlying service models, new contributors can quickly figure out exactly what parts of the project to contribute to. Ease of use: Thanks to this decoupled and organized architecture, our agent and service engineers were able to complete a significant chunk of UI work in a single sprint while the UI engineer was on a weeklong vacation.   By Frank Linehan Frank Linehan is a Senior Software Engineer on the Mobile APM team at New Relic. He's passionate about front-end engineering, emergent JavaScript frameworks, and maintainable and flexible JavaScript projects. He's also very passionate about mountaineering. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 772.96936,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How We Architected the <em>New</em> <em>Relic</em> Mobile Web <em>UI</em> in React",
        "sections": "The <em>new</em> <em>and</em> improved <em>New</em> <em>Relic</em> Mobile <em>UI</em> architecture",
        "body": " error). By moving that shared behavior to the HTTP request object and inheriting off of it, we removed hundreds of lines of redundant code from our project. Plugged in NRQL models The <em>New</em> <em>Relic</em> <em>Query</em> Language models are modules of code that generate NRQL queries used by the <em>UI</em> <em>components</em>"
      },
      "id": "60768db464441f7ce19d854c"
    },
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 747.7059,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Subscribe to your <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "body": " <em>components</em> from the <em>SDK</em>. You&#x27;ve learned how to publish, tag, subscribe, and unsubscribe to and from <em>apps</em> in the catalog. You&#x27;ve also learned how to submit metadata to the catalog. Next steps Now that you know how to build a <em>New</em> <em>Relic</em> <em>One</em> application, you can read the <em>SDK</em> documentation to learn more about all the <em>components</em> you can use to create <em>apps</em> for your own purposes."
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:50Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 745.20654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add user interface <em>components</em> to your <em>application</em>",
        "body": "If an application is organized, it is more readable and more understandable. In your A&#x2F;B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface <em>components</em> to bring some organization to your application and provide <em>new</em> functionality. First"
      },
      "id": "6073006628ccbce73151c12f"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.26105,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.49353,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.4714,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.46234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.46234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    }
  ],
  "/build-apps/build-visualization": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 535.4153,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "body": " see the app under Your apps, you may have to refresh the page or clear your browser cache. It&#x27;s important to note that you can <em>subscribe</em> to applications in the <em>catalog</em> with the <em>nr1</em> <em>CLI</em>. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: Copy the key you created. You'll use it to associate your New Relic account with the CLI. The CLI will then use the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name> with an arbirary name, the <User key> with the key you copied in Step 1, and the region with either us or eu. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 453.9088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic <em>One</em> <em>CLI</em>",
        "body": " this by checking your SDK version: bash Copy $ <em>nr1</em> --version Tip It’s important to distinguish between the newrelic <em>CLI</em> and the <em>nr1</em> <em>CLI</em>. newrelic is for managing entities in your New Relic account. <em>nr1</em> is for managing New Relic <em>One</em> applications. Step 3 of 3 Associate your New Relic account as a <em>CLI</em> profile"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-16T02:10:56Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.94548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to New Relic <em>One</em> SDK",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-16T10:15:36Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.68211,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/embed/",
      "sections": [
        "Describe your app for the catalog",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "baf09ac55fe0770a7b7de7102f2a2a7a463d49de",
      "popularity": 1,
      "body": "In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your Nerdpack. Step 1 of 6 Change to the describe-app/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/describe-app/ab-test Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create --type catalog This creates a catalog directory with template files for inputting custom information about your app. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! catalog/documentation.md Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } catalog/config.json Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory. Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.93393,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Describe your app for the <em>catalog</em>",
        "body": "-programmability-course&#x2F;describe-app&#x2F;ab-test Step 2 of 6 Create the <em>catalog</em> directory: bash Copy $ <em>nr1</em> create --type <em>catalog</em> This creates a <em>catalog</em> directory with template files for inputting custom information about your app. Tip Read our documentation to learn more about the <em>catalog</em> directory. Step 3 of 6 Update"
      },
      "id": "606e63d8e7b9d201e9bfa819"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 362.98065,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.17804,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.15573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.14658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.14658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 362.98065,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.17804,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.15573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.14658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.14658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/embed/",
      "sections": [
        "Nerdpack permissions",
        "Restrictions for basic users",
        "Role-related restrictions",
        "Account access"
      ],
      "published_at": "2021-04-16T02:17:44Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "a153ce2cd8dd363ee81cfb2648787713b4b73bb4",
      "popularity": 1,
      "body": "There are several restrictions around who can publish, use, and subscribe to Nerdpacks (the file packages that represent New Relic One applications). Restrictions for basic users The most important permissions factor is user type. A basic user has several restrictions related to their inability to access Full Stack Observability, and a full user theoretically has full abilities. Basic users can: Build and serve their own Nerdpacks locally Use some public Nerdpacks that don't make use of Full Stack Observability features that another user has subscribed their account to. Basic users can't: Publish the Nerdpacks they've built Tag their Nerdpacks Subscribe an account to a Nerdpack Use private Nerdpacks (including their own) Use public Nerdpacks that have Full Stack Observability features Full users can use any Nerdpacks that the account they're in has been subscribed to, whether built by New Relic or others. Full users theoretically have Nerdpack management permissions, but there may be restrictions related to custom role assignments (see below). Role-related restrictions For full users, there are role-related rules that may impact one's ability to manage Nerdpacks (publish them and subscribe to them). How this works depends on your account/user model: Original user model: Owners and Admins can manage Nerdpacks, as can users specifically assigned the Nerdpack manager add-on role. For more details about how account access works for users, see Account access New Relic One user model: the ability to manage Nerdpacks is dependent on the \"modify Nerdpacks\" capability. That capability is included in the All product admin role, which both the default Admin and User groups have. And it can also be assigned to a custom role. To learn more about account/user models, see User model overview. Account access For organizations with master/sub-account structures: If you subscribe to a Nerdpack from a master account, that access is inherited by all of its sub-accounts. A Nerdpack made by your team can only be subscribed to from the master account that was used to publish it, or from its sub-accounts. This means that, if the Nerdpack needs to be available across your organization, you may need a New Relic admin to deploy it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.17752,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdpack</em> <em>permissions</em>",
        "body": " by New Relic or others. Full users theoretically have <em>Nerdpack</em> management <em>permissions</em>, but there may be restrictions related to custom role assignments (see below). Role-related restrictions For full users, there are role-related rules that may impact one&#x27;s ability to manage Nerdpacks (publish them"
      },
      "id": "6063d5a3196a676061c6f489"
    },
    {
      "sections": [
        "Integrations and custom roles",
        "Recommended role",
        "Optional role",
        "Important",
        "List of permissions",
        "Common permissions",
        "Service-specific permissions",
        "Permissions to link projects through the UI"
      ],
      "title": "Integrations and custom roles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Google Cloud Platform integrations",
        "Get started"
      ],
      "external_id": "d4f60e2d8413ddde9a342980d75a0e216af9baa4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/google-cloud-platform-integrations/get-started/integrations-custom-roles/",
      "published_at": "2021-04-16T16:37:10Z",
      "updated_at": "2021-04-16T16:37:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To read the relevant data from your Google Cloud Platform (GCP) account, New Relic uses the Google Stackdriver API and also other specific services APIs. To access these APIs in your Google Cloud project, the New Relic authorized account needs to be granted a certain set of permissions; GCP uses roles to grant these permissions. Recommended role By default we highly recommend using the GCP primitive role Project Viewer, which grants \"permissions for read-only actions that do not affect your cloud infrastructure state, such as viewing (but not modifying) existing resources or data.\" This role is automatically managed by Google and updated when new Google Cloud services are released or modified. Optional role Alternatively, you can create your own custom role based on the list of permissions, which specifies the minimum set of permissions required to fetch data from each GCP integration. This will allow you to have more control over the permissions set for the New Relic authorized account. Important New Relic has no way of identifying problems related to custom permissions. If you choose to create a custom role, it is your responsibility to maintain it and ensure proper data is being collected. To customize your role you need to: Create a Google Cloud IAM Custom Role in each one of the GCP projects you want to monitor with New Relic. In each custom role, add the permissions that are specifically required for the cloud services you want to monitor according to the following list. Assign the custom role(s) to the New Relic authorized account. List of permissions Common permissions All integrations need the following permission: monitoring.timeSeries.list service.usage.use Service-specific permissions For some GCP integrations, New Relic will also need the following permissions, mainly to collect labels and inventory attributes. Integration Permissions Google AppEngine n/a; Google App Engine does not require additional permissions. Google BigQuery bigquery.datasets.get bigquery.tables.get bigquery.tables.list Google Cloud Functions cloudfunctions.locations.list Google Cloud Load Balancing n/a; Google Cloud Load Balancing does not require additional permissions. Google Cloud Pub/Sub pubsub.subscriptions.get pubsub.subscriptions.list pubsub.topics.get pubsub.topics.list Google Cloud Spanner spanner.instances.list spanner.databases.list spanner.databases.getDdl Google Cloud SQL cloudsql.instances.list Google Cloud Storage storage.buckets.list Google Compute Engine compute.instances.list compute.disks.get compute.disks.list Google Kubernetes Engine container.clusters.list Permissions to link projects through the UI To be able to see the list of projects that you can link to New Relic through the UI, your New Relic authorized service account needs the following permissions: resourcemanager.projects.get monitoring.monitoredResourceDescriptors.list If you do not want to grant New Relic authorized account the permissions that are needed for the linking process through the UI, you have the following options: Assign the Project Viewer or Monitoring Viewer role initially to the authorized account to link Google Cloud projects to New Relic through the UI. After the projects are linked, assign a Google Cloud custom role to the authorized account. Use New Relic NerdGraph to link Google Cloud projects to New Relic. This does not involve listing the viewable projects. However, you must know the id of the project you want to monitor. For more information, see the NerdGraph GraphiQL cloud integrations API tutorial.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.40972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List of <em>permissions</em>",
        "body": " <em>permissions</em>, mainly to collect labels and inventory attributes. Integration <em>Permissions</em> Google <em>App</em>Engine n&#x2F;a; Google <em>App</em> Engine does not require additional <em>permissions</em>. Google BigQuery bigquery.datasets.get bigquery.tables.get bigquery.tables.list Google Cloud Functions cloudfunctions.locations.list Google"
      },
      "id": "603ebb3564441f34b64e8874"
    },
    {
      "sections": [
        "Add custom visualizations to your dashboards",
        "Add a visualization to a dashboard",
        "Manage your dashboard visualizations"
      ],
      "title": "Add custom visualizations to your dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d6c9973ef2c2547a99539d1da027b54db23af42c",
      "image": "https://docs.newrelic.com/static/5f7bd9c6a2a163d1f19c5c8b0d844d2f/c1b63/dashboard_viz.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/add-custom-visualizations-your-dashboards/",
      "published_at": "2021-04-12T03:11:23Z",
      "updated_at": "2021-03-16T11:03:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can build your own visualizations and add them to a dashboard. This gives you great flexibility around what you display on dashboards, from a company logo to custom queries from any data source. This visualization shows the number of people in each city who are viewing New Relic within an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user permissions, which include the Nerdpack manager role, you can add a visualization to a dashboard as described in the following section. The process for creating a visualization is covered in the guide, Build a custom visualization for dashboards. Add a visualization to a dashboard You can add a visualization to a new or existing dashboard. From New Relic, in the top right, click the Apps button, and then on the Apps page, click Custom Visualizations. Hint: if you don't see the Custom Visualizations tile, use the search to locate it. In Custom Visualizations, select the visualization you want to add to a dashboard and then enable it. If there are configuration options, fill those in. The visualization will update with your changes. Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard. If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name. Click Add to dashboard, then click the link to your dashboard to see the custom visualization. Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.45844,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Manage</em> your dashboard visualizations",
        "body": " an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user <em>permissions</em>, which include the <em>Nerdpack</em> <em>manager</em> role, you can add a visualization to a dashboard as described in the following section. The process for creating"
      },
      "id": "603ec4e628ccbc9409eba7ab"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2021-04-16T01:39:18Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2021-01-02T01:38:56Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably.   During this session we will review the following topics:   1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites   This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.   Must have:   Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably.   During this session we will review the following topics:   1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites   This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.   Must have:   Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.85039,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic <em>Applications</em>.",
        "body": " A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    },
    {
      "sections": [
        "No data appears (PHP)",
        "Problem",
        "Solution",
        "For more help"
      ],
      "title": "No data appears (PHP)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Troubleshooting"
      ],
      "external_id": "8dba59344797bc93b3fd1a3b92fdfbb590111766",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/troubleshooting/no-data-appears-php/",
      "published_at": "2021-04-16T07:13:46Z",
      "updated_at": "2021-04-16T07:13:46Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After installing the New Relic PHP agent, generating some traffic, and waiting at least five minutes, no data appears in your New Relic UI. Solution If no data appears after you generate traffic to your app and wait at least five minutes, use New Relic Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve the problem, try the following: PHP agent troubleshooting Comments Compatibility Make sure your system meets the PHP agent's compatibility and requirements. Non-standard PHP version If you are using a non-standard version of PHP, follow the advanced installation procedures to make sure the default installer can find your version of PHP. App name Make sure your apps have a descriptive, unique name. For example, if you have multiple apps with the same name, such as the default app name PHP Application, data from each of these apps rolls up into the default app name, and it may appear as if an individual app is not reporting. Web server Restart your web server (Apache, Nginx, PHP-FPM, etc.), and wait a few minutes for data to appear. phpinfo() Check phpinfo() to verify that you installed the PHP agent and that the license key in it is correct. SELinux If your system uses SELinux, configure SELinux to work with the PHP agent. Log files Verify that both the agent and the daemon are writing to their log files. If not, reinstall the agent. Verify the log file permissions to make sure the log owner is the same as the New Relic user. PHP agent permissions Make sure you have the correct permissions to use the PHP agent. Other If none of these solutions solve the problem, see the troubleshooting procedures for: Agent stops after you update PHP After previously reporting data, the PHP agent stops reporting For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.79485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data <em>appears</em> (PHP)",
        "sections": "No data <em>appears</em> (PHP)",
        "body": ", follow the advanced installation procedures to make sure the default installer can find your version of PHP. <em>App</em> name Make sure your <em>apps</em> have a descriptive, unique name. For example, if you have multiple <em>apps</em> with the same name, such as the default <em>app</em> name PHP Application, data from each of these <em>apps</em>"
      },
      "id": "603e8faae7b9d2b56c2a07df"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/1qf2g217c4q7m/promo-image.1608575584.png",
      "url": "https://learn.newrelic.com/getting-started-with-dashboards-nrql",
      "sections": [
        "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations.",
        "About this workshop",
        "Getting started with Dashboards & NRQL"
      ],
      "published_at": "2021-04-16T01:39:20Z",
      "title": "[Webinar] Getting started with Dashboards & NRQL",
      "updated_at": "2021-04-15T21:10:21Z",
      "type": "",
      "external_id": "20be8b6c5a3882e951f9dfd70354ea7ceaa38c7c",
      "popularity": 1,
      "body": "Sign In [Webinar] Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. Register | FREE Already registered? Sign In About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 111 Getting started with Dashboards & NRQL May 6, 2021, noon - May 6, 2021, 2 p.m. PDT 149 Getting started with Dashboards & NRQL May 11, 2021, 1 p.m. - May 11, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, 1 p.m. - June 8, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, noon - June 8, 2021, 2 p.m. PDT 150 About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Live events Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 111 Getting started with Dashboards & NRQL May 6, 2021, noon - May 6, 2021, 2 p.m. PDT 149 Getting started with Dashboards & NRQL May 11, 2021, 1 p.m. - May 11, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, 1 p.m. - June 8, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, noon - June 8, 2021, 2 p.m. PDT 150 © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.18013,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "[Webinar] Getting started with Dashboards &amp; <em>NRQL</em>",
        "sections": "Learn to use the <em>Data</em> Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of <em>NRQL</em>. Progress to working directly with <em>NRQL</em> to create a wider range of charts and visualizations.",
        "body": " a sandbox account you’ll get familiar with <em>NRQL</em> <em>syntax</em>, work with the Query Builder to build your own queries and charts, and create <em>data</em> rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting"
      },
      "id": "5fe29f8528ccbcf532f15668"
    },
    {
      "image": "https://developer.newrelic.com/static/eb2adf50e7680e8ba5b7daaf06c203d1/757a2/nr1-dashboard.png",
      "url": "https://developer.newrelic.com/collect-data/query-data-nrql/embed/",
      "sections": [
        "Query data with NRQL",
        "Learn more and start building",
        "Documentation",
        "Community forum",
        "GitHub"
      ],
      "published_at": "2021-04-16T02:11:53Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "b702de5dd31aa8a3bfe2548df6ebb92baa78e0d0",
      "popularity": 1,
      "body": "With NRQL, you can query any of the default data being reported by New Relic, plus any custom events and attributes you’ve added. Step 1 of 4 NRQL syntax is comparable to ANSI SQL. Learn more about NRQL syntax SELECT function(attribute) [AS 'label'][, ...] FROM event [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Step 2 of 4 NRQL queries can be as simple as fetching rows of data in a raw tabular form to inspect individual events. Learn what events open source agents provide out of the box -- Fetch a list of Browser PageView events SELECT * FROM PageView Copy Step 3 of 4 NRQL queries can also do extremely powerful calculations before the data is presented to you, such as crafting funnels based on the way people actually use your website. Learn more about NRQL funnels -- See how many users visit, signup, browse and purchase from your site as a funnel SELECT funnel(session, WHERE pageUrl='http://www.demotron.com/' AS 'Visited Homepage', WHERE pageUrl='http://www.demotron.com/signup' AS 'Signed Up', WHERE pageUrl='http://www.demotron.com/browse' AS 'Browsed Items', WHERE pageUrl='http://www.demotron.com/checkout' AS 'Made Purchase') FROM PageView SINCE 12 hours ago Copy Step 4 of 4 Using NRQL, you can customize your New Relic experience by crafting diverse dashboards that show your data from multiple angles. You can share these dashboards with technical and non-technical stakeholders alike. Learn more and start building Documentation For an overview of NRQL syntax, see Introduction to NRQL. For a detailed description of all available functions, see NRQL syntax, components, and functions. Community forum Connect with other developers in the our Explorers Hub. GitHub For examples of integrations and other technologies, check us out on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.73335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Query <em>data</em> with <em>NRQL</em>",
        "body": "With <em>NRQL</em>, you can query any of the default <em>data</em> being reported by New Relic, plus any custom events and attributes you’ve added. Step 1 of 4 <em>NRQL</em> <em>syntax</em> is comparable to ANSI SQL. Learn more about <em>NRQL</em> <em>syntax</em> SELECT function(attribute) [AS &#x27;label&#x27;][, ...] FROM event [WHERE attribute [comparison"
      },
      "id": "6063d5f328ccbc881c43fa66"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/NRQL-Alerting2.png",
      "url": "https://newrelic.com/blog/nerdlog/nrql-alerts-generally-available",
      "sections": [
        "What are NRQL Alerts?",
        "Why use NRQL alerts?",
        "How can you use NRQL alerts?",
        "Where can I get more information?"
      ],
      "published_at": "2021-04-16T04:26:20Z",
      "title": "NRQL Alerts Goes GA: Easily Convert NRQL Queries to Alert Conditions",
      "updated_at": "2021-04-13T23:50:38Z",
      "type": "",
      "external_id": "4e0e8343f3c4f7592a29c28f30f3c437d6e6f8a3",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog NRQL Alerts Goes GA: Easily Convert NRQL Queries to Alert Conditions May 17, 2017 • 4 min read By Chhavi Nijhawan New Relic Query Language (NRQL), pronounced “nerkel,” is the SQL-like language we have been developing since 2014 specifically for analytics. Our customers use NRQL extensively to write custom queries and analyze the data (both metric and events data) they send to New Relic. Along the way we’ve received many requests to add alerting and notifications using data from NRQL queries. Following up on those requests, we announced NRQL alerts at our FutureStack16 user conference in San Francisco last year. Since then, hundreds of customers have participated in the limited-release beta program. They have not only given us great feedback but also demonstrated a plethora of game-changing use cases for NRQL alerting. That’s why I am so happy to announce that NRQL alerting capability is now generally available. What are NRQL Alerts? NRQL alerts are designed to offer the ability to create highly customized alerts using NRQL queries on the data you store in New Relic Insights and the New Relic database (NRDB). Now NRQL queries can be easily converted to alert conditions using the New Relic Alerts UI. The screenshots below show just how easy it is to use: Why use NRQL alerts? New Relic Alerts are designed to provide an easy-to-use, centralized UI to create alert conditions with full-stack visibility. Alert conditions can be easily created on a wide range of metric data collected from almost all New Relic products (including New Relic APM, New Relic Browser, New Relic Synthetics, New Relic Mobile, and New Relic Infrastructure) using the New Relic Alerts UI. Now, in addition to operationalizing on metric data, NRQL alerts extend that capability to your event data stored in NRDB. This data can contain many dimensions, and NRQL lets you instantly slice and dice it to receive notifications when thresholds are met for the nuanced performance indicators that best represent system or business health. One common use case for NRQL alerts is to alert off a group of things based on some shared criteria; for instance, if you want to trigger an alert any time checkout-related transactions have a duration longer than a particular threshold. The following NRQL query shows how easy it is: Customers familiar with New Relic’s Key Transactions capability may be asking, “Isn’t that the same as a Key Transaction response time condition?” Yes, but with NRQL and the addition of a simple custom attribute like “username,” you can modify the query to notify you when a particular VIP customer had a bad experience with checkout: The ability to arbitrarily filter and aggregate with a flexible analytics-focused query language (NRQL) opens the door to endless possibilities for ops and DevOps teams. How can you use NRQL alerts? Since NRQL alerts has been in limited-release beta, early users have been busy coming up with innovative ways to use it. Nate Heinrich recently wrote a description of how NRQL alerts works, and shared his “giant list of things you can do with this that might inspire you.” Read his post NRQL Alerts Will Change How You Think About Using New Relic Data to find more than a dozen examples of useful queries, including creating percentile-based queries on transaction data, so you don’t get swayed by misleading averages. Where can I get more information? For more information on NRQL alerts, refer to the create alert conditions for NRQL queries section of the New Relic documentation. And lots of great information on how to write NRQL queries can be found in the NRQL syntax, components, functions section of our documentation. Or, now that NRQL alerts is generally available, just go ahead and give it a try yourself!   By Chhavi Nijhawan Chhavi Nijhawan is a senior product marketing manager at New Relic. She is passionate about new technologies. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.596245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> Alerts Goes GA: Easily Convert <em>NRQL</em> Queries to Alert Conditions",
        "sections": "What are <em>NRQL</em> Alerts?",
        "body": " been developing since 2014 specifically for analytics. Our customers use <em>NRQL</em> extensively to write custom queries and analyze the <em>data</em> (both metric and events <em>data</em>) they send to New Relic. Along the way we’ve received many requests to add alerting and notifications using <em>data</em> from <em>NRQL</em> queries"
      },
      "id": "60762e4e64441fd0499d8569"
    },
    {
      "sections": [
        "Create smoother charts with sliding windows",
        "When to use sliding windows",
        "Valid NRQL syntax for SLIDE BY",
        "Translation from PromQL-style queries",
        "Use SLIDE BY with MAX and AUTO",
        "Tip"
      ],
      "title": "Create smoother charts with sliding windows",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "97fe07b51e5f2c6a2868c924d1c829d82fd8f585",
      "image": "https://docs.newrelic.com/static/9d882293c1b7b04e65b4bcf6f3ae4bbf/e5166/SlidingWindow2.jpg",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows/",
      "published_at": "2021-04-12T03:16:43Z",
      "updated_at": "2021-03-16T13:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Sliding windows are a technique for generating charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. For example, in the image below, a query gathers data with 5 minute windows. The windows \"slide\" by 1 minute. Each window overlaps with the previous window by 4 minutes. 5-minute windows with 1-minute \"slide\" In contrast, with \"tumbling\" or \"cascading\" windows, the windows do not overlap. For example, in this TIMESERIES 3 minutes NRQL query, the windows are 3 minutes in length, with each beginning when the other ends. There is no overlap in the measurement interval. 3-minute windows with no overlap or \"slide\". When to use sliding windows Sliding windows are helpful when you need to smooth out \"spiky\" charts. One common use case is to use sliding windows to smooth line graphs that have a lot of variation over short periods of time in cases where the rolling aggregate (for example a rolling mean) is more important than aggregates from narrow windows of time. In the example below, data varies greatly from one minute to another, so the 1-minute tumbling window chart shows many high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar data but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid NRQL syntax for SLIDE BY Valid NRQL syntax for the SLIDE BY clause will follow the format below. SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units Copy integer1 specifies the sliding window width and integer2 specifies the SLIDE BY interval. units is a time unit, such as second, minute, hour, or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy Translation from PromQL-style queries When applicable, a PromQL-style query is translated into a NRQL sliding window query. For example, if your PromQL style query uses rate(request_count[5m]) for the past 60 minutes with a 1-minute window overlap, the NRQL translation would be the query below. SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000 Copy In the translation output, the default unit of millisecond is used for TIMESERIES and SLIDE BY clauses. For TIMESERIES, 300000 ms is 300 seconds, or 5 minutes, specifying a window size of 5 minutes. For SLIDE BY, 60000 ms is 60 seconds, specifying a slide interval of 1 minute. Use SLIDE BY with MAX and AUTO You can combine SLIDE BY with MAX and AUTO arguments to further tailor query results, as shown in the examples below. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy Tip When paired with SLIDE BY, TIMESERIES does not support AUTO or MAX. The TIMESERIES value must be an integer time unit value. In other words, SLIDE BY AUTO or SLIDE BY MAX will work, but TIMESERIES AUTO or TIMESERIES MAX followed by SLIDE BY and MAX, AUTO, or a specific integer time unit is not supported. Tip The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which will show up as gaps and unexpected results. If you experience these issues with query results, consider checking for instances of SLIDE BY where the step interval exceeds the window size.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.37631,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Valid <em>NRQL</em> <em>syntax</em> for SLIDE BY",
        "tags": "Query your <em>data</em>",
        "body": " high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar <em>data</em> but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid <em>NRQL</em>"
      },
      "id": "603e8a2528ccbc56e5eba774"
    },
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "Important",
        "General requirements",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "ee49e0ca9bf17447e8349123bfb470ff9964c4fe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-04-16T15:03:36Z",
      "updated_at": "2021-03-30T06:37:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.5942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for custom event <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for custom event <em>data</em>",
        "tags": "Event <em>data</em> sources",
        "body": " for supported <em>data</em> types, naming <em>syntax</em>, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute <em>data</em> types Attribute"
      },
      "id": "6043ef69e7b9d2da1f5799f8"
    }
  ],
  "/automate-workflows/diagnose-problems/error-alerts": [
    {
      "sections": [
        "データエクスプローラーの概要",
        "ヒント",
        "重要な理由",
        "データのクエリ",
        "データエクスプローラーを使用する",
        "イベントを詳しく調べる",
        "メトリックスを詳しく調べる",
        "重要",
        "調査を可視化し絞り込む",
        "クエリエリア",
        "NRQLクエリ表示",
        "チャートエリア",
        "共有してエクスポート",
        "使用事例",
        "新規データを確認",
        "データを検証",
        "データの問題のトラブルシューティング",
        "その他のヘルプ"
      ],
      "title": "データエクスプローラーの概要",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "94545f74e5fd5ab0b18f47342f7a8f2a2fa82558",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-16T15:16:11Z",
      "updated_at": "2021-04-12T03:13:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データエクスプローラーを使用すれば、NRQLの知識がなくても、すべてのデータを視覚的に操作できます。データエクスプローラーを使用してデータにアクセスしクエリやカスタマイズ、視覚化を行い、サービスとサービスをつなぎ、一貫したキュレート済みの体験を実現します。 ヒント データエクスプローラー、およびその他のオブザーバビリティ プラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 システムの状態を調査しますか？リソースの計画を作成し、インシデントを特定しそれに対応し、動作不良のトラブルシューティングを行う必要がありますか？データエクスプローラーにより、NRQLを使用したりクエリを構築せずに、視覚的なメニューを通じて、探しているデータを簡単に特定、取得し、視覚化できます。 データエクスプローラーを使用して、次のことを行えます。 イベントやメトリックスデータに、迅速で直感的な方法でアクセスする。 視覚化し簡単に実行できるようにして、データのディメンションを詳しく調べる。 さまざまな観点からデータを把握する：生データや、進歩や配信などについての知見を提供するさまざまな視覚化。 フィルターによりデータを掘り下げる。 1回のクリックで検索をダッシュボードに追加する。 NRQLのしくみについて理解する: データエクスプローラーは、利用可能なデータを検索している間にクエリがどのように構築されるかを示します。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 データのクエリ データエクスプローラーにアクセスするには、one.newrelic.comに移動し ページの上部にあるデータをクエリアイコンをクリックします。 データのブラウズドロップダウンで、イベントまたはメトリクスを選択します。 データエクスプローラーは、New Relicにあるすべてのデータを詳しく調べるためのポータルです。データエクスプローラーUIにあるイベントやメトリックスを詳しく調べたり、LogsやTracesアプリを選択して詳しく調べることができます。また、タブをクリックして、いつでもクエリビルダーにアクセスすることもできます。 データエクスプローラーを使用する データエクスプローラーは、上部にある範囲絞り込みセクション（a）、左側のデータブラウジングエリア（b）、ワークスペース（c）で構成されます。 データエクスプローラーを使用するには： 調べる範囲を定義する：ブラウズするアカウントとデータタイプ（メトリックまたはイベント）を選択します。 タイムピッカーを使用して時間範囲を選択します。 左側のブロックを使用して、イベントかメトリックスのいずれかについて使用可能なデータをブラウズし、検索を作成します。1ブロックにつき1つの要素しか選択できません。ブロックは検索可能です。 イベントを詳しく調べる イベントタイプ 選択したアカウントで使用できるすべてのイベントを表示します。 デフォルトでは、イベントは名前で並び替えられます。 プロット 以前選択したイベントのすべての数字属性を表示します。 リストの最初の項目はcount( * )で、これは属性ではありません。選択したイベントの数を計算します。 デフォルトでは、属性は名前で並び替えられます。 プロットする関数を選択します。デフォルトでは、各属性は関数Averageに設定されます。 ディメンション 以前選択したイベントとプロットのすべてのディメンションを表示します。 ディメンションは、イベントについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 メトリックスを詳しく調べる APM 時間区切りデータを調べるには、AppID、AppName、またはEntityGuidをステップとして選択します（またはそれらのステップでグループ化します）。それ以外の場合は、すべてのエンティティの集計データを取得します。 メトリック 選択したアカウントで使用できるすべてのメトリックスを表示します。 デフォルトでは、メトリックスは名前で並べ替えられます。 ディメンション 以前選択したメトリックのすべてのディメンションを表示します。 ディメンションは、メトリックについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 重要 ユニットの表示には、メトリックシステム（メトリックSIプレフィックスを含む）が使用されています。 調査を可視化し絞り込む 調査の結果は、右側のワーキングスペースに表示されます。 調査を絞り込むか、チャートを共有する ワーキングスペースには、次のものが表示されます。 クエリエリア クエリエリアでは、クエリを異なる構成要素に分解します。ここで、NRQLクエリとして調査の結果を簡単に読み、プロットしている正確なデータをチェックできます。 NRQLに習熟していない場合、このエリアをチェックしクエリの作成方法について学習します。 クエリの別の部分は次のとおりです。 [ イベントのみ]FROM: 最初のブロックで選択したイベント。 SELECT: 選択したプロットまたはメトリック。この入力では、1つの値と1つの関数のみをプロットします。 GROUP BY: FACET句を表し、選択したディメンションごとにデータをグループ化します。 LIMIT: 表示する値の量を入力します。 WHERE: このフィールドを使用して、結果にさらにフィルターを適用します。この入力では、n値をプロットします。 各項目は、xをクリックしてクエリから削除できます。 NRQLクエリ表示 上記のフィールドと、タイムピッカーで選択した時間範囲で構成される、完全なクエリを表示できます。 ヒント より詳細な検索を行う、またはチャートをカスタマイズする必要がある場合データエクスプローラーから、クエリビルダーにアクセスしてクエリを編集できます。 チャートエリア デフォルトでは、データは線チャートで表示されます。チャートピッカーを使用して、面グラフ、円グラフ、およびバーチャートに簡単に切り替えることができます。結果の生データをテーブルまたはJSON形式として表示することもできます。 ディメンションを選択している場合、チャートは異なるファセットで更新されます。チャートの下に、ファセットのリストとそれぞれの値があるファセットの表が表示されます。 ファセットテーブルを使用して、データをドリルダウンします。クリックしたファセットはフィルターとして適用されます。表は表示されたままなので、別のファセットを簡単に選択して調査を続けることができます。 共有してエクスポート 右上にあるオプションメニューを使用して、チャートを画像として取得、またはリンクとして共有、ダッシュボードに追加できます。 また、URLをコピーし、その他のNew Relicユーザーと調査全体を共有することもできます。 使用事例 次の例で、データエクスプローラーをいつどのように使用するかについて学習してください。 新規データを確認 新規インストゥルメンテーションに接続したばかりで、新規データを利用できるかどうか確認したいと思っています。 アカウントとイベント、または新規データを生成しているメトリックを選択します。 データエクスプローラーで別のツールを使用して、利用できるようになった新規データを使ってみる：そのイベントまたはメトリックの生データを表として見る、またはリストとする、またはクリックしてチャートとしてプロットされることを確認します。 イベントやメトリックを選択した後、ディメンションでデータの形状を確認します。濃度を使用して、あらゆるデータの異なる視点を確認できます。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 データを検証 カスタムイベント/メトリックを変更したので、この変更が正常に行われたかどうかをチェックする必要がある。 データエクスプローラータブで、変更したアカウントとデータタイプ、イベント/メトリックを選択します。 エンティティがデータをレポートしていることと、すべての属性がプロットされていることを確認します。 変更した属性を検索し、更新が正常に行われたことをチェックします。 データの問題のトラブルシューティング アラートやダッシュボードからのイベント/メトリックで何か問題があることが分かっている。イベント/メトリック属性の動作について、根本原因を知る必要がある。 データエクスプローラーで、メニューを使用して、想定どおりに動作していないイベントやメトリックを選択し、データエクスプローラーでそのチャートをプロットします。 そこから、そのデータのディメンションを掘り下げて、関連する属性によりフィルターを適用できます。 また、次のような異なる観点からそのデータを把握することもできます：分布や値の順位、経時進化。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.1322,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "605343b4196a6754132d166e"
    },
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.081993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.081993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053433228ccbcdc10c2fd60"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Tip",
        "Why it matters",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "8f390d6aa6f57d215b3c23f8cf08c02ef310bddc",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-12T03:13:31Z",
      "updated_at": "2021-03-16T11:03:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Tip To use the data explorer and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces apps to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From data explorer you can access query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 46.262936,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": " icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs and Traces apps to <em>explore</em> those. You can also access the query builder any time"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Data explorer: Query and chart event data",
        "Important",
        "Events vs metrics",
        "UI components",
        "Data samples",
        "Caution"
      ],
      "title": "Data explorer: Query and chart event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Explore data"
      ],
      "external_id": "72a23b59b41a3cb521c184c24603d50c28cffdb1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/data-explorer-query-chart-event-data/",
      "published_at": "2021-04-16T03:05:44Z",
      "updated_at": "2021-03-30T08:43:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you explore the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs metrics In New Relic Insights, the Data explorer page has two tabs: Events: In the context of the Insights UI, this refers to any data that can be queried via NRQL. This includes all our major data types, including events and the Metric, Log, and Span data types. Metrics: In the context of the Insights UI, this refers to metric timeslice data. (Note that metric timeslice data is available for querying with NRQL in New Relic One.) For an improved querying and charting experience, we recommend using New Relic One chart builder and dashboards. UI components Use the Events data explorer to view and explore the data available to you. The UI includes: A dropdown that lets you select a data type, like PageView or Transaction. A time-based chart for that data. A sample of that data type, showing its attached attributes, and the ability to see other samples. Ability to search by group by and search for specific attributes. Data samples The most recent sample for the chosen data type is listed at the bottom of the page. Default attributes are underlined. To see more samples, select See more samples. You may need to scroll left and right to see the full table of data. Caution The amount of data stored for a given event type can run into the hundreds of thousands, or even millions, of records. This report only shows a small sample. Use this UI to review the structure of the data, not the contents of a specific record. For example, you can use it to make sure an attribute is populating properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 42.20554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data <em>explorer</em>: Query and chart event data",
        "sections": "Data <em>explorer</em>: Query and chart event data",
        "tags": "<em>Explore</em> data",
        "body": " our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you <em>explore</em> the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs"
      },
      "id": "6043efa0e7b9d2b78d5799d2"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/query-and-store-data/embed/",
      "sections": [
        "Query and store data",
        "Tip",
        "Components overview",
        "Query components",
        "Mutation components",
        "Static methods",
        "NrqlQuery"
      ],
      "published_at": "2021-04-16T02:14:39Z",
      "title": "",
      "updated_at": "2021-03-31T01:51:31Z",
      "type": "",
      "external_id": "d3eb598c248158038b798c880cad839c80c69c03",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. Here you can learn how to use the SDK query components, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Tip Query-related React components can be identified by the Query suffix. Mutation-related components can be identified by the Mutation prefix. Components overview Our data components are based on React Apollo. The most basic component is NerdGraphQuery, which accepts any GraphQL (or GraphQL AST generated by the graphql-tag library as the query parameter, and a set of query variables passed as variables. Over this query, we have created an additional set of queries, which can be divided into four groups: User queries: These allow you to query the current user and its associated accounts. Components in this category: UserStorageQuery and AccountsQuery. Entities queries: Because New Relic One is entity-centric, we use queries to make access to your entities easier. You can count, search, list, query, and favorite them. Components in this category: EntityCountQuery, EntitySearchQuery, EntitiesByDomainTypeQuery, EntitiesByGuidsQuery, EntityByGuidQuery, EntityByNameQuery. Storage queries: New Relic One provides a simple storage mechanism that we call NerdStorage. This can be used by Nerdpack creators to store application configuration setting data, user-specific data, and other small pieces of data. Components in this category: UserStorageQuery, AccountStorageQuery, EntityStorageQuery, UserStorageMutation, AccountStorageMutation, and EntityStorageMutation. For details, see NerdStorage. NRQL queries: To be able to query your New Relic data via NRQL (New Relic Query Language), we provide a NrqlQuery component. This component can return data in different formats, so that you can use it for charting and not only for querying. Query components All query components accept a function as a children prop where the different statuses can be passed. This callback receives an object with the following properties: loading: Boolean that is set to true when data fetching is happening. Our components use the cache-and-network strategy, meaning that after the data has loaded, subsequent data reloads might be triggered first with stale data, then refreshed when the most recent data has arrived. data: Root property where the data requested is retrieved. The structure matches a root structure based on the NerdGraph schema. This is true even for highly nested data structures, which means you’ll have to traverse down to find the desired data. error: Contains an Error instance when the query fails. Set to undefined when data is loading or the fetch was successful. fetchMore: Callback function that can be called when the query is being loaded in chunks. The function will only be present when it’s feasible to do so, more data is available, and no fetchMore has already been triggered. Data is loaded in batches of 200 by default. Other components provided by the platform (like the Dropdown or the List) are capable of accepting fetchMore, meaning you can combine them easily. Mutation components Mutation components also accept a children as a function, like the query ones. The mutation can be preconfigured at the component level, and a function is passed back that you can use in your component. This is the standard React Apollo approach for performing mutations, but you might find it easier to use our static mutation method added to the component. More on this topic below. Static methods All of the described components also expose a static method so that they can be used imperatively rather than declaratively. All Query components have a static Query method, and all Mutation components have a mutation method. These static methods accept the same props as their query component, but passed as an object. For example: // Declarative way (using components). function renderAccountList() { return ( <ul> <AccountsQuery> ({data, error}) => { if (error) { return <li>Failed to retrieve list: {error.message}</li>; } return data.map((account) => { <li key={account.id}>{account.name}</li> }); }} </AccountsQuery> </ul> ); } // Imperative way (using promises). async function getAccountList() { let data = {}; try { data = await AccountsQuery.query(); } catch (error) { console.log('Failed to retrieve list: ' + error.message); return; } return data.actor.accounts.map((account) => { return account.name; }); } Copy Similarly, a mutation can happen either way; either declaratively or imperatively. NrqlQuery NrqlQuery deserves additional explanation, because there are multiple formats in which you can return data from it. To provide maximum functionality, all three are exposed through a formatType property. You can find its different values under NrqlQuery.formatType: NERD_GRAPH: Returns the format in which it arrives from NerdGraph. RAW: The format exposed by default in Insights and dashboards when being plotted as JSON. This format is useful if you have a pre-existing script in this format that you're willing to migrate to or incorporate with. CHART: The format used by the charting engine that we also expose. You can find a more detailed explanation of how to manipulate this format in the guide to chart components, and some examples. If you are willing to push data, we currently do not expose NrqlMutation. To do that, see the Event API for how to add custom events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.52303,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Mutation</em> <em>components</em>",
        "body": " <em>method</em> so that they can be used imperatively rather than declaratively. All <em>Query</em> <em>components</em> have a <em>static</em> <em>Query</em> <em>method</em>, and all <em>Mutation</em> <em>components</em> have a <em>mutation</em> <em>method</em>. These <em>static</em> <em>methods</em> accept the same props as their <em>query</em> component, but passed as an object. For example: &#x2F;&#x2F; Declarative way"
      },
      "id": "6063d5a3196a675a1fc6f4a5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/embed/",
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "published_at": "2021-04-16T02:13:38Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:56Z",
      "type": "",
      "external_id": "31fc09fc1a4af441ce6fa9a9ea59fa2216dd2058",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.45116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ": AccountStorage<em>Query</em> and AccountStorage<em>Mutation</em> Entity access: EntityStorage<em>Query</em> and EntityStorage<em>Mutation</em> Each of these <em>components</em> can operate declaratively (for example, as part of your React rendering <em>methods</em>) or imperatively (by using the <em>static</em> <em>methods</em> for <em>query</em> and <em>mutation</em>). For more information"
      },
      "id": "6063d63428ccbcff4e43fa92"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360/",
      "sections": [
        "Java agent v3.36.0",
        "Improvements",
        "Fixes"
      ],
      "published_at": "2021-04-11T16:59:02Z",
      "title": "Java agent v3.36.0",
      "updated_at": "2021-03-11T03:30:39Z",
      "type": "docs",
      "external_id": "620b9aa4068c44bd29515f153020db735791cd39",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic’s built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.927307,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page"
      },
      "id": "60445ebc196a676dd6960f5e"
    },
    {
      "sections": [
        "newrelic_add_custom_tracer (PHP agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples",
        "Instrument a function",
        "Instrument a method within a class",
        "Instrument a method within a namespaced class",
        "For more help"
      ],
      "title": "newrelic_add_custom_tracer (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "c3a4f57bd2b02aa46f896e6e54ef818bac7d66b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer/",
      "published_at": "2021-04-16T06:04:54Z",
      "updated_at": "2021-04-16T06:04:54Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_add_custom_tracer(string $function_name) Copy Specify functions or methods for the agent to instrument with custom instrumentation. Requirements Compatible with all agent versions. Description Specify functions or methods for the agent to target for custom instrumentation. This is the API equivalent of the newrelic.transaction_tracer.custom setting. You cannot apply custom tracing to internal PHP functions. Parameters Parameter Description $function_name string Required. The name can be formatted either as function_name for procedural functions, or as \"ClassName::method\" for methods. Both static and instance methods will be instrumented if the method syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return values Returns true if the tracer was added successfully. Examples Instrument a function function example_function() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"example_function\"); } } Copy Instrument a method within a class class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"ExampleClass::example_method\"); } } } Copy Instrument a method within a namespaced class namespace Foo\\Bar; class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"Foo\\\\Bar\\\\ExampleClass::example_method\"); } } } Copy Alternatively, on PHP 5.5 or later, the ::class syntax can be used instead: namespace Foo\\Bar { class ExampleClass { function example_method() { // ... } } } namespace { use Foo\\Bar; if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(Bar::class . \"::example_method\"); } } } Copy For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.149017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument a <em>method</em> within a class",
        "body": "&quot; for <em>methods</em>. Both <em>static</em> and instance <em>methods</em> will be instrumented if the <em>method</em> syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return values Returns true if the tracer was added successfully. Examples Instrument"
      },
      "id": "6043c950196a67e23d960f2d"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 30.051111,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " RELIC ACCOUNT ID&gt; in your project with your actual New Relic account ID When you&#x27;re finished, stop serving your New Relic One application by pressing CTRL+C in your local server&#x27;s terminal window. Great work! You now have experience using the NerdStorage <em>query</em> and <em>mutation</em> <em>components</em>. However, there&#x27;s"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "sections": [
        "NerdGraph cloud integrations API tutorial",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph cloud integrations API tutorial",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-04-16T14:50:03Z",
      "updated_at": "2021-04-12T04:27:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to https://api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } }</integration_slug></provider_slug> Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } }</integration_slug></provider_slug> Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.85782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> cloud integrations API tutorial",
        "sections": "<em>NerdGraph</em> cloud integrations API tutorial",
        "tags": "<em>NerdGraph</em>",
        "body": "This document provides examples of how to use New Relic <em>NerdGraph</em> to <em>query</em> and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the <em>NerdGraph</em> GraphiQL explorer, you can also <em>query</em> NRQL data. These examples for querying"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/graphql_aws_services-1024x593.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/graphql-api",
      "sections": [
        "Using GraphQL in New Relic",
        "Example 1: Querying Infrastructure cloud integrations with NerdGraph",
        "Example 2: Modifying integration configurations with NerdGraph",
        "Transfering NerdGraph data to the terminal",
        "New Relic and GraphQL—easing the path for developers"
      ],
      "published_at": "2021-04-16T04:24:43Z",
      "title": "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "381e6b1a3bca81ebc8b6efc8199d2b75983befca",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read By Mark Weitzel As you build observability into your workflows and processes, you need the ability to quickly retrieve, sort, and process all kinds of telemetry through APIs. With New Relic, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous API operations. With the NerdGraph API explorer—built on GraphQL—you can more easily query the data you need, without over-or under-fetching, and reduce manual toil in your data analysis workflows. More specifically, in New Relic you can use NerdGraph to: Query all the entities associated with your account Query, create, and update the workloads associated with your account Create, manage, and add tags to entities Query distributed tracing data Fetch data when building a New Relic One application Understand upstream and downstream relationships with your services Configure your New Relic Infrastructure cloud integrations Query event data and custom event data with NRQL In this post, I’ll walk through two examples using NerdGraph to query information about New Relic Infrastructure cloud integrations and update their configuration values. But first a bit of history. Using GraphQL in New Relic Unlike typical REST APIs that often require loading from multiple endpoints, GraphQL provides a single endpoint that can manage complex queries so developers can get all the data their app needs from many services in one request. GraphQL is strongly typed, which allows developers to explicitly declare what information is available via queries to the GraphQL service. This declaration is done via a GraphQL schema. Schemas give developers the flexibility they need to express information about the data they return. For example, each field has a description, which developers can use to indicate the proper usage of the data. Schemas also provide the API blueprint developers need to build tools for properly constructing queries and guiding proper usage of any returned data. For example, developers can use the schema to indicate if a field has been deprecated so tools like IDEs can surface this fact and discourage use of that data. And “schema stitching”—creating a single schema from several underlying GraphQL APIs—allows developers to deliver a unified access experience across all of their APIs, as we’ve done at New Relic: The New Relic GraphQL implementation includes several underlying GraphQL APIs—including accounts, Infrastructure, and the New Relic database (for constructing NRQL queries). For more information on GraphQL, the following examples of querying cloud integration configuration data use GraphQL queries and mutations: Queries: GraphQL requests that only fetch data Mutations: GraphQL requests that modify and fetch data NerdGraph has a single endpoint: https://api.newrelic.com/graphiql. This launches (after authenticating the user) the NerdGraph API interface—an interactive, browser-based IDE for running GraphQL requests. In the NerdGraph API explorer, you build and run your query on the left, and the result is returned on the right. You can click into fields to drill into their definitions. For example, if you drill into actor, you’ll see it contains fields for user and accounts: { actor { user { name email } accounts { id name } } } The fields under actor expose data from different downstream services that are unified in the GrahQL schema delivered by the GraphQL server. When you issue a query, the GraphQL server pulls apart the query and invokes a resolver for each of the services. When the queries complete (or time out or encounter errors), the GraphQL server assembles the result and returns it to you. In the example above, we get information about the user and all the accounts that they have access to. Let’s walk through our examples to show the full power of GraphQL’s data collection capabilities. Example 1: Querying Infrastructure cloud integrations with NerdGraph In my first example, I’ll use NerdGraph to query for various data about the AWS integrations that are running in my New Relic account. I’ll use the data I gather in this example to update some specific settings in the next section. Tip: If you’re planning on following along, make sure you generate an API key that you can use with New Relic’s GraphQL API. In fact, you can generate one directly from NerdGraph. Let's start with a list of the AWS integrations I have available in New Relic Infrastructure: AWS integrations installed in New Relic Infrastructure. Next, let's retrieve some information about these AWS services via a GraphQL query. I’m going to query for the cloud provider (in this case, AWS) that’s linked to my account and the set of integrations from AWS that I’ve installed. To do this, I need to pass the ID of the account I want to query—this is the account(id: MY ACCOUNT ID) part of the query. Notice that I’m “nesting” requests to get information about the cloud provider and the integrations I’m using. If I were using a REST API, this would require multiple calls, but with the GraphQL API, I can gather this information with just one query.   { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { id name slug } integrations { id name service { id slug name createdAt updatedAt provider { name id } } } } } } } } When the query completes, the GraphQL server assembles the results about the AWS integrations I’ve installed, as shown below (note that I’ve truncated the example): { \"data\": { \"actor\": { \"account\": { \"cloud\": { \"linkedAccounts\": [ { \"authLabel\": \"arn:aws:iam::8xxxxxxx7:role/NewRelicInfrastructure-Integrations-Origami\", \"externalId\": \"8xxxxxxx7\", \"id\": 3542, \"integrations\": [ { \"id\": 75540, \"name\": \"RDS\", \"service\": { \"createdAt\": 1470991744, \"id\": 3, \"name\": \"RDS\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"rds\", \"updatedAt\": 1534242454 } }, { \"id\": 14233, \"name\": \"S3\", \"service\": { \"createdAt\": 1470991745, \"id\": 4, \"name\": \"S3\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"s3\", \"updatedAt\": 1534242454 } }, { \"id\": 12223, \"name\": \"Lambda\", \"service\": { \"createdAt\": 1477910055, \"id\": 14, \"name\": \"Lambda\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"lambda\", \"updatedAt\": 1534242454 } }, { \"id\": 172534, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 } }, } } ] } } } } } But what if I want more specific information about one of the integrations? Specifically, I want to see what tags (user-defined metadata) I’ve applied to a particular integration as well as its metrics polling interval (how often New Relic polls the integration for data), and when these settings were last updated. To do this, I’ll need to use one of the more nuanced features of GraphQL—interfaces, an abstract type that represents a collection of common fields that other object types can implement. So in my original query, I’ll add two new clauses: ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } Now, if my query hits a result that is of type CloudDynamodbIntegration or CloudReshiftIntegration, it also return the fields metricsPollingInterval, tagKey, tagValue, and updatedAt. Here's what my (truncated) query will like now: { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { ... } integrations { id name service { ... } } ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } } } } } } In the result, notice that the DynamoDb and Redshift configuration information contain the extra fields that I specified in the query using their interfaces. { \"id\": 173397, \"metricsPollingInterval\": 900, \"name\": \"Redshift\", \"service\": { \"createdAt\": 1497364366, \"id\": 21, \"name\": \"Redshift\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"redshift\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1544435410 }, { \"id\": 112183, \"metricsPollingInterval\": 900, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1549499902 }, OK! I’ve successfully queried information about my AWS integrations in New Relic Infrastructure, and I’ve used an interface to get additional information about a specific integration. Now, I’ll use the GraphQL API to update the metrics data polling intervals in one of these integrations. Example 2: Modifying integration configurations with NerdGraph In GraphQL, when you modify data with a write operation, it’s called a mutation. In this example, I’ll build a mutation to update the polling intervals of an AWS integration. First, though, I’ll set a polling interval so that we'll notice when I change it with NerdGraph. Here are the configuration options for my AWS DynamoDB integration: DynamoDB integration configuration options in New Relic Infrastructure. As you can see, I’ve set the metrics data and inventory data polling intervals to every 5 minutes, and I’ve also toggled Collect tags to ON. Now I’ll build the mutation query. First, I'll start with the keyword mutation, and like any GraphQL API request, enclose it in a pair of curly braces,{ }. Next, I want to specify that I’m configuring a cloud integration; so I’ll add cloudConfigureIntegration, which takes two arguments: accountId and integrations. For accountId, I’ll use the same account id from the first example to get information about the Infrastructure-linked accounts. The second argument is the integrations that I want to update. Again, integrations are specified by cloud provider, so here I want to include aws. So far my mutation looks like this: mutation{ cloudConfigureIntegration( accountId:MY ACCOUNT ID integrations:{aws I want to specify that I’m updating the configuration for DynamoDB, so I’ll pass in an object with dynamodb as the key and an array that contains objects with the values I want to to set. Remember, for our mutation, we want to update the metricsPollingInterval (valid values are 300, 900, 1800, and 3600 seconds) and add a tagKey (metadata about the function of the integration). The final part of the mutation adds a set of fields to return if my request is successful and a set of fields to return if there are any errors. Here's the full query: mutation{ cloudConfigureIntegration( accountId:630060 integrations:{aws:{ dynamodb:[ { linkedAccountId:4912 metricsPollingInterval:1800 tagKey:\"mdw-test\" }] } } ) { integrations{ id name updatedAt ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } errors{ linkedAccountId message integrationSlug } } } And here’s the result, which shows no errors and indicates DynamoDB’s configuration was successfully updated: { \"data\": { \"cloudConfigureIntegration\": { \"errors\": [], \"integrations\": [ { \"id\": 177184, \"metricsPollingInterval\": 1800, \"name\": \"DynamoDB\", \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1551139957 } ] } } } I can now return to New Relic Infrastructure and refresh the DynamoDB configuration page: Refreshing the DynamoDB configuration in New Relic Infrastructure. Our mutation changed the metric polling interval from 300 seconds (5 minutes) to 1800 seconds (30 minutes), and entered tag key value of mdw-test. That's it! I've successfully updated the configuration of a New Relic Infrastructure integration using NerdGraph. Transfering NerdGraph data to the terminal So, now you know how to explore the New Relic data available to you in NerdGraph, and you know how to create queries and mutations, but how do you transfer this data to your code? To capture code-ready queries and mutations, select the Tools drop down in the NerdGraph explorer. To copy a curl statement with the in-scope query to your clipboard, select Copy as CURL. Paste this code snippet into your terminal, or use it to populate an HTTP request in your code. If you’re working with the New Relic CLI, select Copy as New Relic CLI from the drop down to generate a command-line ready query or mutation. New Relic and GraphQL—easing the path for developers As these examples show, GraphQL is extremely flexible and lightweight, and dramatically reduces the overhead of working with your New Relic data. If you want to challenge yourself even more, create some more complex queries in the Query Builder. For example, can you create a query to grab the count of all of your reporting entities? Hint: check out NerdGraph’s entity search field. We’re passionate about making life for developers as easy as possible. Check out the resources available at developer.newrelic.com, and engage in the discussion with fellow developers on the Explorer’s Hub. By Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.91061,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Started With <em>NerdGraph</em>—The New Relic GraphQL API Explorer",
        "sections": "Transfering <em>NerdGraph</em> data to the <em>terminal</em>",
        "body": " Infrastructure integration using <em>NerdGraph</em>. Transfering <em>NerdGraph</em> data to the <em>terminal</em> So, now you know how to explore the New Relic data available to you in <em>NerdGraph</em>, and you know how to create queries and <em>mutations</em>, but how do you transfer this data to your code? To capture code-ready queries and <em>mutations</em>"
      },
      "id": "6076314c64441f483e9d8576"
    },
    {
      "image": "https://developer.newrelic.com/static/0ce8c387a290d7fbd6be155322be9bce/bc8d6/create-account.png",
      "url": "https://developer.newrelic.com/collect-data/get-started-nerdgraph-api-explorer/embed/",
      "sections": [
        "Explore NerdGraph using the API Explorer",
        "Before you begin",
        "Build a query to retrieve your name",
        "Click the play button to see the result",
        "Add more fields to your query",
        "Experiment with mutations",
        "Tip",
        "Try your NerdGraph query in the terminal",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "48a6f61f0a9e7054169b785f20fbdd6cd97f2a25",
      "popularity": 1,
      "body": "NerdGraph is New Relic's GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don't need to know the query format: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want and filling out their required values. Before you begin Go to api.newrelic.com/graphiql and log in using your New Relic user ID and password: the NerdGraph API Explorer loads up. Make sure you have a valid New Relic user key. You can create one from the NerdGraph API Explorer or view and create them in the API keys UI. Step 1 of 5 Build a query to retrieve your name Time for your first NerdGraph query. Search for your name in the New Relic database: Erase everything in the query editor. Select the following fields in the query explorer in this order: actor, user, name. This GraphQL snippet appears in the editor. { actor { user { name } } } Copy Step 2 of 5 Click the play button to see the result With this query, you're telling NerdGraph to retrieve your name. You're asking for the name field, which is nested within the user field. This refers to the user who owns the API key, which in turn is nested within actor. Click the play button to see the result: It has almost the same shape as the request. All the fields in the Query Builder make up what's called the GraphQL schema, which describes all the available data types and their attributes. To learn more about each field, click the Docs button, or hover over a field in the editor. Step 3 of 5 Add more fields to your query Now you can try adding more fields to your query. The simplest way is clicking the fields in the Query Builder: The API Explorer knows where the attributes should go in the query. In the example, you add the account id and email fields. Once again, running the GraphQL query results in just the data you need, without over or under-fetching data. Notice that the id field has an argument: passing arguments is a powerful way of customizing your NerdGraph queries. Every field and object can contain arguments, so instead of running multiple queries, you just compose the one that you need. { actor { user { name email } account(id: 12345678) } } Copy Step 4 of 5 Experiment with mutations In GraphQL, mutations are a way to execute queries with side effects that can alter the data by creating, updating, or deleting objects (Commonly referred to as CRUD operations in REST APIs). Ready for your first mutation? Erase what's in the editor. Scroll down the Query Builder and expand mutation. Select the fields in the following screenshot: In this case, you're trying to add a custom tag to an entity. Notice that the editor complains if you don't select errors: mutations must have a way of telling you how the operation performed in the backend (failed requests result in null responses). Tip Unlike REST, GraphQL APIs like NerdGraph can return partial responses. For example, if you try adding tags to multiple entities, some mutations can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your NerdGraph query in the terminal Let's say that you've built a NerdGraph query you're happy with and you want to test it elsewhere. To capture code-ready queries and mutations: Select the Tools menu. Copy the query as a curl call or as a New Relic CLI command. bash Copy $ # curl version $ curl https://api.newrelic.com/graphql \\ > -H 'Content-Type: application/json' \\ > -H 'API-Key: API_KEY_REDACTED' \\ > --data-binary '{\"query\":\"{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id: 12345678)\\n }\\n}\\n\", \"variables\":\"\"}' $ $ # New Relic CLI version $ newrelic nerdgraph query '{ $ actor { $ user { $ name $ email $ } $ account(id: 12345678) $ } $ } $ ' Next steps Now you know the basics of composing and testing NerdGraph queries, but how do you turn them into client or server code? Solutions such as GraphQL Code Generator can help you turn the NerdGraph queries into code for your implementation. Try creating more complex queries by clicking fields and expanding objects in the Query Builder (be careful with mutations though, since they could write data to your account). For more information on NerdGraph and explore other projects from the developer community, check out the threads on the Explorer’s Hub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.40714,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Try your <em>NerdGraph</em> <em>query</em> in the <em>terminal</em>",
        "body": " entities, some <em>mutations</em> can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your <em>NerdGraph</em> <em>query</em> in the <em>terminal</em> Let&#x27;s say that you&#x27;ve built a <em>NerdGraph</em> <em>query</em> you&#x27;re happy with and you want to test it elsewhere. To capture code-ready queries and <em>mutations</em>: Select"
      },
      "id": "6063d63364441f87210c8bb4"
    },
    {
      "sections": [
        "NerdGraph API: Examples",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "NerdGraph API: Examples ",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-04-16T14:43:10Z",
      "updated_at": "2021-03-13T02:52:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.46974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: Examples ",
        "sections": "<em>Mutations</em>",
        "tags": "Alerts and <em>Nerdgraph</em>",
        "body": " Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and <em>mutations</em> is through the <em>NerdGraph</em> API explorer. <em>NerdGraph</em> API explorer Our <em>NerdGraph</em> API explorer is a GraphiQL editor where you can prototype queries and <em>mutations</em>. Here are some examples showing"
      },
      "id": "6043fe3864441f2dd2378ee8"
    },
    {
      "sections": [
        "Use NerdGraph to manage license keys and user keys",
        "Overview of feature description",
        "Before using examples",
        "Create keys",
        "Create a user key",
        "Update keys",
        "Delete keys",
        "Query keys"
      ],
      "title": "Use NerdGraph to manage license keys and user keys",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "5610c77ebfcd92d59c1d0a1b15343f499c8e310e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys/",
      "published_at": "2021-04-16T14:50:59Z",
      "updated_at": "2021-03-16T08:11:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains tutorials on how to use NerdGraph to programmatically manage some New Relic API keys. For general information about New Relic keys, see API keys. Overview of feature description You can use the API keys UI to create and manage keys. Alternatively, you can use NerdGraph's ApiAccess field to programmatically create and manage the following types of keys: User keys License keys, including: General license key (used for APM, infrastructure monitoring, more) Browser key (for browser monitoring) One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. Notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Regarding license keys: License keys are categorized by NerdGraph as ingest keys. This is because their main use is to allow data ingest. You can create up to 1,000 keys of each license key type, which allows for key rotation. You can't manage or delete original license keys; you can only create additional license keys and manage keys you've created. Before using examples Things to note before using these example queries: The examples below use license keys (aka ingest keys), but you can query user keys in similar ways, replacing the ingest-key-specific fields with user-key-specific fields. To understand the data structure, we recommend experimenting with queries using the GraphiQL explorer. You can also create, view, and delete user keys using the UI. Create keys You can create multiple keys in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Here's an example of using this query to create a user key: Create a user key To create a user key, you'd change the above query slightly, in the keys section: mutation { apiAccessCreateKeys(keys: {user: {accountId: YOUR_ACCOUNT_ID, userId: YOUR_USER_ID}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Copy Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.5079,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>NerdGraph</em> to manage license keys and user keys",
        "sections": "Use <em>NerdGraph</em> to manage license keys and user keys",
        "tags": "<em>NerdGraph</em>",
        "body": " to let you rotate keys for security purposes. Note that you can&#x27;t use this <em>NerdGraph</em> functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you&#x27;ve created. Notes about this functionality: All <em>mutations</em> can accept multiple keys"
      },
      "id": "603e96bf28ccbc326aeba75c"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/K8s2.png",
      "url": "https://newrelic.com/blog/how-to-relic/kubernetes-operators-for-parallel-deployment",
      "sections": [
        "What is a Kubernetes Operator?",
        "About the New Relic Kubernetes Operator",
        "Before you begin",
        "Installing the operator on your Kubernetes cluster",
        "Using the Kubernetes operator",
        "Workflow overview",
        "Creating your first alert policy",
        "Add NRQL alert conditions to your alert policy",
        "What’s next?",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:25:05Z",
      "title": "How to Use the New Relic Kubernetes Operators for Parallel Deployment",
      "updated_at": "2021-04-14T00:01:39Z",
      "type": "",
      "external_id": "4b06941f074b16cd874c3c525c2153dfc224613d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring How to Use the New Relic Kubernetes Operators for Parallel Deployment Jul 1, 2020 • 6 min read By Sander Blue The New Relic Developer Toolkit offers a suite of tools expressly built to reduce toil for developers. In Practicing Observability as Code: Defining New Relic Alert Policies with Terraform, we explained how to use the New Relic Terraform provider to deploy monitoring and alerting configurations alongside your infrastructure and application code. Now we're doing the same for Kubernetes. In this post, we'll briefly go over Kubernetes Operators, why they're useful, and show how the New Relic Kubernetes Operator provides a seamless way to deploy New Relic resources alongside your Kubernetes deployment. What is a Kubernetes Operator? Operators are software extensions to Kubernetes that make use of custom resources to manage applications and their components. Operators follow Kubernetes principles, notably the control loop. Kubernetes is becoming the de-facto standard for orchestrating containerized services in the cloud. Kubernetes introduced the Operator pattern in version 1.7, giving you the ability to extend Kubernetes by defining custom Kubernetes objects that can perform domain-specific operations, such as configuring and provisioning third-party services. About the New Relic Kubernetes Operator The New Relic Kubernetes Operator provides the ability to configure your New Relic monitoring resources the same way you manage the rest of your Kubernetes configuration. For example, once you've installed the operator in your cluster, you can create a New Relic alert policy via kubectl apply using New Relic's custom Kubernetes AlertsPolicy object. You can also configure the AlertsPolicy object using NRQL alert conditions. To configure a standalone New Relic NRQL alert condition and apply it to a pre-existing alert policy, you can use New Relic's custom AlertsNrqlCondition object. Note: This post was written with the New Relic Kubernetes Operator version v0.0.2 and Kubernetes version 1.18.2. Before you begin This walkthrough assumes you’ve already deployed a Kubernetes cluster. You could even create a local cluster on your machine with kind. To complete the full exercise, you’ll need to: Install kubectl, and point it at the correct cluster, as this will determine the cluster where you’ll install the New Relic operator. Install kustomize. Installing the operator on your Kubernetes cluster Installing the New Relic operator is a two-step process. First, install cert-manager, which automatically provisions and manages TLS certificates in Kubernetes: kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.15.0/cert-manager.yaml Next, install the Kubernetes operator: kustomize build https://github.com/newrelic/newrelic-kubernetes-operator/configs/default | kubectl apply -f - To confirm the installation was successful, run a few kubectl commands to check the status of the Kubernetes operator. Ensure the Kubernetes operator's namespace, newrelic-kubernetes-operator-system, has been applied: kubectl get namespaces The output should be similar to the example below, which includes the Kubernetes operator's namespace, newrelic-kubernetes-operator-system: NAME                                     STATUS   AGE cert-manager                          Active   4m35s default                               Active   20m kube-node-lease                       Active   20m kube-public                           Active   20m kube-system                           Active   20m newrelic-kubernetes-operator-system   Active   3m48s Now, make sure the Kubernetes operator's controller manager is running: kubectl get pods --namespace newrelic-kubernetes-operator-system Note: Don't forget to include the --namespace (shorthand -n) option when running kubectl get pods to ensure you're inspecting resources within the correct namespace. You should see output similar to the following: NAME                                                               READY   STATUS    RESTARTS   AGE newrelic-kubernetes-operator-controller-manager-7b9c64f58crwg9j   2/2     Running   0          157m If you see output similar to the above, you’re ready for the next step. If you don’t see a pod named newrelic-kubernetes-operator-controller-manager-<hash>, double check your Kubernetes configuration to ensure you’re within the correct context and pointing to the correct cluster. Using the Kubernetes operator Now that Kubernetes operator is deployed to your cluster, you can put it to work. You’ll write the alert policy and NRQL alert condition configuration the same way you write your other Kubernetes configurations. Workflow overview Generally, it’s a three-step process to create your first alert policy using kubectl apply. Using a declarative approach, you’ll write an alert policy configuration file. You’ll add your New Relic personal API key to the configuration. You’ll run kubectl apply when your configuration is ready to go. Creating your first alert policy To kick things off, start small. First, create an alert policy with the minimum required configuration, then add a NRQL alert condition to the policy, which will add the condition to the policy in New Relic. A minimal alert policy configuration is represented in the code below. For the sake of this walkthrough, name this file new_relic_alert_policy.yaml. new_relic_alert_policy.yaml apiVersion: nr.k8s.newrelic.com/v1 kind: AlertsPolicy metadata: name: my-policy spec: account_id: <your New Relic account ID> api_key: <your New Relic personal API key> name: \"Alert Policy Created With k8s\" # Feel free to rename region: \"us\" Note: For help locating your personal API key, check out New Relic's personal API key documentation. Now run the kubectl apply command to create your alert policy: kubectl apply -f ./new_relic_alert_policy.yaml You'll see output that reads similar to the following: alertspolicy.nr.k8s.newrelic.com/my-policy created\\ Confirm that your alert policy was created by viewing your policies at alerts.newrelic.com/accounts/{your account ID}/policies. You can search for your new policy by its name. In this case , you’d search for \"Alert Policy Created With k8s.\" You should see your new alert policy. Now it’s time to add a NRQL alert condition to the policy using the same configuration file. Add NRQL alert conditions to your alert policy Now that you’ve created an alert policy, you’ll want to add some alert conditions to the policy so you can trigger alerts when certain metrics are out of line. In your new_relic_alert_policy.yaml file, add a NRQL alert condition to the policy that will alert you when an application's average overall response time is above five seconds for a three minute period. new_relic_alert_policy.yaml # The policy from the previous steps apiVersion: nr.k8s.newrelic.com/v1 kind: AlertsPolicy metadata: name: my-policy spec: account_id: <your New Relic account ID> api_key: <your New Relic personal API key> name: \"Alert Policy Created With k8s\" # Feel free to rename region: \"us\" # Add a NRQL alert condition to the policy conditions: - spec: type: \"NRQL\" name: \"NRQL Alert Condition Created With k8s\" nrql: query: \"SELECT average(duration) FROM Transaction WHERE appName = 'YOUR APP NAME'\" evaluationOffset: 3 enabled: true terms: - threshold: \"5\" threshold_occurrences: \"ALL\" threshold_duration: 180 priority: \"CRITICAL\" operator: \"ABOVE\" violationTimeLimit: \"ONE_HOUR\" valueFunction: \"SINGLE_VALUE\" Note: To receive notifications when an alert is triggered, you'll want to add notification channels to your alert policy. With the alert condition added to the configuration,  you can apply the update, which will create a NRQL alert condition and add it to your policy. kubectl apply -f ./new_relic_alert_policy.yaml To confirm the successful creation of the NRQL alert condition, refresh your alert policy. If you see a new alert condition added to the alert policy, it was a success. To finish things off,  create and add an alert channel to your alert policy. For example, maybe you want to send an email out to your team when your alert condition is triggered. What’s next? Nice work—now you can manage your New Relic alert policies and NRQL alert conditions with code that integrates seamlessly within your Kubernetes workflow. This allows you to configure and manage your alerts with a domain-specific pattern, providing consistency and maintainability. You also gain the benefits of code reviews for any potential changes moving forward. As you and your team progress, you may need to adjust some of the configuration values to better fit your needs. The New Relic Kubernetes Operator is just one of several tools in the New Relic Developer Toolkit aimed at facilitating observability as code. Check out the New Relic Kubernetes Operator and other tools to help automate your workflows at New Relic Open Source. Related Topics Kubernetes Monitoring By Sander Blue Sander is a Senior Software Engineer at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.98781,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to Use the New Relic <em>Kubernetes</em> <em>Operators</em> for Parallel Deployment",
        "sections": "Add <em>NRQL</em> <em>alert</em> <em>conditions</em> to your <em>alert</em> policy",
        "body": " also configure the AlertsPolicy object using <em>NRQL</em> <em>alert</em> <em>conditions</em>. To configure a standalone New Relic <em>NRQL</em> <em>alert</em> condition and apply it to a pre-existing <em>alert</em> policy, you can use New Relic&#x27;s custom Alerts<em>Nrql</em>Condition object. Note: This post was written with the New Relic <em>Kubernetes</em> <em>Operator</em>"
      },
      "id": "607630e3e7b9d2705da5c672"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-kubernetes/embed/",
      "sections": [
        "Set up New Relic using the Kubernetes operator",
        "Before you begin",
        "Installing the operator on your Kubernetes cluster",
        "Creating your first alert policy",
        "Add NRQL alert conditions to your alert policy",
        "Try it out now",
        "Important",
        "What’s next?"
      ],
      "published_at": "2021-04-16T02:09:02Z",
      "title": "",
      "updated_at": "2021-04-02T01:47:43Z",
      "type": "",
      "external_id": "8fdc25f02e298f98c65266f8c1f05998b32e071f",
      "popularity": 1,
      "body": "Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications. You can use it to provision all kinds of infrastructure and services, including New Relic entities. In this guide you'll learn how to set up New Relic for the first time with the official New Relic Kubernetes operator. More specifically, you'll provision an alert policy with NRQL conditions in your New Relic account using Kubernetes. Before you begin This walkthrough assumes you’ve already deployed a Kubernetes cluster. You could even create a local cluster on your machine with kind. To use this guide, you should have some basic knowledge of both New Relic and Kubernetes. To complete the full exercise, you’ll need to: Deploy a New Relic agent if you haven't done so yet. Install New Relic for your application. Install kubectl and point it at the correct cluster; this determines the cluster where you’ll install the New Relic operator. Install kustomize. Step 1 of 3 Installing the operator on your Kubernetes cluster First, install cert-manager, which automatically provisions and manages TLS certificates in Kubernetes. bash Copy $ kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.15.0/cert-manager.yaml Next, install the Kubernetes operator. bash Copy $ kustomize build https://github.com/newrelic/newrelic-kubernetes-operator/config/default | kubectl apply -f - To confirm the installation was successful, run a few kubectl commands to check the status of the Kubernetes operator. Ensure the Kubernetes operator's namespace, newrelic-kubernetes-operator-system, has been applied: bash Copy $ kubectl get namespaces The output should be similar to the following, which includes the Kubernetes operator's namespace, newrelic-kubernetes-operator-system: bash Copy NAME STATUS AGE cert-manager Active 4m35s default Active 20m kube-node-lease Active 20m kube-public Active 20m kube-system Active 20m newrelic-kubernetes-operator-system Active 3m48s Now, make sure the Kubernetes operator's controller manager is running: Note: Don't forget to include the --namespace (shorthand -n) option when running kubectl get pods to ensure you're inspecting resources within the correct namespace. bash Copy $ kubectl get pods --namespace newrelic-kubernetes-operator-system You should see output similar to the following: bash Copy NAME READY STATUS RESTARTS AGE newrelic-kubernetes-operator-controller-manager-7b9c64f58crwg9j 2/2 Running 0 157m If your output is similar to the example shown, you’re ready for the next step. If you don’t see a pod named newrelic-kubernetes-operator-controller-manager-<hash>, double check your Kubernetes configuration to ensure you’re within the correct context and pointing to the correct cluster. Step 2 of 3 Creating your first alert policy To kick things off, start small. First, create an alert policy with the minimum required configuration, then add a NRQL alert condition to the policy, which will add the condition to the policy in New Relic. A minimal alert policy configuration is represented in the code below. For the sake of this walkthrough, name this file new_relic_alert_policy.yaml. Note: For help locating your user key, check out New Relic's user key documentation. apiVersion: nr.k8s.newrelic.com/v1 kind: AlertsPolicy metadata: name: my-policy spec: account_id: <your New Relic account ID> api_key: <your New Relic user key> name: 'Alert Policy Created With k8s' # Feel free to rename region: 'us' Copy Now run the kubectl apply command to create your alert policy. bash Copy $ kubectl apply -f ./new_relic_alert_policy.yaml You'll see output that reads similar to the following: bash Copy alertspolicy.nr.k8s.newrelic.com/my-policy created Confirm that your alert policy was created by viewing your policies at alerts.newrelic.com/accounts/{your account ID}/policies. You can search for your new policy by its name. In this case, search for \"Alert Policy Created With k8s.\" You should see your new alert policy. Next it’s time to add a NRQL alert condition to the policy using the same configuration file. Step 3 of 3 Add NRQL alert conditions to your alert policy In the previous section you created an alert policy; now, you’ll add some alert conditions to the policy so you can trigger alerts when certain metrics are out of line. In your new_relic_alert_policy.yaml file, add a NRQL alert condition to the policy that will alert you when an application's average overall response time is above five seconds for a three minute period. Note: To receive notifications when an alert is triggered, add notification channels to your alert policy, with this code. # The policy from the previous steps apiVersion: nr.k8s.newrelic.com/v1 kind: AlertsPolicy metadata: name: my-policy spec: account_id: <your New Relic account ID> api_key: <your New Relic user key> name: 'Alert Policy Created With k8s' # Feel free to rename region: 'us' # Add a NRQL alert condition to the policy conditions: - spec: type: 'NRQL' name: 'NRQL Alert Condition Created With k8s' nrql: query: \"SELECT average(duration) FROM Transaction WHERE appName = 'YOUR APP NAME'\" evaluationOffset: 3 enabled: true terms: - threshold: '5' threshold_occurrences: 'ALL' threshold_duration: 180 priority: 'CRITICAL' operator: 'ABOVE' violationTimeLimit: 'ONE_HOUR' valueFunction: 'SINGLE_VALUE' Copy With the alert condition added to the configuration, you can apply the update, which will create a NRQL alert condition and add it to your policy. bash Copy $ kubectl apply -f ./new_relic_alert_policy.yaml To confirm that the NRQL alert condition was created successfully, refresh your alert policy. If you see a new alert condition added to the alert policy, it was a success. To finish things off, you'll create and add an alert channel to your alert policy. For example, maybe you want to send an email out to your team when your alert condition is triggered. Try it out now We have a Kubernetes test cluster ready for you in 2 minutes. By following this on-line tutorial, you will learn how to: Deploy the New Relic agent in a Kubernetes environment Use the New Relic Kubernetes operator Some tips to use the on-line tutorial window: Accept the cookies, so you can see the menu bar. Click anywhere in the tutorial window to start. It will take about 2 minutes for your environment to be ready. Press CTRL-l or type clear to clear the terminal window Click on the finish flag icon in the bottom menu to hide or show the instructions Good luck! Important Some browsers automatically disable the use of iframes. If the module isn't loading please check your browser settings. Your browser does not support iframes. What’s next? Nice work — now you can manage your New Relic alert policies and NRQL alert conditions with code that integrates seamlessly within your Kubernetes workflow. This provides the ability to configure and manage your alerts with a domain-specific pattern, providing consistency and maintainability. You also gain the benefits of code reviews for any potential changes moving forward. As you and your team move forward, you might need to adjust some of the configuration values to better fit your needs. The New Relic Kubernetes Operator is just one of several tools in the New Relic Developer Toolkit aimed at facilitating observability as code.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.7462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>NRQL</em> <em>alert</em> <em>conditions</em> to your <em>alert</em> policy",
        "body": " with the official New Relic <em>Kubernetes</em> <em>operator</em>. More specifically, you&#x27;ll provision an <em>alert</em> policy with <em>NRQL</em> <em>conditions</em> in your New Relic account using <em>Kubernetes</em>. Before you begin This walkthrough assumes you’ve already deployed a <em>Kubernetes</em> cluster. You could even create a local cluster on your machine"
      },
      "id": "606677c064441fbf70617a9a"
    },
    {
      "sections": [
        "Recommended ECS alert conditions",
        "Recommended alert conditions"
      ],
      "title": "Recommended ECS alert conditions",
      "type": "docs",
      "tags": [
        "Integrations",
        "Elastic Container Service integration",
        "Understand use data"
      ],
      "external_id": "334d80a75b3ef0a7b6125bf2a15f643ea46d7282",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/elastic-container-service-integration/understand-use-data/ecs-integration-recommended-alert-conditions/",
      "published_at": "2021-04-16T03:43:17Z",
      "updated_at": "2021-03-16T05:41:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's ECS integration reports and displays performance data from your Amazon ECS environment. This document provides some recommended alert conditions for monitoring ECS performance. Recommended alert conditions Here are some recommended ECS alert conditions. To add these alerts, go to the Alerts UI and add the following NRQL alert conditions to an existing or new alert policy: High CPU usage NRQL: FROM ContainerSample SELECT cpuUsed / cpuLimitCores Critical: > 90% for 5 minutes High memory usage NRQL: FROM ContainerSample SELECT memoryUsageBytes / memorySizeLimitBytes Critical: > 80% for 5 minutes Restart count NRQL: FROM ContainerSample SELECT max(restartCount) - min(restartCount) Critical: > 5 for 5 minutes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.73083,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "sections": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "body": " to the Alerts UI and add the following <em>NRQL</em> <em>alert</em> <em>conditions</em> to an existing or new <em>alert</em> policy: High CPU usage <em>NRQL</em>: FROM ContainerSample SELECT cpuUsed &#x2F; cpuLimitCores Critical: &gt; 90% for 5 minutes High memory usage <em>NRQL</em>: FROM ContainerSample SELECT memoryUsageBytes &#x2F; memorySizeLimitBytes Critical: &gt; 80% for 5 minutes Restart count <em>NRQL</em>: FROM ContainerSample SELECT max(restartCount) - min(restartCount) Critical: &gt; 5 for 5 minutes"
      },
      "id": "603e7eee64441f0f674e889f"
    },
    {
      "sections": [
        "Create NRQL alert conditions",
        "Tip",
        "Create a NRQL alert condition",
        "NRQL alert syntax",
        "Important",
        "Reformatting incompatible NRQL",
        "NRQL alert threshold examples",
        "Alert on specific segments of your data",
        "Alert on Nth percentile of your data",
        "Alert on max, min, avg of your data",
        "Alert on a percentage of your data",
        "Alert on Apdex with any T-value",
        "Alert conditions and query order of operations",
        "Example: null value returned",
        "Example: zero value returned",
        "Nested aggregation NRQL alerts",
        "Nested queries with a non-faceted innermost query are not currently supported",
        "Queries at all levels must have the same aggregation window size",
        "Signal loss is not yet supported for nested queries",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps"
      ],
      "title": "Create NRQL alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "2872f770a5fc8a802f99b9f848906f7e351ad761",
      "image": "https://docs.newrelic.com/static/eb8e1b2d826f9fd9cf46fe3dd5455217/c1b63/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/",
      "published_at": "2021-04-16T14:31:15Z",
      "updated_at": "2021-04-06T05:25:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. Tip For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Copy Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount Tip If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions, but not baseline or static Include an optional FACET clause in your NRQL syntax depending on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. Important If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. Reformatting incompatible NRQL Some elements of NRQL used in charts don’t make sense in the streaming context of alerts. Here’s a list of the most common incompatible elements and suggestions for reformatting a NRQL alert query to achieve the same effect. Element Notes SINCE and UNTIL Example: SELECT percentile(largestContentfulPaint, 75) FROM PageViewTiming WHERE (appId = 837807) SINCE yesterday Copy NRQL Alerting produces a never-ending stream of windowed query results, so the SINCE and UNTIL keywords to scope the query to a point in time are not compatible. As a convenience, we automatically strip SINCE and UNTIL from a query when creating a NRQL Alert Condition from the context of a chart. TIMESERIES In NRQL queries, the TIMESERIES clause is used to return data as a time series broken out by a specified period of time. For NRQL alerts, the equivalent property of a signal is the aggregation window. histogram() The histogram() aggregation function is used to generate histograms. histogram() is not compatible with NRQL alerting: histogram aggregations can not be formatted as a time series. To create an alert from a portion of a histogram (e.g. 95th percentile), use the percentile() aggregation function. Multiple Aggregation Functions Each alert condition can only target a single aggregated stream of data. To alert on multiple streams simultaneously, you’ll need to decompose them into individual conditions within the same policy. Original Query: SELECT count(foo), average(bar), max(baz) from Transaction Copy Decomposed: SELECT count(foo) from Transaction SELECT average(bar) from Transaction SELECT max(baz) from Transaction Copy COMPARE WITH The COMPARE WITH clause is used to compare the values for two different time ranges. This type of query is incompatible with NRQL alerting. We recommend using a Baseline Alert Condition to dynamically detect deviations for a particular signal. SLIDE BY The SLIDE BY clause supports a feature known as sliding windows. With sliding windows, SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. Sliding windows are not currently supported in NRQL alerts. LIMIT In NRQL queries, the LIMIT clause is used to control the amount of data a query returns, either the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. LIMIT is not compatible with NRQL alerting: evaluation is always performed on the full result set. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) Copy SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Copy Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction Copy SELECT percentile(databaseDuration, 75) FROM Transaction Copy Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction Copy SELECT average(duration) FROM Transaction Copy Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction Copy SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Copy Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Copy Alert conditions and query order of operations By default, the aggregation window is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, New Relic will collect data for that window using the function in the NRQL alert condition’s query. The query is parsed and executed by our systems in the following order: FROM clause – which event type needs to be grabbed? WHERE clause – what can be filtered out? SELECT clause – what information needs to be returned from the now-filtered data set? Example: null value returned Let's say this is your alert condition query: SELECT count(*) FROM SyntheticCheck WHERE monitorName = 'My Cool Monitor' AND result = 'FAILURE' Copy If there are no failures for the aggregation window: The system will execute the FROM clause by grabbing all SyntheticCheck events on your account. Then it will execute the WHERE clause to filter through those events by looking only for the ones that match the monitor name and result specified. If there are still events left to scan through after completing the FROM and WHERE operations, the SELECT clause will be executed. If there are no remainig events, the SELECT clause will not be executed. This means that aggregators like count() and uniqueCount() will never return a zero value. When there is a count of 0, the SELECT clause is ignored and no data is returned, resulting in a value of NULL. Example: zero value returned If you have a data source delivering legitimate numeric zeroes, the query will return zero values and not null values. Let's say this is your alert condition query, and that MyCoolEvent is an attribute that can sometimes return a zero value. SELECT average(MyCoolAttribute) FROM MyCoolEvent Copy If, in the aggregation window being evaluated, there's at least one instance of MyCoolEvent and if the average value of all MyCoolAttribute attributes from that window is equal to zero, then a 0 value will be returned. If there are no MyCoolEvent events during that minute, then a NULL will be returned due to the order of operations. Tip For more information about this topic, you can check out our blog post on troubleshooting for zero versus null values. Tip You can determine how null values will be handled by adjusting loss of signal and gap filling settings in the Alert Conditions UI. Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ​​​​​ Copy Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)​​ Copy Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. Tip To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you can't use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Important Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Tip Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Tip Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. Important When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.25445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "sections": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alert</em> <em>conditions</em>",
        "body": "You can use <em>NRQL</em> queries to create <em>alert</em> <em>conditions</em>. Once you&#x27;ve defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts &amp; AI"
      },
      "id": "603ef04864441fbc114e8883"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/7ca56bff2292c37f14a7b98e3e919e36/c1b63/new-relic-alerts-baseline-thresholds.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-04-16T14:30:10Z",
      "updated_at": "2021-03-13T05:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trend s, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: APM: Application metric baseline Browser: Metric baseline NRQL (and then choose a baseline type threshold) Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.499187,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alert</em> <em>conditions</em>",
        "body": " that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for <em>NRQL</em> <em>alert</em> <em>conditions</em>.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/automate-workflows/diagnose-problems": [
    {
      "sections": [
        "データエクスプローラーの概要",
        "ヒント",
        "重要な理由",
        "データのクエリ",
        "データエクスプローラーを使用する",
        "イベントを詳しく調べる",
        "メトリックスを詳しく調べる",
        "重要",
        "調査を可視化し絞り込む",
        "クエリエリア",
        "NRQLクエリ表示",
        "チャートエリア",
        "共有してエクスポート",
        "使用事例",
        "新規データを確認",
        "データを検証",
        "データの問題のトラブルシューティング",
        "その他のヘルプ"
      ],
      "title": "データエクスプローラーの概要",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "94545f74e5fd5ab0b18f47342f7a8f2a2fa82558",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-16T15:16:11Z",
      "updated_at": "2021-04-12T03:13:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データエクスプローラーを使用すれば、NRQLの知識がなくても、すべてのデータを視覚的に操作できます。データエクスプローラーを使用してデータにアクセスしクエリやカスタマイズ、視覚化を行い、サービスとサービスをつなぎ、一貫したキュレート済みの体験を実現します。 ヒント データエクスプローラー、およびその他のオブザーバビリティ プラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 システムの状態を調査しますか？リソースの計画を作成し、インシデントを特定しそれに対応し、動作不良のトラブルシューティングを行う必要がありますか？データエクスプローラーにより、NRQLを使用したりクエリを構築せずに、視覚的なメニューを通じて、探しているデータを簡単に特定、取得し、視覚化できます。 データエクスプローラーを使用して、次のことを行えます。 イベントやメトリックスデータに、迅速で直感的な方法でアクセスする。 視覚化し簡単に実行できるようにして、データのディメンションを詳しく調べる。 さまざまな観点からデータを把握する：生データや、進歩や配信などについての知見を提供するさまざまな視覚化。 フィルターによりデータを掘り下げる。 1回のクリックで検索をダッシュボードに追加する。 NRQLのしくみについて理解する: データエクスプローラーは、利用可能なデータを検索している間にクエリがどのように構築されるかを示します。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 データのクエリ データエクスプローラーにアクセスするには、one.newrelic.comに移動し ページの上部にあるデータをクエリアイコンをクリックします。 データのブラウズドロップダウンで、イベントまたはメトリクスを選択します。 データエクスプローラーは、New Relicにあるすべてのデータを詳しく調べるためのポータルです。データエクスプローラーUIにあるイベントやメトリックスを詳しく調べたり、LogsやTracesアプリを選択して詳しく調べることができます。また、タブをクリックして、いつでもクエリビルダーにアクセスすることもできます。 データエクスプローラーを使用する データエクスプローラーは、上部にある範囲絞り込みセクション（a）、左側のデータブラウジングエリア（b）、ワークスペース（c）で構成されます。 データエクスプローラーを使用するには： 調べる範囲を定義する：ブラウズするアカウントとデータタイプ（メトリックまたはイベント）を選択します。 タイムピッカーを使用して時間範囲を選択します。 左側のブロックを使用して、イベントかメトリックスのいずれかについて使用可能なデータをブラウズし、検索を作成します。1ブロックにつき1つの要素しか選択できません。ブロックは検索可能です。 イベントを詳しく調べる イベントタイプ 選択したアカウントで使用できるすべてのイベントを表示します。 デフォルトでは、イベントは名前で並び替えられます。 プロット 以前選択したイベントのすべての数字属性を表示します。 リストの最初の項目はcount( * )で、これは属性ではありません。選択したイベントの数を計算します。 デフォルトでは、属性は名前で並び替えられます。 プロットする関数を選択します。デフォルトでは、各属性は関数Averageに設定されます。 ディメンション 以前選択したイベントとプロットのすべてのディメンションを表示します。 ディメンションは、イベントについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 メトリックスを詳しく調べる APM 時間区切りデータを調べるには、AppID、AppName、またはEntityGuidをステップとして選択します（またはそれらのステップでグループ化します）。それ以外の場合は、すべてのエンティティの集計データを取得します。 メトリック 選択したアカウントで使用できるすべてのメトリックスを表示します。 デフォルトでは、メトリックスは名前で並べ替えられます。 ディメンション 以前選択したメトリックのすべてのディメンションを表示します。 ディメンションは、メトリックについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 重要 ユニットの表示には、メトリックシステム（メトリックSIプレフィックスを含む）が使用されています。 調査を可視化し絞り込む 調査の結果は、右側のワーキングスペースに表示されます。 調査を絞り込むか、チャートを共有する ワーキングスペースには、次のものが表示されます。 クエリエリア クエリエリアでは、クエリを異なる構成要素に分解します。ここで、NRQLクエリとして調査の結果を簡単に読み、プロットしている正確なデータをチェックできます。 NRQLに習熟していない場合、このエリアをチェックしクエリの作成方法について学習します。 クエリの別の部分は次のとおりです。 [ イベントのみ]FROM: 最初のブロックで選択したイベント。 SELECT: 選択したプロットまたはメトリック。この入力では、1つの値と1つの関数のみをプロットします。 GROUP BY: FACET句を表し、選択したディメンションごとにデータをグループ化します。 LIMIT: 表示する値の量を入力します。 WHERE: このフィールドを使用して、結果にさらにフィルターを適用します。この入力では、n値をプロットします。 各項目は、xをクリックしてクエリから削除できます。 NRQLクエリ表示 上記のフィールドと、タイムピッカーで選択した時間範囲で構成される、完全なクエリを表示できます。 ヒント より詳細な検索を行う、またはチャートをカスタマイズする必要がある場合データエクスプローラーから、クエリビルダーにアクセスしてクエリを編集できます。 チャートエリア デフォルトでは、データは線チャートで表示されます。チャートピッカーを使用して、面グラフ、円グラフ、およびバーチャートに簡単に切り替えることができます。結果の生データをテーブルまたはJSON形式として表示することもできます。 ディメンションを選択している場合、チャートは異なるファセットで更新されます。チャートの下に、ファセットのリストとそれぞれの値があるファセットの表が表示されます。 ファセットテーブルを使用して、データをドリルダウンします。クリックしたファセットはフィルターとして適用されます。表は表示されたままなので、別のファセットを簡単に選択して調査を続けることができます。 共有してエクスポート 右上にあるオプションメニューを使用して、チャートを画像として取得、またはリンクとして共有、ダッシュボードに追加できます。 また、URLをコピーし、その他のNew Relicユーザーと調査全体を共有することもできます。 使用事例 次の例で、データエクスプローラーをいつどのように使用するかについて学習してください。 新規データを確認 新規インストゥルメンテーションに接続したばかりで、新規データを利用できるかどうか確認したいと思っています。 アカウントとイベント、または新規データを生成しているメトリックを選択します。 データエクスプローラーで別のツールを使用して、利用できるようになった新規データを使ってみる：そのイベントまたはメトリックの生データを表として見る、またはリストとする、またはクリックしてチャートとしてプロットされることを確認します。 イベントやメトリックを選択した後、ディメンションでデータの形状を確認します。濃度を使用して、あらゆるデータの異なる視点を確認できます。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 データを検証 カスタムイベント/メトリックを変更したので、この変更が正常に行われたかどうかをチェックする必要がある。 データエクスプローラータブで、変更したアカウントとデータタイプ、イベント/メトリックを選択します。 エンティティがデータをレポートしていることと、すべての属性がプロットされていることを確認します。 変更した属性を検索し、更新が正常に行われたことをチェックします。 データの問題のトラブルシューティング アラートやダッシュボードからのイベント/メトリックで何か問題があることが分かっている。イベント/メトリック属性の動作について、根本原因を知る必要がある。 データエクスプローラーで、メニューを使用して、想定どおりに動作していないイベントやメトリックを選択し、データエクスプローラーでそのチャートをプロットします。 そこから、そのデータのディメンションを掘り下げて、関連する属性によりフィルターを適用できます。 また、次のような異なる観点からそのデータを把握することもできます：分布や値の順位、経時進化。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.1322,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "605343b4196a6754132d166e"
    },
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.081993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.081993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053433228ccbcdc10c2fd60"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Tip",
        "Why it matters",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "8f390d6aa6f57d215b3c23f8cf08c02ef310bddc",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-12T03:13:31Z",
      "updated_at": "2021-03-16T11:03:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Tip To use the data explorer and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces apps to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From data explorer you can access query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 46.262936,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": " icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs and Traces apps to <em>explore</em> those. You can also access the query builder any time"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Data explorer: Query and chart event data",
        "Important",
        "Events vs metrics",
        "UI components",
        "Data samples",
        "Caution"
      ],
      "title": "Data explorer: Query and chart event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Explore data"
      ],
      "external_id": "72a23b59b41a3cb521c184c24603d50c28cffdb1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/data-explorer-query-chart-event-data/",
      "published_at": "2021-04-16T03:05:44Z",
      "updated_at": "2021-03-30T08:43:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you explore the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs metrics In New Relic Insights, the Data explorer page has two tabs: Events: In the context of the Insights UI, this refers to any data that can be queried via NRQL. This includes all our major data types, including events and the Metric, Log, and Span data types. Metrics: In the context of the Insights UI, this refers to metric timeslice data. (Note that metric timeslice data is available for querying with NRQL in New Relic One.) For an improved querying and charting experience, we recommend using New Relic One chart builder and dashboards. UI components Use the Events data explorer to view and explore the data available to you. The UI includes: A dropdown that lets you select a data type, like PageView or Transaction. A time-based chart for that data. A sample of that data type, showing its attached attributes, and the ability to see other samples. Ability to search by group by and search for specific attributes. Data samples The most recent sample for the chosen data type is listed at the bottom of the page. Default attributes are underlined. To see more samples, select See more samples. You may need to scroll left and right to see the full table of data. Caution The amount of data stored for a given event type can run into the hundreds of thousands, or even millions, of records. This report only shows a small sample. Use this UI to review the structure of the data, not the contents of a specific record. For example, you can use it to make sure an attribute is populating properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 42.20554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data <em>explorer</em>: Query and chart event data",
        "sections": "Data <em>explorer</em>: Query and chart event data",
        "tags": "<em>Explore</em> data",
        "body": " our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you <em>explore</em> the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs"
      },
      "id": "6043efa0e7b9d2b78d5799d2"
    }
  ],
  "/automate-workflows/get-started-terraform": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-16T04:24:42Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 349.47632,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Step 3: Provision <em>alert</em> conditions based on the four <em>golden</em> <em>signals</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four <em>golden</em> <em>signals</em> of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-16T02:11:53Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "70555c1d24e8e54b46763d57010901e206ef2ccb",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.21\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.32532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6066782e64441f3610617ac3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/embed/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion"
      ],
      "published_at": "2021-04-15T21:03:41Z",
      "title": "",
      "updated_at": "2021-04-01T01:51:55Z",
      "type": "",
      "external_id": "5e43fb43faa36807fc9f1eb660748303373fa8dd",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day — a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.92786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "6065273be7b9d2336c944613"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-04-16T14:38:31Z",
      "updated_at": "2021-04-06T07:43:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirements: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.33855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/proactive_detection6-1024x765.png",
      "url": "https://newrelic.com/blog/nerdlog/new-capabilities-proactive-detection",
      "sections": [
        "Automatic analysis of every anomaly",
        "See all anomalies in a single view",
        "Alert, query, and leverage the power of anomalies in NRDB",
        "The full power of New Relic AI: anomalies integrated into Incident Intelligence",
        "Related Topics"
      ],
      "published_at": "2021-04-16T00:19:16Z",
      "title": "Enhancing New Relic AI With New Capabilities For Proactive Detection",
      "updated_at": "2021-04-13T23:31:44Z",
      "type": "",
      "external_id": "47801e8f396395e32a3da28b34d08b92af08bacb",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit AIOps Enhancing New Relic AI With New Capabilities For Proactive Detection May 4, 2020 • 6 min read By Annette Sheppard The rate of change within your software is faster than ever, and with this pace comes the risk that your team may miss issues, or lose critical time trying to diagnose the causes of errors. Proactive Detection, an essential part of our recently released AIOps solution, New Relic AI, helps DevOps teams avoid such problems and drive faster mean time to resolution (MTTR) by proactively detecting and analyzing anomalies using data from New Relic APM. Whether it’s alerts you didn’t know you needed to set up or dependent systems you may not even own, New Relic AI Proactive Detection surfaces and analyzes anomalies, bringing attention to potential problems before they become bigger issues—all within your team’s existing incident response workflows. Easy to set up, Proactive Detection simply needs a configuration name and a list of the applications to be monitored to begin discovering and analyzing anomalies in your system. Today we’re announcing four key enhancements to Proactive Detection: An in-depth analysis of each anomaly via the Analysis page A complete list of all anomalies in your environment with the Anomaly overview Integration with the New Relic Database (NRDB), so you can create dashboards and alerts based on anomaly data Integration with New Relic AI Incident Intelligence—via NRQL alerts—for deeper context into incidents Automatic analysis of every anomaly Not only does Proactive Detection flag and notify you of anomalies in your system, it also analyzes each anomaly to help you speed troubleshooting. The Analyze page automatically surfaces queries and context to help explain the cause of an anomaly. Each Proactive Detection notification delivered in Slack provides a link to the Analyze page, allowing you to easily investigate an anomaly or switch between anomalies as you dive deeper into issues. Anomalies delivered to your team via Slack quickly link to the Analyze page for deeper analysis The Analyze page provides an overview of the anomaly itself, as well as details and recent activity for an entity. When available, Proactive Detection automatically suggests attributes that help explain the cause of the anomaly and provide paths for further troubleshooting, as shown in the Key Attributes section: The three key attributes surrounding an error spike are visualized to provide you with multiple paths for troubleshooting. Proactive Detection uses APM event data to suggest queries that explain the anomaly, based either on statistical differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “golden signals” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream or downstream of the initial anomaly. Sparklines include anomalies related to the SRE “golden signals” and additional anomalies in related upstream or downstream applications All of this gives your team a holistic view of the events leading up to the anomaly, helping you better identify what is happening in your application and environment. See all anomalies in a single view The Analyze page provides the context surrounding one anomaly, but the Anomaly overview page gives you a broader view of what's happening in your environment. You’ll have a full view of all detected anomalies, with the ability to instantly view more details for each one. If you want to dive in and learn even more about a specific anomaly, simply use the Analyze link. The Anomaly overview page gives you an overview of all anomalies detected in your environment. Alert, query, and leverage the power of anomalies in NRDB Since all anomalies are automatically written to the NRDB, you can use anomaly data to build dashboards, or create alerts. Query any Proactive Detection event from any configured application. For example, use Proactive Detection data in NRQL alerts to notify you when clusters of anomalies occur. Any anomaly can be plotted in a dashboard to discover trends and patterns. You can even build your dashboards to show anomalous events that are relevant to the specific applications you’re monitoring for anomalies in Proactive Detection. Be notified when clusters of anomalies occur. The full power of New Relic AI: anomalies integrated into Incident Intelligence Proactive Detection and Incident Intelligence are New Relic AI’s critical set of capabilities that help teams detect issues early, eliminate alert noise, and drive toward even faster MTTR. Incident Intelligence uses AI and machine learning (ML) to suppress alerts you don’t care about and correlate related incidents and events into single issues, without excessive configuration, training, or onboarding. Stronger together, you can now link anomalies detected with Proactive Detection to Incident Intelligence—via NRQL alerts—to receive enhanced context inside of your Incident Intelligence to gain the full power of New Relic AI. New Relic AI Proactive Detection has a free tier that you can start using today: If you’re new to New Relic, sign up for your free account. Already using New Relic? Get started with Proactive Detection in under 10 minutes by visiting http://one.newrelic.com > New Relic AI > Proactive Detection. Interested in learning more about New Relic AI, check out these resources: Accelerate Incident Response with AIOps: An introduction to AIOps best practices with New Relic AI (eBook) Accelerate Incident Response with AIOps (Webinar) New Relic AI documentation Request a demo   Related Topics AIOps By Annette Sheppard Annette Sheppard is a Senior Product Marketing Manager at New Relic. She is focused on AIOps and is always looking to learn something new. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.84161,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Alert</em>, query, and leverage the power of anomalies in NRDB",
        "body": " differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “<em>golden</em> <em>signals</em>” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream"
      },
      "id": "607629e028ccbc02d751c161"
    }
  ],
  "/automate-workflows/diagnose-problems/high-response-times": [
    {
      "sections": [
        "データエクスプローラーの概要",
        "ヒント",
        "重要な理由",
        "データのクエリ",
        "データエクスプローラーを使用する",
        "イベントを詳しく調べる",
        "メトリックスを詳しく調べる",
        "重要",
        "調査を可視化し絞り込む",
        "クエリエリア",
        "NRQLクエリ表示",
        "チャートエリア",
        "共有してエクスポート",
        "使用事例",
        "新規データを確認",
        "データを検証",
        "データの問題のトラブルシューティング",
        "その他のヘルプ"
      ],
      "title": "データエクスプローラーの概要",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "94545f74e5fd5ab0b18f47342f7a8f2a2fa82558",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-16T15:16:11Z",
      "updated_at": "2021-04-12T03:13:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データエクスプローラーを使用すれば、NRQLの知識がなくても、すべてのデータを視覚的に操作できます。データエクスプローラーを使用してデータにアクセスしクエリやカスタマイズ、視覚化を行い、サービスとサービスをつなぎ、一貫したキュレート済みの体験を実現します。 ヒント データエクスプローラー、およびその他のオブザーバビリティ プラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 システムの状態を調査しますか？リソースの計画を作成し、インシデントを特定しそれに対応し、動作不良のトラブルシューティングを行う必要がありますか？データエクスプローラーにより、NRQLを使用したりクエリを構築せずに、視覚的なメニューを通じて、探しているデータを簡単に特定、取得し、視覚化できます。 データエクスプローラーを使用して、次のことを行えます。 イベントやメトリックスデータに、迅速で直感的な方法でアクセスする。 視覚化し簡単に実行できるようにして、データのディメンションを詳しく調べる。 さまざまな観点からデータを把握する：生データや、進歩や配信などについての知見を提供するさまざまな視覚化。 フィルターによりデータを掘り下げる。 1回のクリックで検索をダッシュボードに追加する。 NRQLのしくみについて理解する: データエクスプローラーは、利用可能なデータを検索している間にクエリがどのように構築されるかを示します。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 データのクエリ データエクスプローラーにアクセスするには、one.newrelic.comに移動し ページの上部にあるデータをクエリアイコンをクリックします。 データのブラウズドロップダウンで、イベントまたはメトリクスを選択します。 データエクスプローラーは、New Relicにあるすべてのデータを詳しく調べるためのポータルです。データエクスプローラーUIにあるイベントやメトリックスを詳しく調べたり、LogsやTracesアプリを選択して詳しく調べることができます。また、タブをクリックして、いつでもクエリビルダーにアクセスすることもできます。 データエクスプローラーを使用する データエクスプローラーは、上部にある範囲絞り込みセクション（a）、左側のデータブラウジングエリア（b）、ワークスペース（c）で構成されます。 データエクスプローラーを使用するには： 調べる範囲を定義する：ブラウズするアカウントとデータタイプ（メトリックまたはイベント）を選択します。 タイムピッカーを使用して時間範囲を選択します。 左側のブロックを使用して、イベントかメトリックスのいずれかについて使用可能なデータをブラウズし、検索を作成します。1ブロックにつき1つの要素しか選択できません。ブロックは検索可能です。 イベントを詳しく調べる イベントタイプ 選択したアカウントで使用できるすべてのイベントを表示します。 デフォルトでは、イベントは名前で並び替えられます。 プロット 以前選択したイベントのすべての数字属性を表示します。 リストの最初の項目はcount( * )で、これは属性ではありません。選択したイベントの数を計算します。 デフォルトでは、属性は名前で並び替えられます。 プロットする関数を選択します。デフォルトでは、各属性は関数Averageに設定されます。 ディメンション 以前選択したイベントとプロットのすべてのディメンションを表示します。 ディメンションは、イベントについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 メトリックスを詳しく調べる APM 時間区切りデータを調べるには、AppID、AppName、またはEntityGuidをステップとして選択します（またはそれらのステップでグループ化します）。それ以外の場合は、すべてのエンティティの集計データを取得します。 メトリック 選択したアカウントで使用できるすべてのメトリックスを表示します。 デフォルトでは、メトリックスは名前で並べ替えられます。 ディメンション 以前選択したメトリックのすべてのディメンションを表示します。 ディメンションは、メトリックについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 重要 ユニットの表示には、メトリックシステム（メトリックSIプレフィックスを含む）が使用されています。 調査を可視化し絞り込む 調査の結果は、右側のワーキングスペースに表示されます。 調査を絞り込むか、チャートを共有する ワーキングスペースには、次のものが表示されます。 クエリエリア クエリエリアでは、クエリを異なる構成要素に分解します。ここで、NRQLクエリとして調査の結果を簡単に読み、プロットしている正確なデータをチェックできます。 NRQLに習熟していない場合、このエリアをチェックしクエリの作成方法について学習します。 クエリの別の部分は次のとおりです。 [ イベントのみ]FROM: 最初のブロックで選択したイベント。 SELECT: 選択したプロットまたはメトリック。この入力では、1つの値と1つの関数のみをプロットします。 GROUP BY: FACET句を表し、選択したディメンションごとにデータをグループ化します。 LIMIT: 表示する値の量を入力します。 WHERE: このフィールドを使用して、結果にさらにフィルターを適用します。この入力では、n値をプロットします。 各項目は、xをクリックしてクエリから削除できます。 NRQLクエリ表示 上記のフィールドと、タイムピッカーで選択した時間範囲で構成される、完全なクエリを表示できます。 ヒント より詳細な検索を行う、またはチャートをカスタマイズする必要がある場合データエクスプローラーから、クエリビルダーにアクセスしてクエリを編集できます。 チャートエリア デフォルトでは、データは線チャートで表示されます。チャートピッカーを使用して、面グラフ、円グラフ、およびバーチャートに簡単に切り替えることができます。結果の生データをテーブルまたはJSON形式として表示することもできます。 ディメンションを選択している場合、チャートは異なるファセットで更新されます。チャートの下に、ファセットのリストとそれぞれの値があるファセットの表が表示されます。 ファセットテーブルを使用して、データをドリルダウンします。クリックしたファセットはフィルターとして適用されます。表は表示されたままなので、別のファセットを簡単に選択して調査を続けることができます。 共有してエクスポート 右上にあるオプションメニューを使用して、チャートを画像として取得、またはリンクとして共有、ダッシュボードに追加できます。 また、URLをコピーし、その他のNew Relicユーザーと調査全体を共有することもできます。 使用事例 次の例で、データエクスプローラーをいつどのように使用するかについて学習してください。 新規データを確認 新規インストゥルメンテーションに接続したばかりで、新規データを利用できるかどうか確認したいと思っています。 アカウントとイベント、または新規データを生成しているメトリックを選択します。 データエクスプローラーで別のツールを使用して、利用できるようになった新規データを使ってみる：そのイベントまたはメトリックの生データを表として見る、またはリストとする、またはクリックしてチャートとしてプロットされることを確認します。 イベントやメトリックを選択した後、ディメンションでデータの形状を確認します。濃度を使用して、あらゆるデータの異なる視点を確認できます。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 データを検証 カスタムイベント/メトリックを変更したので、この変更が正常に行われたかどうかをチェックする必要がある。 データエクスプローラータブで、変更したアカウントとデータタイプ、イベント/メトリックを選択します。 エンティティがデータをレポートしていることと、すべての属性がプロットされていることを確認します。 変更した属性を検索し、更新が正常に行われたことをチェックします。 データの問題のトラブルシューティング アラートやダッシュボードからのイベント/メトリックで何か問題があることが分かっている。イベント/メトリック属性の動作について、根本原因を知る必要がある。 データエクスプローラーで、メニューを使用して、想定どおりに動作していないイベントやメトリックを選択し、データエクスプローラーでそのチャートをプロットします。 そこから、そのデータのディメンションを掘り下げて、関連する属性によりフィルターを適用できます。 また、次のような異なる観点からそのデータを把握することもできます：分布や値の順位、経時進化。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.1322,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "605343b4196a6754132d166e"
    },
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.081993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-12T03:12:32Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.081993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053433228ccbcdc10c2fd60"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Tip",
        "Why it matters",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "8f390d6aa6f57d215b3c23f8cf08c02ef310bddc",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-12T03:13:31Z",
      "updated_at": "2021-03-16T11:03:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Tip To use the data explorer and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces apps to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From data explorer you can access query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 46.262936,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": " icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs and Traces apps to <em>explore</em> those. You can also access the query builder any time"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Data explorer: Query and chart event data",
        "Important",
        "Events vs metrics",
        "UI components",
        "Data samples",
        "Caution"
      ],
      "title": "Data explorer: Query and chart event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Explore data"
      ],
      "external_id": "72a23b59b41a3cb521c184c24603d50c28cffdb1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/data-explorer-query-chart-event-data/",
      "published_at": "2021-04-16T03:05:44Z",
      "updated_at": "2021-03-30T08:43:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you explore the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs metrics In New Relic Insights, the Data explorer page has two tabs: Events: In the context of the Insights UI, this refers to any data that can be queried via NRQL. This includes all our major data types, including events and the Metric, Log, and Span data types. Metrics: In the context of the Insights UI, this refers to metric timeslice data. (Note that metric timeslice data is available for querying with NRQL in New Relic One.) For an improved querying and charting experience, we recommend using New Relic One chart builder and dashboards. UI components Use the Events data explorer to view and explore the data available to you. The UI includes: A dropdown that lets you select a data type, like PageView or Transaction. A time-based chart for that data. A sample of that data type, showing its attached attributes, and the ability to see other samples. Ability to search by group by and search for specific attributes. Data samples The most recent sample for the chosen data type is listed at the bottom of the page. Default attributes are underlined. To see more samples, select See more samples. You may need to scroll left and right to see the full table of data. Caution The amount of data stored for a given event type can run into the hundreds of thousands, or even millions, of records. This report only shows a small sample. Use this UI to review the structure of the data, not the contents of a specific record. For example, you can use it to make sure an attribute is populating properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 42.20554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data <em>explorer</em>: Query and chart event data",
        "sections": "Data <em>explorer</em>: Query and chart event data",
        "tags": "<em>Explore</em> data",
        "body": " our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you <em>explore</em> the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs"
      },
      "id": "6043efa0e7b9d2b78d5799d2"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/embed/",
      "sections": [
        "Create a Nerdpack",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-04-16T02:01:46Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "7487158c521f4cccda9ec299bae4c06242ad07e7",
      "popularity": 1,
      "body": "A Nerdpack is a package that contains all the files that make up a New Relic One application. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet artifact inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 784.67615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Launchers</em>",
        "body": " to publish your application for others to use. Next, look at the <em>launchers</em> and <em>nerdlets</em> subdirectories. <em>Launchers</em> <em>launchers</em> is a directory because you can create multiple <em>launchers</em> for your <em>New</em> <em>Relic</em> <em>One</em> application. nr1 create only created <em>one</em> <em>launcher</em> for your <em>Nerdpack</em> and called it &quot;ab-test-<em>launcher</em>"
      },
      "id": "6072fee664441ffa0d9d8546"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/embed/",
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-03-31T01:50:30Z",
      "type": "",
      "external_id": "ca6bf3fbbc9a8b6c767f9f9d59f055069300be80",
      "popularity": 1,
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 644.22565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": " building guides and the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> command reference. <em>Nerdpack</em> <em>file</em> <em>structure</em> When you generate a <em>Nerdpack</em> template using the nr1 create command, it has the following <em>file</em> <em>structure</em>: my-<em>nerdlet</em> ├── README.md ├── <em>launchers</em> │   └── my-<em>nerdlet</em>-<em>launcher</em> │   ├── icon.png │   └── nr1.json"
      },
      "id": "6063d566196a67d66cc6f473"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application and click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 467.51422,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add navigation to your <em>Nerdlet</em>",
        "body": "={data} fullWidth &#x2F;&gt;; } } &lt;&#x2F;NrqlQuery&gt; } } &lt;&#x2F;PlatformStateContext.Consumer&gt; &lt;&#x2F;div&gt; } } <em>nerdlets</em>&#x2F;ab-test-<em>nerdlet</em>&#x2F;newsletter-signups.js Copy Important Make sure you replace &lt;YOUR <em>NEW</em> <em>RELIC</em> ACCOUNT ID&gt; and &lt;YOUR <em>NEW</em> <em>RELIC</em> ENTITY GUID&gt; with your actual <em>New</em> <em>Relic</em> account ID and the entity GUID you just"
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "image": "https://developer.newrelic.com/static/0642dd0fbf77f167e4757a87aee06996/0086b/select-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/serve-app/embed/",
      "sections": [
        "Serve your New Relic One application",
        "Tip"
      ],
      "published_at": "2021-04-16T02:09:03Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:06Z",
      "type": "",
      "external_id": "1a2cfa887902435c407fbdf71157b81a01a14513",
      "popularity": 1,
      "body": "When you build a New Relic One application, it's valuable to view it on the platform. This helps you design, implement, and debug your application in the environment it will eventually be published to. With nr1, you can launch a development server that hosts your application so that New Relic One can present it to you. Step 1 of 4 From inside the Nerdpack's root directory, serve your Nerdpack: bash Copy $ nr1 nerdpack:serve When the Nerdpack has succeeded building and your application is ready to view, you'll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! Notice the appended query parameter nerdpacks=local. This query parameter tells New Relic to show locally served Nerdpacks. Tip If you don't see your application on the New Relic platform, make sure you've included nerdpacks=local in your querystring! Step 2 of 4 Navigate to the provided url. From the home page, select Apps to view New Relic One applications: Step 3 of 4 Under the Your apps section, find your launcher, called \"A/B Test Launcher\": Step 4 of 4 Select your launcher to see your root Nerdlet and its default welcome message: Congratulations, you've served your first New Relic One application! Notice, in the command's output, that the server reloads when you change files in your Nerdpack. Give it a try by updating nerdlets/ab-test-nerdlet/index.js: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>A/B test results</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Your app automatically refreshes to show the new heading:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 429.6151,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Serve your <em>New</em> <em>Relic</em> <em>One</em> application",
        "body": " <em>Nerdlet</em> and its default welcome message: Congratulations, you&#x27;ve served your first <em>New</em> <em>Relic</em> <em>One</em> application! Notice, in the command&#x27;s output, that the server reloads when you change files in your <em>Nerdpack</em>. Give it a try by updating <em>nerdlets</em>&#x2F;ab-test-<em>nerdlet</em>&#x2F;index.js: import React from &#x27;react"
      },
      "id": "6072fee564441fe6699d8585"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/embed/",
      "sections": [
        "Add pie charts"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "c0f472d2ed9df8035313cd76ee83ec43e75d0a4a",
      "popularity": 1,
      "body": "You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 413.0805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from <em>one</em> lesson to the next. Step 2 of 9 In <em>nerdlets</em>&#x2F;ab-test-<em>nerdlet</em>, add two <em>new</em> Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total"
      },
      "id": "6072ffcc28ccbc786651c18a"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.47433,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.80579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.02672,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.02208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.02208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "https://developer.newrelic.com/static/a2b20353935db8fba0dbfd0cdc71d8e6/b01d9/use-nerdgraph-launcher.png",
      "url": "https://developer.newrelic.com/build-apps/add-nerdgraphquery-guide/embed/",
      "sections": [
        "Add the NerdGraphQuery component to an application",
        "Important",
        "Before you begin",
        "Prepare the sample code",
        "Add the NerdGraphQuery component",
        "How to use NerdGraphQuery.query",
        "Review the results of the NerdGraph query",
        "Summary"
      ],
      "published_at": "2021-04-16T02:07:54Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "b3165fe5bf522e8281dca658bf3ac296c0997ae9",
      "popularity": 1,
      "body": "This guide steps you through the process of adding the `NerdGraphQuery` component to a sample transaction overview application. This allows you to query data from your New Relic account and add it to a dropdown menu. NerdGraph is our GraphQL implementation. GraphQL has some key differences when compared to REST: The client, not the server, determines what data is returned. You can easily collect data from multiple sources. For example, in a single query, you can get account information, infrastructure data, and issue a NRQL request. Important Before completing this exercise, you can experiment with GraphQL queries in our NerdGraph API explorer. We also have a 14-minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1–4 of our CLI quick start, and be sure to make a copy of your account ID from step 1 because you’ll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 8 If you haven't already done so, clone the example applications from our how-to GitHub repo. Here's an example using HTTPS: bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 8 Change to the directory use-nerdgraph-nerdlet: bash Copy $ cd nr1-how-to/use-nerdgraph/nerdlets/use-nerdgraph-nerdlet Step 3 of 8 In your preferred text editor, open index.js. Step 4 of 8 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 8 Change to the /nr1-howto/use-nerdgraph directory: bash Copy $ cd ../.. Step 6 of 8 If this is your first time executing this code run the below command to install all the required modules: bash Copy $ npm install Step 7 of 8 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 8 of 8 Once the sample application is successfully served, go to the local New Relic One homepage (https://one.newrelic.com/?nerdpacks=local), click Apps, and then click Use NerdGraph. After launching the Use NerdGraph application, you see a dashboard that gives an overview of the transactions in your account: Add the NerdGraphQuery component Now you can create a dropdown menu for changing the account the application is viewing. The first step is to import the NerdGraphQuery component into the application's index.js file. Important If you need more details about our example below, see the APIs and components page on https://developer.newrelic.com Step 1 of 3 Add the NerdGraphQuery component into the first StackItem inside of the return in the index.js file: <NerdGraphQuery query={query} variables={variables}> {({ loading, error, data }) => { console.log({ loading, error, data }); if (loading) { return <Spinner />; } if (error) { return 'Error!'; } return null; }} </NerdGraphQuery>; Copy Step 2 of 3 The NerdGraphQuery component takes a query object that states the source you want to access and the data you want returned. Add the following code to your index.js file in the render method: Important In the browser console, you can see the data from your query returned in an object that follows the same structure of the object in the initial query. const query = ` query($id: Int!) { actor { account(id: $id) { name } } } `; Copy Step 3 of 3 To take the data returned by the NerdGraph query and display it in the application, replace the return null in the current NerdGraphQuery component with this return statement: return <HeadingText>{data.actor.account.name} Apps:</HeadingText>; Copy When you go back to the browser and view your application, you see a new headline showing the name of your account returned from NerdGraph: How to use NerdGraphQuery.query At this point, you have implemented the NerdGraphQuery component with the application's render method and displayed the return data within the transaction overview application. Here's what you need to do next: Query NerdGraph inside of the componentDidMount lifecycle method. Save the returned data for later use in the application. Step 1 of 2 This code takes the response from NerdGraph and makes sure the results are processed, stored into the application state, and logged to the browser console for viewing. Add this code into the index.js file just under the constructor: componentDidMount() { const accountId = this.state; const gql = `{ actor { accounts { id name } } }`; const accounts = NerdGraphQuery.query({query: gql}) //The NerdGraphQuery.query method called with the query object to get your account data is stored in the accounts variable. accounts.then(results => { console.log('Nerdgraph Response:', results); const accounts = results.data.actor.accounts.map(account => { return account; }); const account = accounts.length > 0 && accounts[0]; this.setState({ selectedAccount: account, accounts }); }).catch((error) => { console.log('Nerdgraph Error:', error); }) } Copy Step 2 of 2 After the data is stored into state, display a selection so users can change accounts and update the application. To do this, add this code to index.js for the second StackItem in the return statement: { accounts && ( <StackItem> <Select value={selectedAccount} onChange={(evt, value) => this.selectAccount(value)} > {accounts.map((a) => { return ( <SelectItem key={a.id} value={a}> {a.name} </SelectItem> ); })} </Select> </StackItem> ); } Copy Review the results of the NerdGraph query After you complete these steps, look at the application in your browser, and note the following: The dropdown menu now displays the data returned from the NerdGraphQuery.query and allows you to select an account. After you select a new account, the application shows data from the new selection. The final index.js file should have code similar to the code below. This completed sample is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, NerdGraphQuery, Spinner, HeadingText, Grid, GridItem, Stack, StackItem, Select, SelectItem, AreaChart, TableChart, PieChart } from 'nr1' import { timeRangeToNrql } from '@newrelic/nr1-community'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class UseNerdgraphNerdletNerdlet extends React.Component { constructor(props){ super(props) this.state = { accountId: <YOUR ACCOUNT ID>, accounts: null, selectedAccount: null, } } componentDidMount() { const accountId = this.state; const gql = `{ actor { accounts { id name } } }`; const accounts = NerdGraphQuery.query({ query: gql }) accounts.then(results => { console.log('Nerdgraph Response:', results); const accounts = results.data.actor.accounts.map(account => { return account; }); const account = accounts.length > 0 && accounts[0]; this.setState({ selectedAccount: account, accounts }); }).catch((error) => { console.log('Nerdgraph Error:', error); }) } selectAccount(option) { this.setState({ accountId: option.id, selectedAccount: option }); } render() { const { accountId, accounts, selectedAccount } = this.state; console.log({ accountId, accounts, selectedAccount }); const query = ` query($id: Int!) { actor { account(id: $id) { name } } } `; const variables = { id: accountId, }; const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <Stack fullWidth horizontalType={Stack.HORIZONTAL_TYPE.FILL} gapType={Stack.GAP_TYPE.EXTRA_LOOSE} spacingType={[Stack.SPACING_TYPE.MEDIUM]} directionType={Stack.DIRECTION_TYPE.VERTICAL}> <StackItem> <NerdGraphQuery query={query} variables={variables}> {({loading, error, data}) => { if (loading) { return <Spinner />; } if (error) { return 'Error!'; } return <HeadingText>{data.actor.account.name} Apps:</HeadingText>; }} </NerdGraphQuery> </StackItem> {accounts && <StackItem> <Select value={selectedAccount} onChange={(evt, value) => this.selectAccount(value)}> {accounts.map(a => { return ( <SelectItem key={a.id} value={a}> {a.name} </SelectItem> ) })} </Select> </StackItem> } <StackItem> <hr /> <PlatformStateContext.Consumer> {(PlatformState) => { /* Taking a peek at the PlatformState */ const since = timeRangeToNrql(PlatformState); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Transaction Overview </HeadingText> <TableChart fullWidth accountId={accountId} query={trxOverview+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Average Response Time </HeadingText> <AreaChart fullWidth accountId={accountId} query={avgResTime+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Response Code </HeadingText> <PieChart fullWidth accountId={accountId} query={responseCodes+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Transaction Errors </HeadingText> <PieChart fullWidth accountId={accountId} query={errCount+since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> </StackItem> </Stack> ) } } Copy Summary Now that you've completed all the steps in this example, you've successfully queried data from your account using the NerdGraphQuery component in two methods: Using the NerdGraphQuery component inside the application's render method and then passing the returned data into the children's components. Using the NerdGraphQuery.query method to query data before the application renders.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 651.64386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add the <em>NerdGraphQuery</em> <em>component</em> to an <em>application</em>",
        "body": " headline showing the name of your <em>account</em> returned from <em>NerdGraph</em>: How to use <em>NerdGraphQuery.query</em> At this point, you have implemented the <em>NerdGraphQuery</em> <em>component</em> with the application&#x27;s render method and displayed the return <em>data</em> within the <em>transaction</em> <em>overview</em> application. Here&#x27;s what you need to do"
      },
      "id": "6063d5f328ccbc4e6d43fa95"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/embed/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Tip",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-04-16T02:01:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:32:20Z",
      "type": "",
      "external_id": "f2af52e45942b4cf9499282a654340b132766741",
      "popularity": 1,
      "body": "Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your Nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your Nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in componentDidMount(), you've queried NerdGraph for your api_token data. componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your Nerdlet's state is the current token that your Nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your Nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your Nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called componentDidUpdate(). Now, every time your Nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers componentDidUpdate(). In componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your Nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 630.41235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Access <em>NerdStorageVault</em> from your <em>Nerdlet</em>",
        "body": "StorageVault { secret(key: $key) { value } } } } `; const variables = { key: &quot;api_token&quot;, }; <em>NerdGraphQuery.query</em>( { <em>query</em>: <em>query</em>, variables: variables, } ).then( ({ loading, error, <em>data</em> }) =&gt; { if (error) { console.error(error); this.showPrompt(); } if (<em>data</em> &amp;&amp; <em>data.actor.nerd</em>StorageVault.secret) { this.setState"
      },
      "id": "6072ffcd64441f6cc09d8544"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/graphql_aws_services-1024x593.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/graphql-api",
      "sections": [
        "Using GraphQL in New Relic",
        "Example 1: Querying Infrastructure cloud integrations with NerdGraph",
        "Example 2: Modifying integration configurations with NerdGraph",
        "Transfering NerdGraph data to the terminal",
        "New Relic and GraphQL—easing the path for developers"
      ],
      "published_at": "2021-04-16T04:24:43Z",
      "title": "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "381e6b1a3bca81ebc8b6efc8199d2b75983befca",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read By Mark Weitzel As you build observability into your workflows and processes, you need the ability to quickly retrieve, sort, and process all kinds of telemetry through APIs. With New Relic, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous API operations. With the NerdGraph API explorer—built on GraphQL—you can more easily query the data you need, without over-or under-fetching, and reduce manual toil in your data analysis workflows. More specifically, in New Relic you can use NerdGraph to: Query all the entities associated with your account Query, create, and update the workloads associated with your account Create, manage, and add tags to entities Query distributed tracing data Fetch data when building a New Relic One application Understand upstream and downstream relationships with your services Configure your New Relic Infrastructure cloud integrations Query event data and custom event data with NRQL In this post, I’ll walk through two examples using NerdGraph to query information about New Relic Infrastructure cloud integrations and update their configuration values. But first a bit of history. Using GraphQL in New Relic Unlike typical REST APIs that often require loading from multiple endpoints, GraphQL provides a single endpoint that can manage complex queries so developers can get all the data their app needs from many services in one request. GraphQL is strongly typed, which allows developers to explicitly declare what information is available via queries to the GraphQL service. This declaration is done via a GraphQL schema. Schemas give developers the flexibility they need to express information about the data they return. For example, each field has a description, which developers can use to indicate the proper usage of the data. Schemas also provide the API blueprint developers need to build tools for properly constructing queries and guiding proper usage of any returned data. For example, developers can use the schema to indicate if a field has been deprecated so tools like IDEs can surface this fact and discourage use of that data. And “schema stitching”—creating a single schema from several underlying GraphQL APIs—allows developers to deliver a unified access experience across all of their APIs, as we’ve done at New Relic: The New Relic GraphQL implementation includes several underlying GraphQL APIs—including accounts, Infrastructure, and the New Relic database (for constructing NRQL queries). For more information on GraphQL, the following examples of querying cloud integration configuration data use GraphQL queries and mutations: Queries: GraphQL requests that only fetch data Mutations: GraphQL requests that modify and fetch data NerdGraph has a single endpoint: https://api.newrelic.com/graphiql. This launches (after authenticating the user) the NerdGraph API interface—an interactive, browser-based IDE for running GraphQL requests. In the NerdGraph API explorer, you build and run your query on the left, and the result is returned on the right. You can click into fields to drill into their definitions. For example, if you drill into actor, you’ll see it contains fields for user and accounts: { actor { user { name email } accounts { id name } } } The fields under actor expose data from different downstream services that are unified in the GrahQL schema delivered by the GraphQL server. When you issue a query, the GraphQL server pulls apart the query and invokes a resolver for each of the services. When the queries complete (or time out or encounter errors), the GraphQL server assembles the result and returns it to you. In the example above, we get information about the user and all the accounts that they have access to. Let’s walk through our examples to show the full power of GraphQL’s data collection capabilities. Example 1: Querying Infrastructure cloud integrations with NerdGraph In my first example, I’ll use NerdGraph to query for various data about the AWS integrations that are running in my New Relic account. I’ll use the data I gather in this example to update some specific settings in the next section. Tip: If you’re planning on following along, make sure you generate an API key that you can use with New Relic’s GraphQL API. In fact, you can generate one directly from NerdGraph. Let's start with a list of the AWS integrations I have available in New Relic Infrastructure: AWS integrations installed in New Relic Infrastructure. Next, let's retrieve some information about these AWS services via a GraphQL query. I’m going to query for the cloud provider (in this case, AWS) that’s linked to my account and the set of integrations from AWS that I’ve installed. To do this, I need to pass the ID of the account I want to query—this is the account(id: MY ACCOUNT ID) part of the query. Notice that I’m “nesting” requests to get information about the cloud provider and the integrations I’m using. If I were using a REST API, this would require multiple calls, but with the GraphQL API, I can gather this information with just one query.   { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { id name slug } integrations { id name service { id slug name createdAt updatedAt provider { name id } } } } } } } } When the query completes, the GraphQL server assembles the results about the AWS integrations I’ve installed, as shown below (note that I’ve truncated the example): { \"data\": { \"actor\": { \"account\": { \"cloud\": { \"linkedAccounts\": [ { \"authLabel\": \"arn:aws:iam::8xxxxxxx7:role/NewRelicInfrastructure-Integrations-Origami\", \"externalId\": \"8xxxxxxx7\", \"id\": 3542, \"integrations\": [ { \"id\": 75540, \"name\": \"RDS\", \"service\": { \"createdAt\": 1470991744, \"id\": 3, \"name\": \"RDS\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"rds\", \"updatedAt\": 1534242454 } }, { \"id\": 14233, \"name\": \"S3\", \"service\": { \"createdAt\": 1470991745, \"id\": 4, \"name\": \"S3\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"s3\", \"updatedAt\": 1534242454 } }, { \"id\": 12223, \"name\": \"Lambda\", \"service\": { \"createdAt\": 1477910055, \"id\": 14, \"name\": \"Lambda\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"lambda\", \"updatedAt\": 1534242454 } }, { \"id\": 172534, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 } }, } } ] } } } } } But what if I want more specific information about one of the integrations? Specifically, I want to see what tags (user-defined metadata) I’ve applied to a particular integration as well as its metrics polling interval (how often New Relic polls the integration for data), and when these settings were last updated. To do this, I’ll need to use one of the more nuanced features of GraphQL—interfaces, an abstract type that represents a collection of common fields that other object types can implement. So in my original query, I’ll add two new clauses: ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } Now, if my query hits a result that is of type CloudDynamodbIntegration or CloudReshiftIntegration, it also return the fields metricsPollingInterval, tagKey, tagValue, and updatedAt. Here's what my (truncated) query will like now: { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { ... } integrations { id name service { ... } } ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } } } } } } In the result, notice that the DynamoDb and Redshift configuration information contain the extra fields that I specified in the query using their interfaces. { \"id\": 173397, \"metricsPollingInterval\": 900, \"name\": \"Redshift\", \"service\": { \"createdAt\": 1497364366, \"id\": 21, \"name\": \"Redshift\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"redshift\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1544435410 }, { \"id\": 112183, \"metricsPollingInterval\": 900, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1549499902 }, OK! I’ve successfully queried information about my AWS integrations in New Relic Infrastructure, and I’ve used an interface to get additional information about a specific integration. Now, I’ll use the GraphQL API to update the metrics data polling intervals in one of these integrations. Example 2: Modifying integration configurations with NerdGraph In GraphQL, when you modify data with a write operation, it’s called a mutation. In this example, I’ll build a mutation to update the polling intervals of an AWS integration. First, though, I’ll set a polling interval so that we'll notice when I change it with NerdGraph. Here are the configuration options for my AWS DynamoDB integration: DynamoDB integration configuration options in New Relic Infrastructure. As you can see, I’ve set the metrics data and inventory data polling intervals to every 5 minutes, and I’ve also toggled Collect tags to ON. Now I’ll build the mutation query. First, I'll start with the keyword mutation, and like any GraphQL API request, enclose it in a pair of curly braces,{ }. Next, I want to specify that I’m configuring a cloud integration; so I’ll add cloudConfigureIntegration, which takes two arguments: accountId and integrations. For accountId, I’ll use the same account id from the first example to get information about the Infrastructure-linked accounts. The second argument is the integrations that I want to update. Again, integrations are specified by cloud provider, so here I want to include aws. So far my mutation looks like this: mutation{ cloudConfigureIntegration( accountId:MY ACCOUNT ID integrations:{aws I want to specify that I’m updating the configuration for DynamoDB, so I’ll pass in an object with dynamodb as the key and an array that contains objects with the values I want to to set. Remember, for our mutation, we want to update the metricsPollingInterval (valid values are 300, 900, 1800, and 3600 seconds) and add a tagKey (metadata about the function of the integration). The final part of the mutation adds a set of fields to return if my request is successful and a set of fields to return if there are any errors. Here's the full query: mutation{ cloudConfigureIntegration( accountId:630060 integrations:{aws:{ dynamodb:[ { linkedAccountId:4912 metricsPollingInterval:1800 tagKey:\"mdw-test\" }] } } ) { integrations{ id name updatedAt ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } errors{ linkedAccountId message integrationSlug } } } And here’s the result, which shows no errors and indicates DynamoDB’s configuration was successfully updated: { \"data\": { \"cloudConfigureIntegration\": { \"errors\": [], \"integrations\": [ { \"id\": 177184, \"metricsPollingInterval\": 1800, \"name\": \"DynamoDB\", \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1551139957 } ] } } } I can now return to New Relic Infrastructure and refresh the DynamoDB configuration page: Refreshing the DynamoDB configuration in New Relic Infrastructure. Our mutation changed the metric polling interval from 300 seconds (5 minutes) to 1800 seconds (30 minutes), and entered tag key value of mdw-test. That's it! I've successfully updated the configuration of a New Relic Infrastructure integration using NerdGraph. Transfering NerdGraph data to the terminal So, now you know how to explore the New Relic data available to you in NerdGraph, and you know how to create queries and mutations, but how do you transfer this data to your code? To capture code-ready queries and mutations, select the Tools drop down in the NerdGraph explorer. To copy a curl statement with the in-scope query to your clipboard, select Copy as CURL. Paste this code snippet into your terminal, or use it to populate an HTTP request in your code. If you’re working with the New Relic CLI, select Copy as New Relic CLI from the drop down to generate a command-line ready query or mutation. New Relic and GraphQL—easing the path for developers As these examples show, GraphQL is extremely flexible and lightweight, and dramatically reduces the overhead of working with your New Relic data. If you want to challenge yourself even more, create some more complex queries in the Query Builder. For example, can you create a query to grab the count of all of your reporting entities? Hint: check out NerdGraph’s entity search field. We’re passionate about making life for developers as easy as possible. Check out the resources available at developer.newrelic.com, and engage in the discussion with fellow developers on the Explorer’s Hub. By Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 383.08197,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Started With <em>NerdGraph</em>—The New Relic <em>GraphQL</em> API Explorer",
        "sections": "Example 1: <em>Querying</em> Infrastructure cloud integrations with <em>NerdGraph</em>",
        "body": "QL—you can more easily <em>query</em> the <em>data</em> you need, without over-or under-fetching, and reduce manual toil in your <em>data</em> analysis workflows. More specifically, in New Relic you can use <em>NerdGraph</em> to: <em>Query</em> all the entities associated with your <em>account</em> <em>Query</em>, create, and update the workloads associated"
      },
      "id": "6076314c64441f483e9d8576"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/embed/",
      "sections": [
        "Customize NRQL data",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "f51f9d86d3b873b24e967c687d5408eb9918a33f",
      "popularity": 1,
      "body": "In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Tip If something doesn't work, use these debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your Nerdpack served locally, view your application to see your charts serving real data: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 380.92242,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Customize NRQL <em>data</em>",
        "body": ": { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: [&#x27;name&#x27;, &#x27;count&#x27;], }, <em>data</em>: [ { name: &#x27;Subscriptions&#x27;, count: 0 }, { name: &#x27;Page views&#x27;, count: 0 }, ], } } } <em>component</em>DidMount() { Nrql<em>Query.query</em>({ <em>account</em>Id: this.props.<em>account</em>Id, <em>query</em>: `SELECT count(*) FROM"
      },
      "id": "6073014b28ccbc70b651c134"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/5-server-error.png",
      "url": "https://newrelic.com/blog/nerdlog/apollo-server-plugin",
      "sections": [
        "Troubleshooting errors and latency",
        "Scenario 1: Troubleshooting an error",
        "Scenario 2: Latency is caused by an external service"
      ],
      "published_at": "2021-04-15T23:18:16Z",
      "title": "How to Monitor GraphQL Apps with New Relic Apollo Server Plugin",
      "updated_at": "2021-04-13T23:25:03Z",
      "type": "",
      "external_id": "ed9ecf22946c370441fabd487527ea21ce3cec38",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog How to Monitor GraphQL Apps with New Relic Apollo Server Plugin Dec 15, 2020 • 6 min read By Rebecca Rodriguez Apollo Server, an open source GraphQL server that helps you connect a GraphQL schema to an HTTP server in Node, can be used with popular frameworks such as Express, Connect, Hapi, Koa, Restify, and AWS Lambda. Developed four years ago when Facebook open sourced GraphQL, it has accelerated in popularity over REST APIs, mainly due to its efficiency. However, GraphQL can be challenging to monitor. With GraphQL, you can fetch and retrieve data in a single query, enabling you to ask for exactly the data you need while minimizing the amount of data transferred over the network and improving performance. However, this single operation or endpoint is exactly what makes GraphQL operations challenging to monitor. Measuring the response time of one GraphQL endpoint won’t tell you enough about an application’s health. The New Relic Apollo Server plugin provides visibility into GraphQL payloads down to the resolver level and associated external service calls. To monitor your GraphQL applications, you want to understand the timing of individual GraphQL operations and then have the ability to filter down to the root cause of an issue. If a GraphQL operation is slow, the cause of the latency could be due to several things. For one, it could be the structure of the operation itself. For example, batched operations could cause the operation to take longer than desired. Resolvers, the functions responsible for populating the data for a single field in your schema, could also cause latency. In this case, you’d want to adjust the function call. However, latency could also be caused by an external service’s poor performance, such as an API or a database. Using distributed tracing, you can identify which external service the GraphQL field is calling and attribute the latency to that external service. By using the New Relic Apollo Server plugin to instrument your applications, you can get to the root cause of issues. The plugin records the overall timing of the operations and then parses the payload so you can uncover and diagnose the cause of your slow GraphQL operations. Distributed tracing goes further and provides the capability to understand if the latency is coming from the application itself or other services. Troubleshooting errors and latency Let’s walk through two troubleshooting scenarios: We built a simple example Node application that interfaces with NASA’s Near Earth Objects API (search for near earth object). The app allows us to monitor how close an asteroid is to Earth and when it will get here, so we have time to prepare and minimize impact. Using GraphQL, you can query NASA’s API for the asteroid’s relative velocity and distance from the Earth. It’s important that the GraphQL queries avoid errors and latency to avoid misjudging the time it will take the asteroid to reach us. Scenario 1: Troubleshooting an error In this first example, you see a GraphQL error on the error events page and will want to find the root cause to fix it quickly. 1. Click on the error class to see more detailed error information. 2. Select the transaction name in the transaction view, and explore it using distributed tracing. 3. In the distributed trace view, you can identify the transactions that are throwing the errors. 4. Click on a particular trace to get a detailed view of the operation span with the error message and the offending query. In this case, you can see an internal server error related to the resolver. 5. Finally, you can always keep track of your slow operations and resolvers through a custom dashboard view. Scenario 2: Latency is caused by an external service In this example, you have a transaction view that shows a slow transaction: 1. By hovering over it, you see it’s from a slow GraphQL query called ClosestAstroidFound. 2. To understand why the query is slow, click on the transaction and select Find distributed traces for this transaction. 3. When you see slow transactions, you can explore them using distributed tracing. 4. When exploring the transaction, expand the GraphQL resolver span and see it making a call to another instrumented service taking most of this transaction’s time. Instrument your apps to get to the root cause of GraphQL errors and slowness in GraphQL operations with the New Relic Apollo Server plugin. By Rebecca Rodriguez Rebecca Rodriguez is a Senior Product Manager at New Relic with a focus on Python, Node, and Browser observability data ingest. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.55896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to Monitor <em>GraphQL</em> <em>Apps</em> with New Relic Apollo Server Plugin",
        "body": " navigation <em>menu</em>, 4 items How to Relic Best Practices <em>Nerd</em> Life Nerdlog Search the blog Submit Nerdlog How to Monitor <em>Graph</em>QL Apps with New Relic Apollo Server Plugin Dec 15, 2020 • 6 min read By Rebecca Rodriguez Apollo Server, an open source <em>Graph</em>QL server that helps you connect a <em>Graph</em>QL schema"
      },
      "id": "6076284f196a67dc5764a7a5"
    }
  ],
  "/explore-docs/nerdstoragevault": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/embed/",
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "027dd39d82c1996136231ffad1636034152cf482",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 404.3777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Using <em>NerdStorageVault</em> in your <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use <em>NerdStorageVault</em> to store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution. Using <em>NerdStorageVault</em> in your <em>apps</em> <em>NerdStorageVault</em> is used to store and retrieve sensitive secrets <em>data</em>"
      },
      "id": "6063d5f3e7b9d2632f70376b"
    },
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-04-12T10:06:38Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 368.6629,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "NerdGraph allows you to <em>access</em> your <em>New</em> <em>Relic</em> <em>data</em>, but when you want to fetch third-party <em>data</em>, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and <em>encrypted</em> <em>storage</em> location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/",
      "sections": [
        "What's new in New Relic"
      ],
      "published_at": "2021-04-15T21:21:00Z",
      "title": "What's new in New Relic",
      "updated_at": "2021-04-15T01:51:31Z",
      "type": "docs",
      "external_id": "49467ca3d09d7a4f1c1c69fd16be4e20050a7686",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "April 12 A simpler, more intuitive log analytics experience Check out the changes we've made to the UI to help you see details and debug faster! Create Alert Conditions From Any Chart Now you can create an alert condition from just about anywhere in New Relic! Detect patterns and outliers in log data Create queries, alerts, and dashboards using log patterns and outliers April 9 Level up at FutureStack on May 25-27! Connect with Nerds from across the globe to learn, share, and get inspired at our free, virtual event April 8 Aggregated health and activity for your Workloads New Relic Workloads are now easier to read. April 5 Guided install for Java and .NET APM agents We’ve made it simple to set up APM (Java and .NET) using our recently-launched guided installation flow, so you can instrument your systems and start analyzing your telemetry data in 5 minutes - no instrumentation expertise required. April 1 NRQL Updates You can now use Regex within your NRQL queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and New Relic One. FedRAMP: Logs and Metrics now certified Protecting your data is our highest priority, which is why we achieved the US Government’s rigorous FedRAMP Moderate certification in 2020. And now we’re adding support for Logs and Metrics to our long list of supported services. March 30 Kubernetes: Metric Update Moving to container_memory_working_set_bytes and away from container_memory_usage_bytes metric Slow transactions on the service Summary Quickly dive into the most time-consuming requests to your application or service March 25 Nerdlog Roundup: New Relic Lookout, Guided Install, and Open Source Docs Get real-time visibility into your stack, simplify your instrumentation, and edit our docs March 18 Nerdlog Roundup: Root Cause Analysis, Topology (Relationship-Based) Correlation, and more! Reduce your MTTR with free Automatic Proactive Anomaly Detection, find problems fast with root cause analysis, and increase context for issues using topology correlation. March 17 AIOps Made Easy: Get to root cause and respond faster Automatically find root cause and respond faster than ever March 16 Heroku cloud integration for log management Detailed log data made easier than ever Visualize log details in Dashboards with our new Logs Table Widget More flexibility and control for log message visualizations March 15 AIOps Made Easy: Cut down on alert noise Reduce alert fatigue and prioritize what’s important March 10 AIOps Made Easy: Detect unusual changes instantly Automatic proactive anomaly detection for free Nerdlog Roundup: See hosts, services, containers, and more in one view with New Relic Navigator See hundreds of entities in a compact, high-level view March 8 Nerdlog Roundup: Muting Rules, Custom Data Visualizations, and more AIOps fun! Smarter incident intelligence and custom data visualizations February 25 Nerdlog Roundup: Ingesting OpenTelemetry Data, RUM, and more Ingest OpenTelemery data and logs, drop your data, and monitor your browser performance February 24 New Relic Explorer: Say goodbye to blindspots Gain unprecedented visibility into your entire system February 19 Nerdlog Roundup: K6 Load Testing and the ServiceNow and Snowflake Integrations Keep your issues in sync, view your Snowflake and k6 performance data in New Relic One. February 11 Data Dropping update: Now, drop entire dimensional metrics Filter sensitive or low-value data February 8 Check out the Nerdlog We have a new live-stream changelog on Twitch! January 28 Agentless syslog onboarding for New Relic log management Host-based log ingestion using rsyslog or syslog-ng with a new TCP endpoint January 21 New Python agent features Python agent now auto instruments HTTPX and Django ASGI January 19 New Anomalies feed as part of AI overview page View all your anomalies in a single place January 13 New Relic Snowflake Integration New Relic now integrates with Snowflake. January 6 Schedule recurring muting rules Suppress or mute notifications with ease December 7, 2020 Recap: Top 10 new observability features you need to know Our engineers and product managers share their favorite features, capabilities, and integrations to help you be more productive and collaborative. December 1, 2020 Alerts and Applied Intelligence new landing page Surface insights with a new landing page. Percentiles now available in events-to-metrics service For the events-to-metrics service, return an attribute's approximate value at a given percentile. November 12, 2020 API keys app There's a new app for managing your API keys. New Relic Lambda extension Our new extension improves observability of your Lambda data. Share dashboards and curated views with permalinks Sharing what you’re seeing just got easier. November 10, 2020 Invite a teammate See how easy it is to invite your team to New Relic. November 9, 2020 Enhanced errors experience in New Relic One We've improved the new errors experience. November 3, 2020 Troubleshoot performance and crash issues faster with New Relic's real-time Java profiling New Relic is excited to announce the availability of real-time Java profiling using Java Flight Recorder (JFR). October 30, 2020 Build high-resolution charts using sliding windows Increase your chart resolution with rolling aggregates, powered by sliding windows. Kafka Connect: Unlock open source and alternative instrumentation sources Build observability pipelines from open source tools and alternative instrumentation sources with the New Relic connector for Kafka Connect. Veneur sink: Your pipeline to 3rd party metrics Send metrics to New Relic using our Veneur sink. October 29, 2020 Three big updates for your native mobile apps Three big updates: The New Relic iOS and tvOS agents will now be distributed as the New Relic XCFramework Agent 7.0.0. For instrumenting React Native applications, we have an experimental open source React Native Module. Plus, we’ve improved reliability from our Android service and changed the way our service handles Android stack deobfuscation. October 27, 2020 Monitor ASGI apps using the Python agent The Python agent now supports monitoring Uvicorn, Starlette, and FastAPI ASGI applications. Monitor Apollo Server GraphQL Node applications Use our Node.js agent plugin to capture executed GraphQL queries. October 15, 2020 Applied Intelligence: Better, smarter webhooks Webhooks now automatically deliver anomaly charts. October 14, 2020 New Relic One now has a new UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry data. October 13, 2020 Store data in an encrypted storage solution with NerdStorageVault Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save your table column, time range, etc. in the logs UI October 9, 2020 Alerting: Loss of signal detection and configurable gap-filling strategies Specify how long the system should wait before a signal is considered lost. October 7, 2020 New Relic achieves AWS Outposts Ready designation New Relic has achieved the AWS Outposts Ready designation, part of the Amazon Web Services (AWS) Service Ready Program. October 1, 2020 Applied Intelligence now features accelerated suggested decisions Reduce alert noise by using our suggested correlation decisions. September 30, 2020 Applied Intelligence: Deployment events in the issue feed Applied Intelligence now includes any relevant APM deployment data. September 29, 2020 New Relic Edge with Infinite Tracing New Relic users with Pro or Enterprise Full-Stack Observability can now access and benefit from New Relic Edge. September 11, 2020 Anomalies visible in the activity stream The activity stream shows recent events so you can quickly see what's happening in your system. September 9, 2020 Windows Logs supported Support for Windows Logs with New Relic's infrastructure agent September 4, 2020 New Relic One has dark mode! We now have dark mode! New Relic Support for Amazon Web Services (AWS) Bottlerocket Gain full visibility into your workloads and infrastructure running on AWS Bottlerocket. What's new? Your in-product destination for New Relic One updates! September 1, 2020 Issue summary and analysis in Applied Intelligence Rely on the issue summary to help you identify and resolve relevant issues. Visual issue timeline in Applied Intelligence Use our Gantt-style timeline chart to see your related events. August 26, 2020 Real-user monitoring support for W3C trace context and Google Core Web Vitals We've added support for W3C trace context and Google Core Web Vitals! August 18, 2020 Alert analysis for Applied Intelligence Alert analysis gives you greater context for your alert violations and notifications. August 16, 2020 Ingest New Relic Logs directly with Amazon Web Services (AWS) Kinesis Data Firehose New Relic can ingest data from Amazon's Kinesis Data Firehose. Tracing the gap: AWS X-Ray integration Use New Relic with AWS X-Ray, a critical distributed tracing tool for getting visibility across your AWS services. August 10, 2020 Create Grafana dashboards with Prometheus data stored in New Relic You can create Grafana dashboards with Prometheus data stored in New Relic! July 30, 2020 Overall New Relic One experience updates We've made updates across all of New Relic One! Scheduled alert muting Schedule when you want to mute alerts to avoid messages during maintenance or deployments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 295.48276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What&#x27;s <em>new</em> in <em>New</em> <em>Relic</em>",
        "sections": "What&#x27;s <em>new</em> in <em>New</em> <em>Relic</em>",
        "body": " hosts, services, containers, and more in <em>one</em> view with <em>New</em> <em>Relic</em> Navigator See hundreds of entities in a compact, high-level view March 8 Nerdlog Roundup: Muting Rules, Custom <em>Data</em> Visualizations, and more AIOps fun! Smarter incident intelligence and custom <em>data</em> visualizations February 25 Nerdlog"
      },
      "id": "60422917196a677e2fa83ddf"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/jp/whats-new/",
      "sections": [
        "New Relicの新機能"
      ],
      "published_at": "2021-04-12T09:07:40Z",
      "title": "What's new in New Relic",
      "updated_at": "2021-04-12T09:07:40Z",
      "type": "docs-jp",
      "external_id": "cfaaa9015112cddf53bade5c9f859c3bfbc53a97",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "April 9 Level up at FutureStack on May 25-27! Connect with Nerds from across the globe to learn, share, and get inspired at our free, virtual event April 8 Aggregated health and activity for your Workloads New Relic Workloads are now easier to read. April 5 Guided install for Java and .NET APM agents We’ve made it simple to set up APM (Java and .NET) using our recently-launched guided installation flow, so you can instrument your systems and start analyzing your telemetry data in 5 minutes - no instrumentation expertise required. April 1 NRQL Updates You can now use Regex within your NRQL queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and New Relic One. FedRAMP: Logs and Metrics now certified Protecting your data is our highest priority, which is why we achieved the US Government’s rigorous FedRAMP Moderate certification in 2020. And now we’re adding support for Logs and Metrics to our long list of supported services. March 30 Kubernetes: Metric Update Moving to container_memory_working_set_bytes and away from container_memory_usage_bytes metric Slow transactions on the service Summary Quickly dive into the most time-consuming requests to your application or service March 25 Nerdlog Roundup: New Relic Lookout, Guided Install, and Open Source Docs Get real-time visibility into your stack, simplify your instrumentation, and edit our docs March 18 Nerdlog Roundup: Root Cause Analysis, Topology (Relationship-Based) Correlation, and more! Reduce your MTTR with free Automatic Proactive Anomaly Detection, find problems fast with root cause analysis, and increase context for issues using topology correlation. March 17 AIOps Made Easy: Get to root cause and respond faster Automatically find root cause and respond faster than ever March 16 Heroku cloud integration for log management Detailed log data made easier than ever Visualize log details in Dashboards with our new Logs Table Widget More flexibility and control for log message visualizations March 15 AIOps Made Easy: Cut down on alert noise Reduce alert fatigue and prioritize what’s important March 10 AIOps Made Easy: Detect unusual changes instantly Automatic proactive anomaly detection for free Nerdlog Roundup: See hosts, services, containers, and more in one view with New Relic Navigator See hundreds of entities in a compact, high-level view March 8 Nerdlog Roundup: Muting Rules, Custom Data Visualizations, and more AIOps fun! Smarter incident intelligence and custom data visualizations February 25 Nerdlog Roundup: Ingesting OpenTelemetry Data, RUM, and more Ingest OpenTelemery data and logs, drop your data, and monitor your browser performance February 24 New Relic Explorer: Say goodbye to blindspots Gain unprecedented visibility into your entire system February 19 Nerdlog Roundup: K6 Load Testing and the ServiceNow and Snowflake Integrations Keep your issues in sync, view your Snowflake and k6 performance data in New Relic One. February 11 Data Dropping update: Now, drop entire dimensional metrics Filter sensitive or low-value data February 8 Check out the Nerdlog We have a new live-stream changelog on Twitch! January 28 Agentless syslog onboarding for New Relic log management Host-based log ingestion using rsyslog or syslog-ng with a new TCP endpoint January 21 New Python agent features Python agent now auto instruments HTTPX and Django ASGI January 19 New Anomalies feed as part of AI overview page View all your anomalies in a single place January 13 New Relic Snowflake Integration New Relic now integrates with Snowflake. January 6 Schedule recurring muting rules Suppress or mute notifications with ease December 7, 2020 Recap: Top 10 new observability features you need to know Our engineers and product managers share their favorite features, capabilities, and integrations to help you be more productive and collaborative. December 1, 2020 Alerts and Applied Intelligence new landing page Surface insights with a new landing page. Percentiles now available in events-to-metrics service For the events-to-metrics service, return an attribute's approximate value at a given percentile. November 12, 2020 API keys app There's a new app for managing your API keys. New Relic Lambda extension Our new extension improves observability of your Lambda data. Share dashboards and curated views with permalinks Sharing what you’re seeing just got easier. November 10, 2020 Invite a teammate See how easy it is to invite your team to New Relic. November 9, 2020 Enhanced errors experience in New Relic One We've improved the new errors experience. November 3, 2020 Troubleshoot performance and crash issues faster with New Relic's real-time Java profiling New Relic is excited to announce the availability of real-time Java profiling using Java Flight Recorder (JFR). October 30, 2020 Build high-resolution charts using sliding windows Increase your chart resolution with rolling aggregates, powered by sliding windows. Kafka Connect: Unlock open source and alternative instrumentation sources Build observability pipelines from open source tools and alternative instrumentation sources with the New Relic connector for Kafka Connect. Veneur sink: Your pipeline to 3rd party metrics Send metrics to New Relic using our Veneur sink. October 29, 2020 Three big updates for your native mobile apps Three big updates: The New Relic iOS and tvOS agents will now be distributed as the New Relic XCFramework Agent 7.0.0. For instrumenting React Native applications, we have an experimental open source React Native Module. Plus, we’ve improved reliability from our Android service and changed the way our service handles Android stack deobfuscation. October 27, 2020 Monitor ASGI apps using the Python agent The Python agent now supports monitoring Uvicorn, Starlette, and FastAPI ASGI applications. Monitor Apollo Server GraphQL Node applications Use our Node.js agent plugin to capture executed GraphQL queries. October 15, 2020 Applied Intelligence: Better, smarter webhooks Webhooks now automatically deliver anomaly charts. October 14, 2020 New Relic One now has a new UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry data. October 13, 2020 Store data in an encrypted storage solution with NerdStorageVault Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save your table column, time range, etc. in the logs UI October 9, 2020 Alerting: Loss of signal detection and configurable gap-filling strategies Specify how long the system should wait before a signal is considered lost. October 7, 2020 New Relic achieves AWS Outposts Ready designation New Relic has achieved the AWS Outposts Ready designation, part of the Amazon Web Services (AWS) Service Ready Program. October 1, 2020 Applied Intelligence now features accelerated suggested decisions Reduce alert noise by using our suggested correlation decisions. September 30, 2020 Applied Intelligence: Deployment events in the issue feed Applied Intelligence now includes any relevant APM deployment data. September 29, 2020 New Relic Edge with Infinite Tracing New Relic users with Pro or Enterprise Full-Stack Observability can now access and benefit from New Relic Edge. September 11, 2020 Anomalies visible in the activity stream The activity stream shows recent events so you can quickly see what's happening in your system. September 9, 2020 Windows Logs supported Support for Windows Logs with New Relic's infrastructure agent September 4, 2020 New Relic One has dark mode! We now have dark mode! New Relic Support for Amazon Web Services (AWS) Bottlerocket Gain full visibility into your workloads and infrastructure running on AWS Bottlerocket. What's new? Your in-product destination for New Relic One updates! September 1, 2020 Issue summary and analysis in Applied Intelligence Rely on the issue summary to help you identify and resolve relevant issues. Visual issue timeline in Applied Intelligence Use our Gantt-style timeline chart to see your related events. August 26, 2020 Real-user monitoring support for W3C trace context and Google Core Web Vitals We've added support for W3C trace context and Google Core Web Vitals! August 18, 2020 Alert analysis for Applied Intelligence Alert analysis gives you greater context for your alert violations and notifications. August 16, 2020 Ingest New Relic Logs directly with Amazon Web Services (AWS) Kinesis Data Firehose New Relic can ingest data from Amazon's Kinesis Data Firehose. Tracing the gap: AWS X-Ray integration Use New Relic with AWS X-Ray, a critical distributed tracing tool for getting visibility across your AWS services. August 10, 2020 Create Grafana dashboards with Prometheus data stored in New Relic You can create Grafana dashboards with Prometheus data stored in New Relic! July 30, 2020 Overall New Relic One experience updates We've made updates across all of New Relic One! Scheduled alert muting Schedule when you want to mute alerts to avoid messages during maintenance or deployments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 258.0658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What&#x27;s <em>new</em> in <em>New</em> <em>Relic</em>",
        "sections": "<em>New</em> <em>Relic</em>の新機能",
        "body": " queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and <em>New</em> <em>Relic</em> <em>One</em>. FedRAMP: Logs and Metrics now certified Protecting your <em>data</em> is our highest priority, which is why we achieved"
      },
      "id": "6050daaa196a6746822d164e"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.45572,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or <em>data</em> from another service or API. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>. If you want to get started building quickly, first read the requirements. Tip To use our developer site and <em>New</em> <em>Relic</em> <em>One</em>, as well as the rest of our"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/embed/",
      "sections": [
        "Add a chart group",
        "Tip"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:43:09Z",
      "type": "",
      "external_id": "e94780ac131f1a4ce5999771f9bee9650d4f5e9b",
      "popularity": 1,
      "body": "In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group/ab-test Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 196.23059,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-programmability-course&#x2F;add-a-chart-group&#x2F;ab-test Step 2 of 9 In nerdlets&#x2F;ab-test-nerdlet, add a new Javascript file named <em>page</em>-<em>views</em>.js: bash Copy $ touch <em>page</em>-<em>views</em>.js Step 3 of 9 In this new file, create a component called Version<em>PageViews</em> to hold a LineChart, which shows the number of times a <em>page</em>"
      },
      "id": "6072ff19e7b9d25dbba5c689"
    },
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/embed/",
      "sections": [
        "Add a grid",
        "Technical detail"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:42:16Z",
      "type": "",
      "external_id": "bfd5e04da0f000d6970b16677cd5faf8c3b2f461",
      "popularity": 1,
      "body": "In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid/ab-test Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your Nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.08057,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " TotalCancellations from &#x27;.&#x2F;total-cancellations&#x27;; import TotalSubscriptions from &#x27;.&#x2F;total-subscriptions&#x27;; import Version<em>PageViews</em> from &#x27;.&#x2F;<em>page</em>-<em>views</em>&#x27;; import VersionTotals from &#x27;.&#x2F;totals&#x27;; export default class AbTestNerdletNerdlet extends React.Component { render() { return &lt;div&gt; &lt;Grid className=&quot;wrapper"
      },
      "id": "6072565d28ccbc6baf51c18b"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:21Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.9625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " &#x27;nr1&#x27;; import NewsletterSignups from &#x27;.&#x2F;newsletter-signups&#x27;; import PastTests from &#x27;.&#x2F;past-tests&#x27;; import TotalCancellations from &#x27;.&#x2F;total-cancellations&#x27;; import TotalSubscriptions from &#x27;.&#x2F;total-subscriptions&#x27;; import VersionDescription from &#x27;.&#x2F;description&#x27;; import Version<em>PageViews</em> from &#x27;.&#x2F;<em>page</em>"
      },
      "id": "6072569228ccbc932d51c172"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:39Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings/ab-test Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.34987,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", <em>page</em>-<em>views</em>.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your <em>custom</em> components: import React from &#x27;react&#x27;; import { HeadingText, LineChart } from &#x27;nr1&#x27;; export default class"
      },
      "id": "6072ff1928ccbc140b51c16e"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/embed/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:20Z",
      "type": "",
      "external_id": "43c5fb39b73ee2dbbe5f216a577ff77051fcc513",
      "popularity": 1,
      "body": "In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 View your changes: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.77704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>View</em> Subscription Events in New Relic",
        "body": " that still use mock data: Total unsubscriptions per version Version A - <em>Page</em> <em>views</em> vs. subscriptions Version B - <em>Page</em> <em>views</em> vs. subscriptions Version A - <em>Page</em> <em>views</em> Version B - <em>Page</em> <em>views</em> Past tests Some of these charts need to show <em>page</em> <em>view</em> data. Fortunately, your demo application creates a <em>custom</em>"
      },
      "id": "60730124196a6731e464a778"
    }
  ],
  "/components/charts": [
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: Copy the key you created. You'll use it to associate your New Relic account with the CLI. The CLI will then use the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name> with an arbirary name, the <User key> with the key you copied in Step 1, and the region with either us or eu. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 283.90356,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic One <em>CLI</em>",
        "body": " will then use the key to manage entities within your account. Step 2 of 3 Download the SDK&#x27;s installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you&#x27;ve installed the SDK, you&#x27;ll have access to the <em>nr1</em> <em>CLI</em>. Verify"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 274.9826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " want to unsubscribe from the app, and select Update <em>1</em> account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you&#x27;ve built a New Relic One application from the ground up. You&#x27;ve used the <em>nr1</em> <em>CLI</em> to create a <em>Nerdpack</em>, launcher, and Nerdlet. You&#x27;ve used many"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-16T02:10:56Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.54631,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-16T10:15:36Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.4704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/embed/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2021-04-16T02:12:51Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "9f3c1bee195dc75bc1fc2d96b7bdeec591e35449",
      "popularity": 1,
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.37993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>nr1</em> help",
        "body": " The name of a particular channel. Examples $ <em>nr1</em> update $ <em>nr1</em> update somechannel <em>nr1</em> create Create a new component Creates a new component from our template (either a <em>Nerdpack</em>, Nerdlet, launcher, or catalog). The <em>CLI</em> will walk you through this process. To learn more about Nerdpacks and their <em>file</em> <em>structure</em>"
      },
      "id": "6063d63464441f3d6b0c8bee"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 622.8737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> to your New Relic <em>One</em> <em>application</em>",
        "body": " see the app under Your apps, you may have to refresh the page or clear your browser cache. It&#x27;s important to note that you can <em>subscribe</em> to <em>applications</em> in the <em>catalog</em> with the <em>nr1</em> <em>CLI</em>. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: Copy the key you created. You'll use it to associate your New Relic account with the CLI. The CLI will then use the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name> with an arbirary name, the <User key> with the key you copied in Step 1, and the region with either us or eu. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 454.15372,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic <em>One</em> <em>CLI</em>",
        "body": " this by checking your SDK version: bash Copy $ <em>nr1</em> --version Tip It’s important to distinguish between the newrelic <em>CLI</em> and the <em>nr1</em> <em>CLI</em>. newrelic is for managing entities in your New Relic account. <em>nr1</em> is for managing New Relic <em>One</em> <em>applications</em>. Step 3 of 3 Associate your New Relic account as a <em>CLI</em> profile"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 292.28513,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic <em>One</em> <em>Applications</em> (Roundup #5)",
        "sections": "<em>Subscribe</em> to <em>applications</em> with the New Relic <em>One</em> <em>Catalog</em>",
        "body": " GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The <em>Nerdpack</em> <em>file</em> <em>structure</em>, including how to link your application with an entity. Application&#x2F;data access and permissions and security. <em>NR1</em> Workshop: a step-by-step, self-paced, open source"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.45593,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic <em>One</em> <em>Applications</em> (Roundup #6)",
        "sections": "<em>Subscribe</em> to apps in the New Relic <em>One</em> <em>Catalog</em>",
        "body": " to your New Relic account using the following commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-attributory.git cd <em>nr1</em>-attributory <em>nr1</em> <em>nerdpack</em>:publish <em>nr1</em> <em>nerdpack</em>:deploy -c STABLE <em>nr1</em> <em>nerdpack:subscribe</em> -c STABLE Then go to the homepage of <em>one</em>.newrelic.com and select the app’s launcher"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-16T02:10:56Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.987,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to New Relic <em>One</em> SDK",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/embed/",
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "published_at": "2021-04-16T02:15:42Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:45Z",
      "type": "",
      "external_id": "5c7a60b535745e446d5ac1b026d9c5e8323ed7bb",
      "popularity": 1,
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin Before you begin, we recommend first reading about permissions. To start building, you must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 268.87048,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Contribute to <em>developer.newrelic.com</em>",
        "body": "If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> command line interface (<em>CLI</em>) An <em>API</em> <em>key</em>, which you get when you download the <em>CLI</em> Depending on what you want to do with your app, you might have some additional setup"
      },
      "id": "6063d5a2196a677164c6f49e"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: Copy the key you created. You'll use it to associate your New Relic account with the CLI. The CLI will then use the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name> with an arbirary name, the <User key> with the key you copied in Step 1, and the region with either us or eu. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 249.01823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " a User <em>key</em>. From the top navigation, go to <em>API</em> keys: If you have an existing User <em>key</em>, copy it: If not, click Create <em>key</em>: Select User for <em>Key</em> type, optionally add a name and notes, and click Create <em>key</em>: Copy the <em>key</em> you created. You&#x27;ll use it to associate your <em>New</em> <em>Relic</em> <em>account</em> with the <em>CLI</em>. The <em>CLI</em>"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Steps for a successful transition",
        "Get started with New Relic One",
        "Query anything",
        "Visualize more data"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-04-12T02:59:18Z",
      "updated_at": "2021-04-05T03:35:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries, charts, and dashboards. With New Relic One, we have modernized the experience for you to access, analyze, and visualize your data. New Relic One offers an improved charts and dashboards experience, and it provides a platform where we can more rapidly bring new innovations to you. This transition guide can help you understand: What are some of the new and improved features you get with New Relic One charts, dashboards, and queries Why it's easy to transition to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Steps for a successful transition The transition to New Relic One has two parts: the UI and mobile app experience (April 12, 2021) and the Dashboard API (July 2021). Insights functionality Transition to New Relic One UI We have already taken care of your transition from Insights to New Relic One for you! As of April 12, 2021, your old Insights web URLs redirect automatically to New Relic One. We recommend that you familiarize yourself with the new UI features available to you, as described in this transition guide. If you need to view any Insights charts embedded in other websites, go to one.newrelic.com > More > Manage Data. (These older embedded charts will continue to function as expected.) Mobile apps Your Insights mobile app is deprecated as of April 11, 2021. Go to the Google Play Store 2 or Apple App store. Delete your old Insights mobile app, and download the New Relic One mobile app. tvOS apps and large displays New Relic's tvOS app is still available. No action is needed by you at this time. Some New Relic customers with the original pricing model may have set up dashboards on wall screens for restricted users with kiosk mode. No action is required for you to continue to view these dashboards. APIs The Insights API to create dashboards will be deprecated and replaced with the new Dashboards API as of July 2021. We encourage you to start exploring the capabilities of the Dashboards API in NerdGraph now! You can continue to use your Insights insert API key with the Dashboards API, or you can create a new user API key. Every user who wants to query with the NerdGraph API will need their own user API key. The REST API for Insights queries is not affected by this change and will not be deprecated. For more information about which key to use with our APIs, see our documentation about API keys. Easily access your insert and query API keys by going to one.newrelic.com > More > Manage Insights Data> API Keys Partnership accounts This applies only if your account is one of the few using our partnership account structure to deliver New Relic services to your direct customers. In this situation, the Insights EOL will not affect your customers’ pricing. This is simply an EOL for the UI, not an EOL for the account type. Questions If you have questions about the transition, please comment in our Explorers Hub post. Or, if you work with an account team, they will be happy to help you. Get started with New Relic One New Relic One dashboards are an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more! one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. All of the dashboards you previously created in Insights are automatically available in New Relic One. Query anything With New Relic One, you get: Better querying and charting experiences: Query access is available globally, no matter where you are in New Relic One. This includes a \"basic\" query mode that doesn't require knowledge of NRQL. Improved query experience: You can query both the Metric data type and metric timeslice data. Easy customization: Every visualization now has the query accessible. You can augment any curated chart just by changing the NRQL. Visualize more data Not only can you select a wide range of visualization options, you can also add more to your dashboards: Better display options: Make your data easier to understand by using visualizations other than dense, line-heavy charts. New Relic One also offers a better TV mode. More charts or widgets across dashboards: Insights restricted you to a 3-across limit. Now you can display up to 12 across your dashboard, providing increased data density along with improved tooltips and tracking across charts. Easier creation of multi-page dashboards: Insights referred to these as data apps. Your Insights data apps are preserved as multi-page dashboards in New Relic One. Chart consistency and flexibility: Dashboards include facet color consistency across widgets and faster loading times for more performant dashboards. Also, you can add any chart type to a dashboard in New Relic One! The New Relic Insights UI has served our users well for many years, but it's time to give you an even better experience. Join us and make the switch to New Relic One!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.18571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and considerations when you make the switch How to get the most out of using <em>New</em> <em>Relic</em> <em>One</em> Steps for a successful transition The transition to <em>New</em> <em>Relic</em> <em>One</em> has two parts: the UI and mobile app experience (April 12, 2021) and the Dashboard <em>API</em> (July 2021). Insights functionality Transition to <em>New</em>"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/embed/",
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "f17736ed026e1bf9fd253b8b716db26f1f13cc58",
      "popularity": 1,
      "body": "To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.5587,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "body": "To build a <em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (command line interface). This page explains how to use <em>CLI</em> commands to: Generate"
      },
      "id": "6063d63364441f61c30c8be9"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.80579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or data from another service or <em>API</em>. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> apps. If you want to get started building quickly, first read the requirements. Tip To use our <em>developer</em> site and <em>New</em> <em>Relic</em> <em>One</em>, as well as the rest of our"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/build-apps/custom-visualizations-and-the-new-relic-one-sdk": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 535.4153,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> to your New Relic <em>One</em> application",
        "body": " see the app under Your apps, you may have to refresh the page or clear your browser cache. It&#x27;s important to note that you can <em>subscribe</em> to applications in the <em>catalog</em> with the <em>nr1</em> <em>CLI</em>. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: Copy the key you created. You'll use it to associate your New Relic account with the CLI. The CLI will then use the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name> with an arbirary name, the <User key> with the key you copied in Step 1, and the region with either us or eu. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 453.9088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic <em>One</em> <em>CLI</em>",
        "body": " this by checking your SDK version: bash Copy $ <em>nr1</em> --version Tip It’s important to distinguish between the newrelic <em>CLI</em> and the <em>nr1</em> <em>CLI</em>. newrelic is for managing entities in your New Relic account. <em>nr1</em> is for managing New Relic <em>One</em> applications. Step 3 of 3 Associate your New Relic account as a <em>CLI</em> profile"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-16T02:10:56Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.94548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to New Relic <em>One</em> SDK",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-16T10:15:36Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.68211,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/embed/",
      "sections": [
        "Describe your app for the catalog",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "baf09ac55fe0770a7b7de7102f2a2a7a463d49de",
      "popularity": 1,
      "body": "In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your Nerdpack. Step 1 of 6 Change to the describe-app/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/describe-app/ab-test Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create --type catalog This creates a catalog directory with template files for inputting custom information about your app. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! catalog/documentation.md Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } catalog/config.json Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory. Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.93393,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Describe your app for the <em>catalog</em>",
        "body": "-programmability-course&#x2F;describe-app&#x2F;ab-test Step 2 of 6 Create the <em>catalog</em> directory: bash Copy $ <em>nr1</em> create --type <em>catalog</em> This creates a <em>catalog</em> directory with template files for inputting custom information about your app. Tip Read our documentation to learn more about the <em>catalog</em> directory. Step 3 of 6 Update"
      },
      "id": "606e63d8e7b9d201e9bfa819"
    }
  ],
  "/build-apps/customize-visualizations-with-configuration": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 535.60754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Subscribe to your New Relic <em>One</em> application",
        "body": " want to unsubscribe from the app, and select Update <em>1</em> account: If you navigate back to Apps, you will see your app in the <em>catalog</em>. Throughout this course, you&#x27;ve built a New Relic <em>One</em> application from the ground up. You&#x27;ve used the <em>nr1</em> <em>CLI</em> to create a Nerdpack, launcher, and Nerdlet. You&#x27;ve used many"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: Copy the key you created. You'll use it to associate your New Relic account with the CLI. The CLI will then use the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name> with an arbirary name, the <User key> with the key you copied in Step 1, and the region with either us or eu. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 454.15372,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic <em>One</em> <em>CLI</em>",
        "body": " this by checking your SDK version: bash Copy $ <em>nr1</em> --version Tip It’s important to distinguish between the newrelic <em>CLI</em> and the <em>nr1</em> <em>CLI</em>. newrelic is for managing entities in your New Relic account. <em>nr1</em> is for managing New Relic <em>One</em> applications. Step 3 of 3 Associate your New Relic account as a <em>CLI</em> profile"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-16T02:10:56Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.44238,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to New Relic <em>One</em> SDK",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "image": "https://developer.newrelic.com/static/28a19f070d3ae2b215793dd163851d7c/0086b/click-add-to-dashboard.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/embed/",
      "sections": [
        "Add custom visualizations to your dashboards",
        "Before you begin",
        "Note",
        "Add your custom visualization to a dashboard",
        "Manage your dashboard visualizations",
        "Summary",
        "Additional resources"
      ],
      "published_at": "2021-04-16T02:20:40Z",
      "title": "",
      "updated_at": "2021-04-10T01:54:48Z",
      "type": "",
      "external_id": "230f853d85188e6617cfa0014204b34fcb2e5c70",
      "popularity": 1,
      "body": "This lesson builds off of the previous Customize visualizations with configuration lesson. If you haven't followed that lesson, please start there as this lesson assumes you have the code you built there to get started. If you don't have a visualization to follow the examples in this gude, a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using nr1.json configuration, in the following steps, you will configure and add your custom visualization to a New Relic dashboard. Before you begin To get started, follow the Customize visualizations with configuration lesson. Then, publish and subscribe to your Nerdpack. Note To publish a Nerdpack you must be a Full user and granted the Nerdpacks “modify” privilege (which is granted by default). Read our documentation to learn more about Nerdpacks privileges. Add your custom visualization to a dashboard Once you've published your custom visualization to your account, in the following steps you'll configure your visualization and add it to a dashboard. You can add a visualization to a new or existing dashboard within your New Relic account. Step 1 of 6 To find the My Awesome Visualization that you have deployed, you need to look for your visualization in the app catalog. From the New Relic One homepage, select the Apps button in the top right navigation bar: Step 2 of 6 Once on the Apps page, click the Custom Visualizations launcher: Note If you don't see the Custom Visualizations tile, use the search to locate it. Step 3 of 6 In Custom Visualizations, you will see all of the visualization that have been deployed to your account and any visualizations you are serving locally. Select the My Awesome Visualization to add to a dashboard and then enable it: Step 4 of 6 In the previous lesson, you reconfigured your visualization to use the platform configurations panel. Use the configuration options to select your desired chart, select your account, insert a NRQL query, and any other configurations you desire. As you make your selections, the visualization will update with your changes: Step 5 of 6 Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name: Step 6 of 6 Click Add to dashboard, then click the link to your dashboard to see the custom visualization: Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations. Summary Congratulations on completing this final lesson and adding your custom visualization to a New Relic dashboard. In the previous lessons, you've used the tools in the New Relic SDK to create a new custom visualization, configured the visualization using the SDK and using the platform configuration panel. Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.07434,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add custom <em>visualizations</em> to your dashboards",
        "body": ", a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using <em>nr1</em>.json configuration"
      },
      "id": "60710568196a6793b864a754"
    },
    {
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/embed/",
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "published_at": "2021-04-16T02:16:42Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "edab33e46fbc9f8e054670c52397176ce989ae3a",
      "popularity": 1,
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type nerdpack --name my-first-viz $ cd my-first-viz $ nr1 create --type visualization --name custom-viz The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ nr1 nerdpack:serve Then visit New Relic and navigate to Apps > Custom Visualizations > CustomViz to see it in action: Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack artifacts, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.61752,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Introduction to custom <em>visualizations</em>",
        "body": " Relic <em>One</em> SDK and make sure you have the latest version: bash Copy $ <em>nr1</em> update Create a Nerdpack and a visualization: bash Copy $ <em>nr1</em> create --type nerdpack --name my-first-viz $ cd my-first-viz $ <em>nr1</em> create --type visualization --name custom-viz The visualization you created in the my-first-viz"
      },
      "id": "607105a064441fa6da9d8530"
    }
  ],
  "/build-apps/ab-test/third-party-service": [
    {
      "image": "https://developer.newrelic.com/static/9fef87cd4b59ba7b2e8df08c97bd3b85/ba3ac/incorrect-auth-header.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/embed/",
      "sections": [
        "Fetch data from a third-party service",
        "Tip"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:32:19Z",
      "type": "",
      "external_id": "5a9959f254359afeec9b0a9a9f39dd8b83d8c1ee",
      "popularity": 1,
      "body": "In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -H 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.87434,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Fetch</em> <em>data</em> <em>from</em> <em>a</em> <em>third</em>-<em>party</em> <em>service</em>",
        "body": "In previous lessons, you learned of a <em>third</em>-<em>party</em> <em>service</em> that you can use to <em>fetch</em> mock cancellation <em>data</em> for the Total cancellations per version chart in your New Relic One application. Even though the <em>data</em> in this <em>service</em> is fake, the real value of this lesson is learning how you can use <em>third</em>"
      },
      "id": "606d10ee28ccbc1cd5e1c991"
    },
    {
      "sections": [
        "PHP agent not reporting errors",
        "Problem",
        "Solution",
        "Cause",
        "For more help"
      ],
      "title": "PHP agent not reporting errors",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Troubleshooting"
      ],
      "external_id": "320f6c881ef688a15d6a6d90d0adf83ea4119835",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/troubleshooting/php-agent-not-reporting-errors/",
      "published_at": "2021-04-16T07:13:47Z",
      "updated_at": "2021-04-16T07:13:46Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Errors in your application aren't reported or captured by the PHP agent as expected. Solution If you are using a third party error handler (for example: XDebug or Laravel's error handler): Disable the third party error handler. Confirm the errors are reporting by viewing the APM errors page. If you are not using a third party error handler, but you still do not see expected errors (for example: 404 errors): Ensure PHP is handling the error, because New Relic cannot report errors that are not recognized by PHP (such as 404 errors for static assets on the web server). Manually instrument the error you are expecting to see by using the newrelic_notice_error() API call. Confirm the errors are reporting by viewing the APM errors page. Cause PHP handles errors with its own default handler. Many third party handlers, such as XDebug or Laravel's error handler, often override PHP's default handler and capture the error instead of PHP. The PHP agent has its own error handler that relies on PHP capturing the error. Since only one handler can handle an error, the agent does not see errors that were already handled by the third party handler before it could get captured by PHP. Additionally, some errors (for example: 404 errors) often occur at the web server level, which means that PHP is never involved and the error is never captured by the agent. If PHP is used to handle 404 errors, use the newrelic_notice_error() API call to manually instrument those errors. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.37505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP <em>agent</em> not reporting errors",
        "sections": "PHP <em>agent</em> not reporting errors",
        "tags": "<em>Agents</em>",
        "body": "Problem Errors in your application aren&#x27;t reported or captured by the PHP agent as expected. Solution If you are using a <em>third</em> <em>party</em> error handler (for example: XDebug or Laravel&#x27;s error handler): Disable the <em>third</em> <em>party</em> error handler. Confirm the errors are reporting by viewing the APM errors page"
      },
      "id": "603e8eef28ccbc6a8eeba761"
    },
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-04-12T10:06:38Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.125046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in <em>an</em> encrypted storage solution with NerdStorageVault",
        "sections": "Store <em>data</em> in <em>an</em> encrypted storage solution with NerdStorageVault",
        "body": "NerdGraph allows you to access your New Relic <em>data</em>, but when you want to <em>fetch</em> <em>third</em>-<em>party</em> <em>data</em>, NerdStorageVault allows you to safely store a secret to authenticate with a <em>third</em>-<em>party</em> <em>service</em>. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:24Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.55498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create <em>a</em> &quot;Hello, World&quot; <em>app</em>",
        "body": ", gathered <em>from</em> myriad sources—including <em>third</em>-<em>party</em> open source <em>data</em>—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/embed/",
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "027dd39d82c1996136231ffad1636034152cf482",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.98542,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Fetch</em> <em>a</em> single secret",
        "body": " such as: personal access tokens license keys API keys other <em>third</em> <em>party</em> secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can&#x27;t be shared with any other Nerdpack. NerdStorageVault can currently only be used within"
      },
      "id": "6063d5f3e7b9d2632f70376b"
    }
  ],
  "/build-apps/ab-test/chart-headings": [
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:39Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings/ab-test Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1650.0806,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>chart</em> <em>headings</em>",
        "body": " guide details what data each <em>chart</em> shows. Use those details to craft useful <em>headings</em> for your charts. Step 1 of 6 Change to the <em>add</em>-<em>chart</em>-<em>headings</em>&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-<em>chart</em>-<em>headings</em>&#x2F;ab-test Step 2 of 6 In newsletter-signups.js"
      },
      "id": "6072ff1928ccbc140b51c16e"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:50Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 224.182,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> user interface components to your application",
        "body": ", you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll <em>add</em> <em>headings</em> to clarify what each <em>chart</em> represents. Third, you&#x27;ll <em>add</em> descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your"
      },
      "id": "6073006628ccbce73151c12f"
    },
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/embed/",
      "sections": [
        "Add a grid",
        "Technical detail"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:42:16Z",
      "type": "",
      "external_id": "bfd5e04da0f000d6970b16677cd5faf8c3b2f461",
      "popularity": 1,
      "body": "In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid/ab-test Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your Nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.51718,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a grid",
        "body": " and usability of your A&#x2F;B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll <em>add</em> <em>headings</em> to your charts to remind yourself of what data each <em>chart</em> presents."
      },
      "id": "6072565d28ccbc6baf51c18b"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:21Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.57198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> version descriptions",
        "body": "With your charts organized and descriptive <em>headings</em> above each one, your New Relic One application is becoming more usable. In this lesson, you&#x27;ll continue that trend by creating descriptions for each design version in your A&#x2F;B test. Step 1 of 8 Change to the <em>add</em>-version-descriptions&#x2F;ab-test"
      },
      "id": "6072569228ccbc932d51c172"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Extra credit"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.33038,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> tables",
        "body": " sample. This practice will reinforce what you&#x27;ve learned in this lesson. If you need help, review the <em>add</em>-a-<em>chart</em>-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each <em>chart</em> you’ll <em>add</em> to your"
      },
      "id": "60725692196a67b68c64a778"
    }
  ],
  "/build-apps/ab-test/persist-version": [
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/persist-version/embed/",
      "sections": [
        "Persist the selected version"
      ],
      "published_at": "2021-04-16T02:06:51Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:49Z",
      "type": "",
      "external_id": "000f29685ee92dffc2ce7e70539ee1663037ffcb",
      "popularity": 1,
      "body": "In the previous lesson, you created a section of your application that allows you to pick the most effective design from your A/B test. The goal of this section is to end the test once you’ve selected a winner: When you select a version from this form, the selection does not persist in the Select component. Now, it’s time to implement that behavior. Step 1 of 11 Change to the persist-selected-version/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/persist-selected-version/ab-test Step 2 of 11 In end-test.js, initialize EndTestSection.state with a default selectedVersion field: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 3 of 11 Pass the selectedVersion, as a prop, to VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 4 of 11 Supply the selectedVersion to your Select component in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 5 of 11 Create a method, selectVersion(), that updates EndTestSection.state: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy You must bind selectVersion to the EndTestSection component so it can access state. Step 6 of 11 Pass the method to VersionSelector as a prop: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 7 of 11 Set selectVersion as the onChange callback in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 8 of 11 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 9 of 11 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 10 of 11 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 11 of 11 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Voila! When you select a new version as the winner of the A/B test, that version is reflected in the menu. However, when you press End test, nothing happens. In the next lesson, you'll create a confirmation dialog to protect yourself from prematurely ending your A/B test.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1585.1448,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Persist</em> <em>the</em> <em>selected</em> <em>version</em>",
        "body": "In the previous lesson, you created a section of your application that allows you to pick the most effective design from your A&#x2F;B test. The goal of this section is to end the test once you’ve <em>selected</em> a winner: When you <em>select</em> a <em>version</em> from this form, the selection does not <em>persist</em> in the <em>Select</em>"
      },
      "id": "60730001196a67905864a75f"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/embed/",
      "sections": [
        "Add a section to end your test"
      ],
      "published_at": "2021-04-16T02:05:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:49Z",
      "type": "",
      "external_id": "6c1d9d3997eff7f27d00dbf9c8f451f5bec750d9",
      "popularity": 1,
      "body": "In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.72003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " serving your New Relic One application by pressing CTRL+C in your local server&#x27;s terminal window. However, you need to make a few improvements to this code. When you <em>select</em> a <em>version</em>, the <em>selected</em> value in the component doesn&#x27;t change. You must control the value that <em>Select</em> displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to <em>persist</em> your <em>version</em> choice in the <em>Select</em> component."
      },
      "id": "6072569228ccbc8f6151c174"
    },
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/embed/",
      "sections": [
        "Present an end test confirmation modal",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-04-16T02:06:50Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:51Z",
      "type": "",
      "external_id": "554a84f8fe2faf9c2b867686538360771e22fc3c",
      "popularity": 1,
      "body": "In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 View your application: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your Nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. View your application where the modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.86041,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>the</em> <em>version</em> you <em>selected</em> in your modal",
        "body": "={this.props.<em>selectedVersion</em>}&gt; &lt;<em>Select</em>Item value={&#x27;A&#x27;}&gt;<em>Version</em> A&lt;&#x2F;<em>Select</em>Item&gt; &lt;<em>Select</em>Item value={&#x27;B&#x27;}&gt;<em>Version</em> B&lt;&#x2F;<em>Select</em>Item&gt; &lt;&#x2F;<em>Select</em>&gt; } } class EndTestButton extends React.Component { render() { return &lt;div&gt; &lt;Button type={Button.TYPE.DESTRUCTIVE}&gt;End test&lt;&#x2F;Button&gt; &lt;&#x2F;div&gt; } } export default class"
      },
      "id": "6072565e64441f34dd9d8548"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.85179,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", BlockText, Button, Grid, GridItem, HeadingText, Modal, <em>Select</em>, <em>Select</em>Item, } from &#x27;nr1&#x27;; class <em>Version</em>Selector extends React.Component { constructor(props) { super(props); } render() { return &lt;<em>Select</em> onChange={this.props.<em>selectVersion</em>} value={this.props.<em>selectedVersion</em>}&gt; &lt;<em>Select</em>Item value"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/fs14-square.jpg?h=d9bcd22f&itok=iug-FAmH",
      "url": "https://newrelic.com/blog/best-practices/angularjs",
      "sections": [
        "Web GUI vs. MVC",
        "The View-Controller: Computed Properties",
        "Transforming properties and creating new values",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "Adventures in AngularJS: The View-Controller and Computed Properties",
      "updated_at": "2021-04-14T02:12:39Z",
      "type": "",
      "external_id": "ca59ea844b12eb0f03036ef062768e79f477b857",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit DevOps Adventures in AngularJS: The View-Controller and Computed Properties Aug 11, 2014 • 6 min read By Vicente Reig Rincón de Arellano On the Business Engineering team at New Relic, we rely on AngularJS to build and maintain a variety of internal apps to help us keep shipping new features and products. We build rich user interfaces that leverage the browser to support the daily internal operations. AngularJS provides an excellent base to let them grow. As soon as we started our second AngularJS application, however, we realized that we were having to make the same decisions all over again: From training the new hires on GUI programming and Angular's intricacies to then building a framework on top of Angular, and finally building the application. We needed a way to simplify and rationalize the process. Web GUI vs. MVC The first thing that hits you when diving into Web GUI development is that, despite the naming conventions, the patterns to build the application are slightly different compared to model-view-controller (MVC) server-side frameworks. MVCs rely heavily on the browser to translate what the user wants to do into the business logic that the application holds. Views are composed in the server-side, and objects have a shorter life-span: the request cycle. Richer, more complex client GUIs need a different toolset to solve a handful of problems, which traditionally have been addressed by native GUI development: Keeping the application state throughout the user interaction Installing the application in the user's device Building a model that reacts to the user's decisions and perception. (Yehuda Katz condenses this dilemma very well in a 30-minute talk, A Tale of Two MVCs.) To address these issues, we began establishing our own conventions to shape current and forthcoming applications in a uniform manner. AngularJS offers a fantastic foundation to build the framework to construct client-side applications. In fact, we built a sample application—¡Hola, Playlists!—to synthesize all our experiences and opinions in AngularJS in a workshop for New Relic employees. Let’s take a look at the first of the conventions we found useful to build the foundation that supports our GUIs, which addresses putting the View-Controller into shape using Computed Properties. (In subsequent posts, we’ll address additional conventions we’ve established, including ways to let controllers communicate to each other as well as how to mediate routing and nested views to hold together various parts of your application.) Computed Properties have been extensively used to represent the state and its dependencies in an application’s UI, propagating changes throughout the data-binding pipeline. In Java you can observe a Bound Property through a PropertyChangeListener. Cocoa and Objective-C provide Key-Value Observing to accomplish the same mission. Apple’s new Swift programming language incorporates a special syntax called Computed Properties. In the Javascript browser-based space, Ember.js includes Computed Properties as part of the core Object Model and the future ECMAScript already enables data-binding through the Object.observe method. The View-Controller: Computed Properties Angular's Controllers hold the representation of the knowledge—the traditional model— and also act as the link between the user and the system. While the UI is automatically updated by using bidirectional binding to the $scope, Angular doesn't provide a convention to represent richer models, other than assigning POJOs and functions to it: Basically, static properties. Without an existing convention, we found ourselves trying to name the new patterns we were using without using lower level concepts such as listeners, objects, or scope. And that's how we found out about Computed Properties: a little tool to take a source property and create a new value, syncing any change to it whenever the source changes. Computed Properties are made out of three components: A variable to store the results of the computation. This is usually assigned to the $scope to make it available to the template and child controllers A Property Observer implementing the value transformation needed A watcher that triggers the observer every time an attribute in the collection changes. Transforming properties and creating new values For our sample application, we wanted to create playlists out of the selected tunes, enabling the “Create Playlist” button only when at least one song has been selected. We used a Computed Property to represent the state of the button—enabled or disabled—and aggregate the selected tracks. First, we need to aggregate all the selected tracks every time the user selects one by checking the associated checkbox: <table> <tbody> <tr ng-repeat=\"track in tracks\"> <td><input type=\"checkbox\" ng-model=\"track.selected\"/></td> <td>{{ track.name }}</td> <td>{{ track.artists | pluck:'name' | join:', ' }}</td> <td>{{ track.album.name }}</td> </tr> </tbody> </table> The controller associated to this view, by either using the ng-controller directive or binding it to a template in a route, can easily watch the collection of tracks and filter out those that aren't selected. This controller becomes the root controller of this view. // tracks is an Array injected from the resolve section in the current route. app.controller('TracksController', ['$scope', 'tracks', function($scope, tracks){ $scope.tracks = tracks;   $scope.selectedTracks; this.selectedTracksWillChange = function(tracks) { $scope.selectedTracks = tracks.filter(function(track){ return track.selected; }); }; $scope.$watch('tracks', this.selectedTracksWillChange, true); }]); We can finally add our Create Playlist button, governed by a controller in charge of watching how many tunes did the user select, enabling or disabling the button in consequence. <button ng-controller=\"PlaylistController\" ng-click=\"createPlaylist()\" ng-disabled=\"createPlaylistDisabled\"> Create a Playlist </button> We can also use a Computed Property to persist the state of the button, publishing it to the view through the $scope object. Each time the selectedTracks property changes in the root controller, TracksController, createPlaylistDisabled is computed and made available to the template, triggering Angular's render loop. app.controller('PlaylistController', ['$scope', function($scope){ $scope.createPlaylistDisabled = true; this.createPlaylistDisabledWillChange = function(selectedTracks){ $scope.createPlaylistDisabled = (selectedTracks.length == 0); }; $scope.$watch('selectedTracks', this.createPlaylistDisabledWillChange, true) }]); We found that Computed Properties helped us to build useful, ubiquitous conventions for use by developers in New Relic’s Business Engineering team. They also helped us write our code for fellow human beings, revealing what the code is supposed to do and providing a description of how the model gets transformed when the user interacts with the interface. Of course, we’re still battle-testing common ways to shape applications against many different scenarios to find the most robust architecture. So this is just the first in a series of posts presenting the lessons we’ve learned about JavaScript GUI development. Planned follow-up posts will cover patterns of controller communication and how routes mediate to stitch your application together. Related Topics DevOps By Vicente Reig Rincón de Arellano Vicente Reig Rincón de Arellano is a senior engineer in New Relic's Business Engineering team. Prior to joining New Relic, he worked building massively concurrent systems, data integration architectures, and GUIs in a wide variety of technologies such as Ruby, Java, Objective-C, and Javascript. Follow the author Vicente Reig Rincón de Arellano on Twitter Vicente Reig Rincón de Arellano on GitHub Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.09704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adventures in AngularJS: <em>The</em> View-Controller and Computed Properties",
        "sections": "<em>The</em> View-Controller: Computed Properties",
        "body": "(&#x27;tracks&#x27;, this.<em>selected</em>TracksWillChange, true); }]); We can finally add our Create Playlist button, governed by a controller in charge of watching how many tunes did the user <em>select</em>, enabling or disabling the button in consequence. &lt;button ng-controller=&quot;PlaylistController&quot; ng-click=&quot;createPlaylist"
      },
      "id": "60764f97196a6739ac64a7c3"
    }
  ],
  "/build-apps/ab-test/nerdstoragevault": [
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/embed/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Tip",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-04-16T02:01:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:32:20Z",
      "type": "",
      "external_id": "f2af52e45942b4cf9499282a654340b132766741",
      "popularity": 1,
      "body": "Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your Nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your Nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in componentDidMount(), you've queried NerdGraph for your api_token data. componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your Nerdlet's state is the current token that your Nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your Nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your Nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called componentDidUpdate(). Now, every time your Nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers componentDidUpdate(). In componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your Nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 787.3718,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "body": " is called <em>NerdStorageVault</em>. It&#x27;s different <em>from</em> <em>NerdStorage</em>, which you used in the last lesson, because it only supports user <em>storage</em> and encrypts its data. Store <em>your</em> API token Step 1 of 3 Change to the add-<em>nerdstoragevault</em>&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability"
      },
      "id": "6072ffcd64441f6cc09d8544"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:24Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 667.67065,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to <em>NerdStorageVault</em> - New Feature!",
        "body": " to the catalog Intro to <em>NerdStorageVault</em> - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store <em>your</em> data. <em>NerdStorageVault</em> lets you store and retrieve sensitive data secrets such as: Personal <em>access</em> tokens License keys API keys Other third-party"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "https://developer.newrelic.com/static/9fef87cd4b59ba7b2e8df08c97bd3b85/ba3ac/incorrect-auth-header.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/embed/",
      "sections": [
        "Fetch data from a third-party service",
        "Tip"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:32:19Z",
      "type": "",
      "external_id": "5a9959f254359afeec9b0a9a9f39dd8b83d8c1ee",
      "popularity": 1,
      "body": "In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -H 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 587.4457,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Fetch data <em>from</em> a third-party service",
        "body": " in <em>NerdStorageVault</em> is not &quot;ABC123&quot;, then <em>your</em> console will show an error that reads, &quot;Incorrect auth header&quot;: If you set the token to &quot;ABC123&quot;, then Total cancellations per version updates to show the values <em>from</em> the third-party service: Tip If something doesn&#x27;t work, use <em>your</em> browser&#x27;s debug tools to try"
      },
      "id": "606d10ee28ccbc1cd5e1c991"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/embed/",
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "027dd39d82c1996136231ffad1636034152cf482",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 512.8128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Using <em>NerdStorageVault</em> in <em>your</em> apps",
        "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use <em>NerdStorageVault</em> to store data in an encrypted <em>storage</em> solution. Using <em>NerdStorageVault</em> in <em>your</em> apps <em>NerdStorageVault</em> is used to store and retrieve sensitive secrets data"
      },
      "id": "6063d5f3e7b9d2632f70376b"
    },
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-04-12T10:06:38Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.57272,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store data in an encrypted <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store data in an encrypted <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "<em>Nerd</em>Graph allows you to <em>access</em> <em>your</em> New Relic data, but when you want to fetch third-party data, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and encrypted <em>storage</em> location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    }
  ],
  "/build-apps/ab-test/version-descriptions": [
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:21Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1754.4325,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>version</em> <em>descriptions</em>",
        "body": "With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you&#x27;ll continue that trend by creating <em>descriptions</em> for each design <em>version</em> in your A&#x2F;B test. Step 1 of 8 Change to the <em>add</em>-<em>version</em>-<em>descriptions</em>&#x2F;ab-test"
      },
      "id": "6072569228ccbc932d51c172"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:50Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.44382,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> user interface components to your application",
        "body": ", you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll <em>add</em> headings to clarify what each chart represents. Third, you&#x27;ll <em>add</em> <em>descriptions</em> for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your"
      },
      "id": "6073006628ccbce73151c12f"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:39Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings/ab-test Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.425,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> chart headings",
        "body": " and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it&#x27;d be nice to <em>add</em> <em>descriptions</em> to help you remember what each <em>version</em> in your A&#x2F;B test represents. In the next lesson, you&#x27;ll <em>add</em> a description for each design <em>version</em>."
      },
      "id": "6072ff1928ccbc140b51c16e"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/embed/",
      "sections": [
        "Describe your app for the catalog",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "baf09ac55fe0770a7b7de7102f2a2a7a463d49de",
      "popularity": 1,
      "body": "In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your Nerdpack. Step 1 of 6 Change to the describe-app/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/describe-app/ab-test Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create --type catalog This creates a catalog directory with template files for inputting custom information about your app. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! catalog/documentation.md Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } catalog/config.json Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory. Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.13258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " saves the date and <em>version</em> <em>descriptions</em> in local storage. We can use this app for future A&#x2F;B tests as well! catalog&#x2F;documentation.md Copy For this course, you&#x27;re keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions"
      },
      "id": "606e63d8e7b9d201e9bfa819"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.41766,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " as the documentId, and the document data, which includes the <em>version</em> <em>descriptions</em> and the winner. You pass WRITE_DOCUMENT because you&#x27;re either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    }
  ],
  "/build-apps/ab-test/nerdstorage": [
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 533.18066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> <em>NerdStorage</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "body": "} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} &gt; End test &lt;&#x2F;EndTestButton&gt; &lt;&#x2F;GridItem&gt; &lt;&#x2F;Grid&gt; } } nerdlets&#x2F;ab-test-<em>nerdlet</em>&#x2F;end-test.js Copy Fetch test information <em>from</em> <em>NerdStorage</em> Step 1 of 6 In past-tests.js, update PastTests to fetch data <em>from</em> account"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/embed/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Tip",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-04-16T02:01:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:32:20Z",
      "type": "",
      "external_id": "f2af52e45942b4cf9499282a654340b132766741",
      "popularity": 1,
      "body": "Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your Nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your Nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in componentDidMount(), you've queried NerdGraph for your api_token data. componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your Nerdlet's state is the current token that your Nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your Nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your Nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called componentDidUpdate(). Now, every time your Nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers componentDidUpdate(). In componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your Nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 452.1286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> <em>NerdStorageVault</em> <em>from</em> <em>your</em> <em>Nerdlet</em>",
        "body": " is called <em>NerdStorage</em>Vault. It&#x27;s different <em>from</em> <em>NerdStorage</em>, which you used in the last lesson, because it only supports user <em>storage</em> and encrypts its data. Store <em>your</em> API token Step 1 of 3 Change to the add-nerdstoragevault&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability"
      },
      "id": "6072ffcd64441f6cc09d8544"
    },
    {
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/embed/",
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "67c529a70a60d530860fbe80be795d214798dfd9",
      "popularity": 1,
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 425.2862,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Query data <em>from</em> <em>NerdStorage</em>",
        "body": " .&#x2F;nerdlets&#x2F;use-<em>nerdstorage</em>-<em>nerdlet</em>&#x2F;index.js file in the text editor of <em>your</em> choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addTo<em>NerdStorage</em>, and you need to update it to add User<em>Storage</em>Mutation The User<em>Storage</em>"
      },
      "id": "6066782e64441f577f617a9d"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/embed/",
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "published_at": "2021-04-16T02:13:38Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:56Z",
      "type": "",
      "external_id": "31fc09fc1a4af441ce6fa9a9ea59fa2216dd2058",
      "popularity": 1,
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 397.79807,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>NerdStorage</em> in <em>your</em> apps",
        "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use <em>NerdStorage</em> SDK components. Use <em>NerdStorage</em> in <em>your</em> apps <em>NerdStorage</em> is used to store and retrieve simple sets of data, including users&#x27; configuration settings"
      },
      "id": "6063d63428ccbcff4e43fa92"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-16T02:10:56Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 377.5069,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Query and <em>storage</em> components",
        "body": ". For more on this, see <em>NerdStorage</em>. Platform APIs The Platform API components of the SDK enable <em>your</em> application to interact with different parts of the New Relic One platform, by reading and writing state <em>from</em> and to the URL, setting the configuration, etc. They can be divided into these categories"
      },
      "id": "60652884196a67886047e800"
    }
  ],
  "/build-apps/ab-test/catalog": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/catalog/embed/",
      "sections": [
        "Describe your app for the catalog",
        "Create catalog information",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "baf09ac55fe0770a7b7de7102f2a2a7a463d49de",
      "popularity": 1,
      "body": "In the last lesson, you finished the A/B test application you've been building throughout this course. Now, it's time to prepare it for publication. When you publish your app to the New Relic One catalog, users can view it and subscribe to it. You can help your users by showing and telling them what the app does, how to use it, and more. Create catalog information To supply information to the catalog about your app, you need to create the catalog directory in your Nerdpack. Step 1 of 6 Change to the describe-app/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/describe-app/ab-test Step 2 of 6 Create the catalog directory: bash Copy $ nr1 create --type catalog This creates a catalog directory with template files for inputting custom information about your app. Tip Read our documentation to learn more about the catalog directory. Step 3 of 6 Update catalog/documentation.md: ## Documentation This application combines and presents data from New Relic and the Nerdsletter API so that we can make an informed decision on which design version results in more high-quality newsletter subscriptions. It also presents an button to end the test, which saves the date and version descriptions in local storage. We can use this app for future A/B tests as well! catalog/documentation.md Copy For this course, you're keeping the documentation concise by merely describing what the app does. In your own projects, you might also include instructions for contributing to the project in an open source context, installing the app's dependencies, or anything else that might help a user navigate complexities in your app or code. Step 4 of 6 Update catalog/config.json: { \"tagline\": \"Win @ newsletter subscriptions\", \"details\": \"Display test data for our newsletter subscription A/B test\", \"repository\": \"https://github.com/newrelic-experimental/nru-programmability-course\", \"whatsNew\": \"Initial release! Includes:\\n- A variety of charts for understanding the test results\\n- An end test button for storing some test data in a table\", \"support\": { \"email\": { \"address\": \"\" }, \"issues\": { \"url\": \"\" }, \"community\": { \"url\": \"\" } } } catalog/config.json Copy Here, you've specified a tagline, project details, the source code repository, and a short list of everything included in the initial release. In other projects, you might also add a support email or support links. Step 5 of 6 Save the this screenshot to your catalog/screenshots directory. Users will be able to see a carousel of screenshots in your app's About page in the catalog. Step 6 of 6 Save the following icon as icon.png in two places: nru-programmability-course/describe-app/ab-test nru-programmability-course/describe-app/ab-test/launchers/ab-test-launcher This will act as the launcher's icon and the app's catalog icon on the About page. Now you've added documentation, screenshots, metadata, and an icon to your app so that users will be able to understand what it does and why they might need it. For now, these files are all local and they need to be submitted to the catalog. But before you can do that, your app, itself, needs to be published to the catalog. In the next lesson, you'll publish your app, submit your catalog information, and view the results in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 259.9363,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Describe</em> <em>your</em> <em>app</em> <em>for</em> <em>the</em> <em>catalog</em>",
        "body": " what the <em>app</em> does, how to use it, and more. Create <em>catalog</em> information To supply information to the <em>catalog</em> about <em>your</em> <em>app</em>, you need to create the <em>catalog</em> directory in <em>your</em> Nerdpack. Step 1 of 6 Change to the <em>describe</em>-<em>app</em>&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru"
      },
      "id": "606e63d8e7b9d201e9bfa819"
    },
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/publish/embed/",
      "sections": [
        "Publish your New Relic One application",
        "Versions and tags",
        "Tip",
        "Publish your first application",
        "Technical detail",
        "View your application in the catalog",
        "Submit catalog information",
        "Update your version tag"
      ],
      "published_at": "2021-04-16T02:02:46Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:07Z",
      "type": "",
      "external_id": "41ee1ef02494dc82084533ad141ff3202f8ae2d4",
      "popularity": 1,
      "body": "In the last lesson, you created catalog information for the A/B test app you've been building throughout this course. Now, it's time to publish your app to the New Relic One catalog and submit those catalog details. Versions and tags Publishing an application requires two key pieces of information: version tag An application's version identifies the code it contains and is stored in the Nerdpack's root-level package.json file. Every time you modify code in your Nerdpack and are ready to release it, you'll update the version in package.json. For example, if you fix some bugs in the first major version your application code, you might publish the changes under version 1.0.1. An app version's tags describe its state. For example, version 0.0.1 of a work-in-progress application might be published with a DEV tag to indicate that it's in development. Tip There are some rules governing how you can use tags and you can read about those in our tags documentation. Publish your first application Step 1 of 7 Change to the publish/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/publish/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/publish/ab-test. Step 3 of 7 Generate your own app UUID: bash Copy $ nr1 nerdpack:uuid -gf The UUID is used to identify your app in the New Relic One app registry. Because you're using code that we developed for this course, an application with the existing UUID already exists in the registry. By generating your own, you're now able to publish this application. Technical detail The UUID also ties your app to your account and, therefore, allows the application to make Nerdgraph requests on behalf of the account that installed it. Step 4 of 7 In package.json, set version to 1.0.0: { \"private\": true, \"name\": \"ab-test\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"2d923ba6-d231-4dd3-830f-b1923577a422\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } Copy New Relic One uses semantic versioning and, under this convention, 1.0.0 signals the first major release. Now, you're ready to publish! Step 5 of 7 Replace all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively. Step 6 of 7 Publish your New Relic One application: bash Copy $ nr1 nerdpack:publish -t DEV That's it! You published your application to New Relic's registry. The -t parameter specifies a tag for your published version. Among other logs, you should see the following confirmation in your console: bash Copy Publishing Nerdpack AbTest (9da77738-9cf6-43c7-9ba0-e3a8c6ac7380) ✔ Nerdpack published successfully! ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as DEV. For now, you've tagged the 1.0.0 release as DEV because it's still a work in progress. Step 7 of 7 View your app's registry information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 4 Version Date Tags ------- ------------- ------ 1.0.0 5 minutes ago DEV The results of this command detail the information stored in New Relic's registry for your application, including its UUID, version, and account ID. View your application in the catalog Now that your application is published and tagged, you can view it in the New Relic One app catalog. Step 1 of 3 Go to New Relic. Notice that you're not using the ?nerdpacks=local querystring parameter. You don't need it anymore because you're not serving your app locally. Step 2 of 3 From the homepage, navigate to Apps: From here, you can see your application under New Relic One catalog: Notice that this is different than when you locally served your app. Local apps and published apps you're subscribed to show under Your apps instead. Step 3 of 3 Click on your app to see more details: Notice the release date and app version. This page should show the information you created in the last lesson. It doesn't yet, because you haven't submitted that information to the catalog, and publishing your app doesn't do that for you. Submit catalog information Even though you've published your application, there are some things that the catalog doesn't know about. These are the descriptions, screenshots, and metadata you created in the last lesson. nr1 catalog is used to submit and view this information. Step 1 of 3 Submit your catalog information: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for AbTest 1.0.0 If everything goes right, you should see a success message notifying you that the screenshots and metadata were updated. You may, however, get an error when submitting this information to the catalog: bash Copy Uploading screenshots... › Error: 1 error while updating AbTest 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN If you do, try again in a minute or two. It can take a few seconds for the catalog to update with the new version of your application. If that doesn't work, make sure you published your app with nr1 nerdpack:publish. Step 2 of 3 View your catalog information: bash Copy $ nr1 catalog:info description: Nerdpack ab-test details: Display test data for our newsletter subscription A/B test displayName: AbTest icon.url: https://nr3.nr-ext.net/artifact-index-production/a685fec2-29fb-40b0-9f65-4178... previews.0.url: https://application-catalog-production.s3.us-east-2.amazonaws.com/nerdpacks/a... releaseDate: 2021-03-12T15:46:09.600138Z repository: https://github.com/newrelic-experimental/nru-programmability-course tagline: Win @ newsletter subscriptions version: 1.0.0 whatsNew.changes: Initial release! Includes: - A variety of charts for understanding the test r... whatsNew.version: 1.0.0 All the information from catalog shows here. Step 3 of 3 View your app in the catalog: Notice the tagline on the app's catalog entry. Click on the app to see more: Here, you see app details, a documentation tab, release notes, and screenshots. Update your version tag Your app looks great in the catalog, complete with metadata, images, and documentation. Before, you tagged the app as DEV because all of the information wasn't ready for public consumption. Now, it is. It's time to update your version tag. Step 1 of 2 Update your 1.0.0 app version from DEV to STABLE: bash Copy $ nr1 nerdpack:tag -t STABLE ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as STABLE. Without specifying a version, nr1 uses the version specified in package.json. You can specify a version with the -V command. Learn more about nerdpack:tag with the nr1 nerdpack:tag --help command. Step 2 of 2 View your app information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ------------- ------ 1.0.0 30 minutes ago STABLE The app is now tagged with STABLE, indicating it's ready for public use. Technical detail Even though the app is ready for public use, it's still only visible to users of your account. Other accounts can't see apps created by other private accounts unless those apps are added to the public New Relic One catalog. Now that your app is published and its metadata is submitted, you can subscribe your account to the app from the catalog. In the next lesson, you'll learn the ways to subscribe and unsubscribe to your new application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.74474,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View <em>your</em> <em>application</em> in <em>the</em> <em>catalog</em>",
        "body": "In the last lesson, you created <em>catalog</em> information for the A&#x2F;B test <em>app</em> you&#x27;ve been building throughout this course. Now, it&#x27;s time to publish <em>your</em> <em>app</em> to the New Relic One <em>catalog</em> and submit those <em>catalog</em> details. Versions and tags Publishing an application requires two key pieces of information"
      },
      "id": "60730001e7b9d2de18a5c660"
    },
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.56036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Subscribe to <em>your</em> New Relic One <em>application</em>",
        "body": "In the last lesson, you published <em>your</em> A&#x2F;B test <em>app</em> to the New Relic One <em>catalog</em>. You then submitted <em>your</em> <em>app</em>&#x27;s description, metadata, documentation, and screenshots. Now, it&#x27;s time to subscribe <em>your</em> account to the published <em>app</em>. Subscribe to <em>your</em> application Now that <em>your</em> application is published"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/embed/",
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advance configurations",
        "Extend webpack configuration",
        "Proxy browser setup",
        "Summary"
      ],
      "published_at": "2021-04-15T21:03:38Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "1293ef1d7183c27efff24e8be21e9d1b4926ceff",
      "popularity": 1,
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advance configurations Extend webpack configuration You can use our .extended-webpackrc.js file to extend the webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Proxy browser setup Generally, you don't need to know how your application code is loaded in New Relic One. But understanding how this works can help you if you encounter issues (for example, with a proxy or browser setup). When developing, your code is served from your local laptop by using an nr-local.net subdomain. This domain points to 127.0.0.1, and will use a variety of ports to connect, including 9973. In order to load third-party code into the platform, (both in development and production), New Relic One uses an <IFRAME>, as well as a separate domain (a subdomain of nr-ext.net) to perform the load, relying on same-domain policy to sandbox the code. For this reason, your network administrator may need to enable access to: Any subdomain of nr-local.net, or, at the very least, to any domain of the shape of <UserId>.nr-local.net, where UserId is a 32-hexadecimal character identifier that is unique to the user logged into the platform (you can use [0-9a-f]{32} to discriminate it). Any subdomain of nr-ext.net, or, at the very least, to any domain in the shape of <NerdpackUuid>.g <NerdpackGid>.nr-ext.net, where NerdpackUuid is the UUID assigned to your package, and NerdpackGid is zero, or a positive integer (you can use 0|[1-9]\\d+ to discriminate it). Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.18068,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add details to <em>describe</em> <em>your</em> project",
        "body": " that it doesn&#x27;t display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to <em>describe</em> <em>your</em> project Now that <em>your</em> new application is in the New Relic One <em>catalog</em>, you can add details that help users understand what <em>your</em> application does and how"
      },
      "id": "6063d63364441f843d0c8bc3"
    },
    {
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/embed/",
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "f17736ed026e1bf9fd253b8b716db26f1f13cc58",
      "popularity": 1,
      "body": "To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.6522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Configure <em>your</em> CLI preferences",
        "body": " application, see our guide on Deploying <em>your</em> New Relic One <em>app</em>. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or <em>catalog</em>). nr1 profiles Manages"
      },
      "id": "6063d63364441f61c30c8be9"
    }
  ],
  "/build-apps/ab-test/chart-group": [
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/embed/",
      "sections": [
        "Add a chart group",
        "Tip"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:43:09Z",
      "type": "",
      "external_id": "e94780ac131f1a4ce5999771f9bee9650d4f5e9b",
      "popularity": 1,
      "body": "In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group/ab-test Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1684.6661,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> <em>chart</em> <em>group</em>",
        "body": " for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll <em>group</em> them with a <em>ChartGroup</em> and specify that their values are measured in milliseconds. Step 1 of 9 Change to the <em>add</em>-a-<em>chart</em>-<em>group</em>&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru"
      },
      "id": "6072ff19e7b9d25dbba5c689"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Extra credit"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1187.1611,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> tables",
        "body": " sample. This practice will reinforce what you&#x27;ve learned in this lesson. If you need help, review the <em>add</em>-a-<em>chart</em>-<em>group</em> directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each <em>chart</em> you’ll <em>add</em> to your"
      },
      "id": "60725692196a67b68c64a778"
    },
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/embed/",
      "sections": [
        "Add a grid",
        "Technical detail"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:42:16Z",
      "type": "",
      "external_id": "bfd5e04da0f000d6970b16677cd5faf8c3b2f461",
      "popularity": 1,
      "body": "In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid/ab-test Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your Nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.55919,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> grid",
        "body": ". Then, update your Nerdlet&#x27;s render() method by placing each <em>chart</em> in a GrildItem. Finally, place all your items in a Grid: import React from &#x27;react&#x27;; import { <em>ChartGroup</em>, Grid, GridItem } from &#x27;nr1&#x27;; import NewsletterSignups from &#x27;.&#x2F;newsletter-signups&#x27;; import PastTests from &#x27;.&#x2F;past-tests&#x27;; import"
      },
      "id": "6072565d28ccbc6baf51c18b"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:21Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.52402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> version descriptions",
        "body": " description for each design version in your A&#x2F;B test. Step 4 of 8 In your Nerdlet&#x27;s index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from &#x27;react&#x27;; import { <em>ChartGroup</em>, Grid, GridItem } from"
      },
      "id": "6072569228ccbc932d51c172"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/embed/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:20Z",
      "type": "",
      "external_id": "43c5fb39b73ee2dbbe5f216a577ff77051fcc513",
      "popularity": 1,
      "body": "In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 View your changes: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.08939,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> NrqlQuery components to your Nerdlet",
        "body": ": This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a <em>chart</em>: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and <em>group</em> subscription events using these dimensions. Notice"
      },
      "id": "60730124196a6731e464a778"
    }
  ],
  "/build-apps/ab-test/pie-charts": [
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/embed/",
      "sections": [
        "Add pie charts"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "c0f472d2ed9df8035313cd76ee83ec43e75d0a4a",
      "popularity": 1,
      "body": "You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1948.1779,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>pie</em> <em>charts</em>",
        "body": ". Your application is starting to take shape. You’ve created a line <em>chart</em> and two <em>pie</em> <em>charts</em>. For now, these <em>charts</em> use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your <em>charts</em>, however, you’ll learn how to <em>add</em> a table to your application so you can visualize data in a new way."
      },
      "id": "6072ffcc28ccbc786651c18a"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/embed/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:20Z",
      "type": "",
      "external_id": "43c5fb39b73ee2dbbe5f216a577ff77051fcc513",
      "popularity": 1,
      "body": "In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 View your changes: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.93109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Populate <em>charts</em> with pageView event data",
        "body": " New Relic. In this case, you refresh every minute. Populate your <em>PieChart</em> with subscription event data Now that you&#x27;ve seen how to passed New Relic data to Newsletter subscriptions per version, it&#x27;s time to move on to Total subscriptions per version. These two <em>charts</em> are similar in that they compare"
      },
      "id": "60730124196a6731e464a778"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Extra credit"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 196.1687,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> tables",
        "body": " website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the Table<em>Chart</em> components come after the <em>pie</em> <em>charts</em> you created in the last lesson. Step 1 of 8 Change"
      },
      "id": "60725692196a67b68c64a778"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:39Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings/ab-test Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 196.099,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>chart</em> headings",
        "body": " guide details what data each <em>chart</em> shows. Use those details to craft useful headings for your <em>charts</em>. Step 1 of 6 Change to the <em>add</em>-<em>chart</em>-headings&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-<em>chart</em>-headings&#x2F;ab-test Step 2 of 6 In newsletter-signups.js"
      },
      "id": "6072ff1928ccbc140b51c16e"
    },
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/embed/",
      "sections": [
        "Add a chart group",
        "Tip"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:43:09Z",
      "type": "",
      "external_id": "e94780ac131f1a4ce5999771f9bee9650d4f5e9b",
      "popularity": 1,
      "body": "In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group/ab-test Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.12207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a <em>chart</em> group",
        "body": " for newsletter signup requests. Now, you’ll build two more line <em>charts</em>, but this time, you’ll group them with a <em>Chart</em>Group and specify that their values are measured in milliseconds. Step 1 of 9 Change to the <em>add</em>-a-<em>chart</em>-group&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru"
      },
      "id": "6072ff19e7b9d25dbba5c689"
    }
  ],
  "/build-apps/ab-test/demo-setup": [
    {
      "image": "https://developer.newrelic.com/static/555c6dd44f2ffbceff682f7fbc78e01c/ba3ac/demo-service.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/demo-setup/embed/",
      "sections": [
        "Spin up your demo services",
        "Important"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "ec4e6154accdaf3768fc5b029e77e94337973ed8",
      "popularity": 1,
      "body": "Before you build your New Relic One application, you need to spin up your demo services. This coursework depends on two important services: A web service that shows a newsletter signup form. The form's heading text alternates between two versions because you're performing an A/B test to determine which text leads to more high-quality subscriptions. A simulator service that sends steady traffic to the website so that you don't have to manually generate data To spin up your demo services, you first need to install Docker and Docker compose. Spin up your demo services Step 1 of 5 Clone the coursework repository from GitHub: bash Copy $ git clone https://github.com/newrelic-experimental/nru-programmability-course This repository contains code for creating NodeJS New Relic automations. It also contains a an app code directory for each lesson in the course. You'll use these directories to follow along with the course content. Step 2 of 5 Change to the demo directory, called ab-test-app: bash Copy $ cd nru-programmability-course/ab-test-app This directory contains configuration files and READMEs for using the demo. Step 3 of 5 Build and run the web service and simulator containers, using docker-compose: bash Copy $ NEW_RELIC_LICENSE_KEY=<your New Relic license key> docker-compose up -d Important Make sure you replace <your New Relic license key> with your actual license key. Once it's finished, view the website at localhost:3001: Step 4 of 5 Visit New Relic, and navigate to APM in the top navigation menu. Select Newsletter from the list of instrumented services: You may have to wait a minute or two for New Relic to recieve data from your demo services. Once it's ready, you'll see transaction data, such as performance, throughput, and an Apdex score: Step 5 of 5 To spin down your demo services, run docker-compose down from your ab-test-app directory: bash Copy $ docker-compose down Now you're ready to build your New Relic One application!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2479.7615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Spin</em> <em>up</em> <em>your</em> <em>demo</em> <em>services</em>",
        "body": "Before you build <em>your</em> New Relic One application, you need to <em>spin</em> <em>up</em> <em>your</em> <em>demo</em> <em>services</em>. This coursework depends on two important <em>services</em>: A web service that shows a newsletter signup form. The form&#x27;s heading text alternates between two versions because you&#x27;re performing an A&#x2F;B test to determine"
      },
      "id": "6072ff1928ccbc111f51c16a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/sean-winters-1.jpg?h=bb00930c&itok=NUV55qE9",
      "url": "https://newrelic.com/blog/best-practices/best-practices-aws-lambda",
      "sections": [
        "Don’t reinvent the wheel if you don’t have to",
        "Understand there is still an underlying infrastructure",
        "Don’t leave your function out in the cold",
        "Eliminate recursion and embrace concurrency",
        "Know your limits",
        "Take advantage of complementary services",
        "You (probably) don’t need to use serverless functions for everything",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:43Z",
      "title": "Tips and Practical Guidance for Getting Started with AWS Lambda",
      "updated_at": "2021-04-14T00:32:53Z",
      "type": "",
      "external_id": "a58e2de9ff8db1d234d4e9df31045042fef66c1f",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Cloud Tips and Practical Guidance for Getting Started with AWS Lambda Nov 13, 2018 • 11 min read By Sean Winters Contrary to popular opinion, the term “serverless” is not entirely synonymous with AWS Lambda. In fact, the rise of Lambda seems to have inspired widespread adoption—and possible misuse—of the term “serverless.” Serverless is a general term that includes all cloud services that don’t require an administrator to spin up a server to run them (think Amazon DynamoDB or Amazon S3). Amazon Web Services has been promoting serverless computing for some time, and AWS Lambda is their functions as a service (FaaS) platform. The key feature of AWS Lambda is that you can upload and run application code with basically no administrative oversight. AWS takes care of your app’s scale and delivers high availability, and your code runs only when triggered via API calls. These lightweight, hands-off serverless functions are changing developer workflows. I’ve been experimenting with AWS Lambda since it launched, and in my spare time, I’ve built some fun projects using functions and New Relic's AWS Lambda monitoring integration. I’ve found that Lambda generates a lot to think about, from behavior to cost considerations. To that end, I’ve put together this collection of tips and practical advice for getting started with AWS Lambda. (Note: Other major cloud providers like Microsoft Azure and Google Cloud Platform have launched their own serverless, FaaS platforms, but this post focuses on AWS Lambda.) Don’t reinvent the wheel if you don’t have to When you create a new AWS Lambda function, you’re given the option of starting a new function from scratch, choosing a preconfigured template (or “blueprint”) as a starting point, or using an existing function that another user has uploaded to the AWS Serverless Application Repository. If you’re looking to create a common service or application, there’s a good chance you’ll find an implementation to import or borrow from. Applications in the Serverless Application Repository and blueprints adhere to the serverless application model (SAM) template. The AWS serverless application model is an extension of the CloudFormation template—used to define an AWS cloud stack—that defines how your serverless applications connect to other AWS resources. In some cases, shipping an app that uses AWS Lambda functions may be as simple as deploying the template and changing a few environment variables and parameters. Understand there is still an underlying infrastructure Spoiler alert: Underneath it all, your AWS Lambda functions run on containers in AWS' backend. One of the main advantages of using serverless functions is that you’re not supposed to worry about managing the backend. However, if your AWS Lambda function uses a lot of the container’s memory or CPU, or if it uses the host’s underlying file system (for example, to write temporary files), it’s crucial that you specify resources accordingly. It’s also interesting to note that FaaS providers have started rolling out service level agreements (SLAs). AWS has recently released its own, guaranteeing 99.95% availability for each AWS region. This is a good sign of Amazon’s commitment to this service, as well as a likely indicator that more and more enterprises are adopting AWS Lambda functions in their development practices and workflows. Don’t leave your function out in the cold When you trigger an AWS Lambda function for the first time, it needs some time to initialize: to load your code and any dependencies into the assigned container, and then to start the execution of your code. This initial runtime is known as a “cold start.” Subsequent, timely runs with that container won’t require a cold start and thus will be faster. If you leave the function (and therefore the container) inactive, AWS will eventually shut it down, and the function will have a cold start the next time you run it. There’s no definitive measure of how long AWS allows a function to idle—one engineer did enough research to hypothesize that 60% of cold starts happen after 45 minutes of inactivity—but it does seem dependent on factors like function size and the needs of other functions running in the shared cloud. There are ways to minimize the effects of cold starts. First, think about building your AWS Lambda functions as small as possible and minimizing bundled dependencies. According to our 2017 State of Serverles Report, “The total code size of AWS Lambda functions—how much disk space the code and the dependencies of a function consume—tends to be small by modern software standards. Nearly half of the monitored functions could almost fit on a 3½-inch floppy disk. Java functions were notable outliers. Their average code size was more than 20MB, indicating significantly larger function deployment sizes than Node.js or Python functions.” In other words, loading a 5 MB Python function into a new container on a cold start requires significantly less time than it takes to load a 20+ MB Java function. Another way to mitigate cold starts is to use a “keep warm” solution to keep your AWS Lambda functions container safe from termination. There are plenty of tools designed for this purpose, such as the Serverless WarmUP Plugin, which you can use to schedule a “warm up” event to run your functions every few minutes, at minimal cost. Of course, if your AWS Lambda function accepts concurrent requests, it will need to spin up concurrent containers so your function can serve requests as quickly as possible. In this case, cold starts may be unavoidable if the volume of requests is ever increasing, and AWS must start new containers. (Check out our post \"Understanding AWS Lambda Performance—How Much Do Cold Starts Really Matter?\" for more information on cold start optimizations.) Eliminate recursion and embrace concurrency The FaaS model has the potential to radically change how we deploy software applications, but it also requires us to change how we think about writing software to adapt to this new model. Specifically we need to change how we think about recursion and concurrency. It’s important to understand that AWS Lambda uses concurrency to scale your functions. In traditional applications, engineers could have to plug functions into an async framework to get requests running in parallel. With AWS Lambda, concurrency is handled by AWS; if there isn’t a “warm” container available to fulfill a request triggered by event sources like the Amazon API Gateway or Amazon S3, AWS Lambda will spin up a new container. Essentially, AWS removes a layer of abstraction and does the work of concurrency, so you don’t have to worry about it. But automatic concurrency means you have to be careful handling processes like recursion. Some of the most elegantly engineered functions employ a bit of recursion or include carefully crafted recursive implementations of an algorithm. However, in AWS Lambda functions, you don’t want an outer function to call itself. If this happens, AWS will spin up more concurrent instances of the function, and these concurrent instances, coupled with cold starts, will cost you compute time and money (inseparable concepts in this paradigm). Know your limits Function limits For each AWS Lambda function request, AWS sets limits on memory allocation, disk capacity, and execution time. In early November 2018, memory allocation starts at 128 MB and is capped at 3008 MB; disk capacity (/tmp directory storage) is limited to 512 MB; and the maximum duration of an AWS Lambda function is 900 seconds. If your function requires more memory or lasts longer than that, consider refactoring the function to make it more efficient, or break it down into smaller AWS Lambda functions. If you’re hitting disk capacity limits, use Amazon S3 for storage. Concurrency limits As mentioned, AWS Lambda uses concurrency to scale your functions. AWS sets the default limit at 1,000 concurrent executions, per region. Expect some throttling if you exceed this limit. If you have a single function that exceeds your limits, consider adjusting your concurrent execution limit at the function level. Deployment limits If you work with a language that favors large deployment packages, you may hit deployment package limits. Currently, AWS sets deployment limits at 50 MB for zipped packages and 256 MB for unzipped packages. You’ll want to be vigilant about removing unneeded libraries and otherwise keeping your functions as small as possible. If you have a group of specialized AWS Lambda functions (in other words, functions that perform only one task), consider logically combining them into one function to avoid having to deploy the same shared library across the AWS Lambda environment. Monitor your limits with the New Relic AWS Lambda integration Use New Relic's AWS Lambda monitoring integration for New Relic Infrastructure to report data such as invocation counts, error counts, function timers, concurrency, and other metrics and inventory data. You can view your AWS Lambda data in pre-built dashboards and also create custom queries and charts in New Relic Insights. Take advantage of complementary services Bring your team together with Cloud 9 Cloud 9 is a browser-based integrated development environment (IDE) you can use in the AWS console. By bundling necessary plug-ins, libraries, and SDKs, AWS has made it easy to engineer and deploy Lambda functions from Cloud 9. You can run your full Lamba development environment on one EC2 instance, and share real-time access with your team. Perform local development and iteration with SAM CLI If you want to integrate AWS Lambda function development into your local workflow, try the open source AWS SAM CLI. The AWS SAM CLI lets you use the serverless application model (SAM) to locally develop, test, and iterate on your functions before you deploy them into production. Take advantage of open source, including the Serverless Framework The Serverless Framework is an open source, provider-agnostic CLI that allows you to develop and test functions locally and deploy them when you’re ready. It also boasts a great developer community that has come up with an extensive list of plugins for building out your functions. Turn your AWS Lambda functions into a state machine with AWS Step Functions Eventually you may have several AWS Lambda functions—or several AWS Lambda functions and services running in containers or on Amazon Elastic Compute Cloud (EC2) instances—performing different tasks in your application. It can be challenging to coordinate, debug, and visualize what’s going on in your backend. This is where AWS Step Functions help. Think of Step Functions as workflows in which you define your application as a series of steps that must be executed in a particular order. It eventually resembles a state machine enforcing a programmatic flow within your serverless application. You (probably) don’t need to use serverless functions for everything As cutting-edge technology paradigms make their way into the mainstream, eager users will naturally want to apply the new tech to solve old problems. With serverless technologies, we should strive to avoid false dichotomies: It’s not about serverless vs. monoliths, or serverless vs. containers. Instead, let’s work toward definitions for how serverless functions and services, in combination with everything else, fits into our modern architectures. In fact, some cloud users are using serverless in conjunction with traditional servers and containers in their hybrid cloud environments. After all, some applications are a perfect fit for serverless frameworks, and others not so much. If you are considering going full serverless, we recommend that you do your research and calculate whether a serverless architecture would be less expensive or more viable for your needs. You can perform your own comparisons, use an AWS calculator, or have fun trying out third-party estimators. The debate over whether or not serverless functions are ready for the big time will continue for a while, so be sure to check in with both sides, as we did in \"The Great Serverless Debate\" podcast. Related Topics Cloud By Sean Winters Sean Winters is a Technical Support Engineer in New Relic's Dublin office. When not helping customers harness the power of New Relic, he's doing everything it takes to win his fantasy football league. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.73737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Take advantage of complementary <em>services</em>",
        "body": ". In fact, the rise of Lambda seems to have inspired widespread adoption—and possible misuse—of the term “serverless.” Serverless is a general term that includes all cloud <em>services</em> that don’t require an administrator to <em>spin</em> <em>up</em> a server to run them (think Amazon DynamoDB or Amazon S3). Amazon Web"
      },
      "id": "6076383564441ffda49d859c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/6-Snowflake-new-orders-received.png",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-snowflake-integration",
      "sections": [
        "Detect and resolve warehouse performance issues",
        "Optimize costs, credits used",
        "Detect potential security issues and failed logins",
        "Monitoring and alerting custom Snowflake data",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:43Z",
      "title": "New Relic Snowflake Integration Boosts Observability",
      "updated_at": "2021-04-13T23:25:02Z",
      "type": "",
      "external_id": "03e7785a57d3c95f9665eb6cb43c0b27760405e9",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Integrations New Relic Snowflake Integration Boosts Observability Jan 12, 2021 • 6 min read By Daniel Fitzgerald Snowflake, a data platform company that provides a scalable infrastructure in the cloud, can meet a diverse set of needs, from building a data lake to data warehousing, reporting, and analytics. This versatility, plus the benefits of running in the cloud, such as low maintenance and access to massive scale, means that more and more companies are turning to Snowflake. Like any piece of critical infrastructure, once Snowflake starts to play a key role in delivering value to a company or set of users, it’s critically important to make sure it’s secure, performant, and delivers the data you need in a timely fashion. That sounds like a job for New Relic. We are introducing our Snowflake integration, which gives you a broad view of how Snowflake is working across the following areas: costs, performance, security, and availability. In this post, we’ll walk through some key use cases to help you: Detect and resolve warehouse performance issues Optimize costs—whether that’s expensive queries, users running many queries, or warehouses that contribute the most to your bill Detect potential security issues and failed logins Monitor and alert on custom Snowflake data Detect and resolve warehouse performance issues In Snowflake, a virtual warehouse is a massively parallel processing (MPP) cluster, which you can spin up on-demand to execute user queries. Virtual warehouses can be different sizes for different workloads. If a warehouse doesn’t have enough capacity to run the queries in-memory, it will spill some bytes to the disk or remote storage. When this happens, there is a significant impact on query performance. Keep an eye on these metrics, consider setting up alerts to see when these cases happen, and think about increasing the size of virtual warehouses that experience these symptoms. Warehouse size also impacts the number of queries that you can process at any one time. A sign that a cluster needs to be resized is when you see disk spillage (bytes spilled to local or remote storage) or queries being queued. Here are two queries you can use to detect each of these scenarios: SELECT average(BYTES_SPILLED_TO_LOCAL_STORAGE_AVERAGE)FROM SnowflakeVirtualWarehouse WHERE metric_type = 'snowflake.query_performance' SELECT average(QUEUED_LOAD_AVERAGE) FROM SnowflakeVirtualWarehouse WHERE metric_type = 'snowflake.warehouse_performance' You can use New Relic Alerts to tell you when a warehouse is queueing queries and should be resized. If an alert triggers, you can resize the warehouse or increase the maximum number of clusters if you have the multi-cluster warehouses setting enabled. A key area for performance improvements is pinpointing inefficient or poorly written queries. In the chart below, we can detect when Snowflake is spending long periods compiling and executing queries. If you detect a spike in these times, you can dive in further to pinpoint which queries are causing the impact and optimize them to be more efficient. Optimize costs, credits used One of Snowflake’s key benefits is its consumption-based pricing model that allows you to spin up new capacity instantly. Of course, with great power comes great responsibility. Like any consumption-based system, it’s easy to spend more than you mean to; that’s why it’s important to keep an eye on costs and alert when spend goes over an acceptable level. Using a linear prediction function, you can predict when a warehouse spend is likely to reach a certain level in the future based on historical data. You can also alert when a particular warehouse spend goes over a certain amount using NRQL alerts, which can help you get an instant notification if a spend goes above a certain threshold, preventing an unexpected bill due to user error or misconfiguration. Detect potential security issues and failed logins Maintain the security of your Snowflake account by looking at who is logging in. You can track the number of logins, whether they are successful or failed logins, and the  method used, such as an ODBC Connector, via the UI or using a programmatic interface such as the Python driver. A rise in the number of failed logins can indicate that someone is trying to gain unauthorized access to the account or an application or integration that has been misconfigured and could suggest an issue with an application. Monitoring and alerting custom Snowflake data Out of the box, the Snowflake integration collects a wide range of performance-related data. What’s more, the integration enables you to ingest any data stored in Snowflake. If you want to keep an eye on orders, revenue, or customer interactions in real time, you can. All you need to do is add a new query to the integration .yml file, and our agent will store the result of that query in New Relic, running at an interval you choose. Check the GitHub repository for further instructions. It’s easy to export custom data from Snowflake. Here we see tracking sales orders in real time, alongside the valuable performance data. Snowflake is becoming ever more popular, but to ensure that its adoption goes smoothly within your organization, you must have a level of observability across different aspects such as performance, costs, and security. With the New Relic Snowflake integration, this is easily achievable. Sign up for a free New Relic account today and start monitoring your Snowflake account. Related Topics Integrations By Daniel Fitzgerald Daniel Fitzgerald is a senior solutions consultant for New Relic, based in London, UK. He helps some of the New Relic's largest European clients develop their monitoring and observability strategy. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.140724,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ") cluster, which you can <em>spin</em> <em>up</em> on-demand to execute user queries. Virtual warehouses can be different sizes for different workloads. If a warehouse doesn’t have enough capacity to run the queries in-memory, it will spill some bytes to the disk or remote storage. When this happens"
      },
      "id": "6076284e28ccbc11b651c174"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/docker-chart-2-1.jpg",
      "url": "https://newrelic.com/blog/best-practices/docker-usage-dockercon-devops",
      "sections": [
        "Crunching the Docker numbers",
        "Docker use cases, from VM replacements to ephemeral computicles",
        "Docker is changing how code gets written",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:24:24Z",
      "title": "Exclusive: How Docker Containers Are Being Used Right Now",
      "updated_at": "2021-04-14T00:22:55Z",
      "type": "",
      "external_id": "650a66c6c573214be3d1940492d5a8b905b10743",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Cloud Exclusive: How Docker Containers Are Being Used Right Now Apr 18, 2017 • 7 min read By Adam Larson By now you’re probably familiar with Docker, and how its container technology aims to improve the way you do DevOps—and even how you architect your applications. By encapsulating your compute environments into scripted, lightweight black boxes rather than manually defined and cumbersome-to-maintain virtual machines, Docker has helped light up a whole host of new and faster workflows in Continuous Integration/Continuous Deployment (CI/CD) and microservice communication. Docker is a technology that New Relic has embraced for years and it now accounts for a majority of our internal production workloads—heck, our lead site reliability engineer even wrote a book on the topic! (See Docker: Up & Running: Shipping Reliable Containers in Production, by Sean Kane and Karl Matthias). Crunching the Docker numbers So as we approached the two-year anniversary of New Relic’s original release of support for Docker monitoring, we figured it was time to move beyond the anecdotal evidence to show Docker’s growth, impact, and usage by doing what we do best: crunching some numbers. The following data is based on the hundreds of millions of containers customers have sent through our system and speaks to trends in Docker usage across different industries, company sizes, and use cases. First, let’s do the fun glamor stats! In the last two years, New Relic has monitored more than 418 million containers (so many that we had to rewrite our analysis tools to accommodate the massive scale of data). In a typical day, we see more than 1.5 million containers, and an average customer has more than 800 containers running at any given moment. Our top ten customers by Docker container usage actually spin up more than 92,000 containers a day. Docker use cases, from VM replacements to ephemeral computicles So yeah, Docker seems to have officially transcended the realm of “fun new DevOps toy” to become a full-blown production workhorse. But 92,000 containers a day still sounds crazy, right? Well, as we’ve discussed in the past, some people use Docker as a replacement for their VM infrastructure, but others use it for lightweight, ephemeral compute tasks that spin up, do something, and then disappear (think AWS Lambda). To drive home how prevalent this use case is, we thought we’d share some interesting trends in the lifespan of these containers. Docker container lifespan by hours, under 24 hours: The chart above shows that if we analyze only the containers that run for less than 24 hours, the drop-off in usage is stark over time. Literally orders of magnitude more containers run for less than an hour than for several hours (so much so that you can’t even see the long tail on the graph). Docker container lifespan by minutes, under one hour: Going even further, the chart above shows just the containers that have run for less than one hour, ranked by number of minutes they ran. We can see that most of these containers last only a few minutes. I’m doubtful that’s a traditional CRM application running in those containers. Docker container lifespan by hour, from 2 hours to 24 hours: Above, looking at just the containers that live from 2-24 hours, we can see that things start to get a little more spread out, but the trend toward “shorter is better” remains consistent. Docker container lifespan by hour, shown on a Log10 scale: Finally, examining this data via a log scale (since you wouldn’t even be able to see most of the data using a non-log scale) gives a better sense of how container usage is so heavily stacked toward short run and ephemeral. Docker is changing how code gets written Whether it’s quick computicle executions like Lambda or the more constant CI/CD of traditional applications, it’s clear that Docker is impacting the way the industry is writing code—for better or for worse. What do you think these trends mean? Tweet at us @newrelic using hashtag #DockerTrends. Interested in why so many folks choose New Relic to monitor their Dockerized infrastructure? for more details on how we tie containers to what really matters—the applications they support—visit our Docker page or check out New Relic Infrastructure.   Related Topics Cloud By Adam Larson Adam Larson is a senior technical marketing engineer at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.13445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " you do DevOps—and even how you architect <em>your</em> applications. By encapsulating <em>your</em> compute environments into scripted, lightweight black boxes rather than manually defined and cumbersome-to-maintain virtual machines, Docker has helped light <em>up</em> a whole host of new and faster workflows in Continuous"
      },
      "id": "607635e064441f97ad9d8539"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/KeepCalmandCloudOn-min.jpg",
      "url": "https://newrelic.com/blog/best-practices/devops-serverless",
      "sections": [
        "What “serverless” really means",
        "A new role for ops in a serverless world",
        "Six priorities ops should focus on",
        "1. Automation",
        "2. Cost optimization",
        "3. Disaster recovery",
        "4. Monitoring",
        "5. Security",
        "6. Troubleshooting",
        "No rest for the weary ops team",
        "Your turn",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:33:44Z",
      "title": "6 Priorities for Ops in a ‘Serverless’ World",
      "updated_at": "2021-04-14T00:26:38Z",
      "type": "",
      "external_id": "c064ee3e1a66ca1844573730ca1030b89b3ab75d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit DevOps 6 Priorities for Ops in a ‘Serverless’ World Mar 6, 2018 • 9 min read By Kevin Downs The server as we know it is dying [mic drop]. To many, this may not come as a complete surprise. But if for some reason you haven’t been paying attention, the long, slow death of the server began in 2014, when Amazon Web Services (AWS) introduced AWS Lambda. For reference, here is a description of Lambda from AWS: “With Lambda, you can run code for virtually any type of application or backend service—all with zero administration. Just upload your code and Lambda takes care of everything required to run and scale your code with high availability. You can set up your code to automatically trigger from other AWS services or call it directly from any web or mobile app.” What “serverless” really means AWS Lambda is sometimes incorrectly referred to by the generic name “serverless.” However, serverless is a more general term that includes all cloud services that don’t require you, the administrator, to spin up a server to run it. Lambda is just one such cloud service. Another example of a serverless service is notification. AWS has a service called Amazon Simple Notification Service (SNS). You don’t spin up a server and install SNS on it—you consume SNS. There are many other examples of serverless services, so when I refer to serverless, I’m talking about any and all cloud services that don’t require (or allow) you to administer a server. Still, although various serverless services have been around for a while now, it was AWS Lambda that dealt the first real death blow for servers as we’ve known and used them. Since then, both Microsoft Azure and Google Cloud Platform have come out with their own answers to Lambda called Functions. I’ll use the generic term “functions” to refer to this type of serverless service. A new role for ops in a serverless world Lambda’s debut in 2014 prompted me to ponder where operations (the ops part of DevOps) should focus its priorities in a world where developers (the dev part of DevOps) have the ability to spin up, scale up, scale out, consume, repurpose, scale down, scale in, shut down, and retire infrastructure on their own. The fact that developers can now do all of this without looking over the wall for operations support represents a huge shift in workflow. I have total respect for developers, but after two decades on the technical support and monitoring side of the business, sometimes I feel like they’ve made off with the keys to the cloud candy store—and that’s a good thing! So where is all this brave new serverless stuff going to take operations? Should operations staff start polishing their resumes or think about switching careers? Basically, should operations be worried their role is in jeopardy? The answer is no, not by a long shot. Developers are not going to take over operations’ job responsibilities. Robots are not going to invade our domain and mock our pocket protectors. In other words ... Six priorities ops should focus on Of course, that doesn’t mean that nothing is going to change. The rise of serverless and functions and the empowerment of developers will indeed affect how ops teams work. Given that, I have six suggestions (in alphabetical order) for where ops folks should focus their priorities in a DevOps serverless world: 1. Automation As developers increasingly employ powerful scripted architecture services, operations will need to make sure they are one step (if not many steps) ahead. That means everything from checking to see if all the components are running correctly to making sure developers are cleaning up after themselves (“Are you done with that container?”). Operations folks must get good at automating their daily tasks, fast! Remember, developers are using that same automation to create infrastructure and functions as fast as they can, too. My recommendation: Study up on DevOps deployment orchestration tools such as AWS CloudFormation and similar services from other cloud vendors. 2. Cost optimization This issue has been ramping up for a while. Once upon a time, IT budgets were authorized, projects were approved, and infrastructure was purchased. Both developers and operations didn’t really care about costs because that was all handled at the project-approval level. After that, developers were the consumers of infrastructure and operations was there to support that infrastructure, keeping the lights on. Now, operations has a large role to play in understanding where and how to balance cloud-computing’s three-legged stool: availability, performance, and cost. Ops is uniquely positioned to answer such questions as, Are oversized instances being used? Is the autoscaler properly configured to scale down? Are storage and database resources properly being consumed? This becomes essential as developers gain a seemingly unfettered ability to create infrastructure and code functions. In this new environment, operations is the first line of defense against unexpected cloud bills. My recommendation: Become familiar with how cloud vendors charge for their services and shine a light into that dark, scary place (see “Monitoring” below). 3. Disaster recovery We all know things fail, even cloud services. Operations will always need to think about worst-case scenarios and make sure the environments being created are properly configured for failover. We have come a long way from offsite tape-backup repositories, but the same theories apply: what happens if this part of the architecture fails? Operations needs to make sure that as developers script infrastructure and code functions, failover strategies are in place. My recommendation: Break things on purpose (in development environments, of course) to learn how to create fault-tolerant, multi-region architectures ... then try to break those. 4. Monitoring This one can’t be overemphasized: monitor everything you can! If you don’t monitor it, you can’t know if it’s working (or was working) correctly or at all. In a cloud world, monitoring becomes more important as services that were running one minute can be decommissioned in the blink of an eye. Operations needs to monitor serverless services to make sure they are performing (or did perform) as expected. Monitoring cloud services gives operations essential information to improve future cloud service usage. My recommendation: Incorporate the cloud vendor’s built-in monitoring where appropriate. However, do you fully trust the fox to guard the hen house? Look to third-party monitoring solutions to gain an unbiased view. Critically, a third-party monitoring solution is essential to fully instrument and understand complex multi-cloud as well as hybrid (cloud and on-premise) architectures. Only then will you be able to understand the complete picture, an end-to-end monitoring view that shows your applications and their relationships to the cloud services they rely upon. 5. Security Cloud-based security can actually be more secure than the on-premise variety. Yet, “with great power comes great responsibility.” Operations still needs to manage, control, and maintain proper access rights to applications and systems to minimize vulnerability to breaches and avoid improperly exposing private data. With the rise of scripted infrastructure and functions, ops must offer the required cloud services to devs while making sure that those services are secured properly. My recommendation: Establish best-practice security processes as recommended by your cloud vendors and incorporate a cloud security expert into your cloud journey (either an internal stakeholder or an external resource). 6. Troubleshooting Always an essential skill for operations, troubleshooting is pretty much what ops does. That’s not likely to change—operations will always need to figure out what went wrong. With cloud services, though, troubleshooting can become even more complex as operations stretches to take into account things like decoupled applications, scripted infrastructure, and functions. Recommendation: Keep doing what you’re doing. You wouldn’t be in operations if you didn’t have an inner Sherlock Holmes lurking around in there somewhere. No rest for the weary ops team You may be thinking, “We just got here. We just moved to the cloud. We moved our physical servers to instances. We moved our databases as well. Even though we lost a little visibility into the underpinning infrastructure, we gained some cool new features and abilities (I’m looking at you AWS CloudFormation). Now, they go ahead and pull the rug out from under us with this whole functions serverless thing. Can’t we just pause for a little bit?” No, that’s not going to happen. The world is moving rapidly toward serverless as the default option. Of course, not everything currently lends itself well to serverless and/or functions, so it may take a few years for the avalanche to show itself, but, ready or not, it’s coming! Fortunately, operations teams are uniquely suited to support our organizations during this next phase of the cloud journey. We may need to learn a few new tools and tricks, but that’s always been part of the operations job description, right? Your turn You’ve read my thoughts. Where do you think operations should focus its priorities in a DevOps world where “serverless” is becoming the norm rather than the exception? Let us know on Twitter @NewRelic using hashtag #ServerlessOps.   Related Topics DevOps By Kevin Downs As Solutions Strategy Director at New Relic, Kevin has deep knowledge of IT Opps, the cloud industry, and works with customers and partners to assist in their cloud adoption journeys. He’s been in the enterprise software industry for over 20 years, and has spent 12 years as a customer facing solutions architect, selling enterprise software solutions to all verticals. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.09689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Your</em> turn",
        "body": " with zero administration. Just upload <em>your</em> code and Lambda takes care of everything required to run and scale <em>your</em> code with high availability. You can set <em>up</em> <em>your</em> code to automatically trigger from other AWS <em>services</em> or call it directly from any web or mobile app.” What “serverless” really means AWS Lambda"
      },
      "id": "607636be28ccbcda9651c137"
    }
  ],
  "/build-apps/ab-test/platform-state-context": [
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application and click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 657.8213,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from &#x27;react&#x27;; import { HeadingText, LineChart, NrqlQuery, <em>PlatformStateContext</em>, navigation, } from &#x27;nr1&#x27;; const ACCOUNT_ID = 1234567 &#x2F;&#x2F; &lt;<em>YOUR</em> NEW RELIC ACCOUNT ID&gt; export default class"
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/embed/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "58de68bd963cdd2062e88db55cb90ad124055eb6",
      "popularity": 1,
      "body": "In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform's URL state. This context contains an important value you'll use in your app, called timeRange. Notice that your NrqlQuery uses a SINCE clause that identifies the historical timeframe your query should fetch data from. Right now, that SINCE clause is set to 30 MINUTES AGO. With timeRange, you can use the platform's time picker to make this timeframe adjustable. Step 4 of 10 Utilize the platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-platform-state-context/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery now uses the platform state's timeRange, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your Nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 601.5189,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>PlatformStateContext</em> <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " at the start of each lesson, you leave <em>your</em> custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets&#x2F;ab-test-<em>nerdlet</em>&#x2F;newsletter-signups.js, <em>add</em> a <em>PlatformStateContext</em>.Consumer to <em>your</em> NewsletterSignups component&#x27;s render() method"
      },
      "id": "6073000164441f84ce9d853d"
    },
    {
      "image": "https://developer.newrelic.com/static/7f679da4c4ffce5fa547a04b27ac700d/0086b/add-timepicker.png",
      "url": "https://developer.newrelic.com/build-apps/add-time-picker-guide/embed/",
      "sections": [
        "Add a time picker",
        "Before you begin",
        "Important",
        "Prepare the time picker sample code",
        "Import the PlatformStateContext component",
        "Add the time to the queries",
        "Summary"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "852014728d86d0fcfc4345d6402f7533d9ca5e2e",
      "popularity": 1,
      "body": "This guide steps you through the process of adding access to our time picker in the sample transaction overview application. The sample application provides an overview of the telemetry data showing your account's transactions by application, average response time, HTTP response codes, and transaction errors. When you enable the time picker, users can specify the time range of data to view. We also have a 12 minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1–4 of the CLI quick start. In step 1, be sure to make a copy of the number preceding your account name. This is your accound ID, and you’ll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the time picker sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 7 If you haven't already done so, clone the example applications from our how-to GitHub repo. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 7 Change to the directory nr1-howto-add-time-picker-nerdlet: bash Copy $ cd nr1-how-to/add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet Step 3 of 7 In your preferred text editor, open index.js. Step 4 of 7 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 7 Change to the add-time-picker directory: bash Copy $ cd /nr1-how-to/add-time-picker Step 6 of 7 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 7 of 7 Once the sample application is successfully served, go to the local version of New Relic One (https://one.newrelic.com/?nerdpacks=local) click Apps, and click Add Time Picker. After launching the Add Time Picker application, you see a dashboard that gives an overview of the transactions in your New Relic account: By default, the application shows your data within the last 60 minutes. If you toggle the time picker, it doesn't update the charts because the transaction overview application isn't connected to the New Relic One platform. It has no access to the data from the time picker. In the following sections, you'll add the time picker to the example application and add the time to the queries. Import the PlatformStateContext component The first step in adding the time picker is to import the PlatformStateContext component. Important If you need more details about the PlatformStateContext example that follows, see the APIs and components page Here's what the PlatformStateContext component does: Wraps all of the code within the return statement of the render method Makes a function call passing in the New Relic platform state Returns all of the code within our current return statement Complete these steps: Step 1 of 5 In a text editor, open /add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet/index.js. Step 2 of 5 Add the PlatformStateContext component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, PlatformStateContext, } from 'nr1'; Copy Step 3 of 5 Just below the current return insert this code for the PlatformStateContext component: <PlatformStateContext.Consumer> {(platformState) => { return ( // ADD THE CURRENT RETURN CODE HERE ) }} </PlatformStateContext.Consumer> Copy Step 4 of 5 Move the current application code so it is under the return of the PlatformState function call. The return statement should now look like this: return ( <PlatformStateContext.Consumer> {(PlatformState) => { return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); Copy Step 5 of 5 Add a console.log statement to make sure you are seeing appropriate data. Insert the following code inside the PlatformState return statement just before the opening tag for the <Grid> component: /* Taking a peek at the PlatformState */ console.log(PlatformState); Copy After you complete these steps, your browser console displays something like this: Add the time to the queries In your console, you should see some data from the New Relic platform state. Now you're ready to add timeRange data to update the charts in the transaction overview application. This step requires you to import the timeRangeToNrql utility method from the New Relic One community library. Important You can get more details on the New Relic One community library from our GitHub repo. This helper method takes your PlatformState.timeRange duration data, formats it from milliseconds, and returns a formatted SINCE statement to add to your NRQL. Step 1 of 4 Import the timeRangeToNrql method by inserting this line of code below the other import sections: Important You don't need to include the AccountDropdown from the community import example. import { timeRangeToNrql } from '@newrelic/nr1-community'; Copy Step 2 of 4 Pass the PlatformState to the timeRangeToNrql helper, and save its output as a since statement for later use: const since = timeRangeToNrql(PlatformState); Copy Step 3 of 4 After creating the since variable, go through the code in the PlatformStateContext return statement and concatenate the since variable in each of the existing chart component queries. Here's a TableChart example: <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} />; Copy Step 4 of 4 After you update all of the chart components, confirm that the final index.js file looks similar to this: Important This completed sample code is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, } from 'nr1'; import { timeRangeToNrql } from '@newrelic/nr1-community'; export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props) { super(props); this.accountId = 1; } render() { const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <PlatformStateContext.Consumer> {(PlatformState) => { /* Taking a peek at the PlatformState */ console.log(PlatformState); const since = timeRangeToNrql(PlatformState); console.log(since); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount + since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); } } Copy Summary When you completed all the steps in this example, you successfully implemented the time picker in your application by importing the PlatformStateContext component and accessing its timePicker data object.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 408.79382,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> the time <em>to</em> the queries",
        "body": " these steps: Step 1 of 5 In a text editor, open &#x2F;<em>add</em>-time-picker&#x2F;nerdlets&#x2F;nr1-howto-<em>add</em>-time-picker-<em>nerdlet</em>&#x2F;index.js. Step 2 of 5 <em>Add</em> the <em>PlatformStateContext</em> component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart"
      },
      "id": "6063d5f464441fcf580c8bbd"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-16T02:10:56Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 344.1761,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Platform</em> APIs",
        "body": ": <em>PlatformStateContext</em>: provides read access to the <em>platform</em> URL <em>state</em> variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new <em>Nerdlet</em>. <em>NerdletStateContext</em>: provides read access to the <em>Nerdlet</em> URL <em>state</em> variables. Example: an entityGuid in the entity explorer. <em>nerdlet</em>: an object that provides write access to the <em>Nerdlet</em> URL <em>state</em>."
      },
      "id": "60652884196a67886047e800"
    },
    {
      "image": "https://developer.newrelic.com/static/a2b20353935db8fba0dbfd0cdc71d8e6/b01d9/use-nerdgraph-launcher.png",
      "url": "https://developer.newrelic.com/build-apps/add-nerdgraphquery-guide/embed/",
      "sections": [
        "Add the NerdGraphQuery component to an application",
        "Important",
        "Before you begin",
        "Prepare the sample code",
        "Add the NerdGraphQuery component",
        "How to use NerdGraphQuery.query",
        "Review the results of the NerdGraph query",
        "Summary"
      ],
      "published_at": "2021-04-16T02:07:54Z",
      "title": "",
      "updated_at": "2021-03-31T01:52:51Z",
      "type": "",
      "external_id": "b3165fe5bf522e8281dca658bf3ac296c0997ae9",
      "popularity": 1,
      "body": "This guide steps you through the process of adding the `NerdGraphQuery` component to a sample transaction overview application. This allows you to query data from your New Relic account and add it to a dropdown menu. NerdGraph is our GraphQL implementation. GraphQL has some key differences when compared to REST: The client, not the server, determines what data is returned. You can easily collect data from multiple sources. For example, in a single query, you can get account information, infrastructure data, and issue a NRQL request. Important Before completing this exercise, you can experiment with GraphQL queries in our NerdGraph API explorer. We also have a 14-minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1–4 of our CLI quick start, and be sure to make a copy of your account ID from step 1 because you’ll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 8 If you haven't already done so, clone the example applications from our how-to GitHub repo. Here's an example using HTTPS: bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 8 Change to the directory use-nerdgraph-nerdlet: bash Copy $ cd nr1-how-to/use-nerdgraph/nerdlets/use-nerdgraph-nerdlet Step 3 of 8 In your preferred text editor, open index.js. Step 4 of 8 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 8 Change to the /nr1-howto/use-nerdgraph directory: bash Copy $ cd ../.. Step 6 of 8 If this is your first time executing this code run the below command to install all the required modules: bash Copy $ npm install Step 7 of 8 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 8 of 8 Once the sample application is successfully served, go to the local New Relic One homepage (https://one.newrelic.com/?nerdpacks=local), click Apps, and then click Use NerdGraph. After launching the Use NerdGraph application, you see a dashboard that gives an overview of the transactions in your account: Add the NerdGraphQuery component Now you can create a dropdown menu for changing the account the application is viewing. The first step is to import the NerdGraphQuery component into the application's index.js file. Important If you need more details about our example below, see the APIs and components page on https://developer.newrelic.com Step 1 of 3 Add the NerdGraphQuery component into the first StackItem inside of the return in the index.js file: <NerdGraphQuery query={query} variables={variables}> {({ loading, error, data }) => { console.log({ loading, error, data }); if (loading) { return <Spinner />; } if (error) { return 'Error!'; } return null; }} </NerdGraphQuery>; Copy Step 2 of 3 The NerdGraphQuery component takes a query object that states the source you want to access and the data you want returned. Add the following code to your index.js file in the render method: Important In the browser console, you can see the data from your query returned in an object that follows the same structure of the object in the initial query. const query = ` query($id: Int!) { actor { account(id: $id) { name } } } `; Copy Step 3 of 3 To take the data returned by the NerdGraph query and display it in the application, replace the return null in the current NerdGraphQuery component with this return statement: return <HeadingText>{data.actor.account.name} Apps:</HeadingText>; Copy When you go back to the browser and view your application, you see a new headline showing the name of your account returned from NerdGraph: How to use NerdGraphQuery.query At this point, you have implemented the NerdGraphQuery component with the application's render method and displayed the return data within the transaction overview application. Here's what you need to do next: Query NerdGraph inside of the componentDidMount lifecycle method. Save the returned data for later use in the application. Step 1 of 2 This code takes the response from NerdGraph and makes sure the results are processed, stored into the application state, and logged to the browser console for viewing. Add this code into the index.js file just under the constructor: componentDidMount() { const accountId = this.state; const gql = `{ actor { accounts { id name } } }`; const accounts = NerdGraphQuery.query({query: gql}) //The NerdGraphQuery.query method called with the query object to get your account data is stored in the accounts variable. accounts.then(results => { console.log('Nerdgraph Response:', results); const accounts = results.data.actor.accounts.map(account => { return account; }); const account = accounts.length > 0 && accounts[0]; this.setState({ selectedAccount: account, accounts }); }).catch((error) => { console.log('Nerdgraph Error:', error); }) } Copy Step 2 of 2 After the data is stored into state, display a selection so users can change accounts and update the application. To do this, add this code to index.js for the second StackItem in the return statement: { accounts && ( <StackItem> <Select value={selectedAccount} onChange={(evt, value) => this.selectAccount(value)} > {accounts.map((a) => { return ( <SelectItem key={a.id} value={a}> {a.name} </SelectItem> ); })} </Select> </StackItem> ); } Copy Review the results of the NerdGraph query After you complete these steps, look at the application in your browser, and note the following: The dropdown menu now displays the data returned from the NerdGraphQuery.query and allows you to select an account. After you select a new account, the application shows data from the new selection. The final index.js file should have code similar to the code below. This completed sample is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, NerdGraphQuery, Spinner, HeadingText, Grid, GridItem, Stack, StackItem, Select, SelectItem, AreaChart, TableChart, PieChart } from 'nr1' import { timeRangeToNrql } from '@newrelic/nr1-community'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class UseNerdgraphNerdletNerdlet extends React.Component { constructor(props){ super(props) this.state = { accountId: <YOUR ACCOUNT ID>, accounts: null, selectedAccount: null, } } componentDidMount() { const accountId = this.state; const gql = `{ actor { accounts { id name } } }`; const accounts = NerdGraphQuery.query({ query: gql }) accounts.then(results => { console.log('Nerdgraph Response:', results); const accounts = results.data.actor.accounts.map(account => { return account; }); const account = accounts.length > 0 && accounts[0]; this.setState({ selectedAccount: account, accounts }); }).catch((error) => { console.log('Nerdgraph Error:', error); }) } selectAccount(option) { this.setState({ accountId: option.id, selectedAccount: option }); } render() { const { accountId, accounts, selectedAccount } = this.state; console.log({ accountId, accounts, selectedAccount }); const query = ` query($id: Int!) { actor { account(id: $id) { name } } } `; const variables = { id: accountId, }; const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <Stack fullWidth horizontalType={Stack.HORIZONTAL_TYPE.FILL} gapType={Stack.GAP_TYPE.EXTRA_LOOSE} spacingType={[Stack.SPACING_TYPE.MEDIUM]} directionType={Stack.DIRECTION_TYPE.VERTICAL}> <StackItem> <NerdGraphQuery query={query} variables={variables}> {({loading, error, data}) => { if (loading) { return <Spinner />; } if (error) { return 'Error!'; } return <HeadingText>{data.actor.account.name} Apps:</HeadingText>; }} </NerdGraphQuery> </StackItem> {accounts && <StackItem> <Select value={selectedAccount} onChange={(evt, value) => this.selectAccount(value)}> {accounts.map(a => { return ( <SelectItem key={a.id} value={a}> {a.name} </SelectItem> ) })} </Select> </StackItem> } <StackItem> <hr /> <PlatformStateContext.Consumer> {(PlatformState) => { /* Taking a peek at the PlatformState */ const since = timeRangeToNrql(PlatformState); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Transaction Overview </HeadingText> <TableChart fullWidth accountId={accountId} query={trxOverview+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Average Response Time </HeadingText> <AreaChart fullWidth accountId={accountId} query={avgResTime+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Response Code </HeadingText> <PieChart fullWidth accountId={accountId} query={responseCodes+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Transaction Errors </HeadingText> <PieChart fullWidth accountId={accountId} query={errCount+since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> </StackItem> </Stack> ) } } Copy Summary Now that you've completed all the steps in this example, you've successfully queried data from your account using the NerdGraphQuery component in two methods: Using the NerdGraphQuery component inside the application's render method and then passing the returned data into the children's components. Using the NerdGraphQuery.query method to query data before the application renders.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 251.92589,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> the NerdGraphQuery component <em>to</em> an application",
        "body": " file should have code similar to the code below. This completed sample is in <em>your</em> <em>nerdlet</em> final.js. import React from &#x27;react&#x27;; import { <em>PlatformStateContext</em>, NerdGraphQuery, Spinner, HeadingText, Grid, GridItem, Stack, StackItem, Select, SelectItem, AreaChart, TableChart, PieChart } from &#x27;nr1"
      },
      "id": "6063d5f328ccbc4e6d43fa95"
    }
  ],
  "/build-apps/ab-test/grid": [
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/embed/",
      "sections": [
        "Add a grid",
        "Technical detail"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:42:16Z",
      "type": "",
      "external_id": "bfd5e04da0f000d6970b16677cd5faf8c3b2f461",
      "popularity": 1,
      "body": "In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid/ab-test Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your Nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1392.8411,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> <em>grid</em>",
        "body": " going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the <em>add</em>-a-<em>grid</em>&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-a-<em>grid</em>&#x2F;ab-test Step 2 of 6 In your Nerdlet&#x27;s index.js file, import <em>Grid</em> and <em>Grid</em>"
      },
      "id": "6072565d28ccbc6baf51c18b"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:39Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings/ab-test Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 693.34357,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> chart headings",
        "body": " to modify your Nerdlet&#x27;s render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course&#x2F;<em>add</em>-a-<em>grid</em>&#x2F;ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned"
      },
      "id": "6072ff1928ccbc140b51c16e"
    },
    {
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/embed/",
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-02T01:49:33Z",
      "type": "",
      "external_id": "67c529a70a60d530860fbe80be795d214798dfd9",
      "popularity": 1,
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 364.8573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, query, <em>and</em> mutate data using NerdStorage",
        "body": " <em>Grid</em>Item to the application immediately before the closing <em>Grid</em> tag. In the new <em>Grid</em>Item <em>add</em> the following code to display your new button: &lt;Button onClick={() =&gt; this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType"
      },
      "id": "6066782e64441f577f617a9d"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:21Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.82532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> version descriptions",
        "body": "Item with a columnSpan of 12, to stretch the rule the full width of the <em>grid</em>. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course&#x2F;<em>add</em>-version-descriptions&#x2F;ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned"
      },
      "id": "6072569228ccbc932d51c172"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/embed/",
      "sections": [
        "Add a section to end your test"
      ],
      "published_at": "2021-04-16T02:05:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:49Z",
      "type": "",
      "external_id": "6c1d9d3997eff7f27d00dbf9c8f451f5bec750d9",
      "popularity": 1,
      "body": "In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.96565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> section to end your test",
        "body": " of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet&#x27;s index.js file, <em>add</em> EndTestSection to your Nerdlet: import React from &#x27;react&#x27;; import { ChartGroup, <em>Grid</em>, <em>Grid</em>Item } from &#x27;nr1&#x27;; import EndTestSection from &#x27;.&#x2F;end"
      },
      "id": "6072569228ccbc8f6151c174"
    }
  ],
  "/build-apps/ab-test/nrql-customizations": [
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/embed/",
      "sections": [
        "Customize NRQL data",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "f51f9d86d3b873b24e967c687d5408eb9918a33f",
      "popularity": 1,
      "body": "In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Tip If something doesn't work, use these debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your Nerdpack served locally, view your application to see your charts serving real data: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 892.6474,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Customize</em> <em>NRQL</em> <em>data</em>",
        "body": " <em>Nrql</em>Query results to merge <em>data</em> from multiple sources. Merge <em>NRQL</em> from multiple sources Step 1 of 9 Change to the <em>customize</em>-<em>nrql</em>-<em>data</em>&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>customize</em>-<em>nrql</em>-<em>data</em>&#x2F;ab-test This directory contains the code that we expect"
      },
      "id": "6073014b28ccbc70b651c134"
    },
    {
      "sections": [
        "NRQL syntax, clauses, and functions",
        "Syntax",
        "Query components",
        "Required clauses",
        "Required: SELECT statement",
        "Avg response time since last week",
        "Required: FROM clause",
        "Query one data type",
        "Query multiple data types",
        "Optional clauses",
        "AS clause",
        "Query using math function and AS",
        "Query using funnel and AS",
        "COMPARE WITH clause",
        "EXTRAPOLATE clause",
        "Important",
        "Example of extrapolating throughput",
        "Example of extrapolating throughput as a time series",
        "FACET clause",
        "Faceted query using count()",
        "Faceted query using uniqueCount()",
        "Grouping results across time",
        "FACET ... AS clause",
        "FACET CASES clause",
        "Basic usage with WHERE",
        "Group based on multiple attributes",
        "Label groups with AS",
        "FACET ... ORDER BY clause",
        "Tip",
        "LIMIT clause",
        "Query using LIMIT",
        "OFFSET clause",
        "ORDER BY clause",
        "SHOW EVENT TYPES clause",
        "Data types in the last day",
        "SINCE clause",
        "SLIDE BY clause",
        "Use SLIDE BY with MAX or AUTO interval",
        "TIMESERIES clause",
        "Use a set interval",
        "Use an automatically set interval",
        "Use MAX interval",
        "UNTIL clause",
        "WHERE clause",
        "Example query with three conditions",
        "WITH METRIC_FORMAT clause",
        "WITH TIMEZONE clause",
        "Query metric data",
        "Aggregator functions",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "Get Apdex for specific customers",
        "Get Apdex for specific transaction",
        "Get overall Apdex for your app",
        "average(attribute)",
        "buckets(attribute, ceiling [,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(*)",
        "derivative(attribute [,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "earliest(attribute)",
        "Get earliest country per user agent from PageView",
        "eventType()",
        "Use eventType() in filter() function",
        "Use eventType() with FACET",
        "filter(function(attribute), WHERE condition)",
        "Analyze purchases that used offer codes",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling [,number of buckets])",
        "Histogram of response times from PageView events",
        "Prometheus histogram buckets",
        "New Relic distribution metric",
        "Histogram with a FACET clause",
        "keyset()",
        "See all attributes for a data type",
        "latest(attribute)",
        "Get most recent country per user agent from PageView",
        "latestrate(attribute, time interval)",
        "Get the most recent rate of change of PageView Duration",
        "max(attribute)",
        "median(attribute)",
        "Median query",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "mod() within a WHERE clause condition",
        "mod() within a FACET clause",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute [, percentile [, ...]])",
        "Basic percentile query",
        "predictLinear(attribute, [,time interval])",
        "rate(function(attribute) [,time interval])",
        "Basic rate query",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute [,limit])",
        "Using tuple",
        "Type conversion"
      ],
      "title": "NRQL syntax, clauses, and functions",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "97c38ce7950d354d9f1d9efa5f432326f9bb4b00",
      "image": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/images/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-04-12T09:29:33Z",
      "updated_at": "2021-04-12T09:29:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQL is a query language you can use to query the New Relic database. This document explains NRQL syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a NRQL query. Other resources for understanding NRQL: Intro to NRQL: explains what NRQL is used for, what data you can query with it, and basic NRQL syntax Examine NRQL queries used to build New Relic charts Learn how to query the Metric data type Simulate SQL JOIN functions Use funnels to evaluate a series of related data Format NRQL for querying with the Event API Query components Every NRQL query will begin with a SELECT statement or a FROM clause. All other clauses are optional. The clause definitions below also contain example NRQL queries. Required clauses Required: SELECT statement SELECT attribute ... Copy SELECT function(attribute) ... Copy The SELECT specifies what portion of a data type you want to query by specifying an attribute or a function. It's followed by one or more arguments separated by commas. In each argument you can: Get the values of all available attributes by using * as a wildcard. For example: SELECT * from Transaction. Get values associated with a specified attribute or multiple attributes specified in a comma separated list. Get aggregated values from specified attributes by selecting an aggregator function. Label the results returned in each argument with the AS clause. You can also use SELECT with basic math functions. Avg response time since last week This query returns the average response time since last week. SELECT average(duration) FROM PageView SINCE 1 week ago Copy Required: FROM clause SELECT ... FROM data type ... Copy Use the FROM clause to specify the data type you wish to query. You can start your query with FROM or with SELECT. You can merge values for the same attributes across multiple data types in a comma separated list. Query one data type This query returns the count of all APM transactions over the last three days: SELECT count(*) FROM Transaction SINCE 3 days ago Copy Query multiple data types This query returns the count of all APM transactions and Browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Optional clauses AS clause SELECT ... AS 'label' ... Copy Use the AS clause to label an attribute, aggregator, step in a funnel, or the result of a math function with a string delimited by single quotes. The label is used in the resulting chart. Query using math function and AS This query returns the number of page views per session: SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView Copy Query using funnel and AS This query returns a count of people who have visited both the main page and the careers page of a site over the past week: SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago Copy COMPARE WITH clause SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... Copy Use the COMPARE WITH clause to compare the values for two different time ranges. COMPARE WITH requires a SINCE or UNTIL statement. The time specified by COMPARE WITH is relative to the time specified by SINCE or UNTIL. For example, SINCE 1 day ago COMPARE WITH 1 day ago compares yesterday with the day before. The time range for theCOMPARE WITH value is always the same as that specified by SINCE or UNTIL. For example, SINCE 2 hours ago COMPARE WITH 4 hours ago might compare 3:00pm through 5:00pm against 11:00am through 1:00pm. COMPARE WITH can be formatted as either a line chart or a billboard: With TIMESERIES, COMPARE WITH creates a line chart with the comparison mapped over time. Without TIMESERIES, COMPARE WITH generates a billboard with the current value and the percent change from the COMPARE WITH value. Example: This query returns data as a line chart showing the 95th percentile for the past hour compared to the same range one week ago. First as a single value, then as a line chart. SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO Copy EXTRAPOLATE clause You can use this clause with these data types: Transaction TransactionError Custom events reported via APM agent APIs The purpose of EXTRAPOLATE is to mathematically compensate for the effects of APM agent sampling of event data so that query results more closely represent the total activity in your system. This clause will be useful when a New Relic APM agent reports so many events that it often passes its harvest cycle reporting limits. When that occurs, the agent begins to sample events. When EXTRAPOLATE is used in a NRQL query that supports its use, the ratio between the reported events and the total events is used to extrapolate a close approximation of the total unsampled data. When it is used in a NRQL query that doesn’t support its use or that hasn’t used sampled data, it has no effect. Important Note that EXTRAPOLATE is most useful for homogenous data (like throughput or error rate). It's not effective when attempting to extrapolate a count of distinct things (like uniqueCount() or uniques()). This clause works only with NRQL queries that use one of the following aggregator functions: apdex average count histogram sum percentage (if function it takes as an argument supports EXTRAPOLATE) rate (if function it takes as an argument supports EXTRAPOLATE) stddev Example of extrapolating throughput A query that will show the extrapolated throughput of a service named interestingApplication. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE Copy Example of extrapolating throughput as a time series A query that will show the extrapolated throughput of a service named interestingApplication by transaction name, displayed as a time series. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE Copy FACET clause SELECT ... FACET attribute ... Copy Use FACET to separate and group your results by attribute values. For example, you could FACET your PageView data by deviceType to figure out what percentage of your traffic comes from mobile, tablet, and desktop devices. Use the LIMIT clause to specify how many facets appear (default is 10). For more complex grouping, use FACET CASES. FACET clauses support up to five attributes, separated by commas. The facets are sorted in descending order by the first field you provide in the SELECT clause. If you are faceting on attributes with more than 2,000 unique values, a subset of facet values is selected and sorted according to the query type. When selecting min(), max(), or count(), FACET uses those functions to determine how facets are picked and sorted. When selecting any other function, FACET uses the frequency of the attribute you are faceting on to determine how facets are picked and sorted. For more on faceting on multiple attributes, with some real-world examples, see this New Relic blog post. Faceted query using count() This query shows cities with the highest pageview counts. This query uses the total number of pageviews per city to determine how facets are picked and ordered. SELECT count(*) FROM PageView FACET city Copy Faceted query using uniqueCount() This query shows the cities that access the highest number of unique URLs. This query uses the total number of times a particular city appears in the results to determine how facets are picked and ordered. SELECT uniqueCount(pageUrl) FROM PageView FACET city Copy Grouping results across time Advanced segmentation and cohort analysis allow you to facet on bucket functions to more effectively break out your data. Cohort analysis is a way to group results together based on timestamps. You can separate them into buckets that cover a specified range of dates and times. FACET ... AS clause Use FACET ... AS to name facets using the AS keyword in queries. This clause is helpful for adding clearer or simplified names for facets in your results. It can also be used to rename facets in nested aggregation queries. FACET ... AS queries will change the facet names in results (when they appear as headers in tables, for example), but not the actual facet names themselves. FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' Copy FACET CASES clause SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... Copy Use FACET CASES to break out your data by more complex conditions than possible with FACET. Separate multiple conditions with a comma ,. For example, you could query your PageView data and FACET CASES into categories like less than 1 second, from 1 to 10 seconds, and greater than 10 seconds. You can combine multiple attributes within your cases, and label the cases with the AS selector. Data points will be added to at most one facet case, the first facet case that they match. You may also use a time function with your attribute. Basic usage with WHERE SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) Copy Group based on multiple attributes This example groups results into one bucket where the transaction name contains login, and another where the URL contains login and a custom attribute indicates that the user was a paid user: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') Copy Label groups with AS This example uses the AS selector to give your results a human-readable name: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') Copy FACET ... ORDER BY clause In NRQL, the default is for the first aggregation in the SELECT clause to guide the selection of facets in a query. FACET ... ORDER BY allows you to override this default behavior by adding an aggregate function with the ORDER BY modifier to specify how facets are selected. Specifically, the clause will override the priority by which facets are chosen to be in the final result before being limited by the LIMIT clause. This clause can be used in querying but not for alerts or streaming. This example shows how to use FACET ... ORDER BY to find the average durations of app transactions, showing the top 10 (default limit) highest durations by apps which have the highest response size. In this case, if FACET ... ORDER BY is not used, the query results will instead show the top 10 by highest durations, with response size being irrelevant to the app selection. FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) Copy Tip Because the operations are performed before the LIMIT clause is applied, FACET ... ORDER BY does not impact the sort of the final query results, which will be particularly noticeable in the results for non-timeseries queries. Important The ORDER BY modifier in this case works differently than the ORDER BY clause. When parsing queries that follow the format FACET attribute1 ORDER BY attribute2, New Relic will read these as FACET ... ORDER BY queries, but only if ORDER BY appears immediately after FACET. Otherwise ORDER BY will be interpreted by New Relic as a clause. LIMIT clause SELECT ... LIMIT count ... Copy Use the LIMIT clause to control the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. This clause takes a single integer value as an argument. If the LIMIT clause is not specified, or no value is provided, the limit defaults to 10 for FACET queries and 100 in the case of SELECT * queries. The maximum allowed value for the LIMIT clause is 2,000. Query using LIMIT This query shows the top 20 countries by session count and provides 95th percentile of response time for each country for Windows users only. SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY Copy OFFSET clause SELECT ... LIMIT count OFFSET count ... Copy Use the OFFSET clause with LIMIT to control the portion of rows returned by SELECT * or SELECT column queries. Like the LIMIT clause, OFFSET takes a single integer value as an argument. OFFSET sets the number of rows to be skipped before the selected rows of your query are returned. This is constrained by LIMIT. OFFSET rows are skipped starting from the most recent record. For example, the query SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1 returns the last 5 values from Minute_Report except for the most recent one. ORDER BY clause The ORDER BY clause allows you to specify how you want to sort your query results in queries that select event attributes by row. This query orders transactions by duration. FROM Transaction SELECT appName, duration ORDER BY duration Copy The default sort order is ascending, but this can be changed by adding the ASC or DESC modifiers. SHOW EVENT TYPES clause SHOW EVENT TYPES... Copy SHOW EVENT TYPES will return a list of all the data types present in your account for a specific time range. It is used as the first clause in a query instead of SELECT. Important In this context, \"event types\" refers to the data types you can access with a NRQL query. Data types in the last day This query will return all the data types present over the past day: SHOW EVENT TYPES SINCE 1 day ago Copy SINCE clause SELECT ... SINCE [numerical units AGO | phrase] ... Copy The default value is 1 hour ago. Use the SINCE clause to define the beginning of a time range for the returned data. When using NRQL, you can set a UTC timestamp or relative time range. You can specify a timezone for the query but not for the results. NRQL results are based on your system time. See Set time range on dashboards and charts for detailed information and examples. SLIDE BY clause The SLIDE BY clause supports a feature known as sliding windows. With sliding windows,SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. To use SLIDE BY, place it in a query after the TIMESERIES clause. For example, this query pulls data in 5-minute windows with a 1-minute SLIDE BY interval, meaning that each window lasts 5 minutes, but window 1 starts at 0 minutes, window 2 starts at 1 minute, window 3 starts at 2 minutes, and so on. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy To learn more about how and when you can use SLIDE BY, see Create smoother charts with sliding windows. Use SLIDE BY with MAX or AUTO interval You can use sliding windows in combination with MAX or AUTO. However, MAX or AUTO may not be placed between TIMESERIES and SLIDE BY. This query will automatically decide a SLIDE BY window interval. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy This query will set the SLIDE BY window to the maximum interval granularity. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy Important The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which can cause gaps and unexpected results. TIMESERIES clause SELECT ... TIMESERIES integer units ... Copy Use the TIMESERIES clause to return data as a time series broken out by a specified period of time. Since TIMESERIES is used to trigger certain charts, there is no default value. To indicate the time range, use integer units. For example: TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds TIMESERIES can be combined with arguments such as MAX, AUTO, and SLIDE BY to further tailor query results, as shown in the examples below. Important For functions such as average( ) or percentile( ), a large aggregation window can have a significant smoothing effect on outliers. This is true whether or not the query makes use of sliding windows. Use a set interval The value provided indicates the units used to break out the graph. For example, to present a one-day graph showing 30 minute increments: SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes Copy Use an automatically set interval TIMESERIES can also be set to AUTO, which will divide your graph into a reasonable number of divisions. For example, a daily chart will be divided into 30 minute intervals and a weekly chart will be divided into 6 hour intervals. This query returns data as a line chart showing the 50th and 90th percentile of client-side transaction time for one week with a data point every 6 hours. SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO Copy Use MAX interval You can set TIMESERIES to MAX, which will automatically adjust your time window to the maximum number of intervals allowed for a given time period. This allows you to update your time windows without having to manually update your TIMESERIES buckets and ensures your time window is being split into the peak number of intervals allowed. The maximum number of TIMESERIES buckets that will be returned is 366. For example, the following query creates 4-minute intervals, which is the ceiling for a daily chart. SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX Copy UNTIL clause SELECT ... UNTIL integer units AGO ... Copy The default value is NOW. Only use UNTIL to specify an end point other than the default. Use the UNTIL clause to define the end of a time range across which to return data. Once a time range has been specified, the data will be preserved and can be reviewed after the time range has ended. You can specify a UTC timestamp or relative time range. You can specify a time zone for the query but not for the results. The returned results are based on your system time. See Set time range on dashboards and charts for detailed information and examples. WHERE clause Use the WHERE clause to filter results. NRQL returns the results that fulfill the condition(s) you specify in the clause. SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... Copy If you specify more than one condition, separate the conditions by the operators AND or OR. If you want to simulate a SQL join, use custom attributes in a WHERE or FACET clause. Operators that the WHERE clause accepts Description =, !=, <, <=, >, >= NRQL accepts standard comparison operators. Example: state = 'WA' AND Used to define an intersection of two conditions. OR Used to define a union of two conditions. IS NULL Determines if an attribute has a null value. IS NOT NULL Determines if an attribute does not have a null value. IN Determines if the string value of an attribute is in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Example: animalType IN ('cat', 'dog', 'fish') NOT IN Determines if the string value of an attribute is not in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Values must be in parentheses, separated by commas. For example: SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') Copy LIKE Determines if an attribute contains a specified sub-string. The string argument for the LIKE operator accepts the percent sign (%) as a wildcard anywhere in the string. If the substring does not begin or end the string you are matching against, the wildcard must begin or end the string. Examples: userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE Determines if an attribute does not contain a specified sub-string. RLIKE Determines if an attribute contains a specified Regex sub-string. Uses RE2 syntax. Examples: appName RLIKE 'z.*|q.*'' z-app q-app hostname RLIKE 'ip-10-351-[0-2]?[0-9]-.*' ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 Important Note: Slashes must be escaped in the Regex pattern. For example, \\d must be \\\\d. Regex defaults to full-string matching, therefore ^ and $ are implicit and you do not need to add them. If the Regex pattern contains a capture group, the group will be ignored. That is, the group will not be captured for use later in the query. NOT RLIKE Determines if an attribute does not contain a specified Regex sub-string. Uses RE2 syntax. Example query with three conditions This query returns the browser response time for pages with checkout in the URL for Safari users in the United States and Canada over the past 24 hours. SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago Copy WITH METRIC_FORMAT clause For information on querying metric data, see Query metrics. WITH TIMEZONE clause SELECT ... WITH TIMEZONE (selected zone) ... Copy By default, query results are displayed in the timezone of the browser you're using. Use the WITH TIMEZONE clause to select a time zone for a date or time in the query that hasn't already had a time zone specified for it. For example, the query clause SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York' will return data recorded from Monday at midnight, Eastern Standard Time, until midnight Tuesday, Eastern Standard Time. Available Time Zone Selections Africa/Abidjan Africa/Addis_Ababa Africa/Algiers Africa/Blantyre Africa/Cairo Africa/Windhoek America/Adak America/Anchorage America/Araguaina America/Argentina/Buenos_Aires America/Belize America/Bogota America/Campo_Grande America/Cancun America/Caracas America/Chicago America/Chihuahua America/Dawson_Creek America/Denver America/Ensenada America/Glace_Bay America/Godthab America/Goose_Bay America/Havana America/La_Paz America/Los_Angeles America/Miquelon America/Montevideo America/New_York America/Noronha America/Santiago America/Sao_Paulo America/St_Johns Asia/Anadyr Asia/Bangkok Asia/Beirut Asia/Damascus Asia/Dhaka Asia/Dubai Asia/Gaza Asia/Hong_Kong Asia/Irkutsk Asia/Jerusalem Asia/Kabul Asia/Katmandu Asia/Kolkata Asia/Krasnoyarsk Asia/Magadan Asia/Novosibirsk Asia/Rangoon Asia/Seoul Asia/Tashkent Asia/Tehran Asia/Tokyo Asia/Vladivostok Asia/Yakutsk Asia/Yekaterinburg Asia/Yerevan Atlantic/Azores Atlantic/Cape_Verde Atlantic/Stanley Australia/Adelaide Australia/Brisbane Australia/Darwin Australia/Eucla Australia/Hobart Australia/Lord_Howe Australia/Perth Chile/EasterIsland Etc/GMT+10 Etc/GMT+8 Etc/GMT-11 Etc/GMT-12 Europe/Amsterdam Europe/Belfast Europe/Belgrade Europe/Brussels Europe/Dublin Europe/Lisbon Europe/London Europe/Minsk Europe/Moscow Pacific/Auckland Pacific/Chatham Pacific/Gambier Pacific/Kiritimati Pacific/Marquesas Pacific/Midway Pacific/Norfolk Pacific/Tongatapu UTC See Set time range on dashboards and charts for detailed information and examples. Query metric data Metric data is more complex than other types of data. There are specific tips for querying it well. We have two types of metric data, each with their own query guidelines: Query dimensional metrics, which are reported by our Metric API and by some of our tools that use that API, like our Telemetry SDKs and our open-source telemetry integrations (OpenTelemetry, Kamon, Micrometer, more). Query metric timeslice data, which is our original metric data type reported by our APM, mobile monitoring, and browser monitoring. For more on understanding these data types, see Metric data types. Aggregator functions Use aggregator functions to filter and aggregate data in a NRQL query. Some helpful information about using aggregator functions: See the New Relic University tutorials for Filter queries, Apdex queries, and Percentile queries. Or, go to the full online course Writing NRQL queries. Data type \"coercion\" is not supported. Read about available type conversion functions. Cohort analysis functions appear on the New Relic Insights Cohort analysis page. The cohort functions aggregate transactions into time segments. Here are the available aggregator functions. The definitions below contain example NRQL queries. Examples: SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy aggregationendtime() Use the aggregationendtime() function to return the time of the relevant aggregation. More specifically, for a given aggregate, the aggregationendtime() function provides the timestamp of the end of the time period of that aggregation. For example, in a timeseries query, for a data point that encompasses an hour’s worth of data, the function would return the timestamp of the end of that hour period. apdex(attribute, t: ) Use the apdex function to return an Apdex score for a single transaction or for all your transactions. The attribute can be any attribute based on response time, such as duration or backendDuration. The t: argument defines an Apdex T threshold in seconds. The Apdex score returned by the apdex( ) function is based only on execution time. It does not account for APM errors. If a transaction includes an error but completes in Apdex T or less, that transaction will be rated satisfying by the apdex ( ) function. Get Apdex for specific customers If you have defined custom attributes, you can filter based on those attributes. For example, you could monitor the Apdex for a particularly important customer: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy Get Apdex for specific transaction Use the name attribute to return a score for a specific transaction, or return an overall Apdex by omitting name. This query returns an Apdex score for the Controller/notes/index transaction over the last hour: SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago Copy The apdex function returns an Apdex score that measures user satisfaction with your site. Arguments are a response time attribute and an Apdex T threshold in seconds. Get overall Apdex for your app This example query returns an overall Apdex for the application over the last three weeks: SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago Copy average(attribute) Use the average( ) function to return the average value for an attribute. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. buckets(attribute, ceiling [,number of buckets]) Use the buckets() function to aggregate data split up by a FACET clause into buckets based on ranges. You can bucket by any attribute that is stored as a numerical value in the New Relic database. It takes three arguments: Attribute name Maximum value of the sample range. Any outliers will appear in the final bucket. Total number of buckets For more information and examples, see Split your data into buckets. bucketPercentile(attribute) The bucketPercentile( ) function is the NRQL equivalent of the histogram_quantile function in Prometheus. It is intended to be used with dimensional metric data. Instead of the quantile, New Relic returns the percentile, which is the quantile * 100. Use the bucketPercentile( ) function to calculate the quantile from the histogram data in a Prometheus format. It takes the bucket name as an argument and reports percentiles along the bucket's boundaries: SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago Copy Optionally, you can add percentile specifications as an argument: SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago Copy Because multiple metrics are used to make up Prometheus histogram data, you must query for specific Prometheus metrics in terms of the associated <basename>. For example, to compute percentiles from a Prometheus histogram, with the <basename> prometheus_http_request_duration_seconds using NRQL, use bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50). Note how _ bucket is added to the end of the <basename> as a suffix. See the Prometheus.io documentation for more information. cardinality(attribute) Use the cardinality( ) function to obtain the number of combinations of all the dimensions (attributes) on a metric. It takes three arguments, all optional: Metric name: if present, cardinality( ) only computes the metric specified. Include: if present, the include list restricts the cardinality computation to those attributes. Exclude: if present, the exclude list causes those attributes to be ignored in the cardinality computation. SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) Copy count(*) Use the count( ) function to return a count of available records. It takes a single argument; either *, an attribute, or a constant value. Currently, it follows typical SQL behavior and counts all records that have values for its argument. Since count(*) does not name a specific attribute, the results will be formatted in the default \"humanize\" format. derivative(attribute [,time interval]) derivative() finds the rate of change for a given dataset. The rate of change is calculated using a linear least-squares regression to approximate the derivative. Since this calculation requires comparing more than one datapoint, if only one datapoint is included in the evaluation range, the calculation is indeterminate and won't work, resulting in a null value. The time interval is the period for which the rate of change is calculated. For example, derivative(attributeName, 1 minute) will return the rate of change per minute. dimensions(include: {attributes}, exclude: {attributes}) Use the dimensions( ) function to return all the dimensional values on a data type. You can explicitly include or exclude specific attributes using the optional arguments: Include: if present, the include list limits dimensions( ) to those attributes. Exclude: if present, the dimensions( ) calculation ignores those attributes. FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() Copy When used with a FACET clause, dimensions( ) produces a unique timeseries for all facets available on the event type, similar to how Prometheus behaves with non-aggregated queries. earliest(attribute) Use the earliest( ) function to return the earliest value for an attribute over the specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get earliest country per user agent from PageView This query returns the earliest country code per each user agent from the PageView event. SELECT earliest(countryCode) FROM PageView FACET userAgentName Copy eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... Copy Use the eventType() function in a FACET clause to break out results by the selected data type or in a WHERE clause to filter results to a specific data type. This is particularly useful for targeting specific data types with the filter() and percentage() functions. Important In this context, \"event type\" refers to the types of data you can access with a NRQL query. Use eventType() in filter() function This query returns the percentage of total TransactionError results out of the total Transaction results. You can use the eventType() function to target specific types of data with the filter() function. SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago Copy Use eventType() with FACET This query displays a count of how many records each data type (Transaction and TransactionError) returns. SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES Copy filter(function(attribute), WHERE condition) Use the filter() function to limit the results for one of the aggregator functions in your SELECT statement. You can use filter() in conjunction with FACET or TIMESERIES. Filter is only useful when selecting multiple different aggregations such as SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' .... Otherwise, it's better to just use the standard WHERE clause. Analyze purchases that used offer codes You could use filter() to compare the items bought in a set of transactions for those using an offer code versus those who aren't: Use the filter( ) function to limit the results for one of the aggregator functions in your SELECT statement. funnel(attribute, steps) Use the funnel() function to generate a funnel chart. It takes an attribute as its first argument. You then specify steps as WHERE clauses (with optional AS clauses for labels) separated by commas. For details and examples, see the funnels documentation. getField(attribute, field) Use the getField() function to extract a field from complex metrics. It takes the following arguments: Metric type Supported fields summary count, total, max, min gauge count, total, max, min, latest distribution count, total, max, min counter count Examples: SELECT max(getField(mySummary, count)) from Metric Copy SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 Copy histogram(attribute, ceiling [,number of buckets]) Use the histogram( ) function to generate histograms. It takes three arguments: Attribute name Maximum value of the sample range Total number of buckets (between 1 and 500, inclusive) Histogram of response times from PageView events This query results in a histogram of response times ranging up to 10 seconds over 20 buckets. SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy Prometheus histogram buckets histogram( ) accepts Prometheus histogram buckets: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago Copy New Relic distribution metric histogram( ) accepts Distribution metric as an input: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago Copy Histogram with a FACET clause Use histogram( ) with a FACET clause to generate a heatmap chart: SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago Copy keyset() Using keyset() will allow you to see all of the attributes for a given data type over a given time range. It takes no arguments. It returns a JSON structure containing groups of string-typed keys, numeric-typed keys, boolean-typed keys, and all keys. See all attributes for a data type This query returns the attributes found for PageView events from the last day: SELECT keyset() FROM PageView SINCE 1 day ago Copy latest(attribute) Use the latest( ) function to return the most recent value for an attribute over a specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get most recent country per user agent from PageView This query returns the most recent country code per each user agent from the PageView event. SELECT latest(countryCode) FROM PageView FACET userAgentName Copy latestrate(attribute, time interval) Use the latestrate( ) function to return the rate of change of a value based on the last 2 data points. It takes the attribute in question as the first argument and the unit of time for the resulting rate as the second argument. The function returns a result in units of change in attribute/time interval. This function can be useful to provide the most recent rate of change for an attribute in order to see leading-edge trends. Get the most recent rate of change of PageView Duration This query returns the rate of change of duration based on the last 2 data points. It will be returned in units of duration/second because of the 1 SECOND argument. SELECT latestrate(duration, 1 SECOND) FROM PageView Copy max(attribute) Use the max( ) function to return the maximum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. median(attribute) Use the median( ) function to return an attribute's median, or 50th percentile. For more information about percentile queries, see percentile(). Tip The median( ) query is only available when using the query builder. Median query This query will generate a line chart for the median value. SELECT median(duration) FROM PageView TIMESERIES AUTO Copy min(attribute) Use the min( ) function to return the minimum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. minuteOf(attribute) Use the minuteOf() function to extract only the minute portion (i.e. 0-59) of an attribute holding a valid timestamp value. mod(attribute, divisor) Use the mod( ) function to return the floor modulus after dividing the value of the provided numeric attribute (the first argument, or dividend) by a numeric value (the second argument, or divisor). This modulo operation can be used within a WHERE clause condition to filter to an arbitrary subset of results or within a FACET clause as a way to subdivide the result set. mod() within a WHERE clause condition FROM Transaction SELECT * WHERE mod(port, 2) = 1 Copy mod() within a FACET clause FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) Copy percentage(function(attribute), WHERE condition) Use the percentage( ) function to return the percentage of a target data set that matches some condition. The first argument requires an aggregator function against the desired attribute. Use exactly two arguments (arguments after the first two will be ignored). If the attribute is not numeric, this function returns a value of 100%. percentile(attribute [, percentile [, ...]]) Use the percentile( ) function to return an attribute's approximate value at a given percentile. It requires an attribute and can take any number of arguments representing percentile points. The percentile() function enables percentiles to displays with up to three digits after the decimal point, providing greater precision. Percentile thresholds may be specified as decimal values, but be aware that for most data sets, percentiles closer than 0.1 from each other will not be resolved. Percentile display examples Use TIMESERIES to generate a line chart with percentiles mapped over time. Omit TIMESERIES to generate a billboard and attribute sheet showing aggregate values for the percentiles. If no percentiles are listed, the default is the 95th percentile. To return only the 50th percentile value, the median, you can also use median(). Basic percentile query This query will generate a line chart with lines for the 5th, 50th, and 95th percentile. SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO Copy predictLinear(attribute, [,time interval]) predictLinear() is an extension of the derivative() function. It uses a similar method of least-squares linear regression to predict the future values for a dataset. The time interval is how far the query will look into the future. For example, predictLinear(attributeName, 1 hour) is a linear prediction 1 hour into the future of the query time window. Generally, predictLinear() is helpful for continuously growing values like disk space, or predictions on large trends. Since predictLinear() is a linear regression, familiarity with the dataset being queried helps to ensure accurate long-term predictions. Any dataset which grows exponentially, logarithmically, or by other nonlinear means will likely only be successful in very short-term predictions. New Relic recommends against using predictLinear in TIMESERIES queries. This is because each bucket will be making an individual prediction based on its relative timeframe within the query, meaning that such queries will not show predictions from the end of the timeseries forward. rate(function(attribute) [,time interval]) Use the rate( ) function to visualize the frequency or rate of a given query per time interval. For example, you might want to know the number of pageviews per minute over an hour-long period or the count of unique sessions on your site per hour over a day-long period. Use TIMESERIES to generate a line chart with rates mapped over time. Omit TIMESERIES to generate a billboard showing a single rate value averaged over time. Basic rate query This query will generate a line chart showing the rate of throughput for APM transactions per 10 minutes over the past 6 hours. SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES Copy round(attribute) Use the round( ) function to return the rounded value of an attribute. Optionally round( ) can take a second argument, to_nearest, to round the first argument to the closest multiple of the second one. to_nearest can be fractional. SELECT round(n [, to_nearest]) Copy stddev(attribute) Use the stddev( ) function to return one standard deviation for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. stdvar(attribute) Use the stdvar( ) function to return the standard variance for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. sum(attribute) Use the sum( ) function to return the sum recorded values of a numeric attribute over the time range specified. It takes a single argument. Arguments after the first will be ignored. If the attribute is not numeric, it will return a value of zero. uniqueCount(attribute) Use the uniqueCount( ) function to return the number of unique values recorded for an attribute over the time range specified. Tip To optimize query performance, this function returns approximate results for queries that inspect more than 256 unique values. uniques(attribute [,limit]) Use the uniques( ) function to return a list of unique values recorded for an attribute over the time range specified. When used along with the facet clause, a list of unique attribute values will be returned per each facet value. The limit parameter is optional. When it is not provided, the default limit of 1,000 unique attribute values per facet is applied. You may specify a different limit value, up to a maximum of 10,000. The uniques( ) function will return the first set of unique attribute values discovered, until the limit is reached. Therefore, if you have 5,000 unique attribute values in your data set, and the limit is set to 1,000, the operator will return the first 1,000 unique values that it discovers, regardless of their frequency. The maximum number of values that can be returned in a query result is the product of the uniques( ) limit times the facet limit. In the following query, the theoretical maximum number of values that can be returned is 5 million (5,000 x 1,000). Depending on the data set being queried, and the complexity of the query, memory protection limits may prevent a very large query from being executed. From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 Copy Using tuple If you'd like to know the unique combinations of a handful of attributes, you can structure a query in the format SELECT unique(tuple(x, y, ... z)) ...` to get all the unique tuples of values, to maintain their relationship. In the following query, tuple is used on index and cellName together to find uniques where those two values occur in combination. FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) Copy Type conversion NRQL does not support \"coercion.\" This means that a float stored as a string is treated as a string and cannot be operated on by functions expecting float values. You can convert a string with a numeric value or a boolean with a string value to their numeric and boolean types with these functions: Use the numeric() function to convert a number with a string format to a numeric function. The function can be built into a query that uses math functions on query results or NRQL aggregator functions, such as average(). Use the boolean() function to convert a string value of \"true\" or \"false\" to the corresponding boolean value.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.92857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> syntax, clauses, and functions",
        "sections": "<em>NRQL</em> syntax, clauses, and functions",
        "tags": "Query your <em>data</em>",
        "body": " <em>NRQL</em> is used for, what <em>data</em> you can query with it, and basic <em>NRQL</em> syntax Examine <em>NRQL</em> queries used to build New Relic charts Learn how to query the Metric <em>data</em> type Simulate SQL JOIN functions Use funnels to evaluate a series of related <em>data</em> Format <em>NRQL</em> for querying with the Event API Query"
      },
      "id": "604456c1196a678db8960f41"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/server-overview-dashboard.png",
      "url": "https://newrelic.com/blog/how-to-relic/server-overview-dashboard",
      "sections": [
        "Building a Server Overview dashboard",
        "Creating custom dashboards is easy"
      ],
      "published_at": "2021-04-16T04:25:53Z",
      "title": "How to Create a Server Overview Dashboard in New Relic Insights",
      "updated_at": "2021-04-14T02:02:40Z",
      "type": "",
      "external_id": "a682a93ac23e587fc70b52a65c2440851f9214aa",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic How to Create a Server Overview Dashboard in New Relic Insights Aug 10, 2017 • 7 min read By Phil Weber New Relic Infrastructure gives you real-time, searchable, filterable visibility across your entire infrastructure. But what if you want to view key metrics about a server on a single dashboard? Thanks to New Relic Insights, you can! Because Infrastructure stores its data in the New Relic Database (NRDB, the same data store used by Insights), it’s easy to create a Server Overview dashboard. In this post I’d like to walk you through how it’s done. Building a Server Overview dashboard First, log into your New Relic account and navigate to Infrastructure’s Compute page: If you look closely above each chart, you’ll notice a small icon that resembles a chart on an easel: Click this icon to open the chart’s underlying NRQL query in Insights: From here, you can customize the query, give the chart a title, and add it to a dashboard. The NRQL AS clause allows you to customize the label of a query attribute. Let’s add some AS clauses to make the chart legend easier to read. Change the NRQL query to SELECT average(cpuSystemPercent) AS 'CPU System %', average(cpuIOWaitPercent) AS 'CPU I/O Wait %', average(cpuUserPercent)   AS 'CPU User %', average(cpuStealPercent) AS 'CPU Steal %' FROM SystemSample SINCE 60 minutes ago TIMESERIES Click the Run button to execute the query. Give the resulting chart a title, such as “CPU Usage,” and click Add to a Dashboard. In the Add to a Dashboard dialog, select Add to a new dashboard and give your new dashboard a name, such as “Server Overview.” Now go back to Infrastructure and repeat the process for the Load and Memory charts. Infrastructure draws a custom chart to display Used and Available memory as a stacked-area chart. Unfortunately, it is not possible to replicate this chart in Insights. Instead, change the NRQL query to SELECT average(memoryUsedBytes / memoryTotalBytes * 100) AS 'Percent Used', 100 AS 'Max' FROM SystemSample SINCE 60 minutes ago TIMESERIES The SELECT...100 AS 'Max' clause forces the Y-axis to a scale of 0 to 100, allowing us to display the memory used as an easy-to-read percentage. From Infrastructure’s Storage page, change the chart to display Total Utilization %, view the query in Insights, and change it to SELECT average(totalUtilizationPercent) FROM StorageSample FACET entityAndMountPoint SINCE 60 minutes ago TIMESERIES To display network throughput, use the following query: SELECT average(transmitBytesPerSecond / 1024) AS 'Transmitted', average(receiveBytesPerSecond / 1024) AS 'Received' FROM NetworkSample SINCE 60 minutes ago TIMESERIES It can be helpful to see which processes are running on a server, in case one of them is consuming a large amount of CPU or memory, for example. You can use the following query to display a list of running processes, the name of the user who started each process, and how much CPU and memory each process is using: SELECT uniqueCount(processId), latest(userName),   average(cpuPercent) AS 'CPU Percent', average(memoryResidentSizeBytes) / 1024 AS 'Memory (MB)' FROM ProcessSample FACET processDisplayName SINCE 1 hour ago New Relic Infrastructure captures information about system events, such as user logins, package deployments, etc. Let’s add a widget to our dashboard to display recent events: SELECT * FROM InfrastructureEvent SINCE 1 day ago Finally, we need a way to select an individual host, so we can see an overview of a single server. Let’s add a table based on the following query: SELECT average(cpuPercent) AS 'CPU %', average(memoryUsedBytes / memoryTotalBytes) * 100 AS 'Memory Used %' FROM SystemSample FACET hostname SINCE 5 minutes ago LIMIT 10 That query displays the Top 10 host names reporting to your account, in order of CPU usage. After adding the above table to your dashboard, click the ellipsis icon in the upper-right corner of the chart widget and select Edit link: In the resulting Link to dashboard dialog, link the widget to the Current dashboard and save your changes. Now you can select a host name from the table to filter the dashboard to that host: To view the information for a host that’s not included in the Top 10, click in the Search hostname field at the top of the page and select the desired hostname. Creating custom dashboards is easy Pulling key server metrics into a single dashboard takes just a few minutes; now you can easily see the status of an individual server at a glance. Because New Relic Infrastructure stores its data in NRDB, it’s easy to export and customize charts from Infrastructure to Insights, and create custom dashboards that display whatever information you want to see. For more information on using New Relic Insights to share and view Infrastructure data, check out the documentation.   By Phil Weber Phil Weber is a Senior Technical Training Specialist with New Relic University. He worked as a software developer for over 15 years, and has been a technical trainer since 2005. As a consultant, he worked for such clients as Intel and Kaiser Permanente. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.75477,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Creating <em>custom</em> dashboards is easy",
        "body": " minutes; now you can easily see the status of an individual server at a glance. Because New Relic Infrastructure stores its <em>data</em> in NRDB, it’s easy to export and <em>customize</em> charts from Infrastructure to Insights, and create <em>custom</em> dashboards that display whatever information you want to see. For more"
      },
      "id": "60764d40196a67ef7f64a7c0"
    },
    {
      "sections": [
        "NRQLの構文、句、関数",
        "構文",
        "クエリの構成要素",
        "必要な句",
        "必須：SELECT文",
        "直近1週間の平均レスポンスタイム",
        "必須：FROM句",
        "ひとつのデータタイプのクエリ",
        "複数のデータタイプのクエリ",
        "オプションの句",
        "AS句",
        "数学関数とASを使用したクエリ",
        "ファネルとASを使用したクエリ",
        "COMPARE WITH句",
        "EXTRAPOLATE句",
        "重要",
        "スループットの推定の例",
        "時系列としてのスループットの推定の例",
        "FACET句",
        "count()を使用したファセットクエリ",
        "uniqueCount()を使用したファセットクエリ",
        "時間範囲で結果をグループ化",
        "FACET ... AS句",
        "FACET CASES句",
        "WHEREの基本的な使い方",
        "複数の属性に基づくグループ化",
        "ASを使用したグループのラベル付け",
        "FACET ... ORDER BY 句",
        "ヒント",
        "LIMIT句",
        "LIMITを使用したクエリ",
        "OFFSET 句",
        "ORDER BY 句",
        "SHOW EVENT TYPES句",
        "直近1日間のデータタイプ",
        "SINCE句",
        "SLIDE BY句",
        "SLIDE BYをMAXまたはAUTO間隔と一緒に使用する",
        "TIMESERIES句",
        "設定した間隔を使用する",
        "自動設定した間隔を使用する",
        "MAXインターバルを使用する",
        "UNTIL句",
        "WHERE句",
        "3つの条件を使ったクエリの例",
        "WITH METRIC_FORMAT 句",
        "WITH TIMEZONE句",
        "メトリックデータのクエリを行う",
        "集計関数",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "特定の顧客の Apdexを取得する",
        "特定のトランザクションのApdexを取得する",
        "アプリ全体のApdexを取得する",
        "average(attribute)",
        "buckets(attribute, ceiling \\[,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(\\*)",
        "derivative(attribute \\[,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "earliest(attribute)",
        "PageView からユーザーエージェントごとに最も古い国を取得",
        "eventType()",
        "filter()関数でeventType()を使用する",
        "FACETでeventType()を使用する",
        "filter(function(attribute), WHERE condition)",
        "オファーコードを使用した購入を分析する",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling \\[,number of buckets])",
        "PageViewイベントからのレスポンスタイムのヒストグラム",
        "Prometheusヒストグラムバケット",
        "New Relicディストリビューションメトリック",
        "keyset()",
        "データタイプのすべての属性を表示",
        "latest(attribute)",
        "PageView からユーザーエージェントごとに最新の国を取得",
        "latestrate(attribute, time interval)",
        "PageView期間の最新の変化率を取得する",
        "max(attribute)",
        "median(attribute)",
        "中央値クエリ",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "WHERE句条件内のmod()",
        "FACET句内のmod()",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute \\[, percentile \\[, ...]])",
        "基本的なパーセンタイルのクエリ",
        "predictLinear(attribute, \\[,time interval])",
        "rate(function(attribute) \\[,time interval])",
        "基本的な評価クエリ",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute \\[,limit])",
        "タプルの使用",
        "データ型変換",
        "その他のヘルプ"
      ],
      "title": "NRQLの構文、句、関数",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "86a104da11c2a96cd4c395682c86dc9205a32327",
      "image": "https://docs.newrelic.com/jp/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/images/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-04-11T20:57:35Z",
      "updated_at": "2021-04-06T00:25:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQLは、New Relicデータベースのクエリに使用可能なクエリ言語です。このドキュメントではNRQLの構文、句、構成要素、関数について説明します。 構文 このドキュメントは、NRQLクエリにおいて使用される関数と句の参考資料です。NRQLを理解するためのその他のリソース： NRQLの紹介：どのようなNRQLが使用されるのか、それによってどのようなデータをクエリできるのか、そして基本的なNRQL構文について説明しています。 New Relicチャートの作成に使用するNRQLクエリを検証する SQL JOIN関数をシミュレーション ファネルを使用して一連の関連データを評価する Event APIでクエリを行うためのNRQLをフォーマットする クエリの構成要素 すべてのNRQLクエリはSELECT文または FROM句で始まります。その他すべての句は任意です。以下の句の定義には、NRQLクエリの例も含まれます。 必要な句 必須：SELECT文 SELECT属性... コピー SELECT関数（属性）... コピー SELECTは、属性または関数を指定することによってどの部分のデータタイプをクエリしたいかを指定します。その後、カンマ区切りの1つ以上の引数が続きます。各引数では、以下を実行できます。 ワイルドカードとして*を使用することにより、利用可能なすべての属性の値を取得できます。例えば：SELECT * from Transaction。 指定した属性、または カンマ区切りのリストで指定した複数の属性に関連する値を取得できます。 集約関数を選択することで、指定した属性から集約値を取得できます。 AS句を使って、各引数で返された結果にラベルを付けます。 基本的な数学関数とともにSELECTを使用することもできます。 直近1週間の平均レスポンスタイム このクエリは、直近1週間の平均応答時間を返します。 SELECT average(duration) FROM PageView SINCE 1 week ago コピー 必須：FROM句 SELECT ... FROM data type ... コピー FROM句を使用して、クエリしたいデータタイプを指定します。クエリはFROMまたはSELECTから開始することができます。カンマ区切りのリストを使って、複数のデータタイプにまたがる同じ属性の値をマージすることができます。 ひとつのデータタイプのクエリ このクエリは、直近3日間の APMトランザクション の全件数を返します。 SELECT count(*) FROM Transaction SINCE 3 days ago コピー 複数のデータタイプのクエリ このクエリは、直近3日間の APM トランザクション と Browserイベント の全カウント数を返します。 SELECT count(*) FROM Transaction, PageView SINCE 3 days ago コピー オプションの句 AS句 SELECT ... AS 'label' ... コピー AS句を使用して、シングルクォート区切りの文字列で属性、集計、ファネル内のステップ、または数学関数の結果にラベルを付けます。このラベルは結果のチャートで使用されます。 数学関数とASを使用したクエリ このクエリはセッションごとのページ数を返します。 SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView コピー ファネルとASを使用したクエリ このクエリは、過去1週間でサイトのメインページと採用情報ページの両方を訪れた人の数を返します。 SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago コピー COMPARE WITH句 SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... コピー COMPARE WITH句を使用して、2つの異なる時間範囲の値を比較します。 COMPARE WITHでは、SINCEまたはUNTIL文が必要になります。COMPARE WITHで指定された時間は、SINCEまたはUNTILで指定した時間に相対します。たとえば、SINCE 1 day ago COMPARE WITH 1 day agoは、昨日とその前日を比較します。 COMPARE WITH値の時間範囲は、常にSINCEまたはUNTILで指定されたものと同じになります。たとえば、SINCE 2 hours ago COMPARE WITH 4 hours agoは、午後3時から午後5時の範囲と午後1時から午後3時の範囲を比較します。 COMPARE WITHは、折れ線グラフまたはビルボードのいずれかの形式にすることができます： TIMESERIESを使うと、COMPARE WITHは時系列でマッピングされた比較で折れ線グラフを作成します。 TIMESERIESがない場合、COMPARE WITHは現在値とCOMPARE WITH値からの増減率でビルボードを生成します。 例: このクエリは、過去1時間の95パーセンタイルを1週間前の同じ時間範囲と比較した折れ線グラフでデータを返します。一つ目は単一の値、その次は折れ線グラフです。 SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO コピー EXTRAPOLATE句 この句は以下のデータタイプで使用可能です： Transaction TransactionError APMエージェントのAPIを通じて報告されたカスタムイベント EXTRAPOLATEの目的は、クエリ結果がシステム内のアクティビティ全体をより厳密に表現できるよう、イベントデータのAPMエージェントサンプリングの影響を数学的に補うことです。 この節は、New Relic APMエージェントが余りにも多くのイベントを報告することで、収穫サイクルの報告上限を超過しがちになる際に便利です。その場合、エージェントはイベントのサンプリングを開始します。 EXTRAPOLATEに対応したNRQLクエリでこれを使用した場合、報告されたイベントと合計イベントの比率を基に、合計未サンプルデータの近似を推定します。この句に未対応であるか、サンプルデータを使用していないNRQLでこれを使用した場合、結果に影響を与えません。 重要 EXTRAPOLATEは、（スループットやエラー率など）同種データについて最も有用なことに注意してください。（uniqueCount() や uniques()など）特徴的なことの数を外挿しようとする際には有効ではありません。 この句は、以下のいずれかの集約関数を利用したNRQLクエリでのみ機能します： apdex average count histogram sum percentage （引数として取る関数がEXTRAPOLATEに対応している場合） rate （引数として取る関数がEXTRAPOLATEに対応している場合） stddev スループットの推定の例 interestingApplicationという名前のサービスの推定スループットを示すクエリ。 SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE コピー 時系列としてのスループットの推定の例 トランザクション名ごとに、時系列として表示するinterestingApplicationという名前のサービスの推定スループットを示すクエリ。 SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE コピー FACET句 SELECT ... FACET attribute ... コピー FACETを使用すると、結果を属性値で分割してグループ化できます。例えば、PageViewデータでdeviceType別にFACETを行い、トラフィックの何割が携帯電話、タブレット、およびデスクトップデバイスから発生しているかを把握することができます。 LIMIT句を使用して、表示するファセットの数を指定します（デフォルトは10）。複雑なグループ化には、FACET CASESを使用してください。FACET句は、カンマで区切られた最大5つの属性をサポートします。 ファセットは、SELECT句で指定した最初のフィールドによって降順でソートされます。2,000件以上のユニーク値を持つ属性をファセットに指定した場合、ファセット値のサブセットを選択し、それらをクエリタイプに従って並べ替えます。 min()、max()、またはcount()を選択すると、FACETはこれらの関数を使用してファセットの選択方法とソート方法を決定します。その他の関数を選択すると、FACETはファセット対象の属性の発生頻度に基づいて、ファセットの選択方法とソート方法を決定します。 実際の例を使った複数の属性に対するファセットについては、こちらの New Relicのブログ記事をご覧ください。 count()を使用したファセットクエリ このクエリは、ページビュー数が最も多い都市を表示します。このクエリは、都市ごとのページビューの合計数を使用してファセットの選択方法と並べ替え方法を決定します。 SELECT count(*) FROM PageView FACET city コピー uniqueCount()を使用したファセットクエリ このクエリは、最も多数のユニークURLにアクセスしている都市を表示します。このクエリは、特定の都市が結果に表れる合計回数を使用して、ファセットの選択方法と並べ替え方法を決定します。 SELECT uniqueCount(pageUrl) FROM PageView FACET city コピー 時間範囲で結果をグループ化 高度なセグメンテーションやコホート分析では、バケット機能でファセットすることでデータをより効率的に分割することができます。 コホート分析は、タイムスタンプに基づいて結果をグループ化する方法です。指定範囲日時に対応するバケットに結果を分割することができます。 FACET ... AS句 FACET ... AS 句では、クエリで AS キーワードを使用してファセットに名前を付けます。この句は、結果のファセットに明確な名前または簡略化された名前を追加するのに役立ちます。ネスト構造の集計クエリで、ファセットの名前を変更するためにも使用できます。 FACET ... AS クエリでは、結果のファセット名が変更されますが（たとえば、テーブルのヘッダーとして表示される場合）、実際のファセット名自体は変更されません。 FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' コピー FACET CASES句 SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... コピー FACET CASESを使用して、FACETで可能な範囲を超えた複雑な条件別にデータを取り出します。複数の条件はカンマ,で区切ります。たとえば、PageViewデータをクエリして、1秒未満、1秒から10秒、10秒を上回るといったカテゴリにFACET CASESを行うことができます。ケース内の複数の属性を組み合わせたり、ASセレクタを使ってケースにラベルを付けることができます。データ点は、最大で1つのファセットケースに追加されます。つまり、一致する最初のファセットになります。 属性とともに時間関数も使用できます。 WHEREの基本的な使い方 SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) コピー 複数の属性に基づくグループ化 この例は、トランザクション名にloginが含まれる1つのバケットと、URLにloginが含まれ、かつカスタム属性がユーザーが有料ユーザーであったことを示すもう1つのバケットに結果をグループ化します： SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') コピー ASを使用したグループのラベル付け この例は、結果に目視可能な名前をつけるためにASセレクタを使います： SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') コピー FACET ... ORDER BY 句 NRQL では、デフォルトは SELECT 句の最初の集計で、クエリ内のファセットの選択をガイドします。FACET ... ORDER BY 句では、ORDER BY 修飾子を使用して集計関数を追加し、ファセットの選択方法を指定することで、このデフォルトの動作をオーバーライドできます。具体的には、LIMIT句によって制限される前に、最終結果に含めるファセットの優先度をオーバーライドします。この句はクエリで使用できますが、アラートやストリーミングには使用できません。 この例では、FACET ... ORDER BY を使用してアプリ トランザクションの平均期間を見つける方法を示し、応答サイズが最大のアプリによる上位10（デフォルトの制限）の最大期間を示しています。この場合、FACET ... ORDER BY が使用されていない場合、クエリ結果には、アプリの選択とは関係のない応答サイズで、期間が最も長い上位10件が代わりに表示されます。 FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) コピー ヒント LIMIT 句が適用される前に操作が実行されるため、FACET ... ORDER BYは、最終的なクエリ結果の種類に影響を与えません。これは、非時系列クエリの結果で特に顕著になります。 重要 この場合の ORDER BY 修飾子は、ORDER BY 句とは機能が異なります。FACET attribute1 ORDER BY attribute2 の形式に従うクエリを解析する場合、NewRelic はこれらのクエリを FACET ... ORDER BY クエリとして読み取りますが、ORDER BY が FACET の直後に表示される場合に限定されます。それ以外の場合、ORDER BY は New Relic によって句として解釈されます。 LIMIT句 SELECT ... LIMIT count ... コピー LIMIT句を使用して、FACETクエリで返されるファセット値の最大数あるいはSELECT *クエリで返される項目の最大数を管理します。この句は、単一の整数値を引数に取ります。LIMIT句が指定されないか、値が提供されなかった場合、リミットのデフォルト設定はFACETクエリの場合は10に、SELECT *クエリの場合は100となります。 LIMIT句で許容される最大値は2,000です。 LIMITを使用したクエリ このクエリはセッション数上位20カ国を表示し、各国のWindowsユーザー限定でレスポンスタイムの95 パーセンタイルを提供します。 SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY コピー OFFSET 句 SELECT ... LIMIT count OFFSET count ... コピー OFFSET句とLIMIT句を使用して、SELECT *またはSELECTの列クエリによって返される行の一部を制御します。 LIMIT 句と同様に、 OFFSET は引数として単一の整数値を取ります。 OFFSET は、クエリで選択された行が返される前に、スキップされる行数を設定します。これは LIMIT によって制約されます。 OFFSET 行はスキップされ、直近のレコードから開始されます。 たとえば、SELECT InterestingValue FROM Minute_Report LIMIT 5 OFFSET 1 のクエリは、 Minute_Report から、直近の値を除いて最後の5つの値を返します。 ORDER BY 句 ORDER BY 句を使用すると、行でイベント属性を選択するクエリで結果を並べ替える方法を指定できます。 このクエリは、期間順にトランザクションを並べ替えます。 FROM Transaction SELECT appName, duration ORDER BY duration コピー デフォルトの並べ替え順序は昇順ですが、 ASC または DESC の修飾子を追加することで変更できます。 SHOW EVENT TYPES句 SHOW EVENT TYPES... コピー SHOW EVENT TYPESは、特定の時間範囲内にアカウントに存在するすべてのデータタイプのリストを返します。これは、SELECTの代わりにクエリの最初の句として使用されます。 重要 この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータタイプを指します。 直近1日間のデータタイプ このクエリは、直近1日のすべてのデータタイプを返します。 SHOW EVENT TYPES SINCE 1 day ago コピー SINCE句 SELECT ... SINCE [numerical units AGO | phrase] ... コピー デフォルト 値は 1 時間前です。 SINCE句を使用して、返されたデータに対する時間範囲の開始時点を定義します。NRQLを使用する場合、UTCタイムスタンプまたは相対時間範囲を設定できます。タイムゾーンは結果ではなく、クエリに対して指定できます。NRQLの結果はシステム時間に基づきます。 詳細な情報と例については、ダッシュボードとチャートで時間範囲を設定するをご覧ください。 SLIDE BY句 SLIDE BY 句は、スライディングウィンドウと呼ばれる機能をサポートしています。スライディングウィンドウを使用すると、SLIDE BYデータは、互いに重複する時間の「ウィンドウ」に収集されます。これらのウィンドウは、移動集計（移動平均など）が狭い時間枠からの集計よりも重要である場合に、変動の多い折れ線グラフを滑らかにするのに役立ちます。 SLIDE BYを使用するには、TIMESERIES句の後のクエリにこの句を配置します。たとえば、このクエリは1分のSLIDE BY間隔で5分間のウィンドウにデータをプルします。つまり、各ウィンドウは5分間続きますが、ウィンドウ1は0分後に開始し、ウィンドウ2は1分後に開始し、ウィンドウ3は2分後に開始します。 SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute コピー SLIDE BYをいつ、どのように使用できるかについて詳しくは、スライディングウィンドウを使用してよりスムーズなグラフを作成するをご覧ください。 SLIDE BYをMAXまたはAUTO間隔と一緒に使用する スライディングウィンドウは、MAXまたはAUTOと組み合わせて使用できます。ただし、MAXまたはAUTOをTIMESERIES とSLIDE BYの間に配置することはできません。 このクエリは、SLIDE BYウィンドウ間隔を自動的に決定します。 SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO コピー このクエリは、SLIDEBYウィンドウを最大間隔に設定します。 SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX コピー 重要 AUTOまたはMAXによって決定されるSLIDE BY値は、ウィンドウ サイズよりも大きいステップ間隔を生成する可能性があり、ギャップや予期しない結果を引き起こす可能性があります。 TIMESERIES句 SELECT ... TIMESERIES integer units ... コピー TIMESERIES句を使用して、指定期間単位の時系列としてデータを返します。TIMESERIESは特定のチャートをトリガするために使用されることから、デフォルト値はありません。 時間範囲を指定するには、integer unitsを使用します。例えば： TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds 以下の例に示すように、TIMESERIESをMAX、AUTO、SLIDE BYなどの引数と組み合わせると、クエリ結果をさらに調整できます。 重要 average( )またはpercentile( )などの関数では、集計ウィンドウを大きく設定することで、外れ値に対して大幅なスムージング効果が得られます。これは、クエリがスライディングウィンドウを使用するかどうかに関係なく当てはまります。 設定した間隔を使用する 指定された値は、グラフを分割する単位を示します。たとえば、以下のようにして1日のグラフを30分刻みで表示します。 SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes コピー 自動設定した間隔を使用する TIMESERIESはAUTOに設定することもでき、これによってグラフが適切な数の区分に分割されます。たとえば、1日のチャートは30分間隔で分割され、1週間のチャートは6時間間隔で分割されます。 このクエリは、6時間間隔のデータ点で、1週間のクライアントサイドのトランザクションタイムの50パーセントタイルと90パーセンタイルを示す折れ線グラフを返します。 SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO コピー MAXインターバルを使用する TIMESERIESをMAXに設定することで時間枠が自動的に調整され、指定された期間で許可された間隔数を最大にすることができます。これによって、TIMESERIESバケットを手動で更新することなく時間枠を更新でき、認められた最大インターバル数に時間枠を分割できます。返されるTIMESERIESバケットの最大数は366です。 例えば、以下のクエリでは4分間の間隔を作成していますが、これは1日のチャートの上限となります。 SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX コピー UNTIL句 SELECT ... UNTIL integer units AGO ... コピー デフォルト 値は NOWです。UNTILは、デフォルト以外の終了点を指定するためのみに使用してください。 UNTIL句はデータを返す時間範囲の終了時点を定義します。時間範囲を指定するとデータが保存されるようになり、時間範囲が終了した後に確認することができます。時間は UTC タイムスタンプ または相対時間範囲を指定できます。タイムゾーンは結果ではなく、クエリに対して指定できます。返される結果はシステム時間に基づきます。 詳細な情報と例については、ダッシュボードとチャートで時間範囲を設定するをご覧ください。 WHERE句 WHERE句を使用して、結果をフィルタリングします。NRQLは、句で指定した条件を満たす結果を返します。 SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... コピー 複数の条件を指定する場合は、条件を演算子ANDまたはORで区切ります。 SQLのjoinをシミュレートしたい場合は、WHEREまたはFACET句でカスタム属性を使用します。 WHERE句が受け付ける演算子 説明 =, !=, <, <=, >, >= NRQLは標準的な比較演算子を受け付けます。 例: state = 'WA' AND 2つの条件の論理積を定義するために使用します。 OR 2つの条件の論理和を定義するために使用します。 IS NULL 属性がnull値を持つかどうかを判定します。 IS NOT NULL 属性がnull値を持たないかどうかを判定します。 IN 属性の文字列値が指定したセットに存在するかどうかを判断します。この方法を使うと、複数のWHERE句を組み合わせた場合よりもパフォーマンスが向上します。 例: animalType IN （'cat', 'dog', 'fish'） NOT IN 属性の文字列値が指定したセットに存在しないかどうかを判断します。この方法を使うと、複数のWHERE句を組み合わせた場合よりもパフォーマンスが向上します。 値は括弧で囲み、カンマで区切る必要があります。例えば： SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') コピー LIKE 属性に指定の部分文字列が含まれるかどうかを判断します。 LIKE演算子の文字列引数は、文字列内の任意の位置にワイルドカードとしてパーセント記号（%）を受け付けます。部分文字列が一致対象の文字列で開始（先頭に一致）または終了（末尾に一致）しない場合、ワールドカードを文字列の先頭または末尾に指定する必要があります。 例： userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE 属性に指定の部分文字列が含まれないかどうかを判定します。 RLIKE 属性に特定のRegex 部分文字列が含まれるかどうかを判断します。RE2 構文を使用します。 例： appName RLIKE 'z.*|q.*'' z-app q-app hostname RLIKE 'ip-10-351-[0-2]?[0-9]-.*' ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 重要 注: Regexパターンではスラッシュをエスケープする必要があります。たとえば、\\dは\\\\dとする必要があります。 Regexではデフォルトで文字列全体マッチとなっているため、^と$は暗黙となり、追加する必要はありません。 Regexパターンにキャプチャグループが含まれる場合、そのグループは無視されます。つまり、クエリで後で使用するためにグループはキャプチャされません。 NOT RLIKE 属性に指定のRegex部分文字列が含まれないかどうかを判定します。RE2 構文を使用します。 3つの条件を使ったクエリの例 このクエリは、過去24時間、米国およびカナダ国内のSafariユーザーについて、URLにcheckoutが含まれるページのブラウザレスポンスタイムを返します。 SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago コピー WITH METRIC_FORMAT 句 メトリックデータのクエリに関する情報については、メトリックスのクエリを行うをご覧ください。 WITH TIMEZONE句 SELECT ... WITH TIMEZONE (selected zone) ... コピー デフォルトで、クエリ結果は、現在使用中のブラウザのタイムゾーンで表示されます。 WITH TIMEZONE句を使用して、タイムゾーンが未指定のクエリで日付や時刻のタイムゾーンを選択します。 たとえば、SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'というクエリ句は、東部標準時の月曜日午前12時から東部標準時の火曜日午前12時までに記録されたデータを返します。 利用可能なタイムゾーンの選択 アフリカ/アビジャン アフリカ/アディスアベバ アフリカ/アルジェ アフリカ/ブランタイヤ アフリカ/カイロ アフリカ/ウィントフック 米州/アダック 米州/アンカレッジ 米州/アラグアイナ 米州/アルゼンチン/ブエノスアイレス 米州/ベリーズ 米州/ボゴタ 米州/カンポグランデ 米州/カンクン 米州/カラカス 米州/シカゴ 米州/チワワ 米州/ドーソンクリーク 米州/デンバー 米州/エンセナーダ 米州/グリーンベイ 米州/ゴットホープ 米州/グースベイ 米州/ハバナ 米州/ラパス 米州/ロサンゼルス 米州/ミクロン 米州/モンテビデオ 米州/ニューヨーク 米州/モローニャ 米州/サンティアゴ 米州/サンパウロ 米州/セントジョンズ アジア/アナディル アジア/バンコク アジア/ベイルート アジア/ダマスカス アジア/ダッカ アジア/ドバイ アジア/ガザ アジア/香港 アジア/イルクーツク アジア/エルサレム アジア/カブール アジア/カトマンズ アジア/コルカタ アジア/クラスノヤルスク アジア/マガダン アジア/ノボシビルスク アジア/ヤンゴン アジア/ソウル アジア/タシケント アジア/テヘラン アジア/東京 アジア/ウラジオストク アジア/ヤクーツク アジア/エカテリンブルク アジア/エレバン 大西洋/アゾレス 大西洋/カーポベルデ 大西洋/スタンリー オーストラリア/アデレード オーストラリア/ブリスベン オーストラリア/ダーウィン オーストラリア/ユークラ オーストラリア/ホバート オーストラリア/ロードハウ オーストラリア/パース チリ/イースター島 その他/GMT+10 その他/GMT+8 その他/GMT-11 その他/GMT-12 ヨーロッパ/アムステルダム ヨーロッパ/ベルファスト ヨーロッパ/ベオグラード ヨーロッパ/ブリュッセル ヨーロッパ/ダブリン ヨーロッパ/リスボン ヨーロッパ/ロンドン ヨーロッパ/ミンスク ヨーロッパ/モスクワ 太平洋/オークランド 太平洋/チャタム 太平洋/ガンビエ 太平洋/キリバス 太平洋/マルケサス 太平洋/ミッドウェイ 太平洋/ノーフォーク 太平洋/トンガタプ UTC 詳細な情報と例については、ダッシュボードとチャートで時間範囲を設定するをご覧ください。 メトリックデータのクエリを行う NRQLを使用してメトリックデータのクエリを行うには、次のいくつかの方法があります： メトリックタイムスライスデータをクエリ（New Relic APM、Browser、Mobileによりレポートされます） Metricデータタイプをクエリ（一部のインテグレーションおよびテレメトリーSDKによりレポートされます） New Relicでのメトリックスの理解の詳細については、メトリックデータのタイプをご覧ください。 集計関数 集約関数を使用して、NRQLクエリのデータを絞り込み、集約できます。以下に、集約関数の利用に関する便利な情報を提供します： New Relic UniversityのFilter Queries、Apdex Queries、およびPercentile Queriesのチュートリアル。または、完全なWriting NRQL クエリのオンラインコースにアクセスしてください。 データタイプ「型強制」には対応していません。利用可能なデータ型変換関数の詳細を参照してください。 New Relic Insights の コホート分析 ページでは、コホート分析の関数が表示されます。コホート関数は、時間別にトランザクションを集計します。 以下は、利用可能な集約関数になります。以下の定義には、NRQLクエリの例が含まれます。 例： SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago コピー aggregationendtime() aggregationendtime()関数を使用して、関連する集計の時刻を返します。より具体的には、aggregationendtime()関数は、特定の集計に対して集計の期間終了のタイムスタンプを提供します。たとえば、時系列クエリでは、1時間分のデータを含むデータポイントの場合、関数はその時間の終わりのタイムスタンプを返します。 apdex(attribute, t: ) apdex関数を使用して、単一のトランザクションまたはすべてのトランザクションに対してApdexスコアを返します。属性は、durationやbackendDurationなどのレスポンスタイムに基づいて、任意の属性に指定できます。t: 引数は Apdex T の閾値を秒単位で定義します。 apdex（ ）関数が返すApdexスコアは、実行時間のみに基づくものです。APMエラーは考慮していません。エラーが含まれているにもかかわらず、トランザクションがApdex T以下で完了する場合、そのトランザクションはapdex （ ）関数によって満足と評価されます。 特定の顧客の Apdexを取得する もし 定義済みのカスタム属性 がある場合は、それらの属性に基づいて絞り込むことができます。たとえば、特に重要な顧客のApdexを監視することができます。 SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago コピー 特定のトランザクションのApdexを取得する name属性を使用して特定のトランザクションのスコアを返す、またはnameを省略して総合的なApdexを返します。このクエリは、直近1時間の Controller/notes/index トランザクションのApdexスコアを返します。 SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago コピー apdex関数は、サイトに対するユーザーの満足度を測定するApdexスコアを返します。引数は、秒単位のレスポンスタイムの属性とApdex Tの閾値です。 アプリ全体のApdexを取得する このクエリの例では、直近3週間のアプリケーション全体のApdexを返します。 SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago コピー average(attribute) average( )関数を使用して、属性の平均値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。 buckets(attribute, ceiling \\[,number of buckets]) buckets()関数を使用して、FACET句ごとに分割されたデータを、範囲に基づきバケットに集約します。New Relicデータベースの数値として保存される属性ごとにバケットにまとめることができます。 この関数は 3 つの引数を取ります。 属性名 サンプル範囲の最大値。外れ値は最終バケットに表示されます。 バケットの合計数 詳細と例については、データをバケットに分割をご覧ください。 bucketPercentile(attribute) bucketPercentile( )関数は、Prometheusのhistogram_quantile関数のNRQL版です。ディメンションメトリックデータとともに使用します。分位数の代わりにNew Relicパーセンタイルを返します。これは分位数 * 100です。 bucketPercentile( )関数を使用して、Prometheus形式のヒストグラムデータから分位数を計算します。 バケット名を引数として取得し、バケットの境界とともにパーセンタイルをレポートします： SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago コピー オプションで、引数としてパーセンタイル指定を追加できます： SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago コピー 複数のメトリックスを使用してPrometheusヒストグラムデータを構成しているため、関連する<basename>に関して特定のPrometheusメトリックスのクエリを行う必要があります。 たとえば、PrometheusヒストグラムからNRQLを使用して<basename> prometheus_http_request_duration_secondsによりパーセンタイルの計算を行うには、bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)を使用します。 _ bucketがサフィックスとして<basename>の最後に追加されていることに注意してください。 詳しくは、Prometheus.ioドキュメントを参照してください。 cardinality(attribute) cardinality( )関数を使用して、メトリック上のすべてのディメンション（属性）の組み合わせの数を取得します。 次の3つの引数を取りますが、すべてオプションです： Metric name: ある場合、cardinality( )は指定したメトリックのみを計算します。 Include: ある場合、Includeリストは、濃度計算をこの属性に制限します。 Exclude: ある場合、Excludeリストにより、この属性は濃度計算で使用されなくなります。 SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) コピー count(\\*) count（ ）関数を使用して、利用可能なレコード数を返します。これは単一の引数を受け入れます (*、属性、または一定値のいずれか)。現在、一般的なSQL動作に従って、その引数に対する値を持つすべてのレコードを計上します。 count（*）は特定の属性を示すものではないため、結果はデフォルトの「humanize」形式でフォーマットされます。 derivative(attribute \\[,time interval]) derivative()は、所定のデータセットの変化率を検索します。線形最小二乗回帰を使用して変化率を計算し、微分係数を近似します。この計算では複数のデータポイントの比較が必要であるため、評価範囲にデータポイントが1つしかない場合、解が求められず、結果はnull値になります。 時間間隔は、変化率を計算する期間です。たとえば、derivative(attributeName, 1 minute)は、1分あたりの変化率を返します。 dimensions(include: {attributes}, exclude: {attributes}) dimensions( )関数を使用して、データタイプのすべてのディメンション値を返します。 オプションの引数を使用して、特定の属性を明示的に含めたり除外したりすることができます： Include: ある場合、includeリストは、dimensions( )をそれらの属性に限定します。 Exclude: ある場合、dimensions( )の計算ではそれらの属性を使用しません。 FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() コピー FACET句とともに使用する場合、dimensions( )は、未集計クエリでのPrometheusの動作と同様に、イベントタイプで使用できるすべてのファセットについて一意の時系列を生成します。 earliest(attribute) latest（ ）関数を使用して、指定された時間範囲における属性の最も古い値を返します。 単一の引数を取ります。最初の引数以外は無視されます。 FACETと併用する場合、この関数は得られた各ファセットの属性の最新値を返します。 PageView からユーザーエージェントごとに最も古い国を取得 このクエリは、PageView イベントからユーザーエージェントごとに最も古い国コードを返します。 SELECT earliest(countryCode) FROM PageView FACET userAgentName コピー eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... コピー eventType()関数は、選択したデータタイプ別に結果を取り出すためにFACET句で使用、または特定のデータタイプに結果をフィルタリングするためにWHERE句で使用します。これは filter() や percentage() 関数で特定のデータタイプを対象とする際に特に便利です。 重要 この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータタイプを指します。 filter()関数でeventType()を使用する このクエリは、合計Transactionの結果あたりの合計TransactionErrorの結果の割合を返します。eventType()関数を使用して、filter()関数で特定のデータタイプをターゲットにすることができます。 SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago コピー FACETでeventType()を使用する このクエリは、各データタイプ（TransactionおよびTransactionError）が返すレコードの数を表示します。 SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES コピー filter(function(attribute), WHERE condition) filter（ ）関数を使用して、SELECT文内の集計関数の1つに結果を制限できます。filter()は、FACETまたはTIMESERIESと併用することができます。 オファーコードを使用した購入を分析する filter()は、一連のトランザクションで購入された商品の中で、オファーコードを使用して購入された商品と、オファーコードを使用せずに購入された商品を比較するために使用できます： filter（ ）関数を使用して、SELECT文内の集計関数の1つに結果を制限できます。 funnel(attribute, steps) funnel()関数を使用して、ファネルチャートを生成します。属性を最初に引数に取ります。その後、カンマで区切られた複数のWHERE句（オプションでラベル付け用にAS句を含める）をステップとして指定します。 詳細な情報と例については、 ファネルのドキュメントをご覧ください。 getField(attribute, field) getField()関数を使用して、複雑なメトリックスからフィールドを抽出します。 次の引数を取ります： メトリックのタイプ サポートされたフィールド summary count、total、max、min gauge count、total、max、min、latest distribution count、total、max、min counter count 例： SELECT max(getField(mySummary, count)) from Metric コピー SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 コピー histogram(attribute, ceiling \\[,number of buckets]) histogram（ ）関数を使用して、ヒストグラムを生成します。この関数は 3 つの引数を取ります。 属性名 サンプル範囲の最大値 バケットの合計数 PageViewイベントからのレスポンスタイムのヒストグラム このクエリは 20 バケットにわたって 10 秒以内のレスポンスタイムのヒストグラムを生成します。 SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago コピー Prometheusヒストグラムバケット histogram( )では、Prometheusヒストグラムバケットを受け取ります: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago コピー New Relicディストリビューションメトリック histogram( )ではディストリビューションメトリックを入力として受け取ります: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago コピー keyset() keyset()を使用すると、所定の時間範囲における所定のデータタイプに対するすべての属性を表示できます。この関数は引数を取りません。文字列型キー、数値型キー、ブーリアン型キー、およびすべてのキーをグループ化した JSON 構造体を返します。 データタイプのすべての属性を表示 このクエリは、最後の日からのPageViewイベントで見つかった属性を返します： SELECT keyset() FROM PageView SINCE 1 day ago コピー latest(attribute) latest（ ）関数を使用して、指定された時間範囲における属性の最新値を返します。 単一の引数を取ります。最初の引数以外は無視されます。 FACETと併用する場合、この関数は得られた各ファセットの属性の最新値を返します。 PageView からユーザーエージェントごとに最新の国を取得 このクエリは、PageView イベントからユーザーエージェントごとに最新の国コードを返します。 SELECT latest(countryCode) FROM PageView FACET userAgentName コピー latestrate(attribute, time interval) latestrate( )関数を使用して、最後の2つのデータポイントに基づく値の変化率を返します。問題となる属性を最初の引数として受け取り、結果である変化率の時間の単位を2番目の引数として受け取ります。この関数は、属性の変化/時間間隔の単位で結果を返します。 この関数は、最先端の傾向を確認するために、属性の最新の変化率を提供するのに役立ちます。 PageView期間の最新の変化率を取得する このクエリは、最後の2つのデータポイントに基づいて期間の変化率を返します。 1 SECOND 引数があるため、期間/秒の単位で返されます。 SELECT latestrate(duration, 1 SECOND) FROM PageView コピー max(attribute) max（ ）関数を使用して、指定された時間範囲内に記録された数値属性の最大値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。 median(attribute) median( )関数を利用して、属性の中央値あるいは50パーセンタイルを返します。パーセンタイルクエリの詳細に関しては、percentile()を参照してください。 ヒント median( )クエリは、クエリビルダーを利用する場合にのみ利用できます。 中央値クエリ このクエリは、中央値に関する折れ線グラフを生成します。 SELECT median(duration) FROM PageView TIMESERIES AUTO コピー min(attribute) min（ ）関数を使用して、指定された時間範囲内に記録された数値属性の最小値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。 minuteOf(attribute) minuteOf()関数を使用して、有効なタイムスタンプ値を持つ属性の分の部分（0～59）のみを抽出します。 mod(attribute, divisor) 与えられた数値属性の値（最初の引数、すなわち被除数）を数値（2つ目の引数、すなわち除数）で割った後、mod( )関数を使用してfloor係数を返します。このモジュロ演算は、WHERE句の条件内で使用して結果の任意のサブセットにフィルターしたり、FACET句で結果セットをさらに分割したりする方法として使用できます。 WHERE句条件内のmod() FROM Transaction SELECT * WHERE mod(port, 2) = 1 コピー FACET句内のmod() FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) コピー percentage(function(attribute), WHERE condition) percentage（ ）関数を使用して、いくつかの条件に一致する目的のデータセットの割合を返します。 最初の引数には、目的の属性に対する集計関数が必要です。必ず2つの引数を使用してください（最初の 2 つ以外の引数は無視されます）。属性が数値でない場合、この関数は 100% を値として返します。 percentile(attribute \\[, percentile \\[, ...]]) percentile（ ）関数を使用して、所定の指定パーセンタイルでの属性の概算値を返します。この関数は属性が必須であり、パーセンタイル点を表す引数はいくつでも指定できます。percentile() 関数は、小数点以下3桁までの表示を可能にすることで、より厳密な内容を提供できます。パーセンタイルの閾値は小数点値として指定される場合があるものの、大半のデータセットにおいて、互いに0.1よりも近いパーセンタイルは解決されない点に注意してください。 パーセンタイルの表示例 TIMESERIESを使用して、時系列でマッピングされたパーセンタイルで折れ線グラフを生成します。 TIMESERIESを省略して、パーセンタイルの集計値を示すビルボードと属性シートを生成します。 パーセンタイルが指定されていない場合、デフォルトで 95 パーセンタイルとなります。50パーセンタイル値、つまり中央値のみを返すには、median()を使用することもできます。 基本的なパーセンタイルのクエリ このクエリは 5、50、95 パーセンタイルの折れ線を表示する折れ線グラフを生成します。 SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO コピー predictLinear(attribute, \\[,time interval]) predictLinear()は、derivative()関数の拡張です。同様の方法の最小2乗線形回帰を使用して、データセットの将来値を予測します。 時間間隔は、クエリでどの程度将来まで扱うかを表します。たとえば、predictLinear(attributeName, 1 hour)は、1時間の線形予想をクエリの時間枠の将来に当てはめます。 一般に、predictLinear()は、ディスクスペースのような増加が続く値や大きなトレンドの予想などで有用です。 predictLinear()は線形回帰のため、クエリを行っているデータセットに習熟していると、正確な長期的な予想を行えます。 指数的または対数的、その他の非線形的に増加するデータセットでは、非常に短期的な予想でのみ有効な可能性が高いと言えます。 New Relicでは、TIMESERIESクエリでpredictLinearを使用することを推奨していません。これは、各バケットがクエリ内の相対的な期間に基づき個別に予想を行う、つまり、そうしたクエリは時系列終了以後の予想は示さないためです。 rate(function(attribute) \\[,time interval]) rate ()関数を使用して、時間間隔ごとに所定のクエリの頻度またはレートを視覚化します。たとえば、1 時間の 1 分あたりのページビュー数や 1 日間の 1 時間あたりのサイトのユニークセッション数を把握したい場合があるかもしれません。 TIMESERIESを使用して、時系列でマッピングされたレートで折れ線グラフを生成します。 TIMESERIESを省略して、時系列で平均化された単一のレート値を示すビルボードを生成します。 基本的な評価クエリ このクエリは、過去 6 時間の 10 分あたりの APM トランザクションのスループット評価を示す折れ線グラフを生成します。 SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES コピー round(attribute) round( )関数を使用して、属性の丸め値を返します。 オプションで、round( )は2番目の引数to_nearestを取り、最初の引数を2番目の引数の最も近い倍数に切り上げます。to_nearestは分数でも使用できます。 SELECT round(n [, to_nearest]) コピー stddev(attribute) stddev()関数を使用して、指定された時間範囲内に記録された数値属性の標準偏差値を返します。単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。 stdvar(attribute) stdvar()関数を使用して、指定された時間範囲内に記録された数値属性の標準分散を返します。 単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。 sum(attribute) sum（ ）関数を使用して、指定された時間範囲内に記録された数値属性の合計値を返します。 単一の引数を取ります。最初の引数以外は無視されます。属性が数値でない場合は、ゼロを値として返します。 uniqueCount(attribute) uniqueCount（ ）関数を使用して、指定された時間範囲内に記録された属性のユニーク値の数を返します。 ヒント クエリのパフォーマンスを最適化するため、この関数は256を超えるユニーク値を検査するクエリのおおよその結果を返します。 uniques(attribute \\[,limit]) uniques（ ）関数を使用して、指定された時間範囲内に記録された属性のユニーク値のリストを返します。facet句と共に使用すると、各ファセット値ごとに固有の属性値一覧が返されます。 limitパラメータは任意です。これが提供されない場合、ファセットあたり1,000の固有の属性値がデフォルトリミットとして適用されます。最大10,000までの、別のlimitを指定することもできます。uniques( )関数は、上限に達するまで、発見した固有の属性値の最初の一式を返します。このため、データセットに5,000の固有の属性値があり、上限が1,000に設定されている場合、演算子はその頻度に関わらず、発見した最初の1,000の固有の値を返します。 クエリ結果で返すことのできる最大数は、uniques( )上限とfacet上限を掛け合わせたものになります。以下のクエリでは、論理的に返すことの可能な最大値は500万になります（5,000 x 1,000）。 クエリしたデータセットのほか、クエリの複雑さ次第では、メモリ保護上限の影響で非常に大きなクエリの実行が阻止される可能性があります。 From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 コピー タプルの使用 少数の属性の独自の組み合わせを知りたい場合、SELECT unique(tuple(x, y, ... z)) ...`形式でクエリを構築することで、値の独自のタプルをすべて取得して、それらの関係を維持することができます。以下のクエリでは、tupleがインデックスとcellName両方に対して使用され、これらの2つの値が組み合わせで発生する一意の要素を見つけます。 FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) コピー データ型変換 NRQLは「型強制」をサポートしていません。つまり、文字列として保存された浮動小数点は文字列として取り扱われ、浮動小数点数を要求する関数に渡しても操作できません。 次に示す関数を用いることで、数値を伴う文字列、または文字列を伴うブーリアン値をそれぞれ数またはブーリアン値に変換できます。 numeric() 関数を用いて、文字列形式の数値を数値関数に変換します。この関数は、クエリ結果に数学関数を使用するクエリ、もしくはaverage()などのNRQL 集計関数に組み込むことができます。 boolean()関数を用いることで、「true」もしくは「false」の文字列値を対応するブーリアン値に変換できます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.78435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em>の構文、句、関数",
        "sections": "<em>NRQL</em>の構文、句、関数",
        "tags": "Query your <em>data</em>",
        "body": "<em>NRQL</em>は、New Relicデータベースのクエリに使用可能なクエリ言語です。このドキュメントでは<em>NRQL</em>の構文、句、構成要素、関数について説明します。 構文 このドキュメントは、<em>NRQL</em>クエリにおいて使用される関数と句の参考資料です。<em>NRQL</em>を理解するためのその他のリソース： <em>NRQL</em>の紹介：どのような<em>NRQL</em>が使用されるのか、それによってどのようなデータをクエリできるのか、そして基本的な<em>NRQL</em>構文について説明しています。 New Relicチャートの作成に使用する<em>NRQL</em>クエリを検証する SQL JOIN関数をシミュレーション ファネルを使用して一連の関連データを評価する Event"
      },
      "id": "6053a66828ccbc48e1c2fd19"
    },
    {
      "sections": [
        "Rate limits for NRQL queries",
        "Limits on queried events",
        "NRQL query rate limits",
        "Limits on count of data types"
      ],
      "title": "Rate limits for NRQL queries",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "6dd3504c517c84fe20e0066c36482a001d0e2f3a",
      "image": "https://docs.newrelic.com/static/a67951798a5b60f8aca1b4aac861f61a/466da/insights-inspected-event-count-modal_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/rate-limits-nrql-queries/",
      "published_at": "2021-04-12T03:14:28Z",
      "updated_at": "2021-04-05T16:30:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's query language, NRQL, has rate limits in place to ensure a high level of availability and reliability for all users. To understand the places NRQL can be used, see Where is NRQL used?. You will rarely encounter rate limiting, especially if you follow these general guidelines: Limit the amount of requests with complex queries (for example, queries with FACET or TIMESERIES clauses, or queries of over a million events) that run at the same time. Limit the amount of requests run concurrently over extended periods of time to a maximum of 5, especially if they include complex queries. Limits on queried events When you run a NRQL query, it will display the number of events inspected, as shown below: In this context, \"events\" is used in a general sense to refer to all NRQL-available objects; this includes events, metrics, logs, and distributed tracing (span) data. Each New Relic account has limits on the total number of events that can be inspected. There are limits that apply over two different time frames: A rolling 30-minute time window A 24-hour period These limits are as follows: Time period Limit Rolling 30 minutes 300 billion events inspected (equivalent to a sustained rate of 10 billion events inspected per minute) 24 hours 7.2 trillion events inspected Once the limit has been reached for a given time period, limiting will be imposed and some queries may be impacted. After the time period has passed, if query volume drops below the limit, restrictions will be removed automatically. NRQL query rate limits The limit on NRQL queries is 50 queries per second, or 3000 queries per minute. Past this, New Relic cannot guarantee query performance, and you may be rate limited. Limits on count of data types The limit for total number of reported data types is 250 per account over a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. This limit applies to all NRQL-queryable data types. Because there aren't that many different data types reported by New Relic products and integrations, this will mainly be a limit on custom events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.15504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Rate limits for <em>NRQL</em> queries",
        "sections": "Rate limits for <em>NRQL</em> queries",
        "tags": "Query your <em>data</em>",
        "body": " account over a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop <em>data</em>. This limit applies to all <em>NRQL</em>-queryable <em>data</em> types. Because there aren&#x27;t that many different <em>data</em> types reported by New Relic products and integrations, this will mainly be a limit on <em>custom</em> events."
      },
      "id": "603e8e46e7b9d2143d2a07b0"
    }
  ],
  "/build-apps/ab-test/confirmation-modal": [
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/embed/",
      "sections": [
        "Present an end test confirmation modal",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-04-16T02:06:50Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:51Z",
      "type": "",
      "external_id": "554a84f8fe2faf9c2b867686538360771e22fc3c",
      "popularity": 1,
      "body": "In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 View your application: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your Nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. View your application where the modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 384.77368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Present</em> <em>an</em> <em>end</em> <em>test</em> <em>confirmation</em> <em>modal</em>",
        "body": " to ensure you don&#x27;t <em>end</em> it prematurely Show and hide your <em>confirmation</em> <em>modal</em> Step 1 of 12 Change to the <em>present</em>-<em>confirmation</em>-<em>modal</em>&#x2F;ab-<em>test</em> directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>present</em>-<em>confirmation</em>-<em>modal</em>&#x2F;ab-<em>test</em> This directory contains the code your"
      },
      "id": "6072565e64441f34dd9d8548"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.45215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Save <em>test</em> information to NerdStorage",
        "body": "={&#x27;A&#x27;}&gt;Version A&lt;&#x2F;SelectItem&gt; &lt;SelectItem value={&#x27;B&#x27;}&gt;Version B&lt;&#x2F;SelectItem&gt; &lt;&#x2F;Select&gt; } } class <em>EndTest</em>Button extends React.Component { constructor() { super(...arguments); this.state = { <em>modal</em>Hidden: true, } this.show<em>Modal</em> = this.show<em>Modal</em>.bind(this); this.close<em>Modal</em> = this.close<em>Modal</em>.bind(this); this.<em>endTest</em>"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    },
    {
      "image": "https://developer.newrelic.com/static/93a294bc7852a6eea64a7baa55a0aca3/ba3ac/api-token-prompt.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstoragevault/embed/",
      "sections": [
        "Access NerdStorageVault from your Nerdlet",
        "Store your API token",
        "Important",
        "Query your API token",
        "Create your token prompt",
        "Tip",
        "Pass your API token to TotalCancellations"
      ],
      "published_at": "2021-04-16T02:01:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:32:20Z",
      "type": "",
      "external_id": "f2af52e45942b4cf9499282a654340b132766741",
      "popularity": 1,
      "body": "Throughout this course, you're building a New Relic One application that gathers telemetry data from a demo web service that's running an A/B test on a newsletter signup form. The purpose of your New Relic One application is to help you understand how design changes impact the number of high quality newsletter subscriptions your service gets. The business objective, to increase your service's high quality newsletter subscriptions, relies primarily on three key pieces of information: Number of page views per version Number of subscriptions per version Number of cancellations Cancellations are important because if one design version of your newsletter signup form results in a high number of subscriptions but also a high number of cancellations, then those subscriptions are not as valuable. In previous lessons, you gathered data for page views and subscriptions from New Relic's database (NRDB), but you still need cancellation data. Your demo application does not report cancellation data to New Relic, so you need to fetch that data from an external source. We've provided a service at https://api.nerdsletter.net/cancellations to return fake cancellation data for the purposes of this course. If you visit this URL in your browser, you'll see a brief message: \"Unauthorized\". This is because we created this service with a requirement that whoever requests its data must pass an Authorization header with the bearer token ABC123. So before you can request cancellation data from api.nerdsletter.net, you need to implement a few new behaviors in your application: Provide a mechanism for inputting an authorization token Persist the authorization token in a secure data store To input your authorization token, you'll use a Modal with a TextField. The secure data store you'll use is called NerdStorageVault. It's different from NerdStorage, which you used in the last lesson, because it only supports user storage and encrypts its data. Store your API token Step 1 of 3 Change to the add-nerdstoragevault/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstoragevault/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 3 In your Nerdlet's index.js file, initialize state in AbTestNerdletNerdlet with a null token default: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Your Nerdlet uses this token state to manage the authorization token you'll later pass to the third-party service. However, a component's state is not a long-term solution for data management. For that, you need NerdStorageVault. Step 3 of 3 Implement a method, called storeToken(), which mutates NerdStorageVault data, and bind that method to the AbTestNerdletNerdlet instance: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { token: null, } this.storeToken = this.storeToken.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy When you call storeToken() with a new token value, your Nerdlet uses NerdGraph APIs to mutate NerdStorageVault data for the api_token key. If the request to NerdGraph is successful, storeToken() updates state.token so that the new token is locally accessible. Unlike NerdStorage, which has query and mutation components for your convenience, NerdStorageVault has no components in the SDK. Instead, you have to use NerdGraphQuery and NerdGraphMutation to interact with it Important It's important to remember that NerdStorageVault is limited to the user scope. Any other users of your New Relic One application will have their own NerdStorageVault data. This means that even other users on your account will need to enter their token separately. Query your API token Step 1 of 2 First, create methods and state to show and hide your API token prompt: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy state.hideTokenPrompt determines whether or not the prompt is visible. Now, you need a mechanism for revealing the prompt, which is hidden by default. Step 2 of 2 Query NerdStorageVault for your api_token: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, in componentDidMount(), you've queried NerdGraph for your api_token data. componentDidMount() is a React lifecycle method that's called when your component is mounted in the component tree. This means that early in it's setup process, your application will request your api_token. If the NerdGraph query responds successfully with your token from NerdStorageVault, it sets the token in state. Otherwise, it shows the prompt so that you can enter a token. This is great for storing an initial token, but what if you enter the wrong token or the API changes? You need a way reveal the prompt on-demand. Next, you'll create the actual token prompt and a button to manually invoke the prompt. Create your token prompt Step 1 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named token-prompt.js: bash Copy $ touch token-prompt.js Step 2 of 9 In this new file, create a button that allows you to enter a new token on demand: import React from 'react'; import { Button } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenButton receives showPrompt() in its props and calls that method when its Button is clicked. Step 3 of 9 Create a token prompt using a Modal with a TextField: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } nerdlets/ab-test-nerdlet/token-prompt.js Copy ApiTokenPrompt renders a Modal with a TextField, a Button, and an explanatory prompt. You use the Modal to enter your API token. It also provides basic error handling if you try to submit the form with no token value. It's important to distinguish the token in AbTestNerdletNerdlet.state and the token in ApiTokenPrompt.state. The token in your Nerdlet's state is the current token that your Nerdlet knows about. It's this token that matches what's in NerdStorageVault. The token in ApiTokenPrompt.state is a fluid value that changes as you update the text in the TextField. When you press Submit in the modal, ApiTokenPrompt submits its token to your Nerdlet's storeToken() method. Then, storeToken() mutates NerdStorageVault with the new token. You also implemented a few methods to improve the user experience: keyPress() submits the token when the RETURN key is pressed showTokenError() and hideTokenError() remind the user that they must enter a token before submitting the form Step 4 of 9 Export your components, so you can use them in your Nerdlet: import React from 'react'; import { Button, Modal, TextField, } from 'nr1'; class ApiTokenButton extends React.Component { constructor(props) { super(props) } render() { return ( <Button onClick={this.props.showPrompt}>Update API token</Button> ) } } class ApiTokenPrompt extends React.Component { constructor() { super(...arguments); this.state = { token: null, tokenError: false, }; this.submitToken = this.submitToken.bind(this); this.hideTokenError = this.hideTokenError.bind(this); this.changeToken = this.changeToken.bind(this); this.keyPress = this.keyPress.bind(this); } showTokenError() { this.setState({ tokenError: true }); } hideTokenError() { this.setState({ tokenError: false }); } changeToken(event) { this.setState({ token: event.target.value }); } submitToken(event) { event.preventDefault(); if (this.state.token) { this.props.storeToken(this.state.token) this.hideTokenError() this.props.hidePrompt() } else { this.showTokenError() } } keyPress(event) { if(event.keyCode == 13) { event.preventDefault(); this.submitToken(event); } } render() { return <Modal hidden={this.props.hideTokenPrompt} onClose={this.props.hidePrompt}> To see cancellation data, you need to enter an API token for your backend service: <form> <TextField label=\"API token\" onChange={this.changeToken} onKeyDown={this.keyPress} invalid={this.state.tokenError ? \"Token required\" : false} /> <Button type={Button.TYPE.PRIMARY} onClick={this.submitToken}>Submit</Button> </form> </Modal> } } export { ApiTokenButton, ApiTokenPrompt } nerdlets/ab-test-nerdlet/token-prompt.js Copy Step 5 of 9 In your Nerdlet's index.js file, import ApiTokenButton and ApiTokenPrompt and add them to render(): import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstoragevault/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes: When you visit your application for the first time, the prompt is automatically revealed. Enter \"ABC123\" in the TextField, as that's the token that the third-party service expects. Once you submit your token and your Nerdlet hides the prompt, click Update API token at the bottom of your New Relic One application to reveal it again: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Pass your API token to TotalCancellations Step 1 of 3 In index.js, pass the API token to TotalCancellations so you're prepared to make a request to the third-party service: import React from 'react'; import { ChartGroup, Grid, GridItem, NerdGraphMutation, NerdGraphQuery, } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; import { ApiTokenButton, ApiTokenPrompt } from './token-prompt'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { constructor() { super(...arguments); this.state = { hideTokenPrompt: true, token: null, } this.storeToken = this.storeToken.bind(this); this.showPrompt = this.showPrompt.bind(this); this.hidePrompt = this.hidePrompt.bind(this); } storeToken(newToken) { if (newToken != this.state.token) { const mutation = ` mutation($key: String!, $token: SecureValue!) { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: $key, value: $token } ) { status errors { message type } } } `; const variables = { key: \"api_token\", token: newToken, }; NerdGraphMutation.mutate({ mutation: mutation, variables: variables }).then( (data) => { if (data.data.nerdStorageVaultWriteSecret.status === \"SUCCESS\") { this.setState({token: newToken}) } } ); } } showPrompt() { this.setState({ hideTokenPrompt: false }); } hidePrompt() { this.setState({ hideTokenPrompt: true }); } componentDidMount() { const query = ` query($key: String!) { actor { nerdStorageVault { secret(key: $key) { value } } } } `; const variables = { key: \"api_token\", }; NerdGraphQuery.query( { query: query, variables: variables, } ).then( ({ loading, error, data }) => { if (error) { console.error(error); this.showPrompt(); } if (data && data.actor.nerdStorageVault.secret) { this.setState({ token: data.actor.nerdStorageVault.secret.value }) } else { this.showPrompt(); } } ) } render() { return <div> <ApiTokenPrompt hideTokenPrompt={this.state.hideTokenPrompt} hidePrompt={this.hidePrompt} showPrompt={this.showPrompt} storeToken={this.storeToken} /> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}> <TotalCancellations token={this.state.token} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={12}> <ApiTokenButton showPrompt={this.showPrompt} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 2 of 3 In total-cancellations.js, log the token to your browser console: import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { lastToken: null } } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`requesting data with api token ${this.props.token}`) this.setState({lastToken: this.props.token}) } } render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy Here, you've implemented another React lifecycle method, called componentDidUpdate(). Now, every time your Nerdlet's state.token changes, TotalCancellations gets a new token prop, which triggers componentDidUpdate(). In componentDidUpdate(), you check that the incoming token is not the same as the last token it knew about, which is stored in local state. If the incoming token is different, you log a message with the new token and update state.lastToken. This logic prepares your code for a future change to use your API token in a request to a third-party service. Step 3 of 3 With your Nerdpack served locally, view your application to see the log from TotalCancellations in your browser's console: If you change your token, you'll see another log from TotalCancellations with your updated token. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now you know how to use NerdGraphQuery and NerdGraphMutation to manage data in NerdStorageVault! Remember, use NerdStorage for your New Relic One application's non-sensitive data and NerdStorageVault for the sensitive stuff like tokens, passwords, and other secrets. As a bonus, you created a way to manage your token in NerdStorageVault from the user interface. You also passed the token to your TotalCancellations component for later use. Whether it's been with NrqlQuery, AccountStorageQuery, AccountStorageMutation, NerdGraphQuery, or NerdGraphMutation, you've learned several ways to interact with New Relic data in your New Relic One application. But New Relic One applications aren't just another way to show New Relic data. The purpose of New Relic One applications is to show you how your software is helping you meet your business objectives. Sometimes, New Relic data is all you need to make that happen, but other times you need to look beyond New Relic for data to fill in the gaps.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.79224,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " from one lesson to the next. Step 2 of 3 In your Nerdlet&#x27;s index.js file, initialize state in Ab<em>Test</em>NerdletNerdlet with a null token default: import React from &#x27;react&#x27;; import { ChartGroup, Grid, GridItem } from &#x27;nr1&#x27;; import <em>EndTest</em>Section from &#x27;.&#x2F;<em>end</em>-<em>test</em>&#x27;; import NewsletterSignups from"
      },
      "id": "6072ffcd64441f6cc09d8544"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/persist-version/embed/",
      "sections": [
        "Persist the selected version"
      ],
      "published_at": "2021-04-16T02:06:51Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:49Z",
      "type": "",
      "external_id": "000f29685ee92dffc2ce7e70539ee1663037ffcb",
      "popularity": 1,
      "body": "In the previous lesson, you created a section of your application that allows you to pick the most effective design from your A/B test. The goal of this section is to end the test once you’ve selected a winner: When you select a version from this form, the selection does not persist in the Select component. Now, it’s time to implement that behavior. Step 1 of 11 Change to the persist-selected-version/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/persist-selected-version/ab-test Step 2 of 11 In end-test.js, initialize EndTestSection.state with a default selectedVersion field: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 3 of 11 Pass the selectedVersion, as a prop, to VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 4 of 11 Supply the selectedVersion to your Select component in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 5 of 11 Create a method, selectVersion(), that updates EndTestSection.state: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy You must bind selectVersion to the EndTestSection component so it can access state. Step 6 of 11 Pass the method to VersionSelector as a prop: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 7 of 11 Set selectVersion as the onChange callback in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 8 of 11 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 9 of 11 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 10 of 11 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 11 of 11 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Voila! When you select a new version as the winner of the A/B test, that version is reflected in the menu. However, when you press End test, nothing happens. In the next lesson, you'll create a confirmation dialog to protect yourself from prematurely ending your A/B test.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.991,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", stop serving your New Relic One application by pressing CTRL+C in your local server&#x27;s terminal window. Voila! When you select a new version as the winner of the A&#x2F;B <em>test</em>, that version is reflected in the menu. However, when you press <em>End</em> <em>test</em>, nothing happens. In the next lesson, you&#x27;ll create a <em>confirmation</em> dialog to protect yourself from prematurely ending your A&#x2F;B <em>test</em>."
      },
      "id": "60730001196a67905864a75f"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/embed/",
      "sections": [
        "Add a section to end your test"
      ],
      "published_at": "2021-04-16T02:05:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:49Z",
      "type": "",
      "external_id": "6c1d9d3997eff7f27d00dbf9c8f451f5bec750d9",
      "popularity": 1,
      "body": "In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.91347,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add a section to <em>end</em> your <em>test</em>",
        "body": " section has three main components: A heading with instructional copy: &quot;Pick a version to <em>end</em> the <em>test</em>&quot; A component that you use to crown the winning version of the A&#x2F;B <em>test</em> A button to <em>confirm</em> the winner that you selected Step 1 of 10 Change to the add-<em>end</em>-<em>test</em>-section&#x2F;ab-<em>test</em> directory"
      },
      "id": "6072569228ccbc8f6151c174"
    }
  ],
  "/build-apps/ab-test/install-nr1": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.26105,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.49353,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use tags to define <em>the</em> workload content",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.4714,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.46234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.46234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    }
  ],
  "/build-apps/ab-test/end-test": [
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/embed/",
      "sections": [
        "Add a section to end your test"
      ],
      "published_at": "2021-04-16T02:05:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:49Z",
      "type": "",
      "external_id": "6c1d9d3997eff7f27d00dbf9c8f451f5bec750d9",
      "popularity": 1,
      "body": "In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 681.08636,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> <em>section</em> <em>to</em> <em>end</em> <em>your</em> <em>test</em>",
        "body": " of using columnSpan, they use a combination of columnStart and column<em>End</em> to specify which columns they cover. Step 6 of 10 In <em>your</em> Nerdlet&#x27;s index.js file, <em>add</em> <em>EndTestSection</em> to <em>your</em> Nerdlet: import React from &#x27;react&#x27;; import { ChartGroup, Grid, GridItem } from &#x27;nr1&#x27;; import <em>EndTestSection</em> from &#x27;.&#x2F;<em>end</em>"
      },
      "id": "6072569228ccbc8f6151c174"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/persist-version/embed/",
      "sections": [
        "Persist the selected version"
      ],
      "published_at": "2021-04-16T02:06:51Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:49Z",
      "type": "",
      "external_id": "000f29685ee92dffc2ce7e70539ee1663037ffcb",
      "popularity": 1,
      "body": "In the previous lesson, you created a section of your application that allows you to pick the most effective design from your A/B test. The goal of this section is to end the test once you’ve selected a winner: When you select a version from this form, the selection does not persist in the Select component. Now, it’s time to implement that behavior. Step 1 of 11 Change to the persist-selected-version/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/persist-selected-version/ab-test Step 2 of 11 In end-test.js, initialize EndTestSection.state with a default selectedVersion field: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 3 of 11 Pass the selectedVersion, as a prop, to VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 4 of 11 Supply the selectedVersion to your Select component in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 5 of 11 Create a method, selectVersion(), that updates EndTestSection.state: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy You must bind selectVersion to the EndTestSection component so it can access state. Step 6 of 11 Pass the method to VersionSelector as a prop: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 7 of 11 Set selectVersion as the onChange callback in VersionSelector: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Step 8 of 11 Navigate to the root of your Nerdpack at nru-programmability-course/persist-selected-version/ab-test. Step 9 of 11 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 10 of 11 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 11 of 11 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Voila! When you select a new version as the winner of the A/B test, that version is reflected in the menu. However, when you press End test, nothing happens. In the next lesson, you'll create a confirmation dialog to protect yourself from prematurely ending your A/B test.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.50575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "In the previous lesson, you created a <em>section</em> of <em>your</em> application that allows you to pick the most effective design from <em>your</em> A&#x2F;B <em>test</em>. The goal of this <em>section</em> is to <em>end</em> the <em>test</em> once you’ve selected a winner: When you select a version from this form, the selection does not persist in the Select"
      },
      "id": "60730001196a67905864a75f"
    },
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/embed/",
      "sections": [
        "Present an end test confirmation modal",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-04-16T02:06:50Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:51Z",
      "type": "",
      "external_id": "554a84f8fe2faf9c2b867686538360771e22fc3c",
      "popularity": 1,
      "body": "In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 View your application: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your Nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. View your application where the modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.34975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Present <em>an</em> <em>end</em> <em>test</em> confirmation modal",
        "body": ". This provides <em>your</em> component access to the modalHidden prop that you passed in <em>EndTestSection</em>. Then you provide the value of modalHidden to the Modal component&#x27;s hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 <em>Add</em> and bind two new methods"
      },
      "id": "6072565e64441f34dd9d8548"
    },
    {
      "image": "https://developer.newrelic.com/static/7aa6a002a1cdac5a19c8c8439258a0e9/ba3ac/past-tests-before.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nerdstorage/embed/",
      "sections": [
        "Access NerdStorage from your Nerdlet",
        "Save test information to NerdStorage",
        "Tip",
        "Important",
        "Fetch test information from NerdStorage"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "a8af2fddd59337d616809db90cb373eb51082cd8",
      "popularity": 1,
      "body": "In previous lessons, you created a user experience in your application which includes charts and a button to end your A/B test. You also configured your charts to query real data from New Relic's database. However, you left mock data in two charts: Past tests Total cancellations per version Both of these charts hold data that you can't get from New Relic. Past tests shows historical test information, whereas Total cancellations per version shows the number of cancellations each version sees over time. Focus, first on Past tests. Past tests shows historical test information, so you need to store information about each test upon completion. And you have all the tools you need to accomplish this task. First, you have an End test button that triggers the save action. Second, you know how to use NerdGraph and NerdStorage to hold the test information. Save test information to NerdStorage Step 1 of 5 Change to the add-nerdstorage/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nerdstorage/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 5 In nerdlets/ab-test-nerdlet/end-test.js, create a method, EndTestButton.endTest(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy With this code, you build a formatted date string, endDate. Then, you mutate account storage with a call to AccountStorageMutation.mutate(). You pass your account identifier, the WRITE_DOCUMENT action type, \"past-tests\" as the collection name, endDate as the documentId, and the document data, which includes the version descriptions and the winner. You pass WRITE_DOCUMENT because you're either creating a new document or updating a document, if one with a matching collection and documentId already exists. documentId is endDate, which is helpful for only creating one record per day. Tip If you suspected you might complete multiple tests in one day, you'd need to change this logic. Step 3 of 5 Notice this.props.closeModal() at the end of the method. This closes the modal that shows when you try to end a test. Therefore, you can replace the onClick callback for your Yes, end test button in EndTestButton.render(): import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy When you end the test, endTest stores your test data in account storage and closes the modal. This is only half the behavior you need to populate your table, you also need to query this collection from account storage. Step 4 of 5 In your Nerdlet's index.js file, pass the account ID and version descriptions to EndTestSection: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, EndTestSection can access these variables in its props. Step 5 of 5 Forward your account ID and version descriptions from EndTestSection to EndTestButton: import React from 'react'; import { AccountStorageMutation, BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); this.endTest = this.endTest.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } endTest() { const today = new Date(); const dd = String(today.getDate()).padStart(2, '0'); const mm = String(today.getMonth() + 1).padStart(2, '0'); const yyyy = today.getFullYear(); const endDate = `${mm}-${dd}-${yyyy}` AccountStorageMutation.mutate( { accountId: this.props.accountId, actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: \"past-tests\", documentId: endDate, document: { versionADescription: this.props.versionADescription, versionBDescription: this.props.versionBDescription, winner: this.props.selectedVersion, } } ) this.closeModal(); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.endTest}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton accountId={this.props.accountId} selectedVersion={this.state.selectedVersion} versionADescription={this.props.versionADescription} versionBDescription={this.props.versionBDescription} > End test </EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Fetch test information from NerdStorage Step 1 of 6 In past-tests.js, update PastTests to fetch data from account storage and display it in the TableChart: import React from 'react'; import { AccountStorageQuery, HeadingText, Spinner, TableChart, } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <AccountStorageQuery accountId={this.props.accountId} collection=\"past-tests\"> {({ loading, error, data }) => { if (loading) { return <Spinner />; } if (error) { console.debug(error); return 'There was an error fetching your data.'; } data.forEach( function (currentValue, index) { this[index] = { endDate: currentValue.id, versionADescription: currentValue.document.versionADescription, versionBDescription: currentValue.document.versionBDescription, winner: currentValue.document.winner, } }, data ) historicalData.data = data return <TableChart data={[historicalData]} fullWidth /> }} </AccountStorageQuery> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy First, you removed the mocked data from historicalData. Then, you used AccountStorageQuery to fetch data from NerdStorage. You passed your account identifier and the name of the collection in which you stored the document. Notice that there are three return values from the query: loading error data If the query is in progress, loading is true. In this case, you show a Spinner user interface component to let users know that the table isn't yet ready. If the query returned an error, you can see information about that error in the error variable. You log that information to the console for debugging purposes and return an error message. If the query returned successfully, you can access the data in the data variable. Because the data doesn't match the format that the TableChart requires, you loop through the data, format it according to the TableChart specifications, and set it on historicalData.data. Finally, you pass historicalData to your TableChart. Step 2 of 6 In your Nerdlet's index.js file, pass your ACCOUNT_ID to PastTests: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}> <EndTestSection accountId={ACCOUNT_ID} versionADescription={VERSION_A_DESCRIPTION} versionBDescription={VERSION_B_DESCRIPTION} /> </GridItem> <GridItem columnSpan={12}> <PastTests accountId={ACCOUNT_ID} /> </GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-nerdstorage/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. At first, you should see no data: Click End test and approve your action in the modal. Now, you see data in Past tests: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great work! You now have experience using the NerdStorage query and mutation components. However, there's still one more chart with mocked data: Total cancellations per version. Total cancellations per version is different from the other charts in your A/B test application. Because New Relic knows nothing about how many users unsubscribe to your newsletter, you need to request that information from an external source. For the purposes of this course, we've created an external data service that provides fake newsletter cancellation data for you to consume in your application. This mock service lives at https://api.nerdsletter.net/cancellations. New Relic One applications are React applications, which means that you can use React and Javascript facilities to gather data not only from New Relic, but any external service. In a later lesson, you'll learn how to look beyond New Relic for data that will inform you of how your software is helping you achieve your business objectives. But before you learn that, you need to know something about our mock data service: it requires an Authorization header! In this lesson, you learned how to use NerdStorage to query and mutate data in your application's own data store. While NerdStorage is a great place for many categories of data, it's not appropriate for sensitive data, like a token you would pass in an Authorization header to an external service. For that, you'd use NerdStorageVault.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 206.79553,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Access</em> NerdStorage from <em>your</em> Nerdlet",
        "body": "(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return &lt;Grid className=&quot;<em>endTestSection</em>&quot;&gt; &lt;GridItem columnSpan={12}&gt; &lt;HeadingText className=&quot;<em>endTest</em>Header&quot;&gt; Pick the winner of <em>your</em> A&#x2F;B <em>test</em>: &lt;&#x2F;HeadingText&gt; &lt;&#x2F;GridItem&gt; &lt;GridItem columnStart={5} column<em>End</em>={6"
      },
      "id": "607256cae7b9d2df5ba5c67c"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:21Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.60374,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> version descriptions",
        "body": " <em>your</em> New Relic One application by pressing CTRL+C in <em>your</em> local server&#x27;s terminal window. Now, you&#x27;ve added descriptions for <em>your</em> competing designs and <em>your</em> charts. In the next lesson, you’ll create a new <em>section</em> of <em>your</em> application from user interface components. This <em>section</em> will be used to <em>end</em> the A&#x2F;B <em>test</em> with the click of a button."
      },
      "id": "6072569228ccbc932d51c172"
    }
  ],
  "/build-apps/ab-test/table-charts": [
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Extra credit"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 860.0493,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>tables</em>",
        "body": " to the <em>add</em>-<em>tables</em>&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-<em>tables</em>&#x2F;ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you"
      },
      "id": "60725692196a67b68c64a778"
    },
    {
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/embed/",
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "",
      "updated_at": "2021-03-31T01:53:55Z",
      "type": "",
      "external_id": "f6dba06ee883ff39a13eb7090bf3c91f9395d6e2",
      "popularity": 1,
      "body": "Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application. Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component. Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows. As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells. The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.92253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>tables</em> to your New Relic One application",
        "body": " action to your table! <em>Tables</em> are great, but interactive <em>tables</em> can be better: As a last update, you are going to allow users to act on each data row. <em>Add</em> the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when"
      },
      "id": "6063d633196a6796a1c6f441"
    },
    {
      "sections": [
        "Integrations and custom roles",
        "Recommended role",
        "Optional role",
        "Important",
        "List of permissions",
        "Common permissions",
        "Service-specific permissions",
        "Permissions to link projects through the UI"
      ],
      "title": "Integrations and custom roles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Google Cloud Platform integrations",
        "Get started"
      ],
      "external_id": "d4f60e2d8413ddde9a342980d75a0e216af9baa4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/google-cloud-platform-integrations/get-started/integrations-custom-roles/",
      "published_at": "2021-04-16T16:37:10Z",
      "updated_at": "2021-04-16T16:37:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To read the relevant data from your Google Cloud Platform (GCP) account, New Relic uses the Google Stackdriver API and also other specific services APIs. To access these APIs in your Google Cloud project, the New Relic authorized account needs to be granted a certain set of permissions; GCP uses roles to grant these permissions. Recommended role By default we highly recommend using the GCP primitive role Project Viewer, which grants \"permissions for read-only actions that do not affect your cloud infrastructure state, such as viewing (but not modifying) existing resources or data.\" This role is automatically managed by Google and updated when new Google Cloud services are released or modified. Optional role Alternatively, you can create your own custom role based on the list of permissions, which specifies the minimum set of permissions required to fetch data from each GCP integration. This will allow you to have more control over the permissions set for the New Relic authorized account. Important New Relic has no way of identifying problems related to custom permissions. If you choose to create a custom role, it is your responsibility to maintain it and ensure proper data is being collected. To customize your role you need to: Create a Google Cloud IAM Custom Role in each one of the GCP projects you want to monitor with New Relic. In each custom role, add the permissions that are specifically required for the cloud services you want to monitor according to the following list. Assign the custom role(s) to the New Relic authorized account. List of permissions Common permissions All integrations need the following permission: monitoring.timeSeries.list service.usage.use Service-specific permissions For some GCP integrations, New Relic will also need the following permissions, mainly to collect labels and inventory attributes. Integration Permissions Google AppEngine n/a; Google App Engine does not require additional permissions. Google BigQuery bigquery.datasets.get bigquery.tables.get bigquery.tables.list Google Cloud Functions cloudfunctions.locations.list Google Cloud Load Balancing n/a; Google Cloud Load Balancing does not require additional permissions. Google Cloud Pub/Sub pubsub.subscriptions.get pubsub.subscriptions.list pubsub.topics.get pubsub.topics.list Google Cloud Spanner spanner.instances.list spanner.databases.list spanner.databases.getDdl Google Cloud SQL cloudsql.instances.list Google Cloud Storage storage.buckets.list Google Compute Engine compute.instances.list compute.disks.get compute.disks.list Google Kubernetes Engine container.clusters.list Permissions to link projects through the UI To be able to see the list of projects that you can link to New Relic through the UI, your New Relic authorized service account needs the following permissions: resourcemanager.projects.get monitoring.monitoredResourceDescriptors.list If you do not want to grant New Relic authorized account the permissions that are needed for the linking process through the UI, you have the following options: Assign the Project Viewer or Monitoring Viewer role initially to the authorized account to link Google Cloud projects to New Relic through the UI. After the projects are linked, assign a Google Cloud custom role to the authorized account. Use New Relic NerdGraph to link Google Cloud projects to New Relic. This does not involve listing the viewable projects. However, you must know the id of the project you want to monitor. For more information, see the NerdGraph GraphiQL cloud integrations API tutorial.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.83601,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is being collected. To customize your role you need to: Create a Google Cloud IAM Custom Role in each one of the GCP projects you want to monitor with New Relic. In each custom role, <em>add</em> the permissions that are specifically required for the cloud services you want to monitor according to the following"
      },
      "id": "603ebb3564441f34b64e8874"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/mysql3.png",
      "url": "https://newrelic.com/blog/how-to-relic/how-to-monitor-mysql",
      "sections": [
        "Key MySQL Metrics to Monitor",
        "Uptime",
        "Connections",
        "Memory usage",
        "Storage speed",
        "Query speed",
        "Query optimization metrics",
        "Temporary Files and Tables",
        "Locks",
        "Missing indexes",
        "Monitoring MySQL with New Relic",
        "Install the agent and integration on an Ubuntu server",
        "Configure the MySQL integration",
        "View MySQL data in New Relic",
        "From integration to observability"
      ],
      "published_at": "2021-04-16T04:25:17Z",
      "title": "Monitoring MySQL Database Performance with New Relic",
      "updated_at": "2021-04-14T00:08:57Z",
      "type": "",
      "external_id": "3094a8de9f54b579f4a2c39828a89388637abf35",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Monitoring MySQL Database Performance with New Relic Aug 24, 2020 • 11 min read By Tomas Fernandez Zavalia MySQL is an open source relational database system that, like Linux, started its history as a personal side project. Over its 25 years of history, MySQL has gained significant traction, and today a broad range of companies, such as Sony and Uber, use it to run their multi-petabyte mission-critical databases. In a way, MySQL has been a victim of its own success. It’s easy enough to run that developers may take it for granted and assume it doesn’t need supervision. In reality, MySQL is a complex system with a delicate balance you must monitor closely. It exposes a lot of useful metrics you can’t afford to miss because they highlight where bottlenecks are, when it’s time to upgrade, and what queries you should optimize. Like most relational databases, MySQL organizes data using databases (also called schemas) and tables. However, MySQL has a unique modular architecture that lets you choose the best low-level storage engine for the job. MySQL exposes its inner workings in all these levels through dozens of metrics. MySQL is also extremely flexible. You can run it as a single instance, as a primary-secondary cluster, thank to replication, or in multi-master mode. And third-party solutions like Vitess allow you to create horizontally-scaled clusters. Key MySQL Metrics to Monitor Let's start by reviewing some of the most important metrics to monitor in any MySQL instance. To view all available metrics, check out our MySQL integration docs (which we’ll walk through setting up below). Uptime It may sound self-evident, but many teams set alerts for server downtime while forgetting to monitor the MySQL process itself. When the database is down, you want to get notified immediately. Connections MySQL sets a hard limit on the number of simultaneous connections. When you reach it, new connections are blocked until someone disconnects. MySQL allows 151 connections by default. Changing the limit is simple: SET GLOBAL max_connections = 200; Bear in mind that each connection needs at least 3MB, so always try to keep the number of connections as small as possible. To determine the optimum number of connections to set, monitor three metrics: net.maxUsedConnections: The maximum number of connections recorded since the database started. Use this value as a reference to set max_connections. net.threadsConnected: The current number of active connections. net.connectionErrorsMaxConnectionsPerSecond: The number of connections failed per second due to the max_connections limit being reached. If the value is higher than zero, you need to either raise the limit, set up connection pools for your applications, or consider installing a load balancer like ProxySQL. Network issues and buggy clients can also affect MySQL connections. Watch net.abortedClientsPerSecond to detect applications not closing connections properly. A high rate usually indicates problems in the network. Memory usage Databases need a lot of memory to work well, so monitoring memory is vital to keep your MySQL in top shape. First, set up monitoring for the server to ensure it has enough RAM: memoryFreeByes memoryUsedBytes memoryTotalByes Then, on the MySQL side, monitor these metrics: db.innodb.bufferPoolPagesTotal: The number of pages in-memory holding data. You want this number to be as high as possible to reduce disk activity and increase performance. db.innodb.bufferPoolReadsPerSecond: The number of pages not found in-memory that need to be retrieved from disk. If the value is more than 5-15% of db.innodb.bufferPoolPagesTotal, the database needs more memory. In that case, check the server RAM and increase the db.innodb_buffer_pool_size setting on MySQL. db.innodb.logWaitsPerSecond: If this value is consistently high, it means that the log buffer is set too low. In that case, increase innodb_log_buffer_size until the problem goes away. Storage speed After memory, disk I/O speed is the most crucial factor for database performance. Even if the system has enough RAM to allocate the complete database, it’ll still need disk I/O to ensure transaction consistency. The main database workload shapes disk activity. For Online Transaction Processing (OLTP) systems (e.g., systems used for online purchase processing), the following metrics should be smooth and steady. Peaks indicate possible bottlenecks and latency for your users. On the other hand, for Online Analytical Processing (OLAP) systems (e.g., systems used for budgeting and forecasting), uneven activity is a lot more common and should be expected. To keep an eye on workload, monitor the following: db.innodb.dataReadsPerSecond: The number of reads per second. db.innodb.dataWritesPerSecond: The number of writes per second. db.innodb.osLogWrittenBytesPerSecond: The transaction log throughput. This value is proportional to how much the data changes over time. Query speed Watch these metrics to monitor query speed and capture a baseline for your database: query.questionsPerSecond: The number of queries sent by clients. query.queriesPerSecond: The total number of queries per second (QPS), including administrative commands and stored procedures. It measures the raw capacity of the database. query.maxExecutionTimeExceededPerSecond: The number of SELECT statements timed out per second. For OLTP workloads, you never want this value to exceed zero. If you find that your queries are timing out, optimize them. Query optimization metrics Query optimization is where you can make the most significant impact on MySQL performance. To identify long-running queries, activate the MySQL slow query log: SET GLOBAL slow_query_log = 1; SET GLOBAL slow_query_log_file = '/var/log/mysql/mysql-slow.log'; Then set a reasonable query time to capture the worst-behaving queries on a first pass: // 3 seconds threshold SET GLOBAL long_query_time = 3; As performance improves, you can reduce the query time and repeat the process. Once the feature is active, monitor query.slowQueriesPerSecond, analyze the log, and use an EXPLAIN statement to find which queries do worse. Depending on the case, you may need to rewrite them, add or modify indexes, or restructure your tables. Here are some additional metrics to monitor while optimizing queries. Temporary Files and Tables MySQL creates temporary files and tables on disk for operations such as GROUP BY, ORDER BY, or UNION that don’t fit in-memory. Since these can cause excessive disk I/O, keep a close watch on these metrics: db.createdTmpDiskTablesPerSecond measures tables. db.createdTmpFilesPerSecond measures temporary files. While it’s not always possible to reduce these values to zero, you can minimize temporary disk activity by adjusting sort_buffer_size and join_buffer_size, and rewriting queries. Locks MySQL uses table- and row-level locks to ensure data consistency. Poorly written queries and some administrative tasks can lead to long-running locks that block other clients. The main metrics for lock activity are db.tablesLocksWaitedPerSecond for tables, and db.innodb.rowLockTimeAvg and db.innodb.rowLockWaitsPerSecond for rows. Missing indexes MySQL uses indexes for filtering, sorting, and joining tables. When queries and table structures don’t line up, MySQL is forced to scan the whole table. This situation uses up a lot of extra memory and causes heavy disk I/O. Monitor these metrics for details: db.selectFullJoinPerSecond and db.selectFullJoinRangePerSecond indicate whether your tables need additional indexes. db.innodb.bufferPoolReadAheadRndPerSecond helps detect inefficient table-level reads. Monitoring MySQL with New Relic Our MySQL integration uses the New Relic Infrastructure agent to collect and send performance metrics from your MySQL database to our platform.  You can see  your database server’s health and analyze metric data so that you can easily find the source of any problems The integration is compatible with MySQL version 5.6 or higher. In the following example, we’ll show you how to set up Infrastructure Monitoring for an  Ubuntu server running MySQL. If you have a different host OS, check the agent documentation for alternative instructions. Note: You can also monitor MySQL as a service running in Kubernetes or ECS. Install the agent and integration on an Ubuntu server From New Relic One, navigate to your account drop-down (in the top-right corner) and select Add more data. Select your operating system (in this case Ubuntu), and follow the prompts to get your license key and select your Ubuntu version. To deploy the Infrastructure agent and the MySQL integration, run the following commands on your server: Import Infrastructure agent GPG Key. curl -s https://download.newrelic.com/infrastructure_agent/gpg/newrelic-infra.gpg | sudo apt-key add - Add the New Relic repository (view all distributions here). printf \"deb [arch=amd64] https://download.newrelic.com/infrastructure_agent/linux/apt bionic main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Install the infrastructure agent (newrelic-infra) and MySQL integration (nri-mysql). sudo apt-get update && sudo apt-get install -y newrelic-infra nri-mysql Configure the MySQL integration Add a monitoring user in MySQL. mysql -e \"CREATE USER 'newrelic'@'localhost' IDENTIFIED BY 'MONITOR_USER_PASSWORD';\" mysql -e \"GRANT REPLICATION CLIENT ON *.* TO 'newrelic'@'localhost';\" Configure the MySQL integration. cd /etc/newrelic-infra/integrations.d sudo cp mysql-config.yml.sample mysql-config.yml sudo nano mysql-config.yml Fill in the password.hostname: hostname: localhost port: 3306 username: newrelic password: MONITOR_USER_PASSWORD Set remote_monitoring to true. Capture extended_metrics and extended_innodb_metrics. extended_metrics: 1 extended_innodb_metrics: 1 If you have MyISAM tables, also set extended_myisam_metrics: extended_myisam_metrics: 1 Restart the infrastructure agent to complete the setup.systemctl restart newrelic-infra A full list of configuration options is available in our MySQL integration documentation. View MySQL data in New Relic From New Relic One, navigate to Infrastructure to see the incoming data about your servers. To start monitoring your MySQL databases, navigate to Infrastructure > Third-party Services > MySQL Dashboard. Here are a few example charts created based on our integration’s configuration: A QPS graph measures the raw efficiency of your database The Slow Queries chart lets you know when it’s time to optimize your database Use the Max Connections graph to fine tune max_connections Use the I/O activity for the network and disk to find bottlenecks in your system To create more advanced charts and custom dashboards, check out the data explorer. From integration to observability If data is the application’s lifeblood, then the database is its heart. Reliable database performance is vital in any business. By monitoring a few key metrics, you can better understand how your MySQL servers are functioning. The MySQL integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. Make our MySQL integration an essential part of your observability stack. Check out our full list of on-host integrations for more. If you are ready to take control of your databases, sign up for 100GB of ingest per month and one Full-Stack Observability user license—free forever!   By Tomas Fernandez Zavalia Tomas started his career as a PHP developer. After graduating, he worked at British Telecom as head of the Web Services department in Argentina. After that, he went to IBM, where he wore many technical hats: DBA, Sysadmin, and DevOps. He's now an independent consultant and writer. He loves to learn and to teach about technology. In his free time, he likes reading, sailing, and board gaming. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.17625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Temporary Files and <em>Tables</em>",
        "body": ", <em>add</em> or modify indexes, or restructure your <em>tables</em>. Here are some additional metrics to monitor while optimizing queries. Temporary Files and <em>Tables</em> MySQL creates temporary files and <em>tables</em> on disk for operations such as GROUP BY, ORDER BY, or UNION that don’t fit in-memory. Since these can cause"
      },
      "id": "6076329a196a67a65164a773"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/1621DA95-52CD-41D0-B213-21D85D116ED8_1_201_a.jpeg?h=99bb2061&itok=AHnzfGKB",
      "url": "https://newrelic.com/blog/nerd-life/observy-mcobservface-episode-3-bobby-tables",
      "sections": [
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:29:41Z",
      "title": "Observy McObservface Episode 3 - Firefighting and DevOps: The Platypus Incident",
      "updated_at": "2021-04-13T23:25:47Z",
      "type": "",
      "external_id": "8b9ec69b18904641bab8bb353bff9dabb8200f57",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Culture Observy McObservface Episode 3 - Firefighting and DevOps: The Platypus Incident Aug 5, 2020 • 22 min read By Jonan Scheffler This week we were joined by Bobby Tables of Firehydrant.io, a world-renowned purveyor of artisanal, handcrafted incident response services that are, in fact, the opposite of that; perfectly replicable and entirely automated. Bobby talks us through some of the motivation behind the path he and his co-founders walked (sprinted?) when starting their company and the market circumstances that have created a demand for automated incident response. We also touch on the distinction between DevOps and SRE, the pros and cons of microservices, and one particularly memorable incident involving a platypus and a fire hydrant. Should you find a burning need to share your thoughts or rants about the show, please spray them at devrel@newrelic.com. While you’re going to all the trouble of shipping us some bytes, please consider taking a moment to let us know what you’d like to hear on the show in the future. Despite the all-caps flaming you will receive in response, please know that we are sincerely interested in your feedback; we aim to appease. Enjoy the show! Jonan: I'm joined today by my guest, Bobby Tables. How are you today, Bobby? Bobby Tables: I am doing super well, man. How are you? Jonan: I'm doing great. I'm excited to talk to you about some FireHydrant.io stuff, and specifically incident response. I'm really curious about incident response because I'm not a DevOps professional, and I never really have been. Also, before we get into that, I want to hear about you. Tell me who you are and how you ended up here. Bobby Tables: My name is Bobby Tables. People call me that after the xkcd comic, after a mom names her child a SQL injection attack. My real name is Robert Ross. Previous to starting FireHydrant with two of my friends—we were all in the DevOps space—but I worked at Namely HR, where I was building a lot of developer tools. I was on the SRE team. Before Namely, I was at DigitalOcean and before that, I was at Thunderbolt Labs doing a lot of really cool things with that consultancy. So a lot of developer tools in my life, and it had been a really fun time to build it for myself and for others. Jonan: I remember Thunderbolt. How long ago was Thunderbolt? Bobby Tables: I think I was at Thunderbolt Labs, I want to say, six years ago. Jonan: You worked with Bryan Lyles, maybe? Bobby Tables: I did. Jonan: I remember Thunderbolt Labs because you had great stickers. You've always been on point with the branding. At Thunderbolt, you had really good branding and you also have lovely branding at FireHydrant. In fact, I remember an episode recently where there was a Twitter exchange that ended up with quite an interesting logo on your homepage. I wonder if you want to share a story about that. Bobby Tables: So, we somehow ended up engaging with Corey Quinn on Twitter and we posted to Corey on Twitter, from our corporate FireHydrant account, we said, “If you draw a logo for FireHydrant, we'll make it our logo for the rest of the day on our website.” And there was a little bit of exchange. He said, “Don't say things if you won’t actually do it.” And we said, “We're serious.” And Corey recently posted the exchange that happened in their Slack.org, and it basically said, “I need you to draw the duckbill logo peeing on a fire hydrant.” So we get this logo back, I want to say, 30 minutes later, something like that. And I went into our WordPress and uploaded the logo and... Jonan: You had you a duckbill platypus peeing on a fire hydrant... Bobby Tables: We did. Jonan: ... as your logo for the rest of the day? Bobby Tables: We did, yeah. Jonan: It's amazing. Bobby Tables: It got a good laugh. It was pretty funny. And we hold that moment near and dear to our hearts and in the company. Jonan: So you're drinking an old-fashioned? Bobby Tables: I am. Jonan: I'm having some scotch. This is my Operation Shamrock class that I got at New Relic back in the day, when they went and opened an office in Dublin—which I think was their first office overseas. They called it Operation Shamrock. Bobby Tables: That's great. Jonan: So the company that you've started now, FireHydrant, how long ago did you start up? Bobby Tables: The first commit for FireHydrant was in September of 2017. And FireHydrant started as a video series where I wanted to record building an application from scratch. It was a Ruby on Rails application. So I recorded every second of FireHydrant being built for the first 40 hours. And then I had a friend say, \"Hey, what you're building is way more valuable.\" So FireHydrant was a project to basically help with incident response. That was always its intention—to be that, but then I just kind of stopped recording after 40 hours, and then I had a couple of friends join in the fun. And then in December of 2018 is when we raised a seed, and we started the project full-time as a team. So here we are—we have some great clients, and we’re helping incident response. Jonan: How many people are you up to now? You're growing quickly. Bobby Tables: We've grown pretty well. We have 16 people now. Jonan: Wow! And so it was about a year and a half ago? Bobby Tables: A little over a year and a half ago. Jonan: That's awesome. What is it like to raise funding for an idea you have? I have a lot of friends who do these startup things. It seems to be kind of a path for a software engineer of your experience level. I just don't understand the process. Do you just announce on Twitter, \"Hey, someone give me $1 million.\" Where do you go? Bobby Tables: A couple of investors in New York City reached out to us, and I feel bad even telling this story, because there's so many founders that say they had to talk to 50 investors before they were able to get a term sheet. I really feel so lucky being able to say that we had a great idea, we had some really enthusiastic investors, and honestly, that's how we raised it. We were able to tap into our network that had raised a little bit of capital in the past as well, and we had some advice there. We were guided through the whole process, read a lot of books—a lot of books—we definitely tried to read as much as we could before signing anything. But we're really lucky. We have some of the best investors we probably could have ever asked for. So Work-Bench was our first investor, and then our Series A, which closed earlier this year, is Menlo Ventures, which is a really well-established firm. They have investments in Uber, Roku, Warby Parker. So we feel really lucky and we're solving some really cool problems—we just keep the vision moving us forward. Jonan: So I looked at some of your blog posts. What I think your product does is that when you have an incident at your company, FireHydrant.io will be initiated by someone or even automatically initiated when some threshold metric is reached, and it manages the entire incident lifecycle. So suddenly, people start to get the right Slack messages to let the right people know that systems are down and what steps to take next. It presents to them playbooks and resources to walk through, fix the problem; try rebooting this, try rebooting that, set up this new instance of this application. And then in the end, it wraps it all up into a tidy report that you can then use for your retrospective analysis of the incident. How'd I do? Bobby Tables: That was great. Do you want a marketing role? Jonan: I've been at New Relic now for three weeks. Bobby Tables: You just joined New Relic. That's probably not a question yeah... That was a great description of FireHydrant. So we think of FireHydrant—as it really is baked into the name—the tool that helps you put out a fire. So with a lot of the alerting tools that are out there, they kind of receive a signal and they'll wake you up. And that's really what these alerting tools are kind of built to do, and they do it very well. One of the pains that I felt and my team felt was that once I get woken up, what now? So FireHydrant was kind of born with that idea in mind. You have a smoke detector, your smoke detector is going to wake you up when it smells smoke, but it's not going to help you at that point. It's just going to get you out of the house to call someone else to fix the problem for you. Bobby Tables: When you think about a fire hydrant on the street, it's not directly responsible for putting out the fire. Firefighters are responsible for putting out the fire, and the fire hydrant is just an essential tool. So we help you organize the right people as fast as possible. We'll create a Slack channel for your incident. We'll create a Zoom bridge. We can even do things like post a run book for the services that are impacted: Here's how you do a rollback, here's how you send a USR2 signal to reload config. You can store all of that, and FireHydrant makes it really, really easily accessible. If something's broken, New Relic is telling you, \"Hey, your APM is way above threshold.\" It can cause a sense of panic, and you might forget your process. Engineers, they really just want to do the right thing. No engineer is ever going to do anything in an incident response process that's going to intentionally make something worse. But what happens is that they might go into cognitive tunneling where they forget to create a Slack room or update a status page I/O or update our status page product. That's common. So FireHydrant was kind of built around the idea of how we could make it so you have the same process every single time, and we'll do it for you in a few seconds so you can do what you're really good at as an engineer, which is solve the problem. Jonan: Which makes it a brilliant product, I will reiterate. Having been in the position many times where I get a PagerDuty alert for some application that is technically in my sphere of responsibility but I haven't worked with very often or maybe I'm new to the company—even if I am one of the more experienced engineers on my team—when I get that alert, I go into an application that I haven't coded on in a few months. I don't remember all of the things. I just start poking about it at random. It's so valuable to have these run books, which is, from my perspective, a relatively recent innovation. I'm sure that there were people doing this 10 years ago, but I feel like when I first came into the industry about that time, it wasn't a common practice, certainly. And since then, we've gone all in on this DevOps perspective, a term that arose from trying to bridge the gap between developers and IT or systems folk that, really, are the same thing: We're all working toward the same goals, and we're all writing code, and we're all trying to build things in ways that are replicable using tools like FireHydrant. So what is the distinction in your mind? Bobby Tables: Yeah, the question is one that I've had many discussions over beers at many bars. So I think that one of the things you hear, or you can just Google—start typing in “DevOps,” one thing you'll see pop up in Google is “DevOps versus SRE.” And I think it's important to make a distinction here first. So DevOps has a lot of different ideas. It's certain practices around CI/CD. It's certain practices around building tooling for maybe rolling back to employees or to alert, and the process is kind of around that. It's just that. It's just a bunch of ideas. And that's where SRE kind of comes into play, and it's a framework of those ideas. So if you think about an object oriented-language, Google has a really great presentation about this. SRE implements DevOps. SRE inherits from DevOps. And that's a nice way to kind of separate the idea of DevOps versus SRE, I think. Jonan: So, site reliability engineering is an implementation of DevOps principles—DevOps is a collection of ideas, and SRE is the actual implementation? Bobby Tables: Yes. Jonan: So from outside of that world, I started seeing people use the term SRE about the time I started hearing about DevOps—but presumably, those two didn't happen in tandem, did they? So there was a foundational book about DevOps. There was a book that maybe had “unicorn” in the title? Bobby Tables: Yeah. The Unicorn Project: A Novel about Developers, Digital Disruption, and Thriving in the Age of Data, by Gene Kim came out more recently. I think The Phoenix Project by Gene Kim was the one that talked a little bit more directly—in a fictional sense—about DevOps. It’s a really good book. It talks about almost a scary realistic world of DevOps and kind of moving toward it from a non-DevOps world. I haven't read the new one that you're mentioning, The Unicorn Project. Jonan: I was misremembering because I started going to DevOps meetups. Just in the last year or so, I really took an interest in this kind of stuff. It's fascinating to me to look at systems architecture, the way that I would build an application that I'm designing components for. I'm still kind of a fan of microservices now, the bitty, tiny microservices. There is a threshold where you reach and... Bobby Tables: Nano services? Jonan: Nano services, yeah. I think people over-complicated the message there, but I'm still a fan of having apps that approximately have a responsibility. This is where the users live. And architecting a system that way. I use CRC cards sometimes, and I'll do these mind maps when I'm getting ready to set up an application. I feel like systems architecture was very similar, but today, the pieces on the playing field, the number of Legos you have available to you when you're designing a system is huge. If you look at that CNCF page that describes the applications that are under the Cloud Native Computing Foundation, I think there must be 50 logos on that page. And I feel like it's just seeing this explosive growth. If you use the Kubernetes ecosystem, it's just a barometer for the growth of this type of cloud architecture, I guess. It's exploding. And by next year, we may have twice as many. So you've got all of these Legos that you're trying to keep track of and to me—from the outside, because it's not my full-time job, as it is yours—it just looks so hard to keep up with. I would rather try to keep up with JavaScript's ecosystem. Bobby Tables: That's such a good way to compare that. It's interesting that you said Legos, because I talk about this a lot—where if you go to Legoland and you stand very far away, it looks like these sculptures that they're making with Legos have a curvature to them. But if you get close enough, it's still jagged lines. If you put your hand on it, it's still pretty uncomfortable. You still wouldn't want to step on that sculpture. With these Legos, you're able to make these extremely elaborate systems with all these pieces now. But the problem is you're just making it an extremely complex system. And if you don't have a framework or mindset to really manage that system—if you're not really setting up your team for success to manage that system—you're almost doomed. I think a lot of the Kubernetes architecture and all of the other projects around the CNCF; service meshes are becoming a huge thing, right? I just had another layer of complexity, and how do you even graph how a request gets to a process anymore? It's becoming insane as compared to 16 years ago, where I have Apache and I have a little PHP thing listening on port 5,000, whatever it was. It's just so different. Jonan: Back in the day, I used to have to sew together a request myself using a request ID. I would find the app at the front where the user logged in and get the request ID, if we had a request ID and I hoped we did, so I'm not correlating timestamps across microservices. And I'm still searching logs for that request ID and sewing it. And that's all gone now. And we just keep building abstractions that make everything easier. Bobby Tables: And I can speak from experience with FireHydrant. You almost have to build these things from the start now. You kind of have to have this architecture that is going to have a request ID at the load balancing glare that's going to propagate all the way down into pub/sub. Diagnosing these problems is becoming very, very hard. And that's why service-oriented architecture, while it is good for a lot of companies, it's probably not a good idea to really start with. We started with a model. I came from a microservice architecture for my last two companies, and we said, \"Nope, we're going to do a monolith,\" because if something breaks, guess what? You can only break in one place. So, we're going to go there. Jonan: Service-oriented architecture is designed to address pain. And if you don't have the pain yet, then you don't know correctly which pieces to extract. Bobby Tables: Right. And I think that one of the interesting things about architecture that's not talked about enough is that it should follow a lot of the same principles used in good, object-oriented programming. We have solid principles. We have domain-driven design, single responsibility principle. You talk about open-close, dependency inversion. But we don't talk about those same concepts in architecture, which is totally realistic to do. Why can't we have a system that is open-close where we can add a service that extends the functionality of the system? Why can't we do a Liskov substitution where—because we have such a well-defined API for this service—we need to make it a little faster so we swap it with go app, but because it has the same API signature, consumers don't care. We don't talk about architecture and design enough. I think we just throw services at the problem and we redesign the endpoint every time differently—every single time—and we end up with these spaghetti monsters. Uber is even talking about this right now. They have a new blog post about that. I think it was some crazy style, one service to three engineers, and Uber has thousands—thousands—of engineers. Could you imagine doing that? Jonan: I cannot imagine what it's like to be on an engineering team inside that company. I think it has to do with the very, very rapid growth that they experienced. They exploded overnight. They're producing a lot of interesting technology. They have one of the more popular backends for Prometheus. So Prometheus is an application that pulls your applications. So rather than me, when I process a payment for customer Bobby Tables, rather than me calling out to some metrics endpoint and saying, \"Hey, Bobby just paid us $10,\" I just kind of write that locally to some temporary store, and Prometheus comes along every minute or so and pulls an endpoint on my payments application. It gets all of the data of all of the metrics that I've recorded, and it stores them. But Prometheus is not designed as a project to hold that data long-term. It takes it and puts it into a backend store. And Uber M3, I think, is the name of it. Does that sound right? Bobby Tables: Yeah. M3 does sound right. Jonan: That's one of the backends for this. So then Prometheus will use Uber's M3 open source project to store that data longer term. Those kinds of technologies—if you look at the number of time series backends that are available for Prometheus, there's 100 right now. The products that I know of that do the thing you're doing, there's one unified product for handling incident response. So my actual question is not, \"Hey, name all your competitors,\" but why is that not more at the forefront of people's minds? Because it's a thing everyone deals with, right? Every SRE I've ever worked with had the run books and the systems, but it was all hand-rolled. They all had customized artisanal processes. And you're handing a company a whole process in a box. Why isn't that more common? Bobby Tables: That's a great question. I think that FireHydrant can exist today because we've standardized so many other things. Yes, things have gotten more complex, and Kubernetes has started to definitely dominate the way that a lot of modern application architectures are built. I think every major Fortune 100 right now said that they're experimenting with Kubernetes. I remember some article about that, some insane stat. And I'm talking about that because I think it's the same way that FireHydrant can exist today. We started standardizing on so many things in the last 10 to 15 years. Containers exist because we were able to standardize on a format. Docker created this standardized, portable format. Without that standardization, what would Kubernetes do? Because all these abstractions with really well-defined interfaces started to exist, Kubernetes was able to come in and bundle those things together. FireHydrant's the same thing. We had DevOps, and then SRE started to become prominent in the space. I think a lot of organizations are thinking about reliability in a more structured sense. And then we also had people standardized on a chat tool. A lot of the world has moved to Slack. Jonan: I agree with you 1,000%. I know that you are a fellow Rubyist, so I want to take a minute to appreciate what value comes to a community by having an opinion. I think Rails did an amazing thing in getting a lot of programmers to swim in the same direction at the same time. There is definitely something to be said for standardization, the open telemetry change that has come recently where we now have one way to report metrics. I worked with New Relics’ proprietary format back in the day. I would much rather have a metrics format that everyone can use, that we can all interoperate with, right? I feel like we're reaching a point with the DevOps ecosystem and the SRE ecosystem, that we are now learning the value of standardizing how we build these things and how we respond to these things. So if I were to ask you to make some predictions for the future, what's it going to be like in your space in a year? So in a year, I can call you up to be on the podcast and we'll tell you how wrong you were. Bobby Tables: Yeah. I'd love that, set a reminder. I have two predictions that I'm actually not making up on the spot. I've been thinking about this a lot. One of them is that we're going to hit a point where service-oriented architectures are becoming incredibly cumbersome and super complex to the point where we're going to need to get away from Google Sheets as the de facto way of listing the services we're running and who owns them. So I think that we're actually going to see a lot of tools come into play for cataloging the services we're running in production. Because there are a lot of challenges that come with running multiple services that are not just around engineering operations. It's a question of, “How do you make this compliant?” For SOC compliance, you have to log when you deploy a lot of the time. You have to have a deploy log. And when you have 100 services deploying multiple times a day, where does that information go? What is the service? And then people are going multi-region, multi-cloud, even—how do we know where the services are running? That's a challenge that needs to be solved. A lot of companies just have YAML and a GitHub repository to represent that catalog, and that's not going to be sufficient as the year progresses. Jonan: I think it's particularly relevant to what you do in incident response. If there's an incident, what I want to know right away is what things have changed in the last 24 hours, or one hour, or 10 minutes. What things in the system changed? Because I know enough about computers to know that if you don't poke the bear, it just keeps sleeping. Don't change anything ever, right? So you've got to find those changes. And I think service discovery and those kinds of things are really important to doing that. So your prediction for the next year is that we will have some popular player in the ecosystem or some project that does that service discovery well. And, in an opinionated way, that starts to dominate as the standard? Bobby Tables: Yeah. Startups and venture capital—as annoying as it might be— are really good indicators of what's happening. If you look at the last six months, a lot of service catalog startups have been coming out where it is their sole responsibility to list the services you're running and the changes that they've recently had. So, it's happening. The challenge is becoming, “How do we define even what a service is?” We're going to start seeing that challenge. And I'm hoping that the CNCF or some governing body creates a definition of what a service is. Is a load balancer that we don't run a service? If you ask me, that is a service, because your customers don't care that it's on Amazon's ELB, but it's a service that you run. I think that we're going to need a well-defined version of what a service is and have a spec for it, an actual RFC of what a service is. I think what's going to come with that—or hope so—we need a generalized labeling standard. The labels are all over the place. Every major cloud provider, every major metrics consumer—New Relic being one of them—every single one of these services has a way to tag and annotate things. But there is no definition that says what the keys should be and what the value should be for a service. So I really hope that happens. We're going to have someone define a standard set of labels. You could call it “CNCF Labeling Project,” for all I care, that says the name of the service, the purpose of the service, the component that it powers, the team that owns it, and other key value pairs along those lines. And if you think about the value that provides—if I say I have this key value system that I can then add to my ELB in Amazon, because Amazon supports tags, and then I have my deployment reference in Kubernetes that has annotations, and I have a metric that comes out and that has a key value pair—if I have a way to slice down all of those keys across the entire request cycle from ELB to deployment to metric, that enables a crazy amount of observability that we don't have today. It's cobbled together. So I think that we're going to see a service catalog come out. And I think to make that a reality, we're going to have to see a labeling standard come out. That will actually be a really interesting turning point for observability and linking that to the services that we've run in a standardized way. Jonan: I think that's a wise prediction, and I think it’s the most likely to happen so far in the brief history of Observy McObservface. This now being our third episode, that's quite an honor. We've had many predictions already, but you win the prediction game for now. Bobby Tables: Maybe I'll write it now to prove a point and say, \"Yes, it happened.\" Jonan: That should be a blog post. While we're on the subject, you made a blog post about how to make an old-fashioned, is that right? Bobby Tables: I did. Jonan: And was there fire in it? Did you use... you burned your... Bobby Tables: I did, from the back of an orange. I forget the name of the technique, but you can slice off what's called a “coin” on an orange and apply some flames to it as you squeeze and extract some of the oils from the orange and that kind of inserts it into the drink. So that gives it a nice orangy tone. Jonan: I appreciate this very much. I feel like the old-fashioned has become a developer drink somehow, but everyone has an opinion about that. I know software developers who craft their own bitters from scratch. I'm from Portland, and we just do that kind of stuff up here, but still very into the artisanal handcrafted. But I don't think people should be into our artisanal handcrafted incident response, and I'm really glad your company exists. I will repeat my prediction for the episode, which is that you're going to get bought out in a year and a half maximum, and you're going to stop taking my calls. But I really appreciate you taking this one and being on this podcast with me. It's been a real pleasure having you, Bobby. Thank you so much for joining us. Bobby Tables: No, the pleasure is mine. Thanks for reaching out, and I'm always happy to talk to the community. And the real goal for us is to just make developers happier with our tool, so if we're able to keep doing that forever, that's a win for me. Jonan: I am all about developer happiness. That's what I want to do with the rest of my life. Tell us where we can find you on the internet? Bobby Tables: I don't say too much, but you could find me on Twitter, @bobbytables. I'm also on github.com/bobbytables, happy to chat with anyone, if anything I said sounded interesting. Jonan: Awesome. Thank you so much. I'll see you again soon. Bobby Tables: Thank you. Listen to more Observy McObservface episodes. Related Topics Culture By Jonan Scheffler Jonan spends most of his time staring into tiny boxes and pushing buttons. He likes Ruby, Go, machine learning and playing with robots. Follow the author Jonan Scheffler on Twitter Jonan Scheffler on GitHub Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.60211,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Culture Observy McObservface Episode 3 - Firefighting and DevOps: The Platypus Incident Aug 5, 2020 • 22 min read By Jonan Scheffler This week we were joined by Bobby <em>Tables</em> of Firehydrant.io, a world"
      },
      "id": "6076287c28ccbc258751c197"
    }
  ],
  "/build-apps/ab-test/publish": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/publish/embed/",
      "sections": [
        "Publish your New Relic One application",
        "Versions and tags",
        "Tip",
        "Publish your first application",
        "Technical detail",
        "View your application in the catalog",
        "Submit catalog information",
        "Update your version tag"
      ],
      "published_at": "2021-04-16T02:02:46Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:07Z",
      "type": "",
      "external_id": "41ee1ef02494dc82084533ad141ff3202f8ae2d4",
      "popularity": 1,
      "body": "In the last lesson, you created catalog information for the A/B test app you've been building throughout this course. Now, it's time to publish your app to the New Relic One catalog and submit those catalog details. Versions and tags Publishing an application requires two key pieces of information: version tag An application's version identifies the code it contains and is stored in the Nerdpack's root-level package.json file. Every time you modify code in your Nerdpack and are ready to release it, you'll update the version in package.json. For example, if you fix some bugs in the first major version your application code, you might publish the changes under version 1.0.1. An app version's tags describe its state. For example, version 0.0.1 of a work-in-progress application might be published with a DEV tag to indicate that it's in development. Tip There are some rules governing how you can use tags and you can read about those in our tags documentation. Publish your first application Step 1 of 7 Change to the publish/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/publish/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/publish/ab-test. Step 3 of 7 Generate your own app UUID: bash Copy $ nr1 nerdpack:uuid -gf The UUID is used to identify your app in the New Relic One app registry. Because you're using code that we developed for this course, an application with the existing UUID already exists in the registry. By generating your own, you're now able to publish this application. Technical detail The UUID also ties your app to your account and, therefore, allows the application to make Nerdgraph requests on behalf of the account that installed it. Step 4 of 7 In package.json, set version to 1.0.0: { \"private\": true, \"name\": \"ab-test\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"2d923ba6-d231-4dd3-830f-b1923577a422\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } Copy New Relic One uses semantic versioning and, under this convention, 1.0.0 signals the first major release. Now, you're ready to publish! Step 5 of 7 Replace all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively. Step 6 of 7 Publish your New Relic One application: bash Copy $ nr1 nerdpack:publish -t DEV That's it! You published your application to New Relic's registry. The -t parameter specifies a tag for your published version. Among other logs, you should see the following confirmation in your console: bash Copy Publishing Nerdpack AbTest (9da77738-9cf6-43c7-9ba0-e3a8c6ac7380) ✔ Nerdpack published successfully! ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as DEV. For now, you've tagged the 1.0.0 release as DEV because it's still a work in progress. Step 7 of 7 View your app's registry information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 4 Version Date Tags ------- ------------- ------ 1.0.0 5 minutes ago DEV The results of this command detail the information stored in New Relic's registry for your application, including its UUID, version, and account ID. View your application in the catalog Now that your application is published and tagged, you can view it in the New Relic One app catalog. Step 1 of 3 Go to New Relic. Notice that you're not using the ?nerdpacks=local querystring parameter. You don't need it anymore because you're not serving your app locally. Step 2 of 3 From the homepage, navigate to Apps: From here, you can see your application under New Relic One catalog: Notice that this is different than when you locally served your app. Local apps and published apps you're subscribed to show under Your apps instead. Step 3 of 3 Click on your app to see more details: Notice the release date and app version. This page should show the information you created in the last lesson. It doesn't yet, because you haven't submitted that information to the catalog, and publishing your app doesn't do that for you. Submit catalog information Even though you've published your application, there are some things that the catalog doesn't know about. These are the descriptions, screenshots, and metadata you created in the last lesson. nr1 catalog is used to submit and view this information. Step 1 of 3 Submit your catalog information: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for AbTest 1.0.0 If everything goes right, you should see a success message notifying you that the screenshots and metadata were updated. You may, however, get an error when submitting this information to the catalog: bash Copy Uploading screenshots... › Error: 1 error while updating AbTest 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN If you do, try again in a minute or two. It can take a few seconds for the catalog to update with the new version of your application. If that doesn't work, make sure you published your app with nr1 nerdpack:publish. Step 2 of 3 View your catalog information: bash Copy $ nr1 catalog:info description: Nerdpack ab-test details: Display test data for our newsletter subscription A/B test displayName: AbTest icon.url: https://nr3.nr-ext.net/artifact-index-production/a685fec2-29fb-40b0-9f65-4178... previews.0.url: https://application-catalog-production.s3.us-east-2.amazonaws.com/nerdpacks/a... releaseDate: 2021-03-12T15:46:09.600138Z repository: https://github.com/newrelic-experimental/nru-programmability-course tagline: Win @ newsletter subscriptions version: 1.0.0 whatsNew.changes: Initial release! Includes: - A variety of charts for understanding the test r... whatsNew.version: 1.0.0 All the information from catalog shows here. Step 3 of 3 View your app in the catalog: Notice the tagline on the app's catalog entry. Click on the app to see more: Here, you see app details, a documentation tab, release notes, and screenshots. Update your version tag Your app looks great in the catalog, complete with metadata, images, and documentation. Before, you tagged the app as DEV because all of the information wasn't ready for public consumption. Now, it is. It's time to update your version tag. Step 1 of 2 Update your 1.0.0 app version from DEV to STABLE: bash Copy $ nr1 nerdpack:tag -t STABLE ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as STABLE. Without specifying a version, nr1 uses the version specified in package.json. You can specify a version with the -V command. Learn more about nerdpack:tag with the nr1 nerdpack:tag --help command. Step 2 of 2 View your app information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ------------- ------ 1.0.0 30 minutes ago STABLE The app is now tagged with STABLE, indicating it's ready for public use. Technical detail Even though the app is ready for public use, it's still only visible to users of your account. Other accounts can't see apps created by other private accounts unless those apps are added to the public New Relic One catalog. Now that your app is published and its metadata is submitted, you can subscribe your account to the app from the catalog. In the next lesson, you'll learn the ways to subscribe and unsubscribe to your new application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1049.6111,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Publish</em> <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "body": "In the last lesson, you created catalog information for the A&#x2F;B test app you&#x27;ve been building throughout this course. Now, it&#x27;s time to <em>publish</em> <em>your</em> app to the <em>New</em> <em>Relic</em> <em>One</em> catalog and submit those catalog details. Versions and tags Publishing an <em>application</em> requires two key pieces of information"
      },
      "id": "60730001e7b9d2de18a5c660"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application and click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 363.6104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add navigation to <em>your</em> Nerdlet",
        "body": " with platform UI and showing a stacked entity view. You&#x27;ve really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to <em>publish</em> and subscribe to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> so that it can run on our platform instead of <em>your</em> own local server. Second, is to learn how to deal with some common issues you might see in <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> development."
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 362.98065,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", no matter how complex. You can: Use our APIs to get data into <em>New</em> <em>Relic</em> from any source. Visualize that data in <em>your</em> custom applications. <em>one</em>.newrelic.com: Here’s an example of a custom <em>application</em> built on <em>New</em> <em>Relic</em> <em>One</em>. This <em>application</em> gives a highly detailed analysis of a website, using"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.17804,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.15573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    }
  ],
  "/build-apps/ab-test/subscribe": [
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application and click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1165.5576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add navigation <em>to</em> <em>your</em> Nerdlet",
        "body": " with platform UI and showing a stacked entity view. You&#x27;ve really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and <em>subscribe</em> to <em>your</em> <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> so that it can run on our platform instead of <em>your</em> own local server. Second, is to learn how to deal with some common issues you might see in <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> development."
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.26105,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", no matter how complex. You can: Use our APIs to get data into <em>New</em> <em>Relic</em> from any source. Visualize that data in <em>your</em> custom applications. <em>one</em>.newrelic.com: Here’s an example of a custom <em>application</em> built on <em>New</em> <em>Relic</em> <em>One</em>. This <em>application</em> gives a highly detailed analysis of a website, using"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.49353,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use tags <em>to</em> define the workload content",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.4714,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.46234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/ab-test/serve-app": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 362.98065,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", no matter how complex. You can: Use our APIs to get data into <em>New</em> <em>Relic</em> from any source. Visualize that data in <em>your</em> custom applications. <em>one</em>.newrelic.com: Here’s an example of a custom <em>application</em> built on <em>New</em> <em>Relic</em> <em>One</em>. This <em>application</em> gives a highly detailed analysis of a website, using"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-12T03:03:22Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.17804,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.15573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.14658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-12T03:00:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.14658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/ab-test/create-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/embed/",
      "sections": [
        "Create a Nerdpack",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-04-16T02:01:46Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "7487158c521f4cccda9ec299bae4c06242ad07e7",
      "popularity": 1,
      "body": "A Nerdpack is a package that contains all the files that make up a New Relic One application. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet artifact inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1272.7008,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Create</em> <em>a</em> <em>Nerdpack</em>",
        "body": "A <em>Nerdpack</em> is a package that contains all the files that make up a New Relic One application. Nerdpacks include files for metadata, Nerdlets, assets, and more. To <em>create</em> a <em>Nerdpack</em>, use the New Relic One CLI: bash Copy $ nr1 <em>create</em> --type <em>nerdpack</em> When nr1 prompts for a component name, use &quot;ab-test"
      },
      "id": "6072fee664441ffa0d9d8546"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: Copy the key you created. You'll use it to associate your New Relic account with the CLI. The CLI will then use the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name> with an arbirary name, the <User key> with the key you copied in Step 1, and the region with either us or eu. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 999.0896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install <em>and</em> configure the New Relic One CLI",
        "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To <em>create</em> a <em>Nerdpack</em> , you&#x27;ll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its <em>create</em> command. Install and configure the CLI Step 1 of 3 Select or <em>create</em>"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/embed/",
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "published_at": "2021-04-16T02:16:42Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "edab33e46fbc9f8e054670c52397176ce989ae3a",
      "popularity": 1,
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type nerdpack --name my-first-viz $ cd my-first-viz $ nr1 create --type visualization --name custom-viz The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ nr1 nerdpack:serve Then visit New Relic and navigate to Apps > Custom Visualizations > CustomViz to see it in action: Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack artifacts, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 975.2771,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to present that data, you might need to <em>create</em> something entirely unique. With the New Relic One SDK, we&#x27;ve provided you all the tools you&#x27;ll need to <em>create</em> your own visualizations. Build your custom visualization With the New Relic One SDK, you can <em>create</em> a <em>Nerdpack</em>, which houses your visualization code"
      },
      "id": "607105a064441fa6da9d8530"
    },
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 887.389,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Subscribe to your New Relic One <em>application</em>",
        "body": " want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you&#x27;ve built a New Relic One application from the ground up. You&#x27;ve used the nr1 CLI to <em>create</em> a <em>Nerdpack</em>, launcher, and Nerdlet. You&#x27;ve used many"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/embed/",
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-03-31T01:50:30Z",
      "type": "",
      "external_id": "ca6bf3fbbc9a8b6c767f9f9d59f055069300be80",
      "popularity": 1,
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 629.7387,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdpack</em> file structure",
        "body": " application with a monitored entity For basic component definitions, see our component reference. Generate <em>Nerdpack</em> components There are two ways to generate a <em>Nerdpack</em> template: Generate a <em>Nerdpack</em>: Use the New Relic One CLI command nr1 <em>create</em> and select <em>Nerdpack</em> to <em>create</em> a <em>Nerdpack</em> template that includes"
      },
      "id": "6063d566196a67d66cc6f473"
    }
  ],
  "/build-apps/ab-test/navigation": [
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application and click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.62418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>navigation</em> <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": ", navigate to entities, and build Location objects for entities from <em>your</em> <em>Nerdlet</em>. You can also use <em>navigation</em> for other Nerdlets and launchers. Step 1 of 10 Change to the <em>add</em>-<em>navigation</em>&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-<em>navigation</em>&#x2F;ab-test"
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Extra credit"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.22884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> tables",
        "body": " leave <em>your</em> custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets&#x2F;ab-test-<em>nerdlet</em>, <em>add</em> a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals"
      },
      "id": "60725692196a67b68c64a778"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/embed/",
      "sections": [
        "Add pie charts"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "c0f472d2ed9df8035313cd76ee83ec43e75d0a4a",
      "popularity": 1,
      "body": "You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.64815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> pie charts",
        "body": " lesson, you leave <em>your</em> custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets&#x2F;ab-test-<em>nerdlet</em>, <em>add</em> two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total"
      },
      "id": "6072ffcc28ccbc786651c18a"
    },
    {
      "image": "https://developer.newrelic.com/static/733ffe1b10df224863d5c0b4f69894ce/0086b/first-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/first-chart/embed/",
      "sections": [
        "Add your first chart"
      ],
      "published_at": "2021-04-16T02:09:02Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "a6647ae7e6f32626783c432c4c7a2d4e0d896f8d",
      "popularity": 1,
      "body": "In this course, you’re building an A/B test application for the New Relic platform. Previously, you learned about the New Relic One SDK and its component library. Now, It’s time for you to start building your application focusing first on chart components. Before you write any code, consult your design guide to remember what the application will look like when you finish: There are several charts you need to create, which may seem overwhelming at first, but take it one step at a time. The topmost chart, and the first you’ll create, is a line chart that shows the number of users who sign up for your newsletter and what version of your website they were shown. Step 1 of 8 Change to the add-your-first-chart/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-your-first-chart/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named newsletter-signups.js: bash Copy $ touch newsletter-signups.js Step 3 of 8 In this new file, create a component called NewsletterSignups to hold your first LineChart and some mock data: import React from 'react'; import { LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <LineChart data={[versionASignups, versionBSignups]} fullWidth /> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you’ve created two arbitrary data series which represent versions A and B of your test. Right now, you're using manually-crafted data points. In the future, you'll replace these with data queried from New Relic. Notice that you’ve specified a color for each series in the chart. The color metadata attribute takes any CSS-acceptable color format. Setting viz: 'main' means that you want to render the LineChart series as a line, the component's default display style. For the data prop in the LineChart component, you passed the two series in an array so that both are represented together. Finally, you used the chart’s fullWidth prop to stretch the chart’s width to fill the view. Step 4 of 8 In your Nerdlet's index.js file, import your new component and replace the default heading in your Nerdlet's render() method with your new component: import React from 'react'; import NewsletterSignups from './newsletter-signups'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-your-first-chart/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the LineChart displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In seven steps, you’ve breathed life into your New Relic One application. Instead of a bland “Hello world” message, your application now shows a colorful line chart with two mocked data series. These data series represent server-side traffic for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another chart type.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.87534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>your</em> first chart",
        "body": " at this point in the course. By navigating to the correct directory at the start of each lesson, you leave <em>your</em> custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets&#x2F;ab-test-<em>nerdlet</em>, <em>add</em> a new Javascript file named newsletter"
      },
      "id": "607256c964441f74479d8559"
    },
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/embed/",
      "sections": [
        "Add a grid",
        "Technical detail"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:42:16Z",
      "type": "",
      "external_id": "bfd5e04da0f000d6970b16677cd5faf8c3b2f461",
      "popularity": 1,
      "body": "In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid/ab-test Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your Nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.92667,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a grid",
        "body": " going to arrange <em>your</em> columns, you can write some code to realize <em>your</em> plans. Step 1 of 6 Change to the <em>add</em>-a-grid&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-a-grid&#x2F;ab-test Step 2 of 6 In <em>your</em> <em>Nerdlet</em>&#x27;s index.js file, import Grid and GridItem"
      },
      "id": "6072565d28ccbc6baf51c18b"
    }
  ],
  "/build-apps/ab-test/add-charts": [
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Extra credit"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.47275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> tables",
        "body": "In each hands-on lesson in this course, you have been adding something new to <em>your</em> A&#x2F;<em>B</em> <em>test</em> <em>application</em>. You’ve spun up a new launcher and added multiple <em>chart</em> <em>components</em> to <em>your</em> Nerdlet. In this lesson, you’ll create two new Table<em>Chart</em> <em>components</em> that display information about each version of <em>your</em>"
      },
      "id": "60725692196a67b68c64a778"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:50Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 353.45734,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> user interface <em>components</em> <em>to</em> <em>your</em> <em>application</em>",
        "body": " A&#x2F;<em>B</em> <em>test</em>. Before you <em>add</em> user any UI <em>components</em> to <em>your</em> <em>application</em>, remind yourself of how <em>your</em> <em>application</em> will look when you finish: In the next lesson, you arrange <em>your</em> charts to look like they do in <em>your</em> design guide."
      },
      "id": "6073006628ccbce73151c12f"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/embed/",
      "sections": [
        "Add pie charts"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "c0f472d2ed9df8035313cd76ee83ec43e75d0a4a",
      "popularity": 1,
      "body": "You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 346.4256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> pie <em>charts</em>",
        "body": "You’ve begun building <em>your</em> A&#x2F;<em>B</em> <em>test</em> <em>application</em>. So far, it consists of a single line <em>chart</em>, which represents the number of subscriptions <em>your</em> newsletter receives from each version of <em>your</em> website. To understand what you’ll build in this lesson, review the design guide to remember what charts come"
      },
      "id": "6072ffcc28ccbc786651c18a"
    },
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/embed/",
      "sections": [
        "Add a chart group",
        "Tip"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:43:09Z",
      "type": "",
      "external_id": "e94780ac131f1a4ce5999771f9bee9650d4f5e9b",
      "popularity": 1,
      "body": "In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group/ab-test Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 326.48215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> <em>chart</em> group",
        "body": "In previous lessons, you added a variety of charts to <em>your</em> A&#x2F;<em>B</em> <em>test</em> <em>application</em>. These charts presented different facets of information about <em>your</em> A&#x2F;<em>B</em> <em>test</em>, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize"
      },
      "id": "6072ff19e7b9d25dbba5c689"
    },
    {
      "image": "https://developer.newrelic.com/static/28d3e2adf8b81d91071076ff60426bb2/ba3ac/headings-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-headings/embed/",
      "sections": [
        "Add chart headings"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:39Z",
      "type": "",
      "external_id": "85edc6fc684567403335fcaf25fb8e5efb280f3d",
      "popularity": 1,
      "body": "Organizing charts is one way to clarify the information you're trying to convey to your users. Headings are another. Since you have several charts on the same page, use headings to describe the information they show. To remember what data each chart presents, consult your design guide: The design guide details what data each chart shows. Use those details to craft useful headings for your charts. Step 1 of 6 Change to the add-chart-headings/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-chart-headings/ab-test Step 2 of 6 In newsletter-signups.js, page-views.js, past-tests.js, total-cancellations.js, total-subscriptions.js, and totals.js, import HeadingText and add a descriptive heading above the chart in each of your custom components: import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <LineChart data={[versionASignups, versionBSignups]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy import React from 'react'; import { HeadingText, LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <LineChart data={[versionPageViews]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class PastTests extends React.Component { render() { const historicalData = { metadata: { id: 'past-tests', name: 'Past tests', columns: ['endDate', 'versionADescription', 'versionBDescription', 'winner'], }, data: [ { \"endDate\": \"12-15-2020\", \"versionADescription\": \"The homepage's CTA button was green.\", \"versionBDescription\": \"The homepage's CTA button was blue.\", \"winner\": \"A\" }, { \"endDate\": \"09-06-2019\", \"versionADescription\": \"The 'Deals' page showed sales in a carousel.\", \"versionBDescription\": \"The 'Deals' page showed sales in a grid.\", \"winner\": \"B\" } ], } return <div> <HeadingText className=\"chartHeader\"> Past tests </HeadingText> <TableChart data={[historicalData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/past-tests.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy import React from 'react'; import { HeadingText, TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[versionATotals]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Notice the new <div> tag in each render(), which allows you to return multiple elements at once. Also, remember that we provided you a CSS stylesheet that styles the chartHeader class. You can look at nerdlets/ab-test-nerdlet/styles.scss to see more. You don't need to modify your Nerdlet's render() method in index.js because your components encapsulate the new code. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see that your charts have descriptive headings. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Well done! You've created all the charts that are laid out in your design guide. You’ve also organized them into a neat grid and added headings so that the charts are intelligible. While chart headings helps you understand what each chart shows, it'd be nice to add descriptions to help you remember what each version in your A/B test represents. In the next lesson, you'll add a description for each design version.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.3022,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>chart</em> headings",
        "body": " and added headings so that the charts are intelligible. While <em>chart</em> headings helps you understand what each <em>chart</em> shows, it&#x27;d be nice to <em>add</em> descriptions to help you remember what each version in <em>your</em> A&#x2F;<em>B</em> <em>test</em> represents. In the next lesson, you&#x27;ll <em>add</em> a description for each design version."
      },
      "id": "6072ff1928ccbc140b51c16e"
    }
  ],
  "/build-apps/ab-test/first-chart": [
    {
      "image": "https://developer.newrelic.com/static/733ffe1b10df224863d5c0b4f69894ce/0086b/first-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/first-chart/embed/",
      "sections": [
        "Add your first chart"
      ],
      "published_at": "2021-04-16T02:09:02Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "a6647ae7e6f32626783c432c4c7a2d4e0d896f8d",
      "popularity": 1,
      "body": "In this course, you’re building an A/B test application for the New Relic platform. Previously, you learned about the New Relic One SDK and its component library. Now, It’s time for you to start building your application focusing first on chart components. Before you write any code, consult your design guide to remember what the application will look like when you finish: There are several charts you need to create, which may seem overwhelming at first, but take it one step at a time. The topmost chart, and the first you’ll create, is a line chart that shows the number of users who sign up for your newsletter and what version of your website they were shown. Step 1 of 8 Change to the add-your-first-chart/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-your-first-chart/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named newsletter-signups.js: bash Copy $ touch newsletter-signups.js Step 3 of 8 In this new file, create a component called NewsletterSignups to hold your first LineChart and some mock data: import React from 'react'; import { LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <LineChart data={[versionASignups, versionBSignups]} fullWidth /> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you’ve created two arbitrary data series which represent versions A and B of your test. Right now, you're using manually-crafted data points. In the future, you'll replace these with data queried from New Relic. Notice that you’ve specified a color for each series in the chart. The color metadata attribute takes any CSS-acceptable color format. Setting viz: 'main' means that you want to render the LineChart series as a line, the component's default display style. For the data prop in the LineChart component, you passed the two series in an array so that both are represented together. Finally, you used the chart’s fullWidth prop to stretch the chart’s width to fill the view. Step 4 of 8 In your Nerdlet's index.js file, import your new component and replace the default heading in your Nerdlet's render() method with your new component: import React from 'react'; import NewsletterSignups from './newsletter-signups'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-your-first-chart/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the LineChart displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In seven steps, you’ve breathed life into your New Relic One application. Instead of a bland “Hello world” message, your application now shows a colorful line chart with two mocked data series. These data series represent server-side traffic for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another chart type.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1876.1208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>your</em> <em>first</em> <em>chart</em>",
        "body": " for <em>your</em> newsletter and what version of <em>your</em> website they were shown. Step 1 of 8 Change to the <em>add</em>-<em>your</em>-<em>first</em>-<em>chart</em>&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-<em>your</em>-<em>first</em>-<em>chart</em>&#x2F;ab-test This directory contains the code <em>your</em> application should have"
      },
      "id": "607256c964441f74479d8559"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Delayed-Jobs-New-Relic-1024x837.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/monitoring-delayedjob",
      "sections": [
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "Monitoring DelayedJob",
      "updated_at": "2021-04-14T00:06:04Z",
      "type": "",
      "external_id": "2e9c1f784c773aa1fa509a112bcd338cac37c70e",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Monitoring DelayedJob Sep 12, 2012 • 6 min read By Bill Kayser Like many Ruby shops we use the DelayedJob job runner to run many of our background tasks. The New Relic agent has had some basic DelayedJob instrumentation for a while now but until recently you were limited to a few metrics which could only be viewed using the somewhat limited and unwieldy custom charts. But no longer! In the latest release of the Ruby Agent we are sending much richer, useful metrics for DelayedJob workers, and the recently released Custom Dashboards allows you to to build a truly useful view for monitoring and troubleshooting your jobs. Here's what it looks like: This is a Custom Dashboard we built for our DelayedJobs workers running in production. Below, I'll show you the steps to create this in your own New Relic account. But first let me explain what we are looking at. There are four graphs with data reported by the agent running in the DelayedJob worker. Job Queue Length shows the number of jobs waiting to be executed at any given time, based on one minute samples. We break out these numbers by priority since we manage separate workers in three different priority levels. In the graph above, you can see that our highest priority worker maintains a pretty healthy queue while we get a few spikes in our low priority worker every now and then, since the jobs in the low priority queue tend to run a little longer. In our configuration, we destroy jobs when they've run successfully and leave the failed ones. The agent polls the failed jobs and reports the count which we graph in the Failed Jobs chart. We pay particular attention to this chart during a deploy to look for any jump in failing jobs caused by a regression. Locked Jobs is particularly interesting. Jobs are locked while executing, so the number of jobs locked at any given time should not exceed the number of workers. With idle workers, the count will be low. With workers fully utilized, the number will approach the total number of workers. We find you do have to be careful as some jobs occasionally fail without clearing their lock, so you have to manually clear those out. But you can use the Locked Jobs graph as a gauge of your overall worker utilization. The Average Job Execution time graph is simply a graph of the average response time of the DelayedJob transactions. Creating a Custom Dashboard for DelayedJobs Let's walk through the steps to get this set up in a typical account. The first thing you need is the current version of the Ruby Agent gem. You must be running at least version 3.4.2. Then follow these steps in the New Relic application: 1) Select the application where DelayedJob is running. In our case it's \"Background Jobs\". 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and \"Grid\" chart type. 3) Choose Add chart to add the first chart to your dashboard.  Fill in the basic properties, including the titles and chart type, which is \"Stacked Area.\" 4) Select the DelayedJob queue lengths for the graph. Start typing in Workers/. Initially it will say the metric doesn't exist, but when you enter the slash it will display the list of available metrics in the Workers namespace. Keep typing Workers/DelayedJob/queue_length/priority/*.  The metrics will auto-complete as you enter each segment. The asterisk at the end indicates that you want to break down the graph by priority. If you don't use priorities you can chart a single line for the queue length using the metric name Workers/DelayedJob/queue_length/all. 5. That's generally good enough to display the chart, but there are a couple of other properties you can customize. In our case, we removed the limit on the number of different priorities it will show, added \"jobs\" to the y-axis labels, and fixed the application to \"RPM Background\" where the DelayedJob agent reports to. Here's what it looks like: 6. Add the Failed Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking failed jobs: Workers/DelayedJob/failed_jobs. 7. Add the Locked Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking locked jobs: Workers/DelayedJob/locked_jobs. 8. Add the Job Execution Time chart. Repeat steps 3 - 5 but enter the metric for the response time of delayed jobs:  OtherTransaction/DelayedJob/all. We show execution time in milliseconds so we chose To Milliseconds for the Number Format and \"ms\" as the y-axis unit label. We also hide the legend. That's enough to get you started with a good dashboard for monitoring your DelayedJob workers. But you don't have to stop there. You can add a table showing you the summary metrics for each job or a breakdown chart of all the jobs. In addition to showing the response time of jobs, you could chart the throughput. We combine our staging and production servers onto one dashboard by duplicating the charts and picking a different application. Custom Dashboards now makes it easy to configure the charts for the exact data you want to display. If you haven't already, try New Relic today to see how you can improve the performance of your Ruby applications. And as always, we welcome your feedback on this post. Let us know what you think of Custom Dashboards and how you're using them to monitor your applications. Related Topics APM By Bill Kayser Bill has been with New Relic from the beginning as both a developer and a data scientist. Having worked in application performance management for nearly two decades, his role now entails discovering new ways of exploring and interpreting data as well as prototyping innovative new features. Follow the author Bill Kayser on Twitter Bill Kayser on GitHub Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 330.9996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " in the New Relic application: 1) Select the application where DelayedJob is running. In our case it&#x27;s &quot;Background Jobs&quot;. 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and &quot;Grid&quot; <em>chart</em> type. 3) Choose <em>Add</em> <em>chart</em> to <em>add</em> the <em>first</em> <em>chart</em> to <em>your</em> dashboard.  Fill"
      },
      "id": "607631ece7b9d201aea5c63a"
    },
    {
      "image": "https://developer.newrelic.com/static/41a32511bd359042ecee89604474a4c4/ba3ac/table-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/table-charts/embed/",
      "sections": [
        "Add tables",
        "Extra credit"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "53be88b210a5557d650b91d2b918dcc2b96bbd55",
      "popularity": 1,
      "body": "In each hands-on lesson in this course, you have been adding something new to your A/B test application. You’ve spun up a new launcher and added multiple chart components to your Nerdlet. In this lesson, you’ll create two new TableChart components that display information about each version of your website, such as the ratio of customers who subscribe to those who unsubscribe. Review your design guide to understand where these tables will fit into your application: In this design guide, the TableChart components come after the pie charts you created in the last lesson. Step 1 of 8 Change to the add-tables/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-tables/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named totals.js: bash Copy $ touch totals.js Step 3 of 8 In this new file, create a component called VersionTotals to hold your first TableChart and some mock data: import React from 'react'; import { TableChart } from 'nr1'; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } return <TableChart data={[versionATotals]} fullWidth /> } } nerdlets/ab-test-nerdlet/totals.js Copy TableChart is different from PieChart and LineChart in three big ways. First of all, there are no color or viz metadata attributes in its series. TableChart has a standard visualization, so it ignores things like color, which don't apply. Second, the TableChart series have columns metadata attributes. columns determines the names of the columns on the table. Finally, TableChart series data use neither x nor y values. Instead, they use keys that match the table column and values that determine what goes into the row. Notice that VersionTotals takes a version prop and supplies it to the chart metadata's id and name fields. This allows you to use this same component to create a table for version A and B and eliminate duplicate code. Step 4 of 8 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-tables/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the TableChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Extra credit There is one more table in the design guide that records past tests. The columns for this table are: End Date: The end date for the test Version A Description: A description for version A Version B Description: A description for version B Winner: The version selected as the final design Try to build this table in your application with these column names and some fake data, without looking at a code sample. This practice will reinforce what you've learned in this lesson. If you need help, review the add-a-chart-group directory of the coursework repository, which corresponds to the next lesson in this course. This has the code for the PastTests component. Each chart you’ll add to your application throughout this course is unique in its type or in the data it presents. So far, you’ve created tables, pie charts, and a line chart, and they all function independently of one another. In the next lesson, you’ll create a couple more line charts, but this time they’ll function together.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.5604,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> tables",
        "body": " to hold <em>your</em> <em>first</em> Table<em>Chart</em> and some mock data: import React from &#x27;react&#x27;; import { Table<em>Chart</em> } from &#x27;nr1&#x27;; export default class VersionTotals extends React.Component { constructor(props) { super(props); } render() { const versionATotals = { metadata: { id: `totals-${this.props.version}`, name"
      },
      "id": "60725692196a67b68c64a778"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:50Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.7973,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> user interface components to <em>your</em> application",
        "body": ", you’ll use a Grid component to arrange <em>your</em> charts to match the layout in <em>your</em> design guide. Second, you’ll <em>add</em> headings to clarify what each <em>chart</em> represents. Third, you&#x27;ll <em>add</em> descriptions for <em>your</em> A and B design versions to the top of <em>your</em> app. Finally, you’ll create a section for ending <em>your</em>"
      },
      "id": "6073006628ccbce73151c12f"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/embed/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:20Z",
      "type": "",
      "external_id": "43c5fb39b73ee2dbbe5f216a577ff77051fcc513",
      "popularity": 1,
      "body": "In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 View your changes: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.97147,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> NrqlQuery components to <em>your</em> Nerdlet",
        "body": " to pass <em>your</em> NRQL query to <em>your</em> Newsletter subscriptions per version <em>chart</em>. Step 1 of 7 Change to the <em>add</em>-nrql-components&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-nrql-components&#x2F;ab-test This directory contains the code that we expect <em>your</em>"
      },
      "id": "60730124196a6731e464a778"
    }
  ],
  "/build-apps/ab-test/add-ui": [
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-ui/embed/",
      "sections": [
        "Add user interface components to your application"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:50Z",
      "type": "",
      "external_id": "d268d73f00f1e436feaa973365890266c02909a2",
      "popularity": 1,
      "body": "If an application is organized, it is more readable and more understandable. In your A/B test application, you have a lot of charts, but no organization. In the next few lessons, you’ll use user interface components to bring some organization to your application and provide new functionality. First, you’ll use a Grid component to arrange your charts to match the layout in your design guide. Second, you’ll add headings to clarify what each chart represents. Third, you'll add descriptions for your A and B design versions to the top of your app. Finally, you’ll create a section for ending your A/B test. Before you add user any UI components to your application, remind yourself of how your application will look when you finish: In the next lesson, you arrange your charts to look like they do in your design guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 281.7548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>user</em> <em>interface</em> <em>components</em> <em>to</em> <em>your</em> <em>application</em>",
        "body": "If an <em>application</em> is organized, it is more readable and more understandable. In <em>your</em> A&#x2F;B test <em>application</em>, you have a lot of charts, but no organization. In the next few lessons, you’ll use <em>user</em> <em>interface</em> <em>components</em> to bring some organization to <em>your</em> <em>application</em> and provide new functionality. First"
      },
      "id": "6073006628ccbce73151c12f"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:21Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.69423,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> version descriptions",
        "body": " <em>your</em> New Relic One <em>application</em> by pressing CTRL+C in <em>your</em> local server&#x27;s terminal window. Now, you&#x27;ve added descriptions for <em>your</em> competing designs and <em>your</em> charts. In the next lesson, you’ll create a new section of <em>your</em> <em>application</em> from <em>user</em> <em>interface</em> <em>components</em>. This section will be used to end the A&#x2F;B test with the click of a button."
      },
      "id": "6072569228ccbc932d51c172"
    },
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/embed/",
      "sections": [
        "Add a chart group",
        "Tip"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:43:09Z",
      "type": "",
      "external_id": "e94780ac131f1a4ce5999771f9bee9650d4f5e9b",
      "popularity": 1,
      "body": "In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group/ab-test Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.01044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a chart group",
        "body": " is filled with charts, but it doesn&#x27;t look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you&#x27;ll learn about the <em>user</em> <em>interface</em> <em>components</em> from the SDK and how you can use them to organize <em>your</em> charts."
      },
      "id": "6072ff19e7b9d25dbba5c689"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/embed/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:20Z",
      "type": "",
      "external_id": "43c5fb39b73ee2dbbe5f216a577ff77051fcc513",
      "popularity": 1,
      "body": "In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 View your changes: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.44017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> NrqlQuery <em>components</em> <em>to</em> <em>your</em> Nerdlet",
        "body": " the NRQL query above the chart. This shows the chart&#x27;s underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting <em>your</em> data: <em>User</em> <em>interface</em> (UI) selections"
      },
      "id": "60730124196a6731e464a778"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: Copy the key you created. You'll use it to associate your New Relic account with the CLI. The CLI will then use the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name> with an arbirary name, the <User key> with the key you copied in Step 1, and the region with either us or eu. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.56668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " a <em>User</em> key. From the top navigation, go to API keys: If you have an existing <em>User</em> key, copy it: If not, click Create key: Select <em>User</em> for Key type, optionally <em>add</em> a name and notes, and click Create key: Copy the key you created. You&#x27;ll use it to associate <em>your</em> New Relic account with the CLI. The CLI"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    }
  ],
  "/build-apps/ab-test/nrql": [
    {
      "image": "https://developer.newrelic.com/static/26492d2caf619e5337b958df5ace08ea/ba3ac/platform-state.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/platform-state-context/embed/",
      "sections": [
        "Add PlatformStateContext to your Nerdlet",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "58de68bd963cdd2062e88db55cb90ad124055eb6",
      "popularity": 1,
      "body": "In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives. So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to use values in the New Relic platform state. Step 1 of 10 Change to the add-platform-state-context/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-platform-state-context/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In nerdlets/ab-test-nerdlet/newsletter-signups.js, add a PlatformStateContext.Consumer to your NewsletterSignups component's render() method: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Notice that NrqlQuery uses a constant called ACCOUNT_ID. Instead of hardcoding an account identifier in your Nerdlet, you can use accountId from the platform URL state. Step 3 of 10 PlatformStateContext.Consumer provides access to the platform's URL state. This context contains an important value you'll use in your app, called timeRange. Notice that your NrqlQuery uses a SINCE clause that identifies the historical timeframe your query should fetch data from. Right now, that SINCE clause is set to 30 MINUTES AGO. With timeRange, you can use the platform's time picker to make this timeframe adjustable. Step 4 of 10 Utilize the platform state's timeRange: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Now, NewsletterSignups uses platformState.timeRange instead of a hardcoded SINCE clause. While NrqlQuery components accept a convenient timeRange prop, not every component does. You can still use timeRange in other contexts by accessing duration, begin_time, or end_time: <PlatformStateContext.Consumer> {(platformState) => { console.log(platformState.timeRange.duration); }} </PlatformStateContext.Consumer>; Copy Step 5 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-platform-state-context/ab-test. Step 6 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 7 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 10 View your application: Your NrqlQuery now uses the platform state's timeRange, but your chart probably still shows the last 30 minutes. Why? Where does the timeRange in platform state come from? The time picker sits on the right side of your application's navigation bar: Change this value and see your chart update: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 9 of 10 Update VersionPageViews: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, Total subscriptions per version, Total cancellations per version, Version A - Page views vs. subscriptions, Version B - Page views vs. subscriptions, show total values over time. So, hardcoding their SINCE clauses to 7 DAYS AGO makes sense, as this is a reasonable time period for the purposes of this course. Step 10 of 10 While still serving your Nerdpack locally, view your NR1 app to see your charts updating with the time range you choose: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes. The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 664.20276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> PlatformStateContext <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": "} fullWidth &#x2F;&gt;; } } &lt;&#x2F;<em>NrqlQuery</em>&gt; } } &lt;&#x2F;PlatformStateContext.Consumer&gt; &lt;&#x2F;div&gt; } } nerdlets&#x2F;ab-test-<em>nerdlet</em>&#x2F;newsletter-signups.js Copy Important Make sure you replace &lt;<em>YOUR</em> NEW RELIC ACCOUNT ID&gt; with <em>your</em> actual New Relic account ID. Notice that <em>NrqlQuery</em> uses a constant called ACCOUNT_ID. Instead"
      },
      "id": "6073000164441f84ce9d853d"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql/embed/",
      "sections": [
        "Add NrqlQuery components to your Nerdlet",
        "View Subscription Events in New Relic",
        "Update NewsletterSignups with a NrqlQuery",
        "Technical detail",
        "Important",
        "Tip",
        "Populate your PieChart with subscription event data",
        "Populate charts with pageView event data"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:20Z",
      "type": "",
      "external_id": "43c5fb39b73ee2dbbe5f216a577ff77051fcc513",
      "popularity": 1,
      "body": "In this series, you're building a full-fledged New Relic One application that ingests data from a demo service that's running an A/B test. The app shows the A/B test data in interesting ways so that you'll ultimately be able to choose whether Version A or Version B is more effective at accomplishing your business goal: to increase high-quality newsletter subscriptions. In past tutorials, you created charts to visualize your data, and you organized those charts so you can use and understand them. You also created a form in your app for ending your test once you're confident in the most effective version. Until now, though, you can't gauge which version is more effective because your charts have been showing mock data, such as: const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } Copy A chart's data prop is useful for supplying manually-crafted data like this or even reformatted third-party data. But for many of your charts, you want to show real-time New Relic data. For example, Newsletter subscriptions by version should show subscription data, which exists in New Relic's database, NRDB for short. To query NRDB, you first need to know what data you're looking for. Remember your demo backend service? Well, that service reports a subscription event to New Relic when a user subscribes to a newsletter from your site. You can view these subscription events in New Relic while your demo services are running. View Subscription Events in New Relic Before you query NRDB from your charts, experiment with querying data from New Relic's web interface. Step 1 of 3 From your New Relic homepage, go to to the Data explorer from the top navigation menu: Data explorer lets you explore your telemetry data: metrics events logs traces Since the backend submits newsletter subscriptions as events to New Relic, you can see them in this view. Step 2 of 3 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 3 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. Notice the NRQL query above the chart. This shows the chart's underlying query, which is based on these dimensions. Click the page-version dimension to see the query change to group by FACET page_version: The Data explorer presents two options for filtering and sorting your data: User interface (UI) selections like the one you've just made New Relic Query Language (NRQL) The UI is useful for quickly filtering data, and it doesn't require you to know NRQL. For your New Relic One application, however, you need to use NRQL queries. Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Update NewsletterSignups with a NrqlQuery Before you begin integrating New Relic data in your NR1 app, consult your design guide: Your New Relic One application has eight charts in total, including line charts, pie charts, and table charts. Each of these charts currently shows mock data, but they need to show real data to be useful. First, focus on querying data for the topmost chart: Newsletter subscriptions per version. With the query you've built in the Data explorer, you already have the data you need for this chart: Technical detail In your query, you fetch subscription totals (SELECT count(*) FROM subscriptions), group them by their page version (FACET page_version), and focus the timeseries to the past 30 minutes (SINCE 30 MINUTES AGO TIMESERIES). Explore our documentation to learn more about NRQL queries. Next, you learn how to pass your NRQL query to your Newsletter subscriptions per version chart. Step 1 of 7 Change to the add-nrql-components/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-nrql-components/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 In nerdlets/ab-test-nerdlet/newsletter-signups.js, update the LineChart in NewsletterSignups. Remove the mock data, and use the NRQL query you built in the Data explorer: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. In NrqlQuery, you set two props: accountId: The id for the account you query from query: The query to perform With these, your NR1 app can query the data you want to show in your chart. Tip There is a convenience prop for using NRQL to supply data to your charts, called query. If you'd rather not use the NrqlQuery component, try the query prop instead: <LineChart accountId={<YOUR NEW RELIC ACCOUNT ID>} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" /> Copy Keep in mind you must still supply the accountId. Step 3 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/add-nrql-components/ab-test. Step 4 of 7 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 7 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 View your changes: Newsletter subscriptions by version now shows real data from New Relic's database rather than the mock data you defined before. Notice that your chart pulls data when your application loads, but does not continue pulling data while the application is open. You can fix this by adding another prop. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 7 of 7 Add a pollInterval: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES\" pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. The pollInterval is the number of milliseconds between chart refreshes. Each time the chart refreshes, it queries fresh data from New Relic. In this case, you refresh every minute. Populate your PieChart with subscription event data Now that you've seen how to passed New Relic data to Newsletter subscriptions per version, it's time to move on to Total subscriptions per version. These two charts are similar in that they compare subscription event data grouped by version. The primary differences between Newsletter subscriptions per version and Total subscriptions per version are: One is a line chart and one is a pie chart One shows timeseries data and one shows all-time totals Step 1 of 2 In nerdlets/ab-test-nerdlet/total-subscriptions.js, update the TestDistributions component, removing the mock data and populating the PieChart with the same NRQL query you used for Newsletter subscriptions per version but with different TIMESERIES and SINCE clauses: import React from 'react'; import { HeadingText, NrqlQuery, PieChart, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class TotalSubscriptions extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Total subscriptions per version </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version SINCE 7 DAYS AGO\" pollInterval={60000} > { ({ data }) => { return <PieChart data={data} fullWidth /> } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. You don't need the TIMESERIES clause because the pie chart only shows numerical data. You don't need the SINCE clause because Total subscriptions per version needs to show all-time subscription totals. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: Total subscriptions per version now shows all-time subscription totals from both versions of your demo application. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Well done! You've configured some charts to query real subscription data from New Relic's database. Populate charts with pageView event data Consider the remaining charts that still use mock data: Total unsubscriptions per version Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions Version A - Page views Version B - Page views Past tests Some of these charts need to show page view data. Fortunately, your demo application creates a custom event for every page view like it does for subscriptions! Since Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions require data from two sources, ignore these for now and focus on Version A - Page views and Version B - Page views. Step 1 of 2 In page-views.js, remove the mock data from VersionPageViews and use a NrqlQuery component to supply a query: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, } from 'nr1'; const ACCOUNT_ID = 123456 // <YOUR NEW RELIC ACCOUNT ID> export default class VersionPageViews extends React.Component { render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views </HeadingText> <NrqlQuery accountId={ACCOUNT_ID} query={`SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' TIMESERIES`} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> </div> } } nerdlets/ab-test-nerdlet/page-views.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 2 of 2 With your Nerdpack served locally, view your application to see your charts serving real data: In these new queries, you fetch pageView custom events instead of subscription events. You also use a WHERE clause to filter to a particular page_version rather than a FACET to group by page_version. Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Phew, that's a lot of queries, but your application looks great! You're now showing real data in four charts. Remember the two charts you ignored because they require data from two sources? Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions You have to handle these differently than you did for the charts you've been dealing with because NRQL has no method for querying data from multiple sources. In the next lesson, you'll learn how to supply data to these two charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 648.4309,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>NrqlQuery</em> <em>components</em> <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": " to pass <em>your</em> <em>NRQL</em> <em>query</em> to <em>your</em> Newsletter subscriptions per version chart. Step 1 of 7 Change to the <em>add</em>-<em>nrql</em>-<em>components</em>&#x2F;ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course&#x2F;<em>add</em>-<em>nrql</em>-<em>components</em>&#x2F;ab-test This directory contains the code that we expect <em>your</em>"
      },
      "id": "60730124196a6731e464a778"
    },
    {
      "image": "https://developer.newrelic.com/static/1bb805863e9023c9936a0b125893a1a3/ba3ac/select-apm.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/navigation/embed/",
      "sections": [
        "Add navigation to your Nerdlet",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "0b303eec66162ca46bed684f46f7d50bfe94d4ec",
      "popularity": 1,
      "body": "In the last lesson, you used PlatformStateContext from the New Relic One SDK to look up the time range that the user selected from the app's time picker. Now, you'll learn about another component that interacts with the New Relic platform: navigation. The navigation component lets you open entities, navigate to entities, and build Location objects for entities from your Nerdlet. You can also use navigation for other Nerdlets and launchers. Step 1 of 10 Change to the add-navigation/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-navigation/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 10 In newsletter-signups.js, create a new method, called NewsletterSignups.openApmEntity(): import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. This method uses navigation.openStackedEntity() to display your demo application's APM entity in a stacked view. Notice openApmEntity() requires your ENTITY_GUID. You need to locate that ID and store it in a constant. Step 3 of 10 Navigate to APM: See metadata for your Newsletter service: Copy the entity's GUID: Create an ENTITY_GUID constant: import React from 'react'; import { HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and the entity GUID you just copied, respectively. Now, openApmEntity() knows what entity to show. Next, you need to create a button to invoke this method. Step 4 of 10 Create a button to show your APM entity: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you've created a button and configured it to call openApmEntity() when it's clicked. Step 5 of 10 Import Stack and StackItem: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> <Button onClick={this.openAPMEntity}> App performance </Button> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. You'll use Stack and StackItem to lay out the button on the far right side of the same row that the HeadingText is on. Step 6 of 10 Lay out the Stack: import React from 'react'; import { Button, HeadingText, LineChart, NrqlQuery, PlatformStateContext, Stack, StackItem, navigation, } from 'nr1'; const ACCOUNT_ID = 1234567 // <YOUR NEW RELIC ACCOUNT ID> const ENTITY_GUID = \"<YOUR NEW RELIC ENTITY GUID>\" export default class NewsletterSignups extends React.Component { openAPMEntity() { navigation.openStackedEntity(ENTITY_GUID) } render() { return <div> <Stack fullWidth> <StackItem grow={true}> <HeadingText className=\"chartHeader\"> Newsletter subscriptions per version </HeadingText> </StackItem> <StackItem> <Button onClick={this.openAPMEntity}> App performance </Button> </StackItem> </Stack> <PlatformStateContext.Consumer> { (platformState) => { return <NrqlQuery accountId={ACCOUNT_ID} query=\"SELECT count(*) FROM subscription FACET page_version TIMESERIES\" timeRange={platformState.timeRange} pollInterval={60000} > { ({ data }) => { return <LineChart data={data} fullWidth />; } } </NrqlQuery> } } </PlatformStateContext.Consumer> </div> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> with your actual New Relic account ID and entity GUID, respectively. Here, you used a full-width Stack to set up the layout for the row. To make the HeadingText fill the entire row except the width of the button, you used the StackItem.grow prop. Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-navigation/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your application and click App performance: Now you see the stacked entity: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively Congratulations! You're finished writing all the code you'll write for your New Relic One A/B test application. Now, you have an application reporting New Relic data from your demo service that is running an A/B test. You've created several charts, buttons, and other UI elements. And you've organized your components into a readable and usable view. On top of the visuals, you've supplied data to your charts from multiple data sources in and outside of New Relic. You've created some backend functionality which utilizes your New Relic One application's own data store. You've also utilized the platform APIs for interacting with platform UI and showing a stacked entity view. You've really accomplished a lot throughout this course, so far. There are only a few things left to do! First, is to learn how to publish and subscribe to your New Relic One application so that it can run on our platform instead of your own local server. Second, is to learn how to deal with some common issues you might see in New Relic One application development.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 640.7539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> navigation <em>to</em> <em>your</em> <em>Nerdlet</em>",
        "body": "={data} fullWidth &#x2F;&gt;; } } &lt;&#x2F;<em>NrqlQuery</em>&gt; } } &lt;&#x2F;PlatformStateContext.Consumer&gt; &lt;&#x2F;div&gt; } } nerdlets&#x2F;ab-test-<em>nerdlet</em>&#x2F;newsletter-signups.js Copy Important Make sure you replace &lt;<em>YOUR</em> NEW RELIC ACCOUNT ID&gt; and &lt;<em>YOUR</em> NEW RELIC ENTITY GUID&gt; with <em>your</em> actual New Relic account ID and the entity GUID you just"
      },
      "id": "6072565e196a67927a64a797"
    },
    {
      "image": "https://developer.newrelic.com/static/393889edc2b3129309227864da0a5fa6/ba3ac/data-explorer-subscription-edit-nrql.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/nrql-customizations/embed/",
      "sections": [
        "Customize NRQL data",
        "Experiment with data in the Data explorer",
        "technical detail",
        "Merge NRQL from multiple sources",
        "Important",
        "Tip"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:28:30Z",
      "type": "",
      "external_id": "f51f9d86d3b873b24e967c687d5408eb9918a33f",
      "popularity": 1,
      "body": "In this series, you're creating a New Relic One application, or NR1 app for short, that shows A/B test data in a variety of charts. Most of the charts need to show data that comes from a demo service you spun up at the beginning of this series. To refresh your memory on what you're building, review your design guide: In the last lesson, you supplied real data, which comes from New Relic's database, to the following charts: Newsletter subscriptions per version Version A - Page views Version B - Page views Total subscriptions per version Because you have experience querying subscription and page view data, you may feel ready to supply data to even more charts: Version A - Page views vs. subscriptions Version B - Page views vs. subscriptions However, these charts are different than the charts you've supplied data to because they compare data from two different sources: subscription events and pageView events. In this lesson, you learn how to format data from multiple sources to exist in the same chart. Experiment with data in the Data explorer Step 1 of 6 From your New Relic homepage's top navigation menu, go to to the Data explorer: Here, you can experiment with subscription event and pageView event queries to make sure you fetch the right data in your app. Step 2 of 6 Select subscription from the Custom events menu: This queries NRDB for subscription event totals per minute over the last 30 minutes and shows that data in a chart: Step 3 of 6 Click Dimensions to see a list of the attributes associated with these subscription events: You can filter and group subscription events using these dimensions. For Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions, you want to filter your subscription totals by page_version. Step 4 of 6 Click the NRQL query to navigate to the Query builder: Here, you can view and manually edit the query to fetch the data you need. Step 5 of 6 Add a WHERE clause to filter subscription totals by page_version: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES Copy Remove the TIMESERIES clause to fetch a count: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 30 MINUTES AGO Copy Modify the SINCE clause to see totals over the past week: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO Copy Click Run and see the data visualized in a billboard chart instead of a line chart: Step 6 of 6 Version A - Page views vs. subscriptions and Version B - Page views vs. subscriptions need a combined total of four data values: All-time subscription totals for version A All-time page view totals for version A All-time subscription totals for version B All-time page view totals for version B Experiment with the Query builder to discover the four queries which pull the right data. In the end, you'll come up with the following four queries: SELECT count(*) FROM subscription WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 7 DAYS AGO SELECT count(*) FROM subscription WHERE page_version = 'b' SINCE 7 DAYS AGO SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 7 DAYS AGO Copy technical detail Unlike other structured query languages, NRQL doesn't provide a mechanism for joining data across sources. This is why you have to perform two queries to get subscription event totals and pageView event totals. Until now, you've provided every chart with a single query. Here, you have to provide two queries per chart. In the remaining steps, you'll learn how to customize NrqlQuery results to merge data from multiple sources. Merge NRQL from multiple sources Step 1 of 9 Change to the customize-nrql-data/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/customize-nrql-data/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In your Nerdlet's totals.js file, implement constructor() and the React lifecycle method componentDidMount() in VersionTotals: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Here, you initialize your state in the component's constructor. The state has a single value, tableData, which holds series data and metadata for the TableChart. In componentDidMount(), you query the data that populates the data in this state. componentDidMount() is a React lifecycle method that is called when a component is mounted in the component tree. You use this method, instead of the constructor, to query data because your logic, which requests data from New Relic, introduces side effects and sets state values, neither of which you should do in the constructor. In componentDidMount(), you use NrqlQuery in a new way. First, you specified the formatType to NrqlQuery.FORMAT_TYPE.RAW because you're going to modify the data instead of supplying it directly to a chart Before, you used its JSX form in the render() method of a chart. Second, you called its query() method and handled the results in a then() callback, which logs them to the console. Step 3 of 9 In your Nerdlet's index.js file, create a constant called ACCOUNT_ID and pass it to VersionTotals: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const ACCOUNT_ID = 123456 // <YOUR-ACCOUNT-ID> const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}> <VersionTotals version='a' accountId={ACCOUNT_ID} /> </GridItem> <GridItem columnSpan={6}> <VersionTotals version='b' accountId={ACCOUNT_ID} /> </GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/ Copy Important Make sure you replace <YOUR NEW RELIC ACCOUNT ID> with your actual New Relic account ID. Step 4 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/customize-nrql-data/ab-test. Step 5 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 6 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Navigate to your app in New Relic. Step 7 of 9 To view your logs, which are useful for uncovering errors in your application, turn on developer tools in your favorite browser and navigate to the Console: FireFox instructions Safari instructions Chrome instructions With your app on-screen, notice the NRQL data in the console: This console log tells you that you can find the data you're looking for, namely the subscription or pageView count, at data.raw.results[0].count. The next step is to store that count in state.tableData. Tip If something doesn't work, use these debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID Step 8 of 9 In totals.js, store the query data in state: import React from 'react'; import { HeadingText, NrqlQuery, TableChart, } from 'nr1'; export default class VersionTotals extends React.Component { constructor() { super(...arguments); this.state = { tableData: { metadata: { id: `totals-${this.props.version}`, name: `Version ${this.props.version}`, columns: ['name', 'count'], }, data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], } } } componentDidMount() { NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM subscription WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[0].count = data.raw.results[0].count this.setState({tableData}) } }) NrqlQuery.query({ accountId: this.props.accountId, query: `SELECT count(*) FROM pageView WHERE page_version = '${this.props.version}' SINCE 7 DAYS AGO`, formatType: NrqlQuery.FORMAT_TYPE.RAW }).then(({ data }) => { if (data.raw) { let tableData = {...this.state.tableData} tableData.data[1].count = data.raw.results[0].count this.setState({tableData}) } }) } render() { return <div> <HeadingText className=\"chartHeader\"> Version {this.props.version.toUpperCase()} - Page views vs. subscriptions </HeadingText> <TableChart data={[this.state.tableData]} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/totals.js Copy Pay close attention to the data you're accessing. The array indices are particularly important to get right. The subscription data should go to state.tableData.data[0].count because in tableData, it is the first element in the data array: data: [ { name: 'Subscriptions', count: 0 }, { name: 'Page views', count: 0 }, ], Copy By similar logic, page view data should go to state.tableData.data[1].count. Step 9 of 9 With your Nerdpack served locally, view your application to see your charts serving real data: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID In this lesson, you learned how to use NrqlQuery.query() to fetch data from multiple sources and stitch them together into data your chart can use. Notice that there are still two charts in your NR1 application that use mock data: Total unsubscriptions per version Past tests Unfortunately, your demo application doesn't create custom New Relic events when a user unsubscribes from your newsletter or you end an A/B test. In the next lesson, you'll learn how to use NerdGraph and NerdStorage to populate Past tests.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 506.40802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Customize <em>NRQL</em> data",
        "body": " Replaced all instances of &lt;<em>YOUR</em> NEW RELIC ACCOUNT ID&gt; in <em>your</em> project with <em>your</em> actual New Relic account ID Step 8 of 9 In totals.js, store the <em>query</em> data in state: import React from &#x27;react&#x27;; import { HeadingText, <em>NrqlQuery</em>, TableChart, } from &#x27;nr1&#x27;; export default class VersionTotals extends"
      },
      "id": "6073014b28ccbc70b651c134"
    },
    {
      "image": "https://developer.newrelic.com/static/25bfa8bc13b72a76caaf0744cc55a703/9730c/configurable-props.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/configuration-options/embed/",
      "sections": [
        "Configure your custom visualization",
        "Edit your visualization's metadata",
        "Declare your visualization's configurable properties",
        "boolean",
        "string",
        "number",
        "json",
        "enum",
        "nrql",
        "account-id",
        "namespace",
        "collection",
        "Use nr1.json"
      ],
      "published_at": "2021-04-16T02:20:41Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "63535453e3cfb5729cadf7bdbc306cefdd09a2aa",
      "popularity": 1,
      "body": "Customize your visualization's configurable properties to make it reusable. In this document, you'll learn what information your visualization's nr1.json file contains, how you can modify it, and how it's used to make your visualization more flexible. Edit your visualization's metadata nr1.json is a metadata file that lives in your visualization directory and looks something like this: { \"schemaType\": \"VISUALIZATION\", \"id\": \"fun-visualization\", \"displayName\": \"FunVisualization\", \"description\": \"\", \"configuration\": [] } nr1.json Copy It contains the following top-level keys: schemaType: Nerdpack artifacts all have nr1.json metadata files. The schemaType describes the artifact's schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization's string identifier. This must be unique within a given Nerdpack, but it doesn't need to be unique across all Nerdpacks. displayName: The human-readable name that New Relic displays in Custom Visualizations description: The description that New Relic displays in Custom Visualizations configuration: A list of configurable properties for your visualization. You can edit these properties in the web UI and their values are passed to your visualization component. Declare your visualization's configurable properties To declare your visualization's configurable properties, you list them under the configuration key in nr1.json: \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"number\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] Copy In this example, nrqlQueries is a collection of query objects. Each query object consists of an accountId and a query. As a collection, you can have multiple query objects in this visualization. fill and stroke are strings that define a color to be used when rendering the visualization. This example configuration results in the following fields in the visualization's setup UI: Notice the + next to NRQL Queries, which you can use to add query objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it's field's description, if it has one. In your React code, you can access the values of these fields in your visualization component's props: export default class MyCustomVisualization extends React.Component { render() { const { nrqlQueries, stroke, fill } = this.props; return <div> <p>Fill color: { fill }</p> <p>Stroke color: { stroke }</p> <p>First query account ID: { nrqlQueries[0].accountId }</p> <p>First query: { nrqlQueries[0].query }</p> </div> } Copy All configuration objects have the following optional keys: name: The React component prop name title: The UI display name description: An tooltip description All configuration objects require a type key that references the field's data type. Each data type is unique in how it's configured and presented. boolean A boolean property is rendered in the UI as a toggle and represents a true or false state. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"showLabels\", \"title\": \"Show labels\", \"description\": \"Toggles the visibility of the chart's labels.\", \"type\": \"boolean\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { showLabels } = this.props; const label = showLabels ? { fill: '#666' } : false return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar label={label} background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy string A string property is rendered in the UI as a text field and represents a character string. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"title\", \"title\": \"Chart title\", \"description\": \"The chart's title.\", \"type\": \"string\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { HeadingText } from 'nr1'; import { RadialBarChart, RadialBar, Legend, Label } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { title } = this.props; return ( <div> <HeadingText className=\"chart-heading\"> {title} </HeadingText> <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> </div> ) } } index.js Copy number A number property is rendered in the UI as a text field and represents a number. number props take three extra optional keys: min: The minimum value the text field can take max: The maximum value the text field can take step: The interval between valid values While these keys are available, they are not enforced. They are purely for UI purposes. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconSize } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={iconSize} /> </RadialBarChart> ) } } index.js Copy json A json property is rendered in the UI as a text box and represents a JSON object. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"description\": \"The data in the chart\", \"type\": \"json\" } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={JSON.parse(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy enum An enum property is rendered in the UI as a drop-down menu and represents a pre-defined list of choices. An enum takes an array of items, each with its own title and value. An item's title is its UI display title. Its value is its React component prop name. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconType } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconType={iconType} /> </RadialBarChart> ) } } index.js Copy nrql A nrql property is rendered in the UI as a text box and represents a NRQL query. You can use the NrqlQuery component from the nr1 component library to query New Relic's database. You may need to transform the data to fit your visualization's needs. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"query\", \"title\": \"Query\", \"description\": \"The query for chart data.\", \"type\": \"nrql\" } ] } nr1.json Copy import React from 'react'; import inputData from './data'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { query } = this.props; return ( <NrqlQuery accountId={inputData.accountId} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy account-id An account-id property is rendered in the UI as a drop-down menu and represents a New Relic account. From the menu, you can search for and select an account. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"account\", \"title\": \"Account\", \"description\": \"Select the appropriate New Relic account\", \"type\": \"account-id\" } ] } nr1.json Copy import React from 'react'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { account } = this.props; const query = \"SELECT count(*) FROM Public_APICall FACET `http.method`\" return ( <NrqlQuery accountId={account} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy namespace A namespace groups properties in the UI under a single heading. A namespace has items which are accessed in code, by name, as attributes of the namespace prop. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"legend\", \"title\": \"Legend\", \"type\": \"namespace\", \"items\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" }, { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { legend } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={legend.iconSize} iconType={legend.iconType} /> </RadialBarChart> ) } } index.js Copy collection A collection is a group of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection's child items. When you configure a collection in the UI, you can increase or decrease the amount of child items in the collection. In code, you access the collection prop as an array of items. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"type\": \"collection\", \"items\": [ { \"name\": \"name\", \"title\": \"Age group\", \"description\": \"The age range of the group.\", \"type\": \"string\" }, { \"name\": \"val\", \"title\": \"Amount\", \"description\": \"The amount of people in the age group.\", \"type\": \"number\", \"min\": 0 }, { \"name\": \"fill\", \"title\": \"Bar color\", \"description\": \"The color of the chart bar.\", \"type\": \"string\" } ] } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy Use nr1.json You can freely edit nr1.json, but unlike index.js your locally served visualization requires a restart to see its changes. So, if you're serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 nerdpack:serve If your visualization is already published, you need to update your Nerdpack's version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 335.98523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Configure <em>your</em> custom visualization",
        "body": " to <em>NRQL</em> Queries, which you can use to <em>add</em> <em>query</em> objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it&#x27;s field&#x27;s description, if it has"
      },
      "id": "607105a164441f96d19d857f"
    }
  ],
  "/build-apps/add-visualizations-to-dashboard": [
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/subscribe/embed/",
      "sections": [
        "Subscribe to your New Relic One application",
        "Subscribe to your application",
        "Tip",
        "Technical detail",
        "Unsubscribe from your application",
        "Next steps"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "bf9247617121bc5f5014d46f2bb56b4632ce72bc",
      "popularity": 1,
      "body": "In the last lesson, you published your A/B test app to the New Relic One catalog. You then submitted your app's description, metadata, documentation, and screenshots. Now, it's time to subscribe your account to the published app. Subscribe to your application Now that your application is published to the catalog, you can view it by visiting the Apps page of New Relic: From the catalog UI, you can subscribe to applications. Step 1 of 4 From the catalog, click your app: Tip If you don't see your app in the catalog, you may have to refresh the page or clear your browser cache. This opens the app's About page and shows the details you submitted to the catalog in the last lesson: Step 2 of 4 At the top right of this page, click Add this app: This opens the Account access view. Step 3 of 4 From Account access, select the account you want to subscribe to the application and the channel to subscribe to. Finally, select Update 1 account: Here, you only had one version tag to subscribe to. In other projects, you may have other versions with other tags. Technical detail Notice that the web UI uses the term \"channel\" instead of \"tag\". This is a relic of an older version of New Relic One apps. With later versions of nr1, we've moved toward \"tags\" terminology. Eventually, the UI will also use \"tags\". Step 4 of 4 Navigate to the Apps page, and see the AbTest app under Your apps: From there, you can click your app and use it like you did when you were serving it locally! Tip If you don't see the app under Your apps, you may have to refresh the page or clear your browser cache. It's important to note that you can subscribe to applications in the catalog with the nr1 CLI. Read our documentation to learn more. Unsubscribe from your application The process for unsubscribing from an application is similar to that of subscribing. Step 1 of 3 Click the \"i\" icon on your app launcher: Here, you see the same app details you saw when your app was in the catalog. Step 2 of 3 Click Manage access: This opens the Account access view. Step 3 of 3 From Account access, deselect the account you want to unsubscribe from the app, and select Update 1 account: If you navigate back to Apps, you will see your app in the catalog. Throughout this course, you've built a New Relic One application from the ground up. You've used the nr1 CLI to create a Nerdpack, launcher, and Nerdlet. You've used many components from the SDK. You've learned how to publish, tag, subscribe, and unsubscribe to and from apps in the catalog. You've also learned how to submit metadata to the catalog. Next steps Now that you know how to build a New Relic One application, you can read the SDK documentation to learn more about all the components you can use to create apps for your own purposes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 535.60754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Subscribe to your New Relic <em>One</em> application",
        "body": " want to unsubscribe from the app, and select Update <em>1</em> account: If you navigate back to Apps, you will see your app in the <em>catalog</em>. Throughout this course, you&#x27;ve built a New Relic <em>One</em> application from the ground up. You&#x27;ve used the <em>nr1</em> <em>CLI</em> to create a Nerdpack, launcher, and Nerdlet. You&#x27;ve used many"
      },
      "id": "60730094196a67d7d464a7b5"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: Copy the key you created. You'll use it to associate your New Relic account with the CLI. The CLI will then use the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name> with an arbirary name, the <User key> with the key you copied in Step 1, and the region with either us or eu. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 454.15372,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and configure the New Relic <em>One</em> <em>CLI</em>",
        "body": " this by checking your SDK version: bash Copy $ <em>nr1</em> --version Tip It’s important to distinguish between the newrelic <em>CLI</em> and the <em>nr1</em> <em>CLI</em>. newrelic is for managing entities in your New Relic account. <em>nr1</em> is for managing New Relic <em>One</em> applications. Step 3 of 3 Associate your New Relic account as a <em>CLI</em> profile"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/embed/",
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "published_at": "2021-04-16T02:10:56Z",
      "title": "",
      "updated_at": "2021-04-01T01:57:24Z",
      "type": "",
      "external_id": "f2f431bb550b89d1c33f4912389b7b6cd76b2d74",
      "popularity": 1,
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.44238,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to New Relic <em>One</em> SDK",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "60652884196a67886047e800"
    },
    {
      "image": "https://developer.newrelic.com/static/28a19f070d3ae2b215793dd163851d7c/0086b/click-add-to-dashboard.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/embed/",
      "sections": [
        "Add custom visualizations to your dashboards",
        "Before you begin",
        "Note",
        "Add your custom visualization to a dashboard",
        "Manage your dashboard visualizations",
        "Summary",
        "Additional resources"
      ],
      "published_at": "2021-04-16T02:20:40Z",
      "title": "",
      "updated_at": "2021-04-10T01:54:48Z",
      "type": "",
      "external_id": "230f853d85188e6617cfa0014204b34fcb2e5c70",
      "popularity": 1,
      "body": "This lesson builds off of the previous Customize visualizations with configuration lesson. If you haven't followed that lesson, please start there as this lesson assumes you have the code you built there to get started. If you don't have a visualization to follow the examples in this gude, a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using nr1.json configuration, in the following steps, you will configure and add your custom visualization to a New Relic dashboard. Before you begin To get started, follow the Customize visualizations with configuration lesson. Then, publish and subscribe to your Nerdpack. Note To publish a Nerdpack you must be a Full user and granted the Nerdpacks “modify” privilege (which is granted by default). Read our documentation to learn more about Nerdpacks privileges. Add your custom visualization to a dashboard Once you've published your custom visualization to your account, in the following steps you'll configure your visualization and add it to a dashboard. You can add a visualization to a new or existing dashboard within your New Relic account. Step 1 of 6 To find the My Awesome Visualization that you have deployed, you need to look for your visualization in the app catalog. From the New Relic One homepage, select the Apps button in the top right navigation bar: Step 2 of 6 Once on the Apps page, click the Custom Visualizations launcher: Note If you don't see the Custom Visualizations tile, use the search to locate it. Step 3 of 6 In Custom Visualizations, you will see all of the visualization that have been deployed to your account and any visualizations you are serving locally. Select the My Awesome Visualization to add to a dashboard and then enable it: Step 4 of 6 In the previous lesson, you reconfigured your visualization to use the platform configurations panel. Use the configuration options to select your desired chart, select your account, insert a NRQL query, and any other configurations you desire. As you make your selections, the visualization will update with your changes: Step 5 of 6 Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name: Step 6 of 6 Click Add to dashboard, then click the link to your dashboard to see the custom visualization: Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations. Summary Congratulations on completing this final lesson and adding your custom visualization to a New Relic dashboard. In the previous lessons, you've used the tools in the New Relic SDK to create a new custom visualization, configured the visualization using the SDK and using the platform configuration panel. Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.07434,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add custom <em>visualizations</em> to your dashboards",
        "body": ", a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using <em>nr1</em>.json configuration"
      },
      "id": "60710568196a6793b864a754"
    },
    {
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/embed/",
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "published_at": "2021-04-16T02:16:42Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "edab33e46fbc9f8e054670c52397176ce989ae3a",
      "popularity": 1,
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type nerdpack --name my-first-viz $ cd my-first-viz $ nr1 create --type visualization --name custom-viz The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ nr1 nerdpack:serve Then visit New Relic and navigate to Apps > Custom Visualizations > CustomViz to see it in action: Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack artifacts, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.61752,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Introduction to custom <em>visualizations</em>",
        "body": " Relic <em>One</em> SDK and make sure you have the latest version: bash Copy $ <em>nr1</em> update Create a Nerdpack and a visualization: bash Copy $ <em>nr1</em> create --type nerdpack --name my-first-viz $ cd my-first-viz $ <em>nr1</em> create --type visualization --name custom-viz The visualization you created in the my-first-viz"
      },
      "id": "607105a064441fa6da9d8530"
    }
  ],
  "/explore-docs/custom-viz": [
    {
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/embed/",
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "published_at": "2021-04-16T02:16:42Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "edab33e46fbc9f8e054670c52397176ce989ae3a",
      "popularity": 1,
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type nerdpack --name my-first-viz $ cd my-first-viz $ nr1 create --type visualization --name custom-viz The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ nr1 nerdpack:serve Then visit New Relic and navigate to Apps > Custom Visualizations > CustomViz to see it in action: Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack artifacts, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 420.37225,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Introduction to <em>custom</em> <em>visualizations</em>",
        "body": " Relic One <em>SDK</em> and make sure you have the latest version: bash Copy $ <em>nr1</em> update Create a <em>Nerdpack</em> and a visualization: bash Copy $ <em>nr1</em> create --type <em>nerdpack</em> --name my-first-viz $ cd my-first-viz $ <em>nr1</em> create --type visualization --name <em>custom</em>-viz The visualization you created in the my-first-viz"
      },
      "id": "607105a064441fa6da9d8530"
    },
    {
      "image": "https://developer.newrelic.com/static/28a19f070d3ae2b215793dd163851d7c/0086b/click-add-to-dashboard.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/embed/",
      "sections": [
        "Add custom visualizations to your dashboards",
        "Before you begin",
        "Note",
        "Add your custom visualization to a dashboard",
        "Manage your dashboard visualizations",
        "Summary",
        "Additional resources"
      ],
      "published_at": "2021-04-16T02:20:40Z",
      "title": "",
      "updated_at": "2021-04-10T01:54:48Z",
      "type": "",
      "external_id": "230f853d85188e6617cfa0014204b34fcb2e5c70",
      "popularity": 1,
      "body": "This lesson builds off of the previous Customize visualizations with configuration lesson. If you haven't followed that lesson, please start there as this lesson assumes you have the code you built there to get started. If you don't have a visualization to follow the examples in this gude, a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using nr1.json configuration, in the following steps, you will configure and add your custom visualization to a New Relic dashboard. Before you begin To get started, follow the Customize visualizations with configuration lesson. Then, publish and subscribe to your Nerdpack. Note To publish a Nerdpack you must be a Full user and granted the Nerdpacks “modify” privilege (which is granted by default). Read our documentation to learn more about Nerdpacks privileges. Add your custom visualization to a dashboard Once you've published your custom visualization to your account, in the following steps you'll configure your visualization and add it to a dashboard. You can add a visualization to a new or existing dashboard within your New Relic account. Step 1 of 6 To find the My Awesome Visualization that you have deployed, you need to look for your visualization in the app catalog. From the New Relic One homepage, select the Apps button in the top right navigation bar: Step 2 of 6 Once on the Apps page, click the Custom Visualizations launcher: Note If you don't see the Custom Visualizations tile, use the search to locate it. Step 3 of 6 In Custom Visualizations, you will see all of the visualization that have been deployed to your account and any visualizations you are serving locally. Select the My Awesome Visualization to add to a dashboard and then enable it: Step 4 of 6 In the previous lesson, you reconfigured your visualization to use the platform configurations panel. Use the configuration options to select your desired chart, select your account, insert a NRQL query, and any other configurations you desire. As you make your selections, the visualization will update with your changes: Step 5 of 6 Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name: Step 6 of 6 Click Add to dashboard, then click the link to your dashboard to see the custom visualization: Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations. Summary Congratulations on completing this final lesson and adding your custom visualization to a New Relic dashboard. In the previous lessons, you've used the tools in the New Relic SDK to create a new custom visualization, configured the visualization using the SDK and using the platform configuration panel. Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 377.8316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>visualizations</em> to your dashboards",
        "body": ", a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using <em>nr1</em>.json configuration"
      },
      "id": "60710568196a6793b864a754"
    },
    {
      "image": "https://developer.newrelic.com/static/c12c4ff494d08afddd0859dacc95bb43/ba3ac/api-keys.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/install-nr1/embed/",
      "sections": [
        "Install and configure the New Relic One CLI",
        "Install and configure the CLI",
        "Tip",
        "Important"
      ],
      "published_at": "2021-04-16T02:02:45Z",
      "title": "",
      "updated_at": "2021-04-15T21:27:36Z",
      "type": "",
      "external_id": "d878a93c908dd66b558d6fefeff5ba0177d185bc",
      "popularity": 1,
      "body": "One of the primary elements of the New Relic One SDK is the command line interface (CLI). To create a Nerdpack , you'll need to install the SDK, configure the CLI to work with your New Relic account, and then utilize its create command. Install and configure the CLI Step 1 of 3 Select or create a User key. From the top navigation, go to API keys: If you have an existing User key, copy it: If not, click Create key: Select User for Key type, optionally add a name and notes, and click Create key: Copy the key you created. You'll use it to associate your New Relic account with the CLI. The CLI will then use the key to manage entities within your account. Step 2 of 3 Download the SDK's installer for your operating system. Install the SDK for your operating system: Mac download Linux download Windows download Once you've installed the SDK, you'll have access to the nr1 CLI. Verify this by checking your SDK version: bash Copy $ nr1 --version Tip It’s important to distinguish between the newrelic CLI and the nr1 CLI. newrelic is for managing entities in your New Relic account. nr1 is for managing New Relic One applications. Step 3 of 3 Associate your New Relic account as a CLI profile. Use nr1 profiles:add to associate the CLI with your New Relic account: bash Copy $ nr1 profiles:add --name <profile name> --api-key <User key> --region <region> Important Make sure to replace the <profile name> with an arbirary name, the <User key> with the key you copied in Step 1, and the region with either us or eu. Profiles let you select which New Relic account you want to run commands against. If you have multiple accounts, you can view them with profiles:list: bash Copy $ nr1 profiles:list Notice that one profile is your default profile. This is the account your commands will run against, unless you specify another. To specify a profile for a particular command, use the --profile option: bash Copy $ nr1 create --profile <your profile> If this is your first time using the CLI, then the profile you just added is your default profile. If you have other profiles, you need to set your default to the one you'd like to use for this course: bash Copy $ nr1 profiles:default Tip If you forget these commands, you can look them up in the profiles help menu: bash Copy $ nr1 profiles --help Now, you’re ready to build an application with the New Relic One CLI.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 361.96082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " will then use the key to manage entities within your account. Step 2 of 3 Download the <em>SDK</em>&#x27;s installer for your operating system. Install the <em>SDK</em> for your operating system: Mac download Linux download Windows download Once you&#x27;ve installed the <em>SDK</em>, you&#x27;ll have access to the <em>nr1</em> CLI. Verify"
      },
      "id": "607256c9e7b9d2ee9fa5c64b"
    },
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/embed/",
      "sections": [
        "Add a grid",
        "Technical detail"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:42:16Z",
      "type": "",
      "external_id": "bfd5e04da0f000d6970b16677cd5faf8c3b2f461",
      "popularity": 1,
      "body": "In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid/ab-test Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your Nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.72247,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " for your <em>Nerdpack</em>: bash Copy $ <em>nr1</em> <em>nerdpack</em>:uuid -gf Because you cloned the coursework repository that contained an existing <em>Nerdpack</em>, you need to generate your own unique identifier. This UUID maps your <em>Nerdpack</em> to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ <em>nr1</em>"
      },
      "id": "6072565d28ccbc6baf51c18b"
    },
    {
      "image": "https://developer.newrelic.com/static/9fef87cd4b59ba7b2e8df08c97bd3b85/ba3ac/incorrect-auth-header.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/third-party-service/embed/",
      "sections": [
        "Fetch data from a third-party service",
        "Tip"
      ],
      "published_at": "2021-04-16T02:01:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:32:19Z",
      "type": "",
      "external_id": "5a9959f254359afeec9b0a9a9f39dd8b83d8c1ee",
      "popularity": 1,
      "body": "In previous lessons, you learned of a third-party service that you can use to fetch mock cancellation data for the Total cancellations per version chart in your New Relic One application. Even though the data in this service is fake, the real value of this lesson is learning how you can use third party services to supply data to your New Relic One application. If you make a request to the mock service with cancellation data (https://api.nerdsletter.net/cancellations) you'll see a response rejecting your request with a message that reads \"Unauthorized\": bash Copy $ curl https://api.nerdsletter.net/cancellations Unauthorized This is because the Nerdsletter API requires an Authorization header. More specifically, you must pass a bearer token of ABC123 to gain authorized access to its data. If you make a request to the service with the header Authorization: Bearer ABC123, you'll get a successful response with the mocked cancellation data: bash Copy $ curl https://api.nerdsletter.net/cancellations -H 'Authorization: Bearer ABC123' {\"a\": 15, \"b\": 78} In the last lesson, you used NerdGraph to store this API token in your New Relic One application's NerdStorageVault data store. You also passed the token to your TotalCancellations component and logged its use to your browser's console. In this lesson, you follow up that log statement with a real request to the Nerdsletter API using your authorization token. Then, you supply the data from that external resource to your Total cancellations per version chart. Step 1 of 6 Change to the third-party-services/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/third-party-services/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 6 In nerdlets/ab-test-nerdlet/total-cancellations.js, make a request to api.nerdsletter.net with your API token. Save the results to state, and use that state in render(): import React from 'react'; import { HeadingText, PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { constructor() { super(...arguments); this.state = { cancellations: [], lastToken: null } } generateChartData(data) { const cancellationsA = data ? data.a : 0; const cancellationsB = data ? data.b : 0; return [ { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: cancellationsA }, ], }, { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: cancellationsB }, ], }, ] } componentDidUpdate() { if (this.props.token && this.props.token != this.state.lastToken) { console.log(`Requesting data with api token ${this.props.token}`) fetch( \"https://api.nerdsletter.net/cancellations\", {headers: {\"Authorization\": `Bearer ${this.props.token}`}} ).then( (response) => { if (response.status == 200) { return response.json() } else if (response.status == 401) { console.error(\"Incorrect auth header\") } else { console.error(response.text()) } } ).then( (data) => { if (data) { this.setState({ cancellations: this.generateChartData(data), lastToken: this.props.token }) } } ) } } render() { return <div> <HeadingText className=\"chartHeader\"> Total cancellations per version </HeadingText> <PieChart data={this.state.cancellations} fullWidth /> </div> } } nerdlets/ab-test-nerdlet/total-cancellations.js Copy In this code, you initialize TotalCancellations.state.cancellations with zero for the y-value in each series instead of the previously hardcoded values. This helps to more realistically represent what the chart should show if your New Relic One app hasn't successfully requested data from the Nerdsletter API. Next, you use Javascript's fetch() function to make an HTTP request to the Nerdsletter API. You then pass your token in the request's Authorization header. If the request is successful, you update the cancellation data in TotalCancellations.state so that that data is reflected in the component's render method. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/third-party-service/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. It also allows your app to make Nerdgraph requests on behalf of your account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes. If your token in NerdStorageVault is not \"ABC123\", then your console will show an error that reads, \"Incorrect auth header\": If you set the token to \"ABC123\", then Total cancellations per version updates to show the values from the third-party service: Tip If something doesn't work, use your browser's debug tools to try to identify the problem. Make sure you: Copied the code correctly from the lesson Generated a new UUID Replaced all instances of <YOUR NEW RELIC ACCOUNT ID> in your project with your actual New Relic account ID When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Great job! You've come a long way from running nr1 nerdpack:create for the first time. Take a look back at your design guide to see that your application now has everything from an interface and data perspective that you planned from the beginning: You've created eight charts with varying styles and supplied them with dynamic data from multiple sources. You've learned about the New Relic One SDK and used many of its components. You've even gathered data from a third-party service and mixed it seemlessly with your New Relic data to provide a complete look at how the competing versions in your A/B test perform against each other. From here, there is only one more set of APIs in the New Relic One SDK that you've yet to get your hands on: Platform APIs. These will come in handy in improving the usability of your New Relic One application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 341.14868,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "&#x27;s render method. Step 3 of 6 Navigate to the root of your <em>Nerdpack</em> at nru-programmability-course&#x2F;third-party-service&#x2F;ab-test. Step 4 of 6 Generate a new UUID for your <em>Nerdpack</em>: bash Copy $ <em>nr1</em> <em>nerdpack</em>:uuid -gf Because you cloned the coursework repository that contained an existing <em>Nerdpack</em>, you need"
      },
      "id": "606d10ee28ccbc1cd5e1c991"
    }
  ],
  "/explore-docs/custom-viz/configuration-options": [
    {
      "image": "https://developer.newrelic.com/static/28a19f070d3ae2b215793dd163851d7c/0086b/click-add-to-dashboard.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/embed/",
      "sections": [
        "Add custom visualizations to your dashboards",
        "Before you begin",
        "Note",
        "Add your custom visualization to a dashboard",
        "Manage your dashboard visualizations",
        "Summary",
        "Additional resources"
      ],
      "published_at": "2021-04-16T02:20:40Z",
      "title": "",
      "updated_at": "2021-04-10T01:54:48Z",
      "type": "",
      "external_id": "230f853d85188e6617cfa0014204b34fcb2e5c70",
      "popularity": 1,
      "body": "This lesson builds off of the previous Customize visualizations with configuration lesson. If you haven't followed that lesson, please start there as this lesson assumes you have the code you built there to get started. If you don't have a visualization to follow the examples in this gude, a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using nr1.json configuration, in the following steps, you will configure and add your custom visualization to a New Relic dashboard. Before you begin To get started, follow the Customize visualizations with configuration lesson. Then, publish and subscribe to your Nerdpack. Note To publish a Nerdpack you must be a Full user and granted the Nerdpacks “modify” privilege (which is granted by default). Read our documentation to learn more about Nerdpacks privileges. Add your custom visualization to a dashboard Once you've published your custom visualization to your account, in the following steps you'll configure your visualization and add it to a dashboard. You can add a visualization to a new or existing dashboard within your New Relic account. Step 1 of 6 To find the My Awesome Visualization that you have deployed, you need to look for your visualization in the app catalog. From the New Relic One homepage, select the Apps button in the top right navigation bar: Step 2 of 6 Once on the Apps page, click the Custom Visualizations launcher: Note If you don't see the Custom Visualizations tile, use the search to locate it. Step 3 of 6 In Custom Visualizations, you will see all of the visualization that have been deployed to your account and any visualizations you are serving locally. Select the My Awesome Visualization to add to a dashboard and then enable it: Step 4 of 6 In the previous lesson, you reconfigured your visualization to use the platform configurations panel. Use the configuration options to select your desired chart, select your account, insert a NRQL query, and any other configurations you desire. As you make your selections, the visualization will update with your changes: Step 5 of 6 Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name: Step 6 of 6 Click Add to dashboard, then click the link to your dashboard to see the custom visualization: Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations. Summary Congratulations on completing this final lesson and adding your custom visualization to a New Relic dashboard. In the previous lessons, you've used the tools in the New Relic SDK to create a new custom visualization, configured the visualization using the SDK and using the platform configuration panel. Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 772.85767,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>visualizations</em> to <em>your</em> dashboards",
        "body": ", in the following steps, you will <em>configure</em> and add <em>your</em> <em>custom</em> <em>visualization</em> to a New Relic dashboard. Before you begin To get started, follow the Customize visualizations with configuration lesson. Then, publish and subscribe to <em>your</em> Nerdpack. Note To publish a Nerdpack you must be a Full user and granted"
      },
      "id": "60710568196a6793b864a754"
    },
    {
      "image": "https://developer.newrelic.com/static/ddb645bda3b38bb8f8c9eaa7ae882db4/0086b/first-viz.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/embed/",
      "sections": [
        "Introduction to custom visualizations",
        "Build your custom visualization",
        "Your first visualization",
        "Important",
        "Resources",
        "Customize your visualization",
        "Use your custom visualization"
      ],
      "published_at": "2021-04-16T02:16:42Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "edab33e46fbc9f8e054670c52397176ce989ae3a",
      "popularity": 1,
      "body": "When you create a dashboard, you add a variety of charts to visualize your New Relic telemetry data. These charts, offered out-of-the-box, are customizable in that you can: Resize and arrange their positions in your dashboard Update their names, display options, and underlying data queries But sometimes the charts we include in the platform aren't enough for you to get the most from your data. When you want to visualize your data in a specific way that isn't possible with our charts, you can build a custom visualization. New Relic is programmable. This means that if the platform doesn't solve your specific problem, you can write and deploy your own code to fill in some of those gaps. One area where programmability is valuable is in visualizing your data. While New Relic offers all the telemetry data that your apps and services report and provides many different kinds of charts to present that data, you might need to create something entirely unique. With the New Relic One SDK, we've provided you all the tools you'll need to create your own visualizations. Build your custom visualization With the New Relic One SDK, you can create a Nerdpack, which houses your visualization code. This code consists of a React component, logic, data queries, and external dependencies. The SDK also provides a component library that you can use to make NerdGraph requests, access platform state context, and more. Your first visualization To build your first custom visualization, install the New Relic One SDK and make sure you have the latest version: bash Copy $ nr1 update Create a Nerdpack and a visualization: bash Copy $ nr1 create --type nerdpack --name my-first-viz $ cd my-first-viz $ nr1 create --type visualization --name custom-viz The visualization you created in the my-first-viz Nerdpack contains a default component to help you get started. Serve your visualization locally: bash Copy $ nr1 nerdpack:serve Then visit New Relic and navigate to Apps > Custom Visualizations > CustomViz to see it in action: Important To view the locally served visualization, you must use the nerdpacks=local querystring. Enter values into the fields under Configure visualization properties and see how the chart changes: Resources Here is a list of resources for building custom visualizations: Build a custom visualization for dashboards (Guide) Custom visualizations and the New Relic One SDK (Guide) Dashboards and Custom Visualizations (Video) Customize your visualization You have a lot of control over how your visualization operates. You can choose what properties of the visualization are customizable, such as colors, sizes, and how you present your legend. You can choose whether it presents New Relic data or data from an external source. You can even install and use third-party components to create a specific look: Resources Here is a list of resources for configuring custom visualizations: Configuration options (Documentation) Customize visualizations with configuration (Guide) Configuring custom visualizations for dashboards (Video) Use your custom visualization During development, you can serve your visualization locally. Under Apps > Custom Visualizations, you can view and configure your visualization to see how your data looks, but you can't instantiate that chart and use it in your account: To do that, you need to publish it to the New Relic One catalog and subscribe to it from your account. Because custom visualizations are Nerdpack artifacts, you publish and subscribe to them the same way you publish and subscribe to New Relic One applications. Once you've done so, you can add your custom visualization to a dashboard: If you want to reuse your visualization to present different data or the same data in a new way, you can go back to Apps > Custom Visualizations, choose your visualization, configure another instance and add it to your dashboard: Resources Here is a list of resources for using custom visualizations: Add custom visualizations to your dashboards (Documentation) New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil (Blog) Dashboards and Custom Visualizations (Video) Custom Data Visualizations on New Relic (Video)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.11816,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build <em>your</em> <em>custom</em> <em>visualization</em>",
        "body": ") Configuring <em>custom</em> visualizations for dashboards (Video) Use <em>your</em> <em>custom</em> <em>visualization</em> During development, you can serve <em>your</em> <em>visualization</em> locally. Under Apps &gt; <em>Custom</em> Visualizations, you can view and <em>configure</em> <em>your</em> <em>visualization</em> to see how <em>your</em> data looks, but you can&#x27;t instantiate that chart and use"
      },
      "id": "607105a064441fa6da9d8530"
    },
    {
      "image": "https://developer.newrelic.com/static/25bfa8bc13b72a76caaf0744cc55a703/9730c/configurable-props.png",
      "url": "https://developer.newrelic.com/explore-docs/custom-viz/configuration-options/embed/",
      "sections": [
        "Configure your custom visualization",
        "Edit your visualization's metadata",
        "Declare your visualization's configurable properties",
        "boolean",
        "string",
        "number",
        "json",
        "enum",
        "nrql",
        "account-id",
        "namespace",
        "collection",
        "Use nr1.json"
      ],
      "published_at": "2021-04-16T02:20:41Z",
      "title": "",
      "updated_at": "2021-04-10T01:55:44Z",
      "type": "",
      "external_id": "63535453e3cfb5729cadf7bdbc306cefdd09a2aa",
      "popularity": 1,
      "body": "Customize your visualization's configurable properties to make it reusable. In this document, you'll learn what information your visualization's nr1.json file contains, how you can modify it, and how it's used to make your visualization more flexible. Edit your visualization's metadata nr1.json is a metadata file that lives in your visualization directory and looks something like this: { \"schemaType\": \"VISUALIZATION\", \"id\": \"fun-visualization\", \"displayName\": \"FunVisualization\", \"description\": \"\", \"configuration\": [] } nr1.json Copy It contains the following top-level keys: schemaType: Nerdpack artifacts all have nr1.json metadata files. The schemaType describes the artifact's schema. For all visualizations, schemaType is VISUALIZATION. id: Your visualization's string identifier. This must be unique within a given Nerdpack, but it doesn't need to be unique across all Nerdpacks. displayName: The human-readable name that New Relic displays in Custom Visualizations description: The description that New Relic displays in Custom Visualizations configuration: A list of configurable properties for your visualization. You can edit these properties in the web UI and their values are passed to your visualization component. Declare your visualization's configurable properties To declare your visualization's configurable properties, you list them under the configuration key in nr1.json: \"configuration\": [ { \"name\": \"nrqlQueries\", \"title\": \"NRQL Queries\", \"type\": \"collection\", \"items\": [ { \"name\": \"accountId\", \"title\": \"Account ID\", \"description\": \"Account ID to be associated with the query\", \"type\": \"number\" }, { \"name\": \"query\", \"title\": \"Query\", \"description\": \"NRQL query for visualization\", \"type\": \"nrql\" } ] }, { \"name\": \"fill\", \"title\": \"Fill color\", \"description\": \"A fill color to override the default fill color\", \"type\": \"string\" }, { \"name\": \"stroke\", \"title\": \"Stroke color\", \"description\": \"A stroke color to override the default stroke color\", \"type\": \"string\" } ] Copy In this example, nrqlQueries is a collection of query objects. Each query object consists of an accountId and a query. As a collection, you can have multiple query objects in this visualization. fill and stroke are strings that define a color to be used when rendering the visualization. This example configuration results in the following fields in the visualization's setup UI: Notice the + next to NRQL Queries, which you can use to add query objects to the collection. You can also remove queries by hovering over them and clicking - if you have more than one. Also notice the tooltip provided for most of the fields. Each tooltip in the UI corresponds to it's field's description, if it has one. In your React code, you can access the values of these fields in your visualization component's props: export default class MyCustomVisualization extends React.Component { render() { const { nrqlQueries, stroke, fill } = this.props; return <div> <p>Fill color: { fill }</p> <p>Stroke color: { stroke }</p> <p>First query account ID: { nrqlQueries[0].accountId }</p> <p>First query: { nrqlQueries[0].query }</p> </div> } Copy All configuration objects have the following optional keys: name: The React component prop name title: The UI display name description: An tooltip description All configuration objects require a type key that references the field's data type. Each data type is unique in how it's configured and presented. boolean A boolean property is rendered in the UI as a toggle and represents a true or false state. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"showLabels\", \"title\": \"Show labels\", \"description\": \"Toggles the visibility of the chart's labels.\", \"type\": \"boolean\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { showLabels } = this.props; const label = showLabels ? { fill: '#666' } : false return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar label={label} background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy string A string property is rendered in the UI as a text field and represents a character string. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"title\", \"title\": \"Chart title\", \"description\": \"The chart's title.\", \"type\": \"string\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { HeadingText } from 'nr1'; import { RadialBarChart, RadialBar, Legend, Label } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { title } = this.props; return ( <div> <HeadingText className=\"chart-heading\"> {title} </HeadingText> <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> </div> ) } } index.js Copy number A number property is rendered in the UI as a text field and represents a number. number props take three extra optional keys: min: The minimum value the text field can take max: The maximum value the text field can take step: The interval between valid values While these keys are available, they are not enforced. They are purely for UI purposes. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconSize } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={iconSize} /> </RadialBarChart> ) } } index.js Copy json A json property is rendered in the UI as a text box and represents a JSON object. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"description\": \"The data in the chart\", \"type\": \"json\" } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={JSON.parse(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy enum An enum property is rendered in the UI as a drop-down menu and represents a pre-defined list of choices. An enum takes an array of items, each with its own title and value. An item's title is its UI display title. Its value is its React component prop name. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { iconType } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconType={iconType} /> </RadialBarChart> ) } } index.js Copy nrql A nrql property is rendered in the UI as a text box and represents a NRQL query. You can use the NrqlQuery component from the nr1 component library to query New Relic's database. You may need to transform the data to fit your visualization's needs. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"query\", \"title\": \"Query\", \"description\": \"The query for chart data.\", \"type\": \"nrql\" } ] } nr1.json Copy import React from 'react'; import inputData from './data'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { query } = this.props; return ( <NrqlQuery accountId={inputData.accountId} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy account-id An account-id property is rendered in the UI as a drop-down menu and represents a New Relic account. From the menu, you can search for and select an account. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"account\", \"title\": \"Account\", \"description\": \"Select the appropriate New Relic account\", \"type\": \"account-id\" } ] } nr1.json Copy import React from 'react'; import { NrqlQuery } from 'nr1'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { transformData(rawData) { if (rawData) { return rawData.map((entry) => ({ \"name\": entry.metadata.name, \"val\": entry.data[0].y, \"fill\": entry.metadata.color })); } } render() { const { account } = this.props; const query = \"SELECT count(*) FROM Public_APICall FACET `http.method`\" return ( <NrqlQuery accountId={account} query={query} > {({ data }) => { return <RadialBarChart width={1000} height={700} data={this.transformData(data)} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> }} </NrqlQuery> ) } } index.js Copy namespace A namespace groups properties in the UI under a single heading. A namespace has items which are accessed in code, by name, as attributes of the namespace prop. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"legend\", \"title\": \"Legend\", \"type\": \"namespace\", \"items\": [ { \"name\": \"iconSize\", \"title\": \"Icon size\", \"description\": \"The size of legend icons.\", \"type\": \"number\" }, { \"name\": \"iconType\", \"title\": \"Icon shape\", \"description\": \"The shape of legend icons.\", \"type\": \"enum\", \"items\": [ { \"title\": \"square\", \"value\": \"square\" }, { \"title\": \"circle\", \"value\": \"circle\" }, { \"title\": \"diamond\", \"value\": \"diamond\" }, { \"title\": \"star\", \"value\": \"star\" }, { \"title\": \"triangle\", \"value\": \"triangle\" } ] } ] } ] } nr1.json Copy import React from 'react'; import data from './data'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { legend } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" iconSize={legend.iconSize} iconType={legend.iconType} /> </RadialBarChart> ) } } index.js Copy collection A collection is a group of repeatable property sets or namespaces under a single heading. When you create a collection, you specify properties for the collection's child items. When you configure a collection in the UI, you can increase or decrease the amount of child items in the collection. In code, you access the collection prop as an array of items. Example: { \"schemaType\": \"VISUALIZATION\", \"id\": \"custom-viz\", \"displayName\": \"CustomViz\", \"description\": \"MyCustomViz\", \"configuration\": [ { \"name\": \"data\", \"title\": \"Chart data\", \"type\": \"collection\", \"items\": [ { \"name\": \"name\", \"title\": \"Age group\", \"description\": \"The age range of the group.\", \"type\": \"string\" }, { \"name\": \"val\", \"title\": \"Amount\", \"description\": \"The amount of people in the age group.\", \"type\": \"number\", \"min\": 0 }, { \"name\": \"fill\", \"title\": \"Bar color\", \"description\": \"The color of the chart bar.\", \"type\": \"string\" } ] } ] } nr1.json Copy import React from 'react'; import { RadialBarChart, RadialBar, Legend } from 'recharts'; export default class CustomVizVisualization extends React.Component { render() { const { data } = this.props; return ( <RadialBarChart width={1000} height={700} data={data} > <RadialBar background dataKey='val' /> <Legend layout='vertical' verticalAlign='middle' align=\"right\" /> </RadialBarChart> ) } } index.js Copy Use nr1.json You can freely edit nr1.json, but unlike index.js your locally served visualization requires a restart to see its changes. So, if you're serving your visualization locally, teardown your local server with CTRL+C and spin it up again: bash Copy $ nr1 nerdpack:serve If your visualization is already published, you need to update your Nerdpack's version in package.json and publish and subscribe to the new version: bash Copy $ nr1 nerdpack:publish $ nr1 nerdpack:subscribe",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.34688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Configure</em> <em>your</em> <em>custom</em> <em>visualization</em>",
        "body": ". displayName: The human-readable name that New Relic displays in <em>Custom</em> Visualizations description: The description that New Relic displays in <em>Custom</em> Visualizations configuration: A list of configurable properties for <em>your</em> <em>visualization</em>. You can edit these properties in the web UI and their values are passed"
      },
      "id": "607105a164441f96d19d857f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/cloud-migration-quickstart-2.png",
      "url": "https://newrelic.com/blog/how-to-relic/dashboards-and-custom-visualizations",
      "sections": [
        "Visualize your data from scratch or a quickstart",
        "Extend capabilities with the dashboards API and customizations UI",
        "Let’s build together"
      ],
      "published_at": "2021-04-16T04:27:09Z",
      "title": "New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil",
      "updated_at": "2021-04-13T23:29:41Z",
      "type": "",
      "external_id": "5d1ed7d2f89c24024b85aac381ce3940605bd0e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil Feb 25, 2021 • 4 min read By Sebastian Galiano Molina If you’re like most engineers, you may find yourself parsing through data from more sources than ever before. Chances are that you need a way to visualize and customize all the data to fit your organization’s needs, and report and efficiently communicate your analysis to different stakeholders. Starting from scratch isn’t the most efficient way. The good news is that you don’t have to start from scratch. As a New Relic One user, you can begin accessing new dashboards and custom visualization capabilities today that give you access to a library of dashboards, third-party custom visualization capabilities, and quickstart visualizations, based on common use cases in the New Relic One Catalog and the New Relic One Dashboard API. Visualize your data from scratch or a quickstart If you would like a custom visualization, you can create smaller-scale custom widgets and pin them to a dashboard. Is there a visualization you like in a popular JavaScript charting library like D3 or Recharts? You can now use it in your custom visualization connected to the data already in the Telemetry Data Platform. Are you looking for maps, heat maps, and traffic lights to visualize your system movements? We have you covered. Sample charts you can generate using the D3 or Recharts charting library.   To make it even easier to find the template you want, you can access a Quickstarts Library, a community repository of New Relic dashboards, alerts, and installation instructions. Deploy the app in your account to quickly find the template you want and start using it in your account. Best of all? We built this all in open source, which means you can provide feedback and suggestions on use cases you’re looking to solve. Create an issue or send a pull request—we’re building this library for you and your needs. Sample cloud migration quickstart. Extend capabilities with the dashboards API and customizations UI New Relic One dashboards provide custom visualizations that can be automated through templates and a full dashboard CRUD API, with custom chart widgets built with React.js, the ability to pull in third-party library widgets, and a library of templates to get started fast—and all of it in open source. With the recent customization updates, you can now quickly add widgets directly to dashboards simply by clicking “add to dashboards” in the Query Builder. You can also customize existing widgets to display data as you need it: Number and time formatter: Define decimals (e.g., number of 9s in your SLO) and formatting your dates and timestamps (e.g., US format or EU format) Customize y-axis: You can now define how you want your y-axis to behave by setting it to a specific value and ignore outliers Customize y-axis min/max   Format date and time to fit your needs.   Format numbers to appropriate decimal places for more precision.   As a busy engineer, reducing toil is a must. You can use the API to deploy a standard set of dashboards for every new service you create. And if you need inspiration, a large inventory of pre-built custom dashboards reflect observability best practices. You’ll find a range of subject areas, including infrastructure monitoring, cloud, browser, and mobile monitoring. Let’s build together We designed these new capabilities to help you innovate. We’re continuously listening to your feedback and adding more templates, resources, and visualizations to our libraries. Because we’re invested in working in the “open source way” and providing you transparency, our visualization builder pulls from the open source ecosystem, so you can visualize data in any way that you prefer. If you have feedback or suggestions, please feel free to submit it through New Relic One. We’re building an extensive library and we encourage you to join us. Check out developer.newrelic.com to learn more. By Sebastian Galiano Molina Sebastian Galiano Molina is a Senior Product Manager Data Visualization, Data Exploration and Dashboards at New Relic, based in Barcelona. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.21185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Dashboards and <em>Custom</em> <em>Visualizations</em>: Flexibility with Less Toil",
        "sections": "<em>Visualize</em> <em>your</em> data from scratch or a quickstart",
        "body": " cases in the New Relic One Catalog and the New Relic One Dashboard API. Visualize <em>your</em> data from scratch or a quickstart If you would like a <em>custom</em> <em>visualization</em>, you can create smaller-scale <em>custom</em> widgets and pin them to a dashboard. Is there a <em>visualization</em> you like in a popular JavaScript charting"
      },
      "id": "60762965196a677f8464a77b"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.77245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a <em>custom</em> New Relic One application ",
        "sections": "Build a <em>custom</em> New Relic One application",
        "body": " the PageView events reported from New Relic Browser. Tip If <em>your</em> <em>visualization</em> needs are relatively simple, consider using <em>custom</em> charts and <em>custom</em> dashboards. Now, visit our developer site and start building!"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/build-apps/advanced-config": [
    {
      "image": "https://developer.newrelic.com/static/28a19f070d3ae2b215793dd163851d7c/0086b/click-add-to-dashboard.png",
      "url": "https://developer.newrelic.com/build-apps/add-visualizations-to-dashboard/embed/",
      "sections": [
        "Add custom visualizations to your dashboards",
        "Before you begin",
        "Note",
        "Add your custom visualization to a dashboard",
        "Manage your dashboard visualizations",
        "Summary",
        "Additional resources"
      ],
      "published_at": "2021-04-16T02:20:40Z",
      "title": "",
      "updated_at": "2021-04-10T01:54:48Z",
      "type": "",
      "external_id": "230f853d85188e6617cfa0014204b34fcb2e5c70",
      "popularity": 1,
      "body": "This lesson builds off of the previous Customize visualizations with configuration lesson. If you haven't followed that lesson, please start there as this lesson assumes you have the code you built there to get started. If you don't have a visualization to follow the examples in this gude, a accompanying example visualization is available on GitHub Following the previous lesson, you reconfigured your visualization to use the platform configurations panel removing the unneeded SegmentedControl component. Now that you can customize your visualization using nr1.json configuration, in the following steps, you will configure and add your custom visualization to a New Relic dashboard. Before you begin To get started, follow the Customize visualizations with configuration lesson. Then, publish and subscribe to your Nerdpack. Note To publish a Nerdpack you must be a Full user and granted the Nerdpacks “modify” privilege (which is granted by default). Read our documentation to learn more about Nerdpacks privileges. Add your custom visualization to a dashboard Once you've published your custom visualization to your account, in the following steps you'll configure your visualization and add it to a dashboard. You can add a visualization to a new or existing dashboard within your New Relic account. Step 1 of 6 To find the My Awesome Visualization that you have deployed, you need to look for your visualization in the app catalog. From the New Relic One homepage, select the Apps button in the top right navigation bar: Step 2 of 6 Once on the Apps page, click the Custom Visualizations launcher: Note If you don't see the Custom Visualizations tile, use the search to locate it. Step 3 of 6 In Custom Visualizations, you will see all of the visualization that have been deployed to your account and any visualizations you are serving locally. Select the My Awesome Visualization to add to a dashboard and then enable it: Step 4 of 6 In the previous lesson, you reconfigured your visualization to use the platform configurations panel. Use the configuration options to select your desired chart, select your account, insert a NRQL query, and any other configurations you desire. As you make your selections, the visualization will update with your changes: Step 5 of 6 Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard: If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name: Step 6 of 6 Click Add to dashboard, then click the link to your dashboard to see the custom visualization: Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations. Summary Congratulations on completing this final lesson and adding your custom visualization to a New Relic dashboard. In the previous lessons, you've used the tools in the New Relic SDK to create a new custom visualization, configured the visualization using the SDK and using the platform configuration panel. Additional resources New Relic Quick Tips video: Dashboards and Custom Visualizations (6 minutes) New Relic NerdBytes video: Configuring custom visualizations for dashboards (7 minutes) New Relic Nerdlog live stream: Custom Data Visualizations on New Relic (30 minutes) New Relic One SDK components: Intro to New Relic One SDK Component library",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.95001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add custom visualizations to <em>your</em> dashboards",
        "body": " account and any visualizations you are serving locally. Select the My Awesome Visualization to add to a dashboard and then <em>enable</em> it: Step 4 of 6 In the previous lesson, you reconfigured <em>your</em> visualization to use the platform <em>configurations</em> panel. Use the configuration options to select <em>your</em> desired"
      },
      "id": "60710568196a6793b864a754"
    },
    {
      "image": "https://developer.newrelic.com/static/5972bbab1eb47533d3d2171defc47fce/ba3ac/chart-group-syncing.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/chart-group/embed/",
      "sections": [
        "Add a chart group",
        "Tip"
      ],
      "published_at": "2021-04-16T02:03:48Z",
      "title": "",
      "updated_at": "2021-04-15T21:43:09Z",
      "type": "",
      "external_id": "e94780ac131f1a4ce5999771f9bee9650d4f5e9b",
      "popularity": 1,
      "body": "In previous lessons, you added a variety of charts to your A/B test application. These charts presented different facets of information about your A/B test, and they behaved independently from one other. In this lesson, you’ll create a new pair of line charts and learn how to synchronize their behaviors. Before you write any new code, consult your design guide to understand the role that these new charts will play in your application: In the design guide, there is a line graph under each of the tables you created in the last lesson. These line graphs show the version-specific response times for newsletter signup requests. Now, you’ll build two more line charts, but this time, you’ll group them with a ChartGroup and specify that their values are measured in milliseconds. Step 1 of 9 Change to the add-a-chart-group/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-chart-group/ab-test Step 2 of 9 In nerdlets/ab-test-nerdlet, add a new Javascript file named page-views.js: bash Copy $ touch page-views.js Step 3 of 9 In this new file, create a component called VersionPageViews to hold a LineChart, which shows the number of times a page is viewed: import React from 'react'; import { LineChart } from 'nr1'; export default class VersionPageViews extends React.Component { render() { const versionPageViews = { metadata: { id: `page-views-${this.props.version}`, name: `Version ${this.props.version.toUpperCase()}`, viz: 'main', color: 'blue', units_data: { y: 'MS' } }, data: [ { x: 0, y: 10 }, { x: 10, y: 13 }, { x: 20, y: 11.5 }, { x: 30, y: 10 }, { x: 40, y: 8.75 }, { x: 50, y: 9 }, ], } return <LineChart data={[versionPageViews]} fullWidth /> } } nerdlets/ab-test-nerdlet/page-views.js Copy Notice the new attribute in the series' metadata fields: units_data. This attribute describes the unit type for a specified data axis. In this case, you set the unit type for the y axis to 'MS', which stands for milliseconds. Other options for unit types, include: 'PERCENTAGE', 'TIMESTAMP', and 'BYTES_PER_SECOND'. Step 4 of 9 In your Nerdlet's index.js file, import your new component and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <VersionPageViews version='a' /> <VersionPageViews version='b' /> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 9 In index.js, import ChartGroup from nr1 and group your VersionPageViews: import React from 'react'; import { ChartGroup } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> <VersionTotals version='a' /> <VersionTotals version='b' /> <ChartGroup> <VersionPageViews version='a' /> <VersionPageViews version='b' /> </ChartGroup> <PastTests /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Because the tables are conceptually related, as they show contrasting performance metrics over the same timeslice, it makes sense to group them in a ChartGroup. This means that the two charts behave synchronously. For example, when you hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-chart-group/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the LineChart components synchronized in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Tip Each of the chart component types you've used in this lesson have had different series configurations. Most chart components share the same metadata attributes, like LineChart and PieChart, but differ in their data formats. It's helpful to be aware of the different data formats, for when you create your own charts. You can read more about the data formats in the chart component documentation. Now your application is filled with charts, but it doesn't look great. The charts are stacked on top of one another in an unhelpful way. In the next lesson, you'll learn about the user interface components from the SDK and how you can use them to organize your charts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.03563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " hover over one chart, the other chart shows a hover indicator at the same x coordinate. Step 6 of 9 Navigate to the root of <em>your</em> <em>Nerdpack</em> at nru-programmability-course&#x2F;add-a-chart-group&#x2F;ab-test. Step 7 of 9 Generate a new UUID for <em>your</em> <em>Nerdpack</em>: bash Copy $ nr1 <em>nerdpack</em>:uuid -gf Because you cloned"
      },
      "id": "6072ff19e7b9d25dbba5c689"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/embed/",
      "sections": [
        "Create a Nerdpack",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-04-16T02:01:46Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "7487158c521f4cccda9ec299bae4c06242ad07e7",
      "popularity": 1,
      "body": "A Nerdpack is a package that contains all the files that make up a New Relic One application. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet artifact inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.8946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a <em>Nerdpack</em>",
        "body": "&quot; and watch the tool create the foundations of <em>your</em> <em>Nerdpack</em>. Once it&#x27;s finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the <em>Nerdpack</em>: bash Copy $ ls ab-test README.md nerdlets nr1.json"
      },
      "id": "6072fee664441ffa0d9d8546"
    },
    {
      "image": "https://developer.newrelic.com/static/0642dd0fbf77f167e4757a87aee06996/0086b/select-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/serve-app/embed/",
      "sections": [
        "Serve your New Relic One application",
        "Tip"
      ],
      "published_at": "2021-04-16T02:09:03Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:06Z",
      "type": "",
      "external_id": "1a2cfa887902435c407fbdf71157b81a01a14513",
      "popularity": 1,
      "body": "When you build a New Relic One application, it's valuable to view it on the platform. This helps you design, implement, and debug your application in the environment it will eventually be published to. With nr1, you can launch a development server that hosts your application so that New Relic One can present it to you. Step 1 of 4 From inside the Nerdpack's root directory, serve your Nerdpack: bash Copy $ nr1 nerdpack:serve When the Nerdpack has succeeded building and your application is ready to view, you'll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! Notice the appended query parameter nerdpacks=local. This query parameter tells New Relic to show locally served Nerdpacks. Tip If you don't see your application on the New Relic platform, make sure you've included nerdpacks=local in your querystring! Step 2 of 4 Navigate to the provided url. From the home page, select Apps to view New Relic One applications: Step 3 of 4 Under the Your apps section, find your launcher, called \"A/B Test Launcher\": Step 4 of 4 Select your launcher to see your root Nerdlet and its default welcome message: Congratulations, you've served your first New Relic One application! Notice, in the command's output, that the server reloads when you change files in your Nerdpack. Give it a try by updating nerdlets/ab-test-nerdlet/index.js: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>A/B test results</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Your app automatically refreshes to show the new heading:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.94963,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Serve <em>your</em> New Relic One application",
        "body": " can present it to you. Step 1 of 4 From inside the <em>Nerdpack</em>&#x27;s root directory, serve <em>your</em> <em>Nerdpack</em>: bash Copy $ nr1 <em>nerdpack</em>:serve When the <em>Nerdpack</em> has succeeded building and <em>your</em> application is ready to view, you&#x27;ll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test"
      },
      "id": "6072fee564441fe6699d8585"
    },
    {
      "image": "https://developer.newrelic.com/static/63525dcf6b061a9f0e095fbe8a7bf295/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/publish/embed/",
      "sections": [
        "Publish your New Relic One application",
        "Versions and tags",
        "Tip",
        "Publish your first application",
        "Technical detail",
        "View your application in the catalog",
        "Submit catalog information",
        "Update your version tag"
      ],
      "published_at": "2021-04-16T02:02:46Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:07Z",
      "type": "",
      "external_id": "41ee1ef02494dc82084533ad141ff3202f8ae2d4",
      "popularity": 1,
      "body": "In the last lesson, you created catalog information for the A/B test app you've been building throughout this course. Now, it's time to publish your app to the New Relic One catalog and submit those catalog details. Versions and tags Publishing an application requires two key pieces of information: version tag An application's version identifies the code it contains and is stored in the Nerdpack's root-level package.json file. Every time you modify code in your Nerdpack and are ready to release it, you'll update the version in package.json. For example, if you fix some bugs in the first major version your application code, you might publish the changes under version 1.0.1. An app version's tags describe its state. For example, version 0.0.1 of a work-in-progress application might be published with a DEV tag to indicate that it's in development. Tip There are some rules governing how you can use tags and you can read about those in our tags documentation. Publish your first application Step 1 of 7 Change to the publish/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/publish/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 7 Navigate to the root of your Nerdpack at nru-programmability-course/publish/ab-test. Step 3 of 7 Generate your own app UUID: bash Copy $ nr1 nerdpack:uuid -gf The UUID is used to identify your app in the New Relic One app registry. Because you're using code that we developed for this course, an application with the existing UUID already exists in the registry. By generating your own, you're now able to publish this application. Technical detail The UUID also ties your app to your account and, therefore, allows the application to make Nerdgraph requests on behalf of the account that installed it. Step 4 of 7 In package.json, set version to 1.0.0: { \"private\": true, \"name\": \"ab-test\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"2d923ba6-d231-4dd3-830f-b1923577a422\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } Copy New Relic One uses semantic versioning and, under this convention, 1.0.0 signals the first major release. Now, you're ready to publish! Step 5 of 7 Replace all instances of <YOUR NEW RELIC ACCOUNT ID> and <YOUR NEW RELIC ENTITY GUID> in your project with your actual New Relic account ID and entity GUID, respectively. Step 6 of 7 Publish your New Relic One application: bash Copy $ nr1 nerdpack:publish -t DEV That's it! You published your application to New Relic's registry. The -t parameter specifies a tag for your published version. Among other logs, you should see the following confirmation in your console: bash Copy Publishing Nerdpack AbTest (9da77738-9cf6-43c7-9ba0-e3a8c6ac7380) ✔ Nerdpack published successfully! ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as DEV. For now, you've tagged the 1.0.0 release as DEV because it's still a work in progress. Step 7 of 7 View your app's registry information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 4 Version Date Tags ------- ------------- ------ 1.0.0 5 minutes ago DEV The results of this command detail the information stored in New Relic's registry for your application, including its UUID, version, and account ID. View your application in the catalog Now that your application is published and tagged, you can view it in the New Relic One app catalog. Step 1 of 3 Go to New Relic. Notice that you're not using the ?nerdpacks=local querystring parameter. You don't need it anymore because you're not serving your app locally. Step 2 of 3 From the homepage, navigate to Apps: From here, you can see your application under New Relic One catalog: Notice that this is different than when you locally served your app. Local apps and published apps you're subscribed to show under Your apps instead. Step 3 of 3 Click on your app to see more details: Notice the release date and app version. This page should show the information you created in the last lesson. It doesn't yet, because you haven't submitted that information to the catalog, and publishing your app doesn't do that for you. Submit catalog information Even though you've published your application, there are some things that the catalog doesn't know about. These are the descriptions, screenshots, and metadata you created in the last lesson. nr1 catalog is used to submit and view this information. Step 1 of 3 Submit your catalog information: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for AbTest 1.0.0 If everything goes right, you should see a success message notifying you that the screenshots and metadata were updated. You may, however, get an error when submitting this information to the catalog: bash Copy Uploading screenshots... › Error: 1 error while updating AbTest 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN If you do, try again in a minute or two. It can take a few seconds for the catalog to update with the new version of your application. If that doesn't work, make sure you published your app with nr1 nerdpack:publish. Step 2 of 3 View your catalog information: bash Copy $ nr1 catalog:info description: Nerdpack ab-test details: Display test data for our newsletter subscription A/B test displayName: AbTest icon.url: https://nr3.nr-ext.net/artifact-index-production/a685fec2-29fb-40b0-9f65-4178... previews.0.url: https://application-catalog-production.s3.us-east-2.amazonaws.com/nerdpacks/a... releaseDate: 2021-03-12T15:46:09.600138Z repository: https://github.com/newrelic-experimental/nru-programmability-course tagline: Win @ newsletter subscriptions version: 1.0.0 whatsNew.changes: Initial release! Includes: - A variety of charts for understanding the test r... whatsNew.version: 1.0.0 All the information from catalog shows here. Step 3 of 3 View your app in the catalog: Notice the tagline on the app's catalog entry. Click on the app to see more: Here, you see app details, a documentation tab, release notes, and screenshots. Update your version tag Your app looks great in the catalog, complete with metadata, images, and documentation. Before, you tagged the app as DEV because all of the information wasn't ready for public consumption. Now, it is. It's time to update your version tag. Step 1 of 2 Update your 1.0.0 app version from DEV to STABLE: bash Copy $ nr1 nerdpack:tag -t STABLE ✔ Tagged 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 version 1.0.0 as STABLE. Without specifying a version, nr1 uses the version specified in package.json. You can specify a version with the -V command. Learn more about nerdpack:tag with the nr1 nerdpack:tag --help command. Step 2 of 2 View your app information: bash Copy $ nr1 nerdpack:info Id: 9da77738-9cf6-43c7-9ba0-e3a8c6ac7380 Region: us Account ID: 123456 Local version: 1.0.0 Subscription Model: OWNER_AND_ALLOWED Version Count: 1 Version Date Tags ------- ------------- ------ 1.0.0 30 minutes ago STABLE The app is now tagged with STABLE, indicating it's ready for public use. Technical detail Even though the app is ready for public use, it's still only visible to users of your account. Other accounts can't see apps created by other private accounts unless those apps are added to the public New Relic One catalog. Now that your app is published and its metadata is submitted, you can subscribe your account to the app from the catalog. In the next lesson, you'll learn the ways to subscribe and unsubscribe to your new application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.013,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish <em>your</em> New Relic One application",
        "body": ": version tag An application&#x27;s version identifies the code it contains and is stored in the <em>Nerdpack</em>&#x27;s root-level package.json file. Every time you modify code in <em>your</em> <em>Nerdpack</em> and are ready to release it, you&#x27;ll update the version in package.json. For example, if you fix some bugs in the first major"
      },
      "id": "60730001e7b9d2de18a5c660"
    }
  ],
  "/build-apps/publish-deploy/serve": [
    {
      "image": "https://developer.newrelic.com/static/0642dd0fbf77f167e4757a87aee06996/0086b/select-apps.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/serve-app/embed/",
      "sections": [
        "Serve your New Relic One application",
        "Tip"
      ],
      "published_at": "2021-04-16T02:09:03Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:06Z",
      "type": "",
      "external_id": "1a2cfa887902435c407fbdf71157b81a01a14513",
      "popularity": 1,
      "body": "When you build a New Relic One application, it's valuable to view it on the platform. This helps you design, implement, and debug your application in the environment it will eventually be published to. With nr1, you can launch a development server that hosts your application so that New Relic One can present it to you. Step 1 of 4 From inside the Nerdpack's root directory, serve your Nerdpack: bash Copy $ nr1 nerdpack:serve When the Nerdpack has succeeded building and your application is ready to view, you'll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test it at: https://one.newrelic.com/?nerdpacks=local ↩ Server will reload automatically if you modify any file! Notice the appended query parameter nerdpacks=local. This query parameter tells New Relic to show locally served Nerdpacks. Tip If you don't see your application on the New Relic platform, make sure you've included nerdpacks=local in your querystring! Step 2 of 4 Navigate to the provided url. From the home page, select Apps to view New Relic One applications: Step 3 of 4 Under the Your apps section, find your launcher, called \"A/B Test Launcher\": Step 4 of 4 Select your launcher to see your root Nerdlet and its default welcome message: Congratulations, you've served your first New Relic One application! Notice, in the command's output, that the server reloads when you change files in your Nerdpack. Give it a try by updating nerdlets/ab-test-nerdlet/index.js: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>A/B test results</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Your app automatically refreshes to show the new heading:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.57475,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Serve</em> your New Relic One application",
        "body": " can present it to you. Step 1 of 4 From inside the <em>Nerdpack</em>&#x27;s root directory, <em>serve</em> your <em>Nerdpack</em>: bash Copy $ nr1 <em>nerdpack:serve</em> When the <em>Nerdpack</em> has succeeded building and your application is ready to view, you&#x27;ll see a message with a link to New Relic One: bash Copy ✔ Server ready! Test"
      },
      "id": "6072fee564441fe6699d8585"
    },
    {
      "image": "https://developer.newrelic.com/static/c0fc692420367ccce1f5a49d4844c098/ba3ac/grid-screenshot.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/grid/embed/",
      "sections": [
        "Add a grid",
        "Technical detail"
      ],
      "published_at": "2021-04-16T02:00:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:42:16Z",
      "type": "",
      "external_id": "bfd5e04da0f000d6970b16677cd5faf8c3b2f461",
      "popularity": 1,
      "body": "In previous hands-on lessons, you created all the charts from your design guide. Unfortunately, they aren’t laid out like they are in the design. The New Relic One SDK provides multiple solutions for organizing your components. The one you’ll learn about in this lesson is the Grid component. To arrange your charts, place them in a Grid. A Grid is a container you use to organize your content into 12-column rows. A GridItem is the building block for a Grid. You specify the columnSpan of a GridItem between 1 and 12 to determine how much of the row that the GridItem should cover. So, if you want a chart to stretch across the width of the view, you would place the chart in a GridItem with a columnSpan of 12. If you want twelve charts to fit in a single row, use a columnSpan of 1. Using the design guide as a base, you can plan how to organize your Grid: Once you’ve planned out how you’re going to arrange your columns, you can write some code to realize your plans. Step 1 of 6 Change to the add-a-grid/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-a-grid/ab-test Step 2 of 6 In your Nerdlet's index.js file, import Grid and GridItem. Then, update your Nerdlet's render() method by placing each chart in a GrildItem. Finally, place all your items in a Grid: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy The columnSpan for each chart matches the layout plan. Every chart that takes up half the 12-column row has a columnSpan of 6, and every chart that takes up the whole row has a columnSpan of 12. Notice that each of the charts in the ChartGroup, but not the ChartGroup itself, is in a GridItem. A ChartGroup connects charts' behaviors, not their locations. Each chart fills its columnSpan because they use the fullWidth prop. fullWidth makes the chart fill its available horizontal space and GridItem.columnSpan restricts that space to some fraction of the row. Remove a fullWidth prop, and see how the chart reacts. Technical detail Notice the wrapper class applied to the Grid. We quietly provided some CSS styles to help make this app look great! This isn't a CSS course, so we won't cover everything we added, we'll just include the styles we intend for you to use in the code snippets. Just know that every UI component in the New Relic One SDK provides a className prop where you can provide a CSS class name. You can view the styles in nerdlets/ab-test-nerdlet/styles.scss. Step 3 of 6 Navigate to the root of your Nerdpack at nru-programmability-course/add-a-grid/ab-test. Step 4 of 6 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 6 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 6 View your changes in New Relic: Here, you see your charts styled and arranged in a grid. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In just six steps, you significantly improved the readability and usability of your A/B test application, but you can take further steps to improve the usability of your charts. In the next lesson, you’ll add headings to your charts to remind yourself of what data each chart presents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.68703,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " for your <em>Nerdpack</em>: bash Copy $ nr1 <em>nerdpack</em>:uuid -gf Because you cloned the coursework repository that contained an existing <em>Nerdpack</em>, you need to generate your own unique identifier. This UUID maps your <em>Nerdpack</em> to your New Relic account. Step 5 of 6 <em>Serve</em> your application locally: bash Copy $ nr1"
      },
      "id": "6072565d28ccbc6baf51c18b"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/embed/",
      "sections": [
        "Add pie charts"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "c0f472d2ed9df8035313cd76ee83ec43e75d0a4a",
      "popularity": 1,
      "body": "You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.6648,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " <em>Serve</em> your application locally: bash Copy $ nr1 <em>nerdpack:serve</em> Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you&#x27;re finished, stop serving your New Relic One application by pressing CTRL+C in your local server&#x27;s terminal window"
      },
      "id": "6072ffcc28ccbc786651c18a"
    },
    {
      "image": "https://developer.newrelic.com/static/733ffe1b10df224863d5c0b4f69894ce/0086b/first-chart.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/first-chart/embed/",
      "sections": [
        "Add your first chart"
      ],
      "published_at": "2021-04-16T02:09:02Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "a6647ae7e6f32626783c432c4c7a2d4e0d896f8d",
      "popularity": 1,
      "body": "In this course, you’re building an A/B test application for the New Relic platform. Previously, you learned about the New Relic One SDK and its component library. Now, It’s time for you to start building your application focusing first on chart components. Before you write any code, consult your design guide to remember what the application will look like when you finish: There are several charts you need to create, which may seem overwhelming at first, but take it one step at a time. The topmost chart, and the first you’ll create, is a line chart that shows the number of users who sign up for your newsletter and what version of your website they were shown. Step 1 of 8 Change to the add-your-first-chart/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-your-first-chart/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named newsletter-signups.js: bash Copy $ touch newsletter-signups.js Step 3 of 8 In this new file, create a component called NewsletterSignups to hold your first LineChart and some mock data: import React from 'react'; import { LineChart } from 'nr1'; export default class NewsletterSignups extends React.Component { render() { const versionASignups = { metadata: { id: 'version-a-newsletter-signups', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 15 }, { x: 30, y: 5 }, { x: 40, y: 30 }, { x: 50, y: 25 }, ], } const versionBSignups = { metadata: { id: 'version-b-newsletter-signups', name: 'Version B', viz: 'main', color: 'green', }, data: [ { x: 0, y: 20 }, { x: 10, y: 5 }, { x: 20, y: 25 }, { x: 30, y: 45 }, { x: 40, y: 50 }, { x: 50, y: 35 }, ], } return <LineChart data={[versionASignups, versionBSignups]} fullWidth /> } } nerdlets/ab-test-nerdlet/newsletter-signups.js Copy Here, you’ve created two arbitrary data series which represent versions A and B of your test. Right now, you're using manually-crafted data points. In the future, you'll replace these with data queried from New Relic. Notice that you’ve specified a color for each series in the chart. The color metadata attribute takes any CSS-acceptable color format. Setting viz: 'main' means that you want to render the LineChart series as a line, the component's default display style. For the data prop in the LineChart component, you passed the two series in an array so that both are represented together. Finally, you used the chart’s fullWidth prop to stretch the chart’s width to fill the view. Step 4 of 8 In your Nerdlet's index.js file, import your new component and replace the default heading in your Nerdlet's render() method with your new component: import React from 'react'; import NewsletterSignups from './newsletter-signups'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-your-first-chart/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes in New Relic: Here, you see the LineChart displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. In seven steps, you’ve breathed life into your New Relic One application. Instead of a bland “Hello world” message, your application now shows a colorful line chart with two mocked data series. These data series represent server-side traffic for each of the competing designs in your demo website. In the next lesson, you’ll build on this foundation by creating another chart type.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.6648,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Step 7 of 8 <em>Serve</em> your application locally: bash Copy $ nr1 <em>nerdpack:serve</em> Step 8 of 8 View your changes in New Relic: Here, you see the LineChart displayed in your application. When you&#x27;re finished, stop serving your New Relic One application by pressing CTRL+C in your local server&#x27;s terminal"
      },
      "id": "607256c964441f74479d8559"
    },
    {
      "image": "https://developer.newrelic.com/static/31d9850a96215e9e5a7cac8197d86fd8/ba3ac/version-descriptions.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/version-descriptions/embed/",
      "sections": [
        "Add version descriptions"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:29:21Z",
      "type": "",
      "external_id": "5bf9eb481abfbf304b939fe6a2fd83dd458e9186",
      "popularity": 1,
      "body": "With your charts organized and descriptive headings above each one, your New Relic One application is becoming more usable. In this lesson, you'll continue that trend by creating descriptions for each design version in your A/B test. Step 1 of 8 Change to the add-version-descriptions/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-version-descriptions/ab-test Step 2 of 8 In nerdlets/ab-test-nerdlet, add a new Javascript file named description.js: bash Copy $ touch description.js Step 3 of 8 In this new file, create a new React component, called VersionDescription, which uses a HeadingText and a BlockText to render a version description that you pass, using the description prop: import React from 'react'; import { BlockText, HeadingText } from 'nr1'; export default class VersionDescription extends React.Component { constructor(props) { super(props); } render() { return ( <div> <HeadingText className=\"versionHeader\"> Version {this.props.version} </HeadingText> <BlockText className=\"versionText\"> {this.props.description} </BlockText> </div> ) } } nerdlets/ab-test-nerdlet/description.js Copy You'll use this one class to create a version description for each design version in your A/B test. Step 4 of 8 In your Nerdlet's index.js file, import VersionDescription, create descriptions for each design version, and create a new GridItem component for each design version: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Here, you've created two VersionDescription components. You passed the description and version props, which correspond to a design version. You also added a horizontal rule to visually separate the descriptions from the charts in your app. For this, you added a GridItem with a columnSpan of 12, to stretch the rule the full width of the grid. Step 5 of 8 Navigate to the root of your Nerdpack at nru-programmability-course/add-version-descriptions/ab-test. Step 6 of 8 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 7 of 8 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 8 of 8 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Now, you've added descriptions for your competing designs and your charts. In the next lesson, you’ll create a new section of your application from user interface components. This section will be used to end the A/B test with the click of a button.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.57672,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the coursework repository that contained an existing <em>Nerdpack</em>, you need to generate your own unique identifier. This UUID maps your <em>Nerdpack</em> to your New Relic account. Step 7 of 8 <em>Serve</em> your application locally: bash Copy $ nr1 <em>nerdpack:serve</em> Step 8 of 8 View your changes: When you&#x27;re finished, stop serving"
      },
      "id": "6072569228ccbc932d51c172"
    }
  ],
  "/ab-test": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/ab-test/create-nerdpack/embed/",
      "sections": [
        "Create a Nerdpack",
        "Root directory",
        "Javascript files",
        "Metadata file",
        "Launchers",
        "Nerdlets",
        "Tip"
      ],
      "published_at": "2021-04-16T02:01:46Z",
      "title": "",
      "updated_at": "2021-04-15T21:36:24Z",
      "type": "",
      "external_id": "7487158c521f4cccda9ec299bae4c06242ad07e7",
      "popularity": 1,
      "body": "A Nerdpack is a package that contains all the files that make up a New Relic One application. Nerdpacks include files for metadata, Nerdlets, assets, and more. To create a Nerdpack, use the New Relic One CLI: bash Copy $ nr1 create --type nerdpack When nr1 prompts for a component name, use \"ab-test\" and watch the tool create the foundations of your Nerdpack. Once it's finished, explore the files it created for you. Root directory At the root level, you have a directory called ab-test. Everything inside this directory is part of the Nerdpack: bash Copy $ ls ab-test README.md nerdlets nr1.json package.json launchers node_modules package-lock.json Readme.md provides instructions for creating Nerdpack elements and serving your application locally. This and nr1 --help are useful if you forget how to interact with your Nerdpack using the command line tool. Javascript files package.json, package-lock.json, and node_modules are important for running your JavaScript application, but aren't unique to Nerdpacks. You can learn about these modules from JavaScript courses should you need to tweak them. For now, take a look at nr1.json, one of the most relevant files in this directory. Metadata file nr1.json is the Nerdpack's metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One application for running and analyzing A/B tests, update the package's displayName to \"A/B Test\" and set the description to \"A/B test your application using New Relic One\": { \"schemaType\": \"NERDPACK\", \"id\": \"311bcd0c-f7eb-4285-afed-4219179bf91d\", \"displayName\": \"A/B Test\", \"description\": \"A/B test your application using New Relic One.\" } nr1.json Copy It's good to describe your application's purpose, especially if you're going to publish your application for others to use. Next, look at the launchers and nerdlets subdirectories. Launchers launchers is a directory because you can create multiple launchers for your New Relic One application. nr1 create only created one launcher for your Nerdpack and called it \"ab-test-launcher\". Inside its directory, there are two files: icon.png is an image that represents the application nr1.json is the launcher's metadata file Use \"A/B Test Launcher\" for the launcher's displayName and \"Open the A/B test Nerdlet\" for the description in nr1.json: { \"schemaType\": \"LAUNCHER\", \"id\": \"ab-test-launcher\", \"displayName\": \"A/B Test Launcher\", \"description\": \"Open the A/B test Nerdlet\", \"rootNerdletId\": \"ab-test-nerdlet\" } launchers/ab-test-launcher/nr1.json Copy Notice that the launcher has a rootNerdletId. This identifies the Nerdlet that the launcher opens when it's selected. This Nerdpack has only one Nerdlet, called ab-test-nerdlet, but some Nerdpacks may have multiple. Make sure that you set the rootNerdletId to the Nerdlet you want the launcher to open. Nerdlets The nerdlets directory contains all the Nerdlets that make up your New Relic One application. Since ab-test-nerdlet is the only Nerdlet in this Nerdpack, there is only one subdirectory. In nerdlets/ab-test-nerdlet, there are three files: index.js is the JavaScript file that contains your Nerdlet component styles.scss holds the Sass stylesheet for your Nerdlet nr1.json contains the Nerdlet's metadata Update your Nerdlet's displayName to \"A/B Test\" and description to \"Control and view results of your A/B test\": { \"schemaType\": \"NERDLET\", \"id\": \"ab-test-nerdlet\", \"displayName\": \"A/B Test\", \"description\": \"Control and view results of your A/B test\" } nerdlets/ab-test-nerdlet/nr1.json Copy Now, you've customized your Nerdpack, Nerdlet, and launcher with informative display names and descriptions, but what does your application actually do? Check out index.js to see what your default Nerdlet looks like: import React from 'react'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <h1>Hello, ab-test-nerdlet Nerdlet!</h1>; } } nerdlets/ab-test-nerdlet/index.js Copy Here, you have AbTestNerdletNerdlet, which nr1 created for you. It's a React component that renders a first-level welcome heading. Because this is the root Nerdlet, as specified in your launcher's nr1.json file, when you click on your launcher in the New Relic platform, the launcher will open a view that displays this heading. Tip In this lesson, you used nr1 create to create a Nerdpack, complete with a launcher and a Nerdlet. If you want to create another Nerdlet or Launcher in your Nerdpack, you can also do that with nr1 create: bash Copy $ nr1 create --type nerdlet $ nr1 create --type launcher You can even skip the --type flag and select an option from a list: bash Copy $ nr1 create ? What kind of component do you want to create? › - Use arrow-keys. Return to submit. nerdpack ❯ nerdlet - create a/an Nerdlet artifact inside your Nerdpack. launcher catalog visualization In the next lesson, you'll learn how to serve your Nerdpack locally and see your app in action!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.26112,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create <em>a</em> Nerdpack",
        "body": " file nr1.json is the Nerdpack&#x27;s metadata file, containing a schema type, unique identifier, a display name, and a description. Since you’re building a New Relic One <em>application</em> for running and analyzing A&#x2F;<em>B</em> tests, update the package&#x27;s displayName to &quot;A&#x2F;<em>B</em> <em>Test</em>&quot; and set the description to &quot;A&#x2F;<em>B</em> <em>test</em>"
      },
      "id": "6072fee664441ffa0d9d8546"
    },
    {
      "image": "https://developer.newrelic.com/static/94e5a261137b037470725fb4c1806cb8/ba3ac/charts-design-guide.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/add-charts/embed/",
      "sections": [
        "Add chart components to your A/B test application"
      ],
      "published_at": "2021-04-16T02:04:41Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:07Z",
      "type": "",
      "external_id": "c6c3610a3267705c0888958509095a737b8c7f7e",
      "popularity": 1,
      "body": "The New Relic One application that you're building throughout this course allows developers to A/B test their websites. To run a successful A/B test, site owners need to be able to analyze the results. Without knowing how each design performs, how will developers determine which design to use? Here is a mockup for the A/B test application you're building: Your application displays data for two competing versions. With various charts and tables, your users will be able to analyze the results of their test and make informed decisions on which design will work best to achieve their goals. You’ll refer back to this mockup many times throughout this course. It shows you what charts to create, how to organize them, and what kind of data to provide them. In the next four sections, you learn how to create every chart that your A/B test application needs to operate effectively. After that, you’ll arrange the charts to match the mockup’s design and supply New Relic data collected from the demo applications you spun up earlier.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.65875,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> chart components to your <em>A</em>&#x2F;<em>B</em> <em>test</em> <em>application</em>",
        "body": "The New Relic One <em>application</em> that you&#x27;re building throughout this course allows developers to A&#x2F;<em>B</em> <em>test</em> their websites. To run a successful A&#x2F;<em>B</em> <em>test</em>, site owners need to be able to analyze the results. Without knowing how each design performs, how will developers determine which design to use? Here"
      },
      "id": "606e639828ccbc82c1542179"
    },
    {
      "image": "https://developer.newrelic.com/static/0bfb3b922442fc57c0a3d5f0bb95b8e6/ba3ac/end-test-section-v1.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/end-test/embed/",
      "sections": [
        "Add a section to end your test"
      ],
      "published_at": "2021-04-16T02:05:47Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:49Z",
      "type": "",
      "external_id": "6c1d9d3997eff7f27d00dbf9c8f451f5bec750d9",
      "popularity": 1,
      "body": "In this course, you’re building an A/B test application in New Relic. The application presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective and show that design to every user who visits your site. In this lesson, you’ll build a form into your application that lets you choose which design you want to show to every user of your site. Before writing any code, look at your design guide to review the section you’re going to build: This new section has three main components: A heading with instructional copy: \"Pick a version to end the test\" A component that you use to crown the winning version of the A/B test A button to confirm the winner that you selected Step 1 of 10 Change to the add-end-test-section/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-end-test-section/ab-test Step 2 of 10 In nerdlets/ab-test-nerdlet, add a new Javascript file named end-test.js: bash Copy $ touch end-test.js Step 3 of 10 In this new file, create a VersionSelector component to encapsulate a Select and its SelectItem child components: import React from 'react'; import { Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } nerdlets/ab-test-nerdlet/end-test.js Copy VersionSelector renders a Select component with two choices. In each SelectItem, you specify a value prop. In this case, you use 'A' to represent version A and 'B' to represent version B. Step 4 of 10 Create another component for a Button you'll use to make your test as ended: import React from 'react'; import { Button, Select, SelectItem } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } nerdlets/ab-test-nerdlet/end-test.js Copy This looks trivial, but it will encapsulate button logic as you iterate on your app code. Step 5 of 10 Create a final component for the entire section you'll use to mark the end of your test: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { render() { return <Select> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button>End test</Button> </div> } } export default class EndTestSection extends React.Component { render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you create a Grid with three items. First, you create a GridItem that contains a HeadingText and spans all 12 columns. In the next row, you have two items: The VersionSelector component you created in the previous step A Button which reads \"End test\" These items each span one column, but instead of using columnSpan, they use a combination of columnStart and columnEnd to specify which columns they cover. Step 6 of 10 In your Nerdlet's index.js file, add EndTestSection to your Nerdlet: import React from 'react'; import { ChartGroup, Grid, GridItem } from 'nr1'; import EndTestSection from './end-test'; import NewsletterSignups from './newsletter-signups'; import PastTests from './past-tests'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; import VersionDescription from './description'; import VersionPageViews from './page-views'; import VersionTotals from './totals'; const VERSION_A_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter\"' const VERSION_B_DESCRIPTION = 'The newsletter signup message says, \"Sign up for our newsletter and get a free shirt!\"' export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <Grid className=\"wrapper\"> <GridItem columnSpan={6}> <VersionDescription description={VERSION_A_DESCRIPTION} version=\"A\" /> </GridItem> <GridItem columnSpan={6}> <VersionDescription description={VERSION_B_DESCRIPTION} version=\"B\" /> </GridItem> <GridItem columnSpan={12}><hr /></GridItem> <GridItem columnSpan={12}><NewsletterSignups /></GridItem> <GridItem columnSpan={6}><TotalSubscriptions /></GridItem> <GridItem columnSpan={6}><TotalCancellations /></GridItem> <GridItem columnSpan={6}><VersionTotals version='a' /></GridItem> <GridItem columnSpan={6}><VersionTotals version='b' /></GridItem> <ChartGroup> <GridItem columnSpan={6}> <VersionPageViews version='a' /> </GridItem> <GridItem columnSpan={6}> <VersionPageViews version='b' /> </GridItem> </ChartGroup> <GridItem columnSpan={12}><EndTestSection /></GridItem> <GridItem columnSpan={12}><PastTests /></GridItem> </Grid> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 7 of 10 Navigate to the root of your Nerdpack at nru-programmability-course/add-end-test-section/ab-test. Step 8 of 10 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 9 of 10 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 10 of 10 View your changes: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. However, you need to make a few improvements to this code. When you select a version, the selected value in the component doesn't change. You must control the value that Select displays using its value prop and onChange event handler. In the next lesson, you’ll update your code to persist your version choice in the Select component.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.05624,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> <em>a</em> section to end your <em>test</em>",
        "body": "In this course, you’re building an A&#x2F;<em>B</em> <em>test</em> <em>application</em> in New Relic. The <em>application</em> presents a lot of data, through its charts, about the effectiveness of each design version you’re testing on your demo website. Ultimately, you’ll be able to use that data to decide which design is most effective"
      },
      "id": "6072569228ccbc8f6151c174"
    },
    {
      "image": "https://developer.newrelic.com/static/64fe6f33655b8b090cae9ae2a7571df2/ba3ac/pie-charts.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/pie-charts/embed/",
      "sections": [
        "Add pie charts"
      ],
      "published_at": "2021-04-16T01:59:56Z",
      "title": "",
      "updated_at": "2021-04-15T21:39:40Z",
      "type": "",
      "external_id": "c0f472d2ed9df8035313cd76ee83ec43e75d0a4a",
      "popularity": 1,
      "body": "You’ve begun building your A/B test application. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll build in this lesson, review the design guide to remember what charts come next: In the design, there are two pie charts beneath the line chart that you’ve already created. One represents the distribution of users who receive version A and version B. The other represents the distribution of successful requests from users who got version A and version B. Step 1 of 9 Change to the add-pie-charts/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/add-pie-charts/ab-test This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 9 In nerdlets/ab-test-nerdlet, add two new Javascript files: total-subscriptions.js total-cancellations.js bash Copy $ touch total-subscriptions.js total-cancellations.js Step 3 of 9 In total-subscriptions.js, create a component, called TotalSubscriptions, which renders mocked subscription data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalSubscriptions extends React.Component { render() { const subscriptionsA = { metadata: { id: 'subscriptions-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 259 }, ], } const subscriptionsB = { metadata: { id: 'subscriptions-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 318 }, ], } return <PieChart data={[subscriptionsA, subscriptionsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Notice that the series data is formatted differently for PieChart than it was for LineChart. Because PieChart uses unidimensional data, its series only take y-values. Step 4 of 9 In total-cancellations.js, create a component, called TotalCancellations, which renders mocked cancellation data: import React from 'react'; import { PieChart } from 'nr1'; export default class TotalCancellations extends React.Component { render() { const cancellationsA = { metadata: { id: 'cancellations-A', name: 'Version A', viz: 'main', color: 'blue', }, data: [ { y: 118 }, ], } const cancellationsB = { metadata: { id: 'cancellations-B', name: 'Version B', viz: 'main', color: 'green', }, data: [ { y: 400 }, ], } return <PieChart data={[cancellationsA, cancellationsB]} fullWidth /> } } nerdlets/ab-test-nerdlet/total-subscriptions.js Copy Step 5 of 9 In your Nerdlet's index.js file, import your new components and update your Nerdlet's render() method: import React from 'react'; import NewsletterSignups from './newsletter-signups'; import TotalCancellations from './total-cancellations'; import TotalSubscriptions from './total-subscriptions'; export default class AbTestNerdletNerdlet extends React.Component { render() { return <div> <NewsletterSignups /> <TotalSubscriptions /> <TotalCancellations /> </div> } } nerdlets/ab-test-nerdlet/index.js Copy Step 6 of 9 Navigate to the root of your Nerdpack at nru-programmability-course/add-pie-charts/ab-test. Step 7 of 9 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 8 of 9 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 9 of 9 View your changes in New Relic: Here, you see the PieChart components displayed in your application. When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Your application is starting to take shape. You’ve created a line chart and two pie charts. For now, these charts use mocked data, but you’ll provide them real data in a later lesson. Before you focus on the data in your charts, however, you’ll learn how to add a table to your application so you can visualize data in a new way.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.04456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> pie charts",
        "body": "You’ve begun building your A&#x2F;<em>B</em> <em>test</em> <em>application</em>. So far, it consists of a single line chart, which represents the number of subscriptions your newsletter receives from each version of your website. To understand what you’ll <em>build</em> in this lesson, review the design guide to remember what charts come"
      },
      "id": "6072ffcc28ccbc786651c18a"
    },
    {
      "image": "https://developer.newrelic.com/static/4c8cde0a54474df47cb4ef715beaf644/ba3ac/end-test-modal.png",
      "url": "https://developer.newrelic.com/build-apps/ab-test/confirmation-modal/embed/",
      "sections": [
        "Present an end test confirmation modal",
        "Show and hide your confirmation modal",
        "Tip",
        "Use the version you selected in your modal"
      ],
      "published_at": "2021-04-16T02:06:50Z",
      "title": "",
      "updated_at": "2021-04-15T21:38:51Z",
      "type": "",
      "external_id": "554a84f8fe2faf9c2b867686538360771e22fc3c",
      "popularity": 1,
      "body": "In this tutorial, you're building an A/B test application. The application surfaces data about an ongoing A/B test on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you're building a section which allows you to end the test by deciding a winner of the experiment: Unfortunately, there are a few issues with the code and design for this section. By the end of this course, pressing End test will tell your website's backend server that every customer should see the version selected here. This is destructive behavior because it makes an irreversible change to your website. To account for the desctructiveness of pressing End test, you need to modify some features of your application: Make the button look important to catch your eye Prompt yourself with a confirmation message before ending the test to ensure you don't end it prematurely Show and hide your confirmation modal Step 1 of 12 Change to the present-confirmation-modal/ab-test directory of the coursework repository: bash Copy $ cd nru-programmability-course/present-confirmation-modal/ab-test This directory contains the code your application should have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next. Step 2 of 12 In nerdlets/ab-test-nerdlet/end-test.js, update the Button to use the DESTRUCTIVE styling: import React from 'react'; import { Button, Grid, GridItem, HeadingText, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Tip Read more about Button and its props on the New Relic developer site. Step 3 of 12 Navigate to the root of your Nerdpack at nru-programmability-course/present-confirmation-modal/ab-test. Step 4 of 12 Generate a new UUID for your Nerdpack: bash Copy $ nr1 nerdpack:uuid -gf Because you cloned the coursework repository that contained an existing Nerdpack, you need to generate your own unique identifier. This UUID maps your Nerdpack to your New Relic account. Step 5 of 12 Serve your application locally: bash Copy $ nr1 nerdpack:serve Step 6 of 12 View your application: Now you've styled your button to convey its destructive consequences, but that's not enough to prevent you from accidentally clicking it. Next, you create a shield for your website's backend. This extra layer of protection requires you to confirm that you intend to end the test before actually doing so. Step 7 of 12 Add a Modal to EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Your new modal contains a heading, a confirmation message, the winning design version, and two buttons. You'll explore some of these components later in this course. With your Nerdpack served locally, view your application to see your new Modal: Tip Remember, while your server is running, it will update automatically when you save your code. The modal looks great, but it has three issues: It was present before you clicked End test You can't dismiss it It always says you selected \"Version A\", even if you didn't In the following steps, you'll correct all three of these issues. Step 8 of 12 In EndTestButton, initialize state with a value for modalHidden: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor(props) { super(props); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy modalHidden determines whether or not to hide the modal. The default value of modalHidden is true because you only want to show the modal when you select End test. Step 9 of 12 Supply modalHidden to the Modal: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy First, you've created a constructor to accept component props. This provides your component access to the modalHidden prop that you passed in EndTestSection. Then you provide the value of modalHidden to the Modal component's hidden prop. Tip Read more about Modal and its props on the New Relic developer site. Step 10 of 12 Add and bind two new methods to EndTestSection: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Use closeModal and showModal to close and show your modal, respectively, depending on how a user interacts with the modal. Step 11 of 12 Show the modal when you click End test: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Here, you've supplied showModal() as the callback for the Button component's onClick event. View your application where the modal is hidden by default. Click End test to see the modal. Step 12 of 12 Close the modal from the Modal component's onClose callback and from the Yes, end test and No, continue test buttons: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and click End test. The modal opens and displays your confirmation message. Close the modal by clicking X at the top right, either of its buttons, or even in the dark space to its left. Notice that the modal says you chose \"Version A\", even if you choose \"Version B\". This is because \"Version A\" is hardcoded in the Modal text. Next, you'll make that dynamic. Use the version you selected in your modal Step 1 of 2 In EndTestSection, pass selectedVersion to the EndTestButton: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version A</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy Now, you can access the selected version from the EndTestButton component's props. Step 2 of 2 Use selectedVersion in your confirmation message: import React from 'react'; import { BlockText, Button, Grid, GridItem, HeadingText, Modal, Select, SelectItem, } from 'nr1'; class VersionSelector extends React.Component { constructor(props) { super(props); } render() { return <Select onChange={this.props.selectVersion} value={this.props.selectedVersion}> <SelectItem value={'A'}>Version A</SelectItem> <SelectItem value={'B'}>Version B</SelectItem> </Select> } } class EndTestButton extends React.Component { constructor() { super(...arguments); this.state = { modalHidden: true, } this.showModal = this.showModal.bind(this); this.closeModal = this.closeModal.bind(this); } closeModal() { this.setState({ modalHidden: true }); } showModal() { this.setState({ modalHidden: false }); } render() { return <div> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.showModal}>End test</Button> <Modal hidden={this.state.modalHidden} onClose={this.closeModal}> <HeadingText>Are you sure?</HeadingText> <BlockText> If you end the test, all your users will receive the version you selected: </BlockText> <BlockText spacingType={[BlockText.SPACING_TYPE.LARGE]}> <b>Version {this.props.selectedVersion}</b> </BlockText> <Button onClick={this.closeModal}>No, continue test</Button> <Button type={Button.TYPE.DESTRUCTIVE} onClick={this.closeModal}>Yes, end test</Button> </Modal> </div> } } export default class EndTestSection extends React.Component { constructor() { super(...arguments); this.state = { selectedVersion: 'A', }; this.selectVersion = this.selectVersion.bind(this); } selectVersion(event, value) { this.setState({ selectedVersion: value }); } render() { return <Grid className=\"endTestSection\"> <GridItem columnSpan={12}> <HeadingText className=\"endTestHeader\"> Pick the winner of your A/B test: </HeadingText> </GridItem> <GridItem columnStart={5} columnEnd={6} className=\"versionSelector\"> <VersionSelector selectedVersion={this.state.selectedVersion} selectVersion={this.selectVersion} /> </GridItem> <GridItem columnStart={7} columnEnd={8}> <EndTestButton selectedVersion={this.state.selectedVersion}>End test</EndTestButton> </GridItem> </Grid> } } nerdlets/ab-test-nerdlet/end-test.js Copy View your application and select \"Version B\" from the menu. Click End test to see \"Version B\" in the confirmation modal: When you're finished, stop serving your New Relic One application by pressing CTRL+C in your local server's terminal window. Congratulations! You've done a lot of work and it shows in the usefulness of your application. You've created charts that show mocked data. You've organized your charts into a readable structure. You've added an interface for your users to interact with the test. Now, you need some real data. In the next lesson, you'll replace the mocked data in your charts with real data from your backend service.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.44727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Present <em>an</em> end <em>test</em> confirmation modal",
        "body": "In this tutorial, you&#x27;re building an A&#x2F;<em>B</em> <em>test</em> <em>application</em>. The <em>application</em> surfaces data about an ongoing A&#x2F;<em>B</em> <em>test</em> on your website, which you then use to decide which page design version is most effective at engaging users. As part of that overarching goal, you&#x27;re building a section which allows"
      },
      "id": "6072565e64441f34dd9d8548"
    }
  ]
}