{
  "/terms": [
    {
      "category_2": "Alerts release notes",
      "nodeid": 41921,
      "sections": [
        "New Relic Platform release notes",
        "Alerts release notes",
        "APM release notes",
        "Cloud Integrations release notes",
        "Diagnostics release notes",
        "Mobile release notes",
        "Kubernetes integration release notes",
        "1-25-2021 : Alerts: Improved Baseline Threshold Terms UI",
        "Changes"
      ],
      "title": "1-25-2021 : Alerts: Improved Baseline Threshold Terms UI",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "New Relic Platform release notes",
      "external_id": "5aba4616aa2a0eb8c93576e28dcf88a6b31b2b58",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/platform-release-notes/alerts-release-notes/1-25-2021-alerts-improved-baseline-threshold-terms-ui",
      "published_at": "2021-01-31T12:44:27Z",
      "updated_at": "2021-01-27T15:06:04Z",
      "breadcrumb": "Contents / New Relic Platform Release Notes / Alerts release notes",
      "document_type": "release_notes_platform",
      "popularity": 1,
      "body": "[RSS] Released on:¬† January 25, 2021 Changes ‚Äã‚Äã‚Äã‚Äã‚Äã‚ÄãThe slider control for setting critical and warning terms on NRQL baseline conditions has been updated to more clearly label the threshold value as the number of standard deviations, and to permit you to manually set that value with an open input field. The underlying evaluation of the condition remains the same.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.42017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "1-25-2021 : Alerts: Improved Baseline Threshold <em>Terms</em> UI",
        "sections": "1-25-2021 : Alerts: Improved Baseline Threshold <em>Terms</em> UI",
        "body": "[RSS] Released on:¬† January 25, 2021 Changes ‚Äã‚Äã‚Äã‚Äã‚Äã‚ÄãThe slider control for setting critical and warning <em>terms</em> on NRQL baseline <em>conditions</em> has been updated to more clearly label the threshold value as the number of standard deviations, and to permit you to manually set that value with an open input field. The underlying evaluation of the condition remains the same."
      },
      "id": "6011815c64441f92963e17d3"
    },
    {
      "image": "",
      "url": "https://opensource.newrelic.com/cla/",
      "sections": [
        "NEW RELIC, INC.",
        "INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT",
        "Definitions.",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:50:50Z",
      "title": "New Relic Open Source Contributor License Agreement",
      "updated_at": "2020-12-08T13:43:57Z",
      "type": "opensource",
      "external_id": "478151b2a97835e82c3cd1eaa49610793dc56783",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "External Projects Highlighted Projects New Relic Projects Standards Menu External Projects Highlighted Projects New Relic Projects Standards NEW RELIC, INC. INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT Thank you for your interest in contributing to the open source projects of New Relic, Inc. (‚ÄúNew Relic‚Äù). In order to clarify the intellectual property license granted with Contributions from any person or entity, New Relic must have a Contributor License Agreement (\"Agreement\") on file that has been signed by each Contributor, indicating agreement to the license terms below. This Agreement is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following terms and conditions for Your present and future Contributions submitted to New Relic. Except for the licenses granted herein to New Relic and recipients of software distributed by New Relic, You reserve all right, title, and interest in and to Your Contributions. Definitions. \"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is entering into this Agreement with New Relic. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to New Relic for inclusion in, or documentation of, any of the products managed or maintained by New Relic (the \"Work\"). For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to New Relic or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, New Relic for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by You as \"Not a Contribution.\" Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contributions alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that Your Contribution, or the Work to which You have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed. You represent that You are legally entitled to grant the above licenses. If Your employer(s) has rights to intellectual property that You create that includes Your Contributions, You represent that You have received permission to make Contributions on behalf of that employer, that Your employer has waived such rights for Your Contributions to New Relic, or that Your employer has executed a separate Agreement with New Relic. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others). You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which You are personally aware and which are associated with any part of Your Contributions. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. Should You wish to submit work that is not Your original creation, You may submit it to New Relic separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which You are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here] \". You agree to notify New Relic of any facts or circumstances of which You become aware that would make these representations inaccurate in any respect. This site uses cookies üç™ We use cookies and other similar technologies (\"Cookies\") on our websites and services to enhance your experience and to provide you with relevant content. By using our websites and services you are agreeing to the use of cookies. You can read more here. If you consent to our cookies, please click Yes. Yes No",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.46277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following <em>terms</em> and <em>conditions</em> for Your present and future Contributions submitted to New Relic. Except"
      },
      "id": "5f31822264441fcbe056a984"
    },
    {
      "category_2": "Developer Edition",
      "nodeid": 39641,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Developer Program Resources",
        "For more help"
      ],
      "title": "Developer Program Resources",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "98308cfffa652e4c25967e1be5b848b9c28ca410",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-developer-edition/developer-program-resources",
      "published_at": "2021-01-31T12:34:33Z",
      "updated_at": "2020-08-08T19:17:02Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / Developer Edition",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic Developer edition policy",
      "body": "As a customer, you are eligible to participate in New Relic‚Äôs Developer Program. Additional information and resources are available at New Relic‚Äôs Developer Program site. By downloading, accessing, or using the developer resources (including the CLI), you agree that usage of the developer resources is pursuant to the New Relic Developers Terms and Conditions and that you have the authority to bind your organization. Such terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.666,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is pursuant to the New Relic Developers <em>Terms</em> and <em>Conditions</em> and that you have the authority to bind your organization. Such <em>terms</em> do not have to be signed in order to be binding. If you do not agree to these <em>terms</em> and <em>conditions</em>, your sole remedy is to not use these developer resources. If your"
      },
      "id": "5f338507e7b9d2f670c9de83"
    },
    {
      "category_2": "New Relic One",
      "nodeid": 39366,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Preview access for New Relic One",
        "For more help"
      ],
      "title": "Preview access for New Relic One",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "eae3865081d3bd8ad2dd8b6eaf0fe0147355360c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-one/preview-access-new-relic-one",
      "published_at": "2021-01-31T09:18:37Z",
      "updated_at": "2020-07-31T04:41:27Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / New Relic One",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer with a paid subscription to New Relic products, you are eligible to participate in preview access of the New Relic One platform (e.g. Telemetry Data Platform, Full Stack Observability, and Applied Intelligence products) for the period beginning July 31, 2020 and ending December 31, 2020 (‚ÄúPreview Access‚Äù). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE TERMS AND CONDITIONS IN LIEU OF ANY OTHER TERMS. These terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not participate in Preview Access. New Relic reserves the right to terminate or restrict Preview Access, in whole or in part, at any time. Notwithstanding the foregoing and any other materials provided by New Relic, select customers are ineligible for the Preview Access. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 301.59018,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", 2020 (‚ÄúPreview Access‚Äù). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE <em>TERMS</em> AND <em>CONDITIONS</em> IN LIEU OF ANY OTHER <em>TERMS</em>. These <em>terms</em> do not have to be signed in order to be binding"
      },
      "id": "5f23a0f7e7b9d29da9c82305"
    },
    {
      "category_2": "Product definitions",
      "nodeid": 39646,
      "sections": [
        "License information",
        "General usage licenses",
        "Special services licenses",
        "Distributed licenses",
        "Referenced policies",
        "Product definitions",
        "Usage plans",
        "FAQ",
        "New Relic One pricing: Definitions",
        "For more help"
      ],
      "title": "New Relic One pricing: Definitions",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "License information",
      "external_id": "097fc095ef18942f3af1845237742340e36416b8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/product-definitions/new-relic-one-pricing-definitions",
      "published_at": "2021-01-31T11:58:48Z",
      "updated_at": "2020-09-10T14:58:10Z",
      "breadcrumb": "Contents / Licenses / License information / Product definitions",
      "document_type": "page",
      "popularity": 1,
      "info": "This document provides definitions of terminology you may see in New Relic contracts.",
      "body": "This document provides definitions of terminology you may see in the Terms or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment Term Commitment Term means the non-cancelable, committed Subscription Term for the Products. Customer Data Customer Data means the data, information, or content that Customer and its users send to an Account from the Software, the Customer Properties, or Third-Party Services. Customer Properties Customer Properties means Customer‚Äôs websites, infrastructure, networks, mobile applications, or other systems, as well as Customer accounts on Third-Party Services. Documentation Documentation means the New Relic technical guides and documentation made available from the dedicated ‚ÄòDocumentation‚Äô page of the New Relic website. GB Ingested A GB Ingested is a measurement of the volume of metrics, events, logs, traces, or other telemetry data sent to or generated by the Products for the benefit of the Customer, including from the Software, the Customer Properties, or Third-Party Services. In this context, a GB is defined as 1 billion bytes. Login Credentials Login Credentials means the username, email address, password, or other personal information that is provided by a Customer user in order to manage an Account. Monthly Provisioned User A Monthly Provisioned User is any user who can log into Customer‚Äôs Account(s) and access the New Relic One Product functionality as specified in an Order and the Documentation. Order Order means the purchasing order for access to the Service or related services that: (1) is either executed by the Parties or entered into by you via self-service, and references this Agreement, or (2) is entered into by you and a Channel Partner. Paid Terms of Service Paid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/paid. Product(s) Product(s) mean the purchase of the New Relic subscription products described in the applicable Order and any updates, corrections, bug fixes, modifications, improvements, related services, new features, and functionality (made generally available to New Relic‚Äôs customer base) thereto. Software Software means the distributed software, APIs, scripts, or other code proprietary to New Relic provided with the Products. Terms Terms means the underlying Customer-New Relic agreement and the Order. Third-Party Services Third-Party Services means any third party platform, add-on, service, or product not provided by New Relic and that a user integrates or enables for use with the Products, including third-party applications and plug-ins. Unpaid Terms of Service Unpaid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/unpaid. Usage Plan Usage Plan refers to the Service or Product pricing, invoicing related information, and product-specific terms (e.g. concurrent user account sessions) contained within the Documentation. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.77563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "This document provides definitions of <em>terminology</em> you may see in New Relic contracts.",
        "body": "This document provides definitions of terminology you may see in the <em>Terms</em> or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment <em>Term</em> Commitment <em>Term</em> means"
      },
      "id": "5f23b039196a67030b94f5c4"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:03:13Z",
      "title": "New Relic Developers",
      "updated_at": "2021-01-30T01:38:00Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 25 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 312.12988,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Getting started with <em>New</em> <em>Relic</em> and Terraform",
        "body": " source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "Automate workflows",
      "updated_at": "2021-01-30T01:54:22Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 292.50195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " min Learn how to provision <em>New</em> <em>Relic</em> resources using the Kubernetes operator Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Getting started with <em>New</em> <em>Relic</em> and Terraform 30 min Learn how to provision <em>New</em> <em>Relic</em> resources using Terraform Set up <em>New</em> <em>Relic</em>"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.94427,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Quickly <em>tag</em> a set of resources",
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Add <em>tags</em> to applications you instrument for easier filtering and organization.",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " of your entities. Before you begin For this guide you need a <em>New</em> <em>Relic</em> user <em>key</em>: You can view and create them in the <em>API</em> keys UI. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-mutation/",
      "sections": [
        "NerdGraphMutation",
        "Usage",
        "Examples",
        "Do a mutation",
        "Do mutation and refetch query",
        "Props",
        "Example 1",
        "Methods",
        "NerdGraphMutation.render",
        "NerdGraphMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "NerdGraphMutation",
      "updated_at": "2021-01-29T01:58:06Z",
      "type": "developer",
      "external_id": "12d0744f112e48cd91b3d640657329423ab2faec",
      "document_type": "page",
      "popularity": 1,
      "body": "A generic NerdGraph mutation component that allows you to mutate anything from NerdGraph. Usage import { NerdGraphMutation } from 'nr1' Copy Examples Do a mutation 1 NerdGraphMutation.mutate({ 2 mutation: ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity( 5 guid: $guid 6 tags: { key: \"team\", values: [\"ui\"] } 7 ) { 8 errors { 9 message 10 } 11 } 12 } 13 `, 14 variables: { 15 guid: 'XXXXXXXXXXX', 16 }, 17 }); Copy Do mutation and refetch query 1 function render() { 2 const mutation = ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 5 errors { 6 message 7 } 8 } 9 } 10 `; 11 const variables = { 12 guid: 'XXXXXXXXXXX', 13 tags: { key: 'team', values: ['ui'] }, 14 }; 15 16 // NOTE: Sometimes mutations take awhile so doing a refetch immediatly after a mutate 17 // doesn't show any change. 18 return ( 19 <NerdGraphQuery query={query} variables={variables}> 20 {({ data, refetch }) => ( 21 <> 22 <RenderData data={data} /> 23 <Button 24 onClick={() => 25 NerdGraphMutation.mutate({ 26 mutation, 27 variables, 28 }).then(refetch) 29 } 30 > 31 Mutate 32 </Button> 33 </> 34 )} 35 </NerdGraphQuery> 36 ); 37 } Copy Props childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined mutationrequiredstring|object GraphQL mutation, either as a string or a GraphQL document parsed into an AST by graphql-tag. Example 1 1 import { ngql } from 'nr1'; 2 3 const mutation = ngql` 4 mutation($guid: EntityGuid!) { 5 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 6 errors { 7 message 8 } 9 } 10 } 11 `; Copy variablesobject Object containing all of the variables your mutation needs to execute. Methods NerdGraphMutation.render function () => undefined NerdGraphMutation.mutate Static method to use NerdGraphMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any NerdGraphMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.50273,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "A generic NerdGraph mutation component that allows you to mutate anything from NerdGraph. Usage import { NerdGraphMutation } from &#x27;nr1&#x27; Copy Examples Do a mutation 1 NerdGraphMutation.mutate({ 2 mutation: ngql` 3 mutation($guid: <em>Entity</em>Guid!) { 4 taggingAdd<em>TagsToEntity</em>( 5 guid: $guid 6 <em>tags</em>: { <em>key</em>"
      },
      "id": "5efa999c64441fe20b5f7e06"
    },
    {
      "category_2": "Core concepts",
      "nodeid": 29366,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "Use tags to help organize and find your data",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "How tags are added",
        "Use tags to filter the UI",
        "Custom queries and charts",
        "For more help"
      ],
      "title": "Use tags to help organize and find your data",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data",
      "external_id": "377d38d0b4b47ae77db599de89577b8d2725e01e",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data",
      "published_at": "2021-01-31T10:23:45Z",
      "updated_at": "2021-01-23T16:37:44Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Core concepts",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use tags to improve organization and findability of your observability data. ",
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). And you can also add your own custom tags. You can use tags in the UI to filter down to relevant data, as shown here: Here you can see an accountId tag being used to filter workloads for a specific account. You can use tags to: Help organize data coming from a large number of sources and/or to a large number of New Relic accounts Identity teams, roles, environment, or regions to know who‚Äôs responsible for what (see example use cases) Better organize and search dashboards and workloads Tags are useful for organizing data at a high level. If you wanted to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events would be a better solution. At New Relic, tags were previously called \"labels.\" You may sometimes see \"label\" used in our code; for example, some of our APM agent config files use a label config option for tags. Keep reading to learn more about tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, read the best practices below to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you‚Äôll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Be consistent with capitalization. For example, avoid using both env: staging and env: Staging (although tag searching is case-insensitive in the UI and API) Tips on cross-team implementation: One reason for using tags is to improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Keep this reference manual up-to-date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity‚Äôs name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can apply tags via the UI and API or you can add tags using APM agent configuration: C SDK: not available Go .NET Node.js PHP Python Ruby Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Use tags to filter the UI Use the filter field at the top of the entity explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Entity explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity‚Äôs metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's ellipsis icon. OR Select an entity. Near the top of the page, select the information icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries and charts As explained in Tag sources, some attributes are available as tags. You can query attributes and create custom charts using NRQL. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.22333,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>tags</em> to help organize and find your data",
        "sections": "Use <em>New</em> <em>Relic</em> One",
        "info": "How to use <em>tags</em> to improve organization and findability of your observability data. ",
        "category_0": "<em>New</em> <em>Relic</em> One",
        "category_1": "Use <em>New</em> <em>Relic</em> One",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>new</em>-<em>relic</em>-one&#x2F;use-<em>new</em>-<em>relic</em>-one&#x2F;core-concepts&#x2F;use-<em>tags</em>-help-organize-find-your-data",
        "body": "In the software industry, a <em>tag</em> typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At <em>New</em> <em>Relic</em>, our <em>tags</em> are <em>key</em>:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> One &#x2F; Use <em>New</em> <em>Relic</em> One &#x2F; Core concepts"
      },
      "id": "600c50d8e7b9d2a186a8f1d3"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps",
        "Permissions for managing applications",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:55:31Z",
      "title": "Build apps",
      "updated_at": "2021-01-31T02:35:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Permissions for managing applications ¬† Learn about permissions for subscribing to apps Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.47432,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Publish</em> and <em>deploy</em> <em>apps</em>",
        "body": " 20 min <em>Add</em> a time picker to a sample application Create a &quot;Hello, World!&quot; application 15 min Build a &quot;Hello, World!&quot; <em>app</em> and <em>publish</em> it to New Relic One <em>Add</em> a table to your <em>app</em> 30 min <em>Add</em> a table to your New Relic One <em>app</em> Create a custom map view 30 min Build an <em>app</em> to show page view data on a map"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Permissions for managing applications",
        "New Relic One pricing plan",
        "Original product-based pricing",
        "This site uses cookies üç™"
      ],
      "title": "Permissions for managing applications",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-01-31T02:57:34Z",
      "updated_at": "2020-12-04T01:59:58Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for subscribing to apps",
      "body": "When you create an app, you'll likely want to share it. From New Relic One's Apps page, you can subscribe to apps you create, publish, and deploy, and to other publicly available apps. You must have the Nerdpack manager role to subcribe accounts to apps. Read on to learn about permissions and versions. Permissions for managing applications The Nerdpack manager role is a New Relic add-on role. When you create a Nerdpack, you have the Nerdpack manager role for handling that Nerdpack. New Relic account administrators have the Nerdpack manager role automatically, and can subscribe their accounts to available Nerdpacks. User permissions vary depending on which pricing plan you are on. New Relic One pricing plan For accounts with New Relic One pricing, there are permissions differences for basic users and full users: Full users have the Nerdpack manager role and have full capabilities for creating and managing New Relic One applications, as well as accessing all types of applications in the New Relic One catalog. A basic user can develop and view their own local New Relic One apps, but they cannot: Subscribe other users to apps they‚Äôve created. Access or manage apps in the New Relic One catalog. Access apps in the entity explorer sidebar. Original product-based pricing For accounts on our original product-based pricing, here are access details: Subscribe to publicly available applications To subscribe to publicly available applications, you must have the Nerdpack manager role. Nerdpack manager permissions are automatically assigned to New Relic account owners and admins and can be assigned to individual users. If you aren‚Äôt an owner or admin, you can request Nerdpack manager permission, or ask your New Relic admin or owner to subscribe the apps to your account for you. You can add any of the publicly available applications to master accounts or separate sub-accounts on which you have the Nerdpack manager role, or to separate sub-accounts under a master account you own or administer. If you add the application to a master account, the access flows to all of its sub-accounts as well. Subscribe to applications that you create You also must have the Nerdpack manager role to subscribe the applications you create to accounts. Applications that you publish and deploy can only be subscribed to the master account that was used to publish them, or to its sub-accounts. This means you might want a New Relic admin to deploy your applications for you if they need to be available across the organization.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 53.903786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Permissions for managing <em>applications</em>",
        "sections": "Permissions for managing <em>applications</em>",
        "info": "Learn about permissions for <em>subscribing</em> to <em>apps</em>",
        "tags": "managing <em>apps</em>",
        "body": "When you create an <em>app</em>, you&#x27;ll likely want to share it. From New Relic One&#x27;s <em>Apps</em> page, you can <em>subscribe</em> to <em>apps</em> you create, <em>publish</em>, and <em>deploy</em>, and to other publicly available <em>apps</em>. You must have the Nerdpack manager role to subcribe accounts to <em>apps</em>. Read on to learn about permissions"
      },
      "id": "5f45bf2864441ffb4dfdcdbb"
    },
    {
      "category_2": "Hosting services",
      "nodeid": 13151,
      "sections": [
        "Node.js agent",
        "Getting started",
        "Installation and configuration",
        "Extend your instrumentation",
        "Attributes",
        "API guides",
        "Hosting services",
        "Troubleshooting",
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Node.js agent",
      "external_id": "92a838b215a23bd47fcc8b45abdf347c56f720db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment",
      "published_at": "2021-01-31T10:01:52Z",
      "updated_at": "2020-08-18T06:29:37Z",
      "breadcrumb": "Contents / APM agents / Node.js agent / Hosting services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your APM's Node.js app in the Google App Engine (GAE) flexible environment. ",
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 27.178373,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use native <em>deploy</em>",
        "info": "How to install your APM&#x27;s Node.js <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": ". This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime Use native <em>deploy</em> To use Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with your"
      },
      "id": "5972fea707552313d3f9ba8d"
    },
    {
      "category_2": "Hosting services",
      "nodeid": 13866,
      "sections": [
        "Python agent",
        "Getting started",
        "Installation",
        "Configuration",
        "Supported features",
        "Back-end services",
        "Custom instrumentation",
        "API guides",
        "Python agent API",
        "Web frameworks and servers",
        "Async instrumentation",
        "Hosting services",
        "Attributes",
        "Troubleshooting",
        "Install the Python agent in GAE flexible environment",
        "Deploy using GAE's native support",
        "Build a custom runtime using Docker",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install the Python agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Python agent",
      "external_id": "c1ce9a74f2eccba9cf0cd509a6f15f2d02fabb16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/hosting-services/install-python-agent-gae-flexible-environment",
      "published_at": "2021-01-31T04:33:33Z",
      "updated_at": "2020-08-30T17:24:26Z",
      "breadcrumb": "Contents / APM agents / Python agent / Hosting services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your Python app in the Google App Engine (GAE) flexible environment. ",
      "body": "With the Python agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding agent data to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in New Relic One. This document explains how to add agent data to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Deploy using GAE's native support When using Google App Engine \"native mode\" installation, you provide your app code and an app.yaml file. Google App Engine then deploys to a standard prebuilt Docker image. For example, to deploy with native support for a Flask/Django app: Follow standard procedures to install the Python agent, including your license key. Set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to newrelic.ini. Once the agent and configuration file have been installed, the Python agent can automatically monitor applications that reside in the GAE flexible environment. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add agent data to your GAE flex app by building a custom runtime for Docker. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Our GAE flex examples on Github for Python Google App Engine's documentation for Python Google App Engine's tutorials to deploy a Python app 1. Set up the GAE project and install dependencies When building a custom runtime using Docker, set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to the Dockerfile instead of to your Python app's newrelic.ini. Follow standard procedures to install the Python agent, including your license key. Follow Google App Engine procedures Python to create a Google Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK also provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: env: flex runtime: custom 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example shows the Python agent installed for an application served with gunicorn. These procedures are similar to the Python quick start guide. The Dockerfile will contain customer-specific code, including Python version, installation requirements, etc). # [START dockerfile] FROM gcr.io/google_appengine/python # Install the fortunes binary from the debian repositories. RUN apt-get update && apt-get install -y fortunes # Optional: Change the -p argument to use Python 2.7. RUN virtualenv /env -p python3.5 # Set virtualenv environment variables. This is equivalent to running # source /env/bin/activate. ENV VIRTUAL_ENV /env ENV PATH /env/bin:$PATH ADD requirements.txt /app/ RUN pip install -r requirements.txt ADD . /app/ CMD NEW_RELIC_CONFIG_FILE=newrelic.ini newrelic-admin run-program gunicorn -b :$PORT main:app # [END dockerfile] 4. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud app deploy Wait until the deployment completes. To open the app in the browser, run the following command: gcloud app browse To view your GAE flex app data, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect Python agent logs to Stackdriver in the Cloud Platform Console, add the following statement to the newrelic.ini configuration: log_file = stderr To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 17.147093,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Deploy</em> using GAE&#x27;s native support",
        "info": "How to install your Python <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": " explains how to <em>add</em> agent data to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime <em>Deploy</em> using GAE&#x27;s native support When using Google <em>App</em> Engine &quot;native mode&quot; installation, you provide"
      },
      "id": "5f3fb624196a672fda1cd4a3"
    },
    {
      "category_2": "Installation",
      "nodeid": 13121,
      "sections": [
        "Go agent",
        "Get started",
        "Installation",
        "Configuration",
        "Instrumentation",
        "API guides",
        "Features",
        "Troubleshooting",
        "Install the Go agent in GAE flexible environment",
        "Build a custom runtime using Docker",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install the Go agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Go agent",
      "external_id": "d6409627d1a1d951d544a84613ad1709456f4560",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/installation/install-go-agent-gae-flexible-environment",
      "published_at": "2021-01-31T06:06:26Z",
      "updated_at": "2020-08-15T09:48:00Z",
      "breadcrumb": "Contents / APM agents / Go agent / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your New Relic's Go app in the Google App Engine (GAE) flexible environment. ",
      "body": "With our Go agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. Here we explain how to add New Relic to your GAE flex app by configuring a custom runtime, and give an example of deploying a Go app with Docker. The Go agent can run in a GAE flexible environment using a custom runtime. Due to limitations of other environments, do not use the GAE standard environment or Google App Engine's \"native mode\" installation. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by installing the Go agent, building a custom Go runtime for Docker, and deploying a golang application. For more information about deploying and configuring your Go app in the GAE flexible environment, see: Google App Engine's documentation for Go Google App Engine's tutorials to deploy a Go app 1. Set up the GAE project and install dependencies Follow standard procedures to install the Go agent for your specific app server, including your license key. Follow Google App Engine procedures for Go to create a new Cloud Platform project, create an App Engine application, download and install git, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example code defines the golang version used. FROM golang:1.8-onbuild CMD go run main.go 4. Build a Docker image To build the Docker image, run the following command. Be sure to include the period at the end of the code, to indicate the current directory contains the build files. docker build --rm -t Docker-image-name . 5. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud --project go-app-name app deploy Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see GAE's documentation for debugging an instance. To redirect New Relic Go agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.yml file to: log_file_name: STDOUT For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 17.009762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "How to install your New Relic&#x27;s Go <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": " command line tool to manage and <em>deploy</em> GAE <em>apps</em>. 2. Configure your <em>app</em>.yaml The <em>app</em>.yaml configuration file is required for a GAE flexible environment <em>app</em> with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex 3. Configure a Dockerfile The Dockerfile defines the Docker"
      },
      "id": "5f37af50196a67d8f955e63e"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-query/",
      "sections": [
        "NerdGraphQuery",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "Methods",
        "NerdGraphQuery.render",
        "NerdGraphQuery.query",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:56:28Z",
      "title": "NerdGraphQuery",
      "updated_at": "2021-01-29T01:58:06Z",
      "type": "developer",
      "external_id": "1ada6e056e031c141b2bb989e4ec200b3a7ce988",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One SDK provides Query components based on ApolloClient's query components. These components are an abstraction layer making it easier to query NerdGraph without worrying about configuring Apollo Client and, for the most common use cases, without having to write GraphQL queries. A generic NerdGraph Query component that allows you to query anything from NerdGraph. Usage import { NerdGraphQuery } from 'nr1' Copy Examples Example 1 1 function render() { 2 const query = ` 3 query($id: Int!) { 4 actor { 5 account(id: $id) { 6 name 7 } 8 } 9 } 10 `; 11 12 const variables = { 13 id: 1, 14 }; 15 16 return ( 17 <NerdGraphQuery query={query} variables={variables}> 18 {({ loading, error, data }) => { 19 if (loading) { 20 return <Spinner />; 21 } 22 23 if (error) { 24 return 'Error!'; 25 } 26 27 return <BlockText>{data.actor.account.name}</BlockText>; 28 }} 29 </NerdGraphQuery> 30 ); 31 } Copy Props childrenfunction Render prop function as a child. function ( queryResult : {Object // Results of the query. ) => undefined fetchPolicyTypeenum DEFAULT NerdGraphQuery . FETCH_POLICY_TYPE . CACHE_AND_NETWORK Fetch policy to be used for the query. Allows you to specify how you want your query to interact with the cached data. CACHE_AND_NETWORK: The query returns your initial data from the cache if available. However, regardless of whether or not the full data is in your cache, the query always makes a request using your network interface and returns the updated data. This option is not available when using the static query() method of the component. CACHE_FIRST: The query makes a request using your network interface only if the data for your query is not already in the cache. CACHE_ONLY: The query never makes a request using your network interface. Instead it returns the data available in the cache. If the data for your query does not exist in the cache, then an error is thrown. NETWORK_ONLY: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. NO_CACHE: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. Unlike the NETWORK_ONLY policy, it does not write any data to the cache after the query completes. <One of NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_AND_NETWORK , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_FIRST , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NETWORK_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NO_CACHE , > pollIntervalnumber DEFAULT 0 Interval in milliseconds to poll for new data. queryrequiredstring|object GraphQL query, either as a string or a GraphQL document parsed into an AST by the gql method of nr1. Example 1 1 import { ngql } from 'nr1'; 2 3 const query = ngql` 4 { 5 actor { 6 user { 7 id 8 email 9 name 10 } 11 } 12 } 13 `; Copy variablesobject Object containing all the variables your query needs to execute. Methods NerdGraphQuery.render function () => undefined NerdGraphQuery.query function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 905.2943,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraphQuery</em>",
        "sections": "<em>NerdGraphQuery</em>",
        "body": " <em>NerdGraph</em> <em>Query</em> <em>component</em> that allows you to <em>query</em> anything from <em>NerdGraph</em>. Usage import { <em>NerdGraphQuery</em> } from &#x27;nr1&#x27; Copy Examples Example 1 1 function render() { 2 const <em>query</em> = ` 3 <em>query</em>($id: Int!) { 4 actor { 5 <em>account</em>(id: $id) { 6 name 7 } 8 } 9 } 10 `; 11 12 const variables = { 13 id: 1, 14"
      },
      "id": "5efa999d28ccbc6bfd307ddb"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps",
        "Permissions for managing applications",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:55:31Z",
      "title": "Build apps",
      "updated_at": "2021-01-31T02:35:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Permissions for managing applications ¬† Learn about permissions for subscribing to apps Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 812.9686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the <em>NerdGraphQuery</em> <em>component</em> to an <em>application</em>",
        "body": " building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the <em>NerdGraphQuery</em> <em>component</em> to an application 20 minutes The <em>NerdGraphQuery</em> <em>component</em> allows you to <em>query</em> <em>data</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-mutation/",
      "sections": [
        "NerdGraphMutation",
        "Usage",
        "Examples",
        "Do a mutation",
        "Do mutation and refetch query",
        "Props",
        "Example 1",
        "Methods",
        "NerdGraphMutation.render",
        "NerdGraphMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "NerdGraphMutation",
      "updated_at": "2021-01-29T01:58:06Z",
      "type": "developer",
      "external_id": "12d0744f112e48cd91b3d640657329423ab2faec",
      "document_type": "page",
      "popularity": 1,
      "body": "A generic NerdGraph mutation component that allows you to mutate anything from NerdGraph. Usage import { NerdGraphMutation } from 'nr1' Copy Examples Do a mutation 1 NerdGraphMutation.mutate({ 2 mutation: ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity( 5 guid: $guid 6 tags: { key: \"team\", values: [\"ui\"] } 7 ) { 8 errors { 9 message 10 } 11 } 12 } 13 `, 14 variables: { 15 guid: 'XXXXXXXXXXX', 16 }, 17 }); Copy Do mutation and refetch query 1 function render() { 2 const mutation = ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 5 errors { 6 message 7 } 8 } 9 } 10 `; 11 const variables = { 12 guid: 'XXXXXXXXXXX', 13 tags: { key: 'team', values: ['ui'] }, 14 }; 15 16 // NOTE: Sometimes mutations take awhile so doing a refetch immediatly after a mutate 17 // doesn't show any change. 18 return ( 19 <NerdGraphQuery query={query} variables={variables}> 20 {({ data, refetch }) => ( 21 <> 22 <RenderData data={data} /> 23 <Button 24 onClick={() => 25 NerdGraphMutation.mutate({ 26 mutation, 27 variables, 28 }).then(refetch) 29 } 30 > 31 Mutate 32 </Button> 33 </> 34 )} 35 </NerdGraphQuery> 36 ); 37 } Copy Props childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined mutationrequiredstring|object GraphQL mutation, either as a string or a GraphQL document parsed into an AST by graphql-tag. Example 1 1 import { ngql } from 'nr1'; 2 3 const mutation = ngql` 4 mutation($guid: EntityGuid!) { 5 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 6 errors { 7 message 8 } 9 } 10 } 11 `; Copy variablesobject Object containing all of the variables your mutation needs to execute. Methods NerdGraphMutation.render function () => undefined NerdGraphMutation.mutate Static method to use NerdGraphMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any NerdGraphMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 602.26324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraphMutation</em>",
        "sections": "<em>NerdGraphMutation</em>",
        "body": "} variables={variables}&gt; 20 {({ <em>data</em>, refetch }) =&gt; ( 21 &lt;&gt; 22 &lt;Render<em>Data</em> <em>data</em>={<em>data</em>} &#x2F;&gt; 23 &lt;Button 24 onClick={() =&gt; 25 <em>NerdGraph</em>Mutation.mutate({ 26 mutation, 27 variables, 28 }).then(refetch) 29 } 30 &gt; 31 Mutate 32 &lt;&#x2F;Button&gt; 33 &lt;&#x2F;&gt; 34 )} 35 &lt;&#x2F;<em>NerdGraphQuery</em>&gt; 36 ); 37 } Copy Props"
      },
      "id": "5efa999c64441fe20b5f7e06"
    },
    {
      "category_2": "Intro to APIs",
      "nodeid": 2151,
      "sections": [
        "Get started",
        "Intro to APIs",
        "Types of New Relic API keys",
        "Manage API keys in UI",
        "Overview of API keys",
        "User key",
        "License key",
        "Browser key",
        "REST API key",
        "Insights insert key",
        "Insights query key",
        "Admin key",
        "For more help"
      ],
      "title": "Types of New Relic API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "external_id": "7642ec789132dd9f20604844a8d6aad2a12baa59",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/types-new-relic-api-keys",
      "published_at": "2021-01-31T06:49:51Z",
      "updated_at": "2021-01-31T06:49:51Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Types of New Relic API keys, who can use them, and how to add, update, or delete API keys.",
      "body": "New Relic has several different APIs that each require their own type of API key to use. This resource describes our API keys, what they're used for, and how to access them. Manage API keys in UI Here's a direct link to the API keys UI page. To find this from the New Relic UI: From the account dropdown, select Account settings. Select API keys. Overview of API keys The table below summarizes our available API keys and their uses. Some keys are able to be used by more than one API. If you're using a specific API, see the docs for that API to understand which keys are required and recommended. Key type What it's for Where to access User key (aka \"personal API key\") Used for NerdGraph (our GraphQL API) and for accessing REST API endpoints (dependent on user permissions). API keys UI License key Allows ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. API keys UI Insights insert key (aka \"Insert key\") Allows ingestion of events via HTTPS request from our metric, log, trace, and event APIs and the tools that use those APIs. Go to the API keys UI and click Insights insert key. Browser key Allows ingestion of browser monitoring data. API keys UI Mobile key (aka \"mobile app token\") Allows mobile monitoring data to be sent to New Relic. See Mobile app token. REST API key Note: we recommend using the user key instead because it has fewer limitations. The REST API key is for using our REST APIs for Alerts, APM, Browser, Infrastructure alerts, as well as Mobile REST APIs and the API Explorer. Go to the API keys UI and click REST API key. Admin API key As of December 4, 2020, all existing admin keys have been migrated to be user keys. For more information, see Admin key and User key below. API keys UI (will appear as user keys) Insights query key (aka \"Query key\") This key allows use of the Insights query API. Note: we now recommend using NerdGraph to query New Relic data. Go to the API keys UI and click Insights query key. User key New Relic user keys (previously referred to as \"personal API keys\") are required for NerdGraph (our GraphQL API), which allows you to query most New Relic data and do some types of configuration. User keys also let you use our REST API, with restrictions based on your permissions. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a user key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select User. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a user key Go to the API keys UI. In the row of the user key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a user key Go to the API keys UI. In the row of the user key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. In December 2020, user keys supplanted Admin API keys. For details, see Admin API key. License key New Relic license keys allow the ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. If you're using a specific API, see the docs for that API to understand which keys are required or recommended. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a license key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select License. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a license key Go to the API keys UI. In the row of the license key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a license API key Go to the API keys UI. In the row of the license key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Browser key The browser key allows the ingestion of data from New Relic browser monitoring. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a browser key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select Browser. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a browser key Go to the API keys UI. In the row of the browser API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a browser key Go to the API keys UI. In the row of the browser API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. REST API key We recommend using a user key to use the REST API because that key has fewer limitations. You can use a REST API key with our REST API and the API Explorer. For parent accounts with sub-accounts, each sub-account must use its own REST API key. Availability: Each New Relic account can have only one REST API key. Activate or change REST API key Go to the API keys UI and select REST API key. Click Regenerate REST API key. Click (Show key) to view your account's new REST API key. Copy your account's REST API key to use with New Relic's REST API. View REST API keys To view REST API keys: Go to the API keys UI and select REST API key. Click (Show key) to view your account's new REST API key. Delete REST API key To delete your account's REST API key: Before you delete an API key, make sure you have the correct account or sub-account. Go to the API keys UI and select REST API key. Select the delete [trash can icon] icon for the REST API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Insights insert key The Insights insert key (aka the \"Insert key\") is required for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. Generate an Insights insert key Go to the API keys UI and select Insights insert keys. Next to the Insert keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights insert key Go to the API keys UI and select Insights insert keys. Under Insert Keys, find the key you want to modify. Select Edit or Delete. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. Generate an Insights query key You must have access to the UIs you plan to query and the correct permissions in order to register or modify this key. Insights query keys are generated per account; they're not associated with a specific user. This means that any user in an account with access to a query key can use it. To register this key: Go to the API keys UI and select Insights query keys. Next to the Query Keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights query key To edit or delete this key: Go to the API keys UI page and select Insights query keys. Under Query Keys, find the key you want to modify. Select Edit or Delete. Admin key As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don‚Äôt need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says ‚ÄúMigrated from an admin user key‚Äù in the key table, so you‚Äôll be able to find them easily. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 424.5939,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Overview</em> of API keys",
        "body": " <em>query</em> key (aka &quot;<em>Query</em> key&quot;) This key allows use of the Insights <em>query</em> API. Note: we now recommend using <em>NerdGraph</em> to <em>query</em> New Relic <em>data</em>. Go to the API keys UI and click Insights <em>query</em> key. User key New Relic user keys (previously referred to as &quot;personal API keys&quot;) are required for <em>NerdGraph</em> (our"
      },
      "id": "5d7485b128ccbc1b5c32ad31"
    },
    {
      "category_2": "Manage data",
      "nodeid": 39276,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert data to metrics",
        "Ingest APIs",
        "Manage data coming into New Relic",
        "Data ingestion sources",
        "Set alerts for data use",
        "Adjust your data ingest",
        "For more help"
      ],
      "title": "Manage data coming into New Relic",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "ba12759affe2895e875af1af096d895d09f6d030",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data-new-relic/manage-data/manage-data-coming-new-relic",
      "published_at": "2021-01-31T12:13:52Z",
      "updated_at": "2021-01-31T12:13:52Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Manage data",
      "document_type": "page",
      "popularity": 1,
      "info": "For accounts on the New Relic One pricing plan: how we ingest and store and calculate ingested data. ",
      "body": "When you connect your data to New Relic, we process what we receive and apply data dropping and transformation rules. Then we count the bytes needed to represent your data in a standard format, like JSON. If you're on our New Relic One pricing plan, you're charged by the number of bytes written to our database, above and beyond the standard amount that‚Äôs free. This doc is for accounts on our New Relic One pricing plan. If you're on our original product-based pricing plan, see Original data retention. Not sure which you're on? See Overview of pricing and account/user structure. The Data ingestion page shows your ingest rates for a period you specify on the top-right of the Data management hub. Since 30 days ago is the default setting, but you can also set a custom date span. The page shows your daily average GBs, and the total for the range you set. You can toggle between an overall ingest view and an account view to identify which of your accounts are sending the most data. The page also provides the current month-to-date, and the projected end-of-month total ingest rates. With this information, you can proactively drop data or turn off agents in order to manage ingest and, therefore, costs. If you want to take a look at how we query the data, click the ellipsis icon (just above the chart) to slide out the chart query and open it in our query builder. And If you want to drill down further into your data usage, check out the sample queries in the usage docs. From the Login drop-down, select Manage your data, and then select Data ingestion. This is the Data ingestion page with data source and account views. Data ingestion sources The Data ingestion page describes which of your data sources provide the most data on average and during specific data ranges. The sources are described here. Billable data sources Description Timeslices (1-minute) and Metric:Raw Metrics are timeslices + MetricRaw Metric group: MetricsBytes Metric timeslice data averages to one-hour periods after eight days. After 90 days, the permanent metric data continues to be stored in one-hour periods. We currently store the raw metric data for 30 days. You are only billed for the initial ingest volume. You are not billed for subsequent rollups. APM (transactions and errors) APM events Metric group: ApmEventsBytes InfraSamples:Raw Includes multiple Infrastructure events Infrastructure host data Metric group:InfraHostBytes Information related to your servers and virtual machines coming from infrastructure agents, including storage and network data Infrastructure process data stored in ProcessSample. Metric group: InfraProcessBytes Data are metrics related to each process running on the hosts running the Infrastructure agent. This feature is turned off by default. Infrastructure integrations Metric group: InfraIntegrationBytes Performance data related to applications and services, typically managed by the customer, including data related to Docker containers, Windows services, Nagios checks, and cloud integrations such as managed services in AWS, Azure, and GCP. Logging Includes logs and LogExtendedRecord Metric group: LoggingBytes Log messages longer than 4KB are split into multiple events that, when needed, are stitched together to display the original message; this reduces the size of message data. Default Custom events Metric group: CustomEventsBytes Mobile error Mobile general Breadcrumb crash event trails Mobile session Mobile exception Mobile crash Mobile events Metric group: MobileEventsBytes Tracing Metric group: TracingBytes Namespaces that contain all tracing events, including tracing spans and excluding internal tracing. Browser:EventLog Browser Browser:JSErrors PcvPerf (PageView timing) Browser events Metric group: BrowserEventsBytes Lambda Serverless Metric group: ServerlessBytes Set alerts for data use Query and alert on usage data describes how to set alerts to get notified if you're nearing data ingest limits you don't want to cross. For example, you might set an alert on logs, which can stack up quickly in an active system. Adjust your data ingest Drop data for lower retention costs and data compliance On ingest, we apply data dropping rules so you won't be charged for data that's not useful. Learn how to set additional data dropping ‚Äã‚Äã‚Äã‚Äã‚Äãrules yourself. Use NerdGraph to drop entire data types or drop data attributes from data types so they‚Äôre not written to NRDB. This enables you to focus on the data you want, reduces retention costs, and avoids writing sensitive data to the database. For dropping log data, see Drop data with drop filter rules. Turn off agents and integrations If you don‚Äôt need data from specific agents or integrations that you have installed, you can uninstall/delete those tools. For instructions, see the specific documentation for an agent or integration. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 403.61038,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>data</em> coming into New Relic",
        "sections": "Convert <em>data</em> to <em>metrics</em>",
        "info": "For <em>accounts</em> on the New Relic One pricing plan: how we ingest and store and calculate ingested <em>data</em>. ",
        "category_0": "Telemetry <em>Data</em> Platform",
        "category_1": "Ingest and manage <em>data</em>",
        "category_2": "Manage <em>data</em>",
        "body": " <em>drop</em>-<em>down</em>, select Manage your <em>data</em>, and then select <em>Data</em> ingestion. This is the <em>Data</em> ingestion page with <em>data</em> source and <em>account</em> views. <em>Data</em> ingestion sources The <em>Data</em> ingestion page describes which of your <em>data</em> sources provide the most <em>data</em> on average and during specific <em>data</em> ranges. The sources",
        "breadcrumb": "Contents &#x2F; Telemetry <em>Data</em> Platform &#x2F; Ingest and manage <em>data</em> &#x2F; Manage <em>data</em>"
      },
      "id": "5f24629ae7b9d251c2c82338"
    }
  ],
  "/try-our-apis": [
    {
      "category_2": "Core concepts",
      "nodeid": 41906,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Introduction",
        "Why a new dashboards API?",
        "From REST endpoints to graphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "external_id": "b5ac1e396f08a48f318a283be906aa8b9bca7310",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph",
      "published_at": "2021-01-31T13:15:31Z",
      "updated_at": "2021-01-30T05:06:03Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Core concepts",
      "document_type": "page",
      "popularity": 1,
      "body": "Introduction In case you haven‚Äôt heard, NerdGraph is New Relic‚Äôs unified API in a graphQL flavor. The new dashboards API follows this unified approach and is exposed through Nerdgraph for user consumption. Why a new dashboards API? Dashboards in New Relic One embrace the entity concept and are now an entity in New Relic‚Äôs entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features, with many more coming: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to graphQL queries/mutations One of the main benefits from a graphQL API is that it provides a complete and understandable description of the APIs data. By using NerdGraph GraphiQL explorer, you can discover graphQL types and fields along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new graphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic‚Äôs entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } You can list all the dashboards by the creator‚Äôs email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } You can list all the dashboards by the creator‚Äôs userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = 2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity guid. Then you can access all the dashboard properties that you are interested in by adding them in the graphQL query. In the example below we are only interested in the entity guid and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in graphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although graphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields. Moreover, there is a doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard guid and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory. For more information, there is a doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity guid. mutation { dashboardDelete { status errors { type description } } } Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what‚Äôs the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 728.0043,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dashboards <em>API</em> migration: from Insights <em>API</em> to <em>Nerdgraph</em>",
        "sections": "Dashboards <em>API</em> migration: from Insights <em>API</em> to <em>Nerdgraph</em>",
        "category_0": "<em>New</em> <em>Relic</em> One",
        "category_1": "Use <em>New</em> <em>Relic</em> One",
        "body": " a complete and understandable description of the <em>APIs</em> data. By using <em>NerdGraph</em> Graphi<em>QL</em> explorer, you can discover <em>graphQL</em> types and fields along with a brief explanation. We want to facilitate your migration from the Insights <em>API</em> to the <em>new</em> <em>New</em> <em>Relic</em> One dashboards <em>API</em>. Find below some examples",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> One &#x2F; Use <em>New</em> <em>Relic</em> One &#x2F; Core concepts"
      },
      "id": "6014e93c64441f4eea3e17bc"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/apis/ngql/",
      "sections": [
        "ngql",
        "Usage",
        "Examples",
        "Example 1",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T03:01:05Z",
      "title": "ngql",
      "updated_at": "2021-01-29T02:00:56Z",
      "type": "developer",
      "external_id": "c0e1e450b0a391194a5929899437475e824b808c",
      "document_type": "page",
      "popularity": 1,
      "body": "A JavaScript template literal tag that parses GraphQL query strings into GraphQL documents that can be used to do NerdGraph queries. Usage import { ngql } from 'nr1' Copy Examples Example 1 1 import { ngql } from 'nr1'; 2 3 const query = ngql` 4 { 5 actor { 6 user { 7 id 8 email 9 name 10 } 11 } 12 } 13 `; 14 15 function render() { 16 return <NerdGraphQuery query={query}>// ...</NerdGraphQuery>; 17 } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 672.6066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "A JavaScript template literal tag that parses <em>GraphQL</em> query strings into <em>GraphQL</em> documents that can be used to do <em>NerdGraph</em> queries. Usage import { ngql } from &#x27;nr1&#x27; Copy Examples Example 1 1 import { ngql } from &#x27;nr1&#x27;; 2 3 const query = ngql` 4 { 5 actor { 6 user { 7 id 8 email 9 name 10 } 11 } 12 } 13 `; 14 15 function render() { 16 return &lt;<em>NerdGraph</em>Query query={query}&gt;&#x2F;&#x2F; ...&lt;&#x2F;<em>NerdGraph</em>Query&gt;; 17 } Copy"
      },
      "id": "60136c5828ccbcdda71ed5ef"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-query/",
      "sections": [
        "NerdGraphQuery",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "Methods",
        "NerdGraphQuery.render",
        "NerdGraphQuery.query",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:56:28Z",
      "title": "NerdGraphQuery",
      "updated_at": "2021-01-29T01:58:06Z",
      "type": "developer",
      "external_id": "1ada6e056e031c141b2bb989e4ec200b3a7ce988",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One SDK provides Query components based on ApolloClient's query components. These components are an abstraction layer making it easier to query NerdGraph without worrying about configuring Apollo Client and, for the most common use cases, without having to write GraphQL queries. A generic NerdGraph Query component that allows you to query anything from NerdGraph. Usage import { NerdGraphQuery } from 'nr1' Copy Examples Example 1 1 function render() { 2 const query = ` 3 query($id: Int!) { 4 actor { 5 account(id: $id) { 6 name 7 } 8 } 9 } 10 `; 11 12 const variables = { 13 id: 1, 14 }; 15 16 return ( 17 <NerdGraphQuery query={query} variables={variables}> 18 {({ loading, error, data }) => { 19 if (loading) { 20 return <Spinner />; 21 } 22 23 if (error) { 24 return 'Error!'; 25 } 26 27 return <BlockText>{data.actor.account.name}</BlockText>; 28 }} 29 </NerdGraphQuery> 30 ); 31 } Copy Props childrenfunction Render prop function as a child. function ( queryResult : {Object // Results of the query. ) => undefined fetchPolicyTypeenum DEFAULT NerdGraphQuery . FETCH_POLICY_TYPE . CACHE_AND_NETWORK Fetch policy to be used for the query. Allows you to specify how you want your query to interact with the cached data. CACHE_AND_NETWORK: The query returns your initial data from the cache if available. However, regardless of whether or not the full data is in your cache, the query always makes a request using your network interface and returns the updated data. This option is not available when using the static query() method of the component. CACHE_FIRST: The query makes a request using your network interface only if the data for your query is not already in the cache. CACHE_ONLY: The query never makes a request using your network interface. Instead it returns the data available in the cache. If the data for your query does not exist in the cache, then an error is thrown. NETWORK_ONLY: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. NO_CACHE: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. Unlike the NETWORK_ONLY policy, it does not write any data to the cache after the query completes. <One of NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_AND_NETWORK , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_FIRST , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NETWORK_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NO_CACHE , > pollIntervalnumber DEFAULT 0 Interval in milliseconds to poll for new data. queryrequiredstring|object GraphQL query, either as a string or a GraphQL document parsed into an AST by the gql method of nr1. Example 1 1 import { ngql } from 'nr1'; 2 3 const query = ngql` 4 { 5 actor { 6 user { 7 id 8 email 9 name 10 } 11 } 12 } 13 `; Copy variablesobject Object containing all the variables your query needs to execute. Methods NerdGraphQuery.render function () => undefined NerdGraphQuery.query function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 669.71545,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraphQuery</em>",
        "sections": "<em>NerdGraphQuery</em>",
        "body": "<em>New</em> <em>Relic</em> One SDK provides Query components based on ApolloClient&#x27;s query components. These components are an abstraction layer making it easier to query <em>NerdGraph</em> without worrying about configuring Apollo Client and, for the most common use cases, without having to write <em>GraphQL</em> queries. A generic"
      },
      "id": "5efa999d28ccbc6bfd307ddb"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-mutation/",
      "sections": [
        "NerdGraphMutation",
        "Usage",
        "Examples",
        "Do a mutation",
        "Do mutation and refetch query",
        "Props",
        "Example 1",
        "Methods",
        "NerdGraphMutation.render",
        "NerdGraphMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "NerdGraphMutation",
      "updated_at": "2021-01-29T01:58:06Z",
      "type": "developer",
      "external_id": "12d0744f112e48cd91b3d640657329423ab2faec",
      "document_type": "page",
      "popularity": 1,
      "body": "A generic NerdGraph mutation component that allows you to mutate anything from NerdGraph. Usage import { NerdGraphMutation } from 'nr1' Copy Examples Do a mutation 1 NerdGraphMutation.mutate({ 2 mutation: ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity( 5 guid: $guid 6 tags: { key: \"team\", values: [\"ui\"] } 7 ) { 8 errors { 9 message 10 } 11 } 12 } 13 `, 14 variables: { 15 guid: 'XXXXXXXXXXX', 16 }, 17 }); Copy Do mutation and refetch query 1 function render() { 2 const mutation = ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 5 errors { 6 message 7 } 8 } 9 } 10 `; 11 const variables = { 12 guid: 'XXXXXXXXXXX', 13 tags: { key: 'team', values: ['ui'] }, 14 }; 15 16 // NOTE: Sometimes mutations take awhile so doing a refetch immediatly after a mutate 17 // doesn't show any change. 18 return ( 19 <NerdGraphQuery query={query} variables={variables}> 20 {({ data, refetch }) => ( 21 <> 22 <RenderData data={data} /> 23 <Button 24 onClick={() => 25 NerdGraphMutation.mutate({ 26 mutation, 27 variables, 28 }).then(refetch) 29 } 30 > 31 Mutate 32 </Button> 33 </> 34 )} 35 </NerdGraphQuery> 36 ); 37 } Copy Props childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined mutationrequiredstring|object GraphQL mutation, either as a string or a GraphQL document parsed into an AST by graphql-tag. Example 1 1 import { ngql } from 'nr1'; 2 3 const mutation = ngql` 4 mutation($guid: EntityGuid!) { 5 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 6 errors { 7 message 8 } 9 } 10 } 11 `; Copy variablesobject Object containing all of the variables your mutation needs to execute. Methods NerdGraphMutation.render function () => undefined NerdGraphMutation.mutate Static method to use NerdGraphMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any NerdGraphMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 668.13586,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraphMutation</em>",
        "sections": "<em>NerdGraphMutation</em>",
        "body": "A generic <em>NerdGraph</em> mutation component that allows you to mutate anything from <em>NerdGraph</em>. Usage import { <em>NerdGraph</em>Mutation } from &#x27;nr1&#x27; Copy Examples Do a mutation 1 <em>NerdGraph</em>Mutation.mutate({ 2 mutation: ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity( 5 guid: $guid 6 tags: { key"
      },
      "id": "5efa999c64441fe20b5f7e06"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps",
        "Permissions for managing applications",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:55:31Z",
      "title": "Build apps",
      "updated_at": "2021-01-31T02:35:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Permissions for managing applications ¬† Learn about permissions for subscribing to apps Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 651.56396,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add the <em>NerdGraphQuery</em> component to an application",
        "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and <em>GraphQL</em>, you can create custom views tailored to your business. These guides are designed to help you start"
      },
      "id": "5efa999d64441fc0f75f7e21"
    }
  ],
  "/build-apps/add-time-picker-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/platform-state-context/",
      "sections": [
        "PlatformStateContext",
        "Usage",
        "Examples",
        "Basic",
        "Props",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:24Z",
      "title": "PlatformStateContext",
      "updated_at": "2021-01-29T01:56:48Z",
      "type": "developer",
      "external_id": "aa6b86b3dc0dcd7cd758b20655318b108875cce7",
      "document_type": "page",
      "popularity": 1,
      "body": "React context to access the platform URL state. Usage import { PlatformStateContext } from 'nr1' Copy Examples Basic <PlatformStateContext.Consumer> {(platformState) => <pre>{JSON.stringify(platformState, null, 4)}</pre>} </PlatformStateContext.Consumer>; 1 <PlatformStateContext.Consumer> 2 {(platformState) => <pre>{JSON.stringify(platformState, null, 4)}</pre>} 3 </PlatformStateContext.Consumer>; Copy Props There are no props for this component.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.58154,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PlatformStateContext</em>",
        "sections": "<em>PlatformStateContext</em>",
        "body": "React context to access the platform URL state. Usage import { <em>PlatformStateContext</em> } from &#x27;nr1&#x27; Copy Examples Basic &lt;PlatformStateContext.Consumer&gt; {(platformState) =&gt; &lt;pre&gt;{JSON.stringify(platformState, null, 4)}&lt;&#x2F;pre&gt;} &lt;&#x2F;PlatformStateContext.Consumer&gt;; 1 &lt;PlatformStateContext.Consumer&gt; 2 {(platformState) =&gt; &lt;pre&gt;{JSON.stringify(platformState, null, 4)}&lt;&#x2F;pre&gt;} 3 &lt;&#x2F;PlatformStateContext.Consumer&gt;; Copy Props There are no props for this component."
      },
      "id": "5efa997128ccbccc6f307dc0"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps",
        "Permissions for managing applications",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:55:31Z",
      "title": "Build apps",
      "updated_at": "2021-01-31T02:35:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Permissions for managing applications ¬† Learn about permissions for subscribing to apps Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.43266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a <em>time</em> <em>picker</em> to your <em>app</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:03:13Z",
      "title": "New Relic Developers",
      "updated_at": "2021-01-30T01:38:00Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 25 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.1448,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an <em>app</em> to show page view data on a map Add a <em>time</em> <em>picker</em> to your <em>app</em> 20 min Add a <em>time</em> <em>picker</em> to a sample"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/apis/nerdlet/",
      "sections": [
        "nerdlet",
        "Usage",
        "API methods",
        "nerdlet.getSetUrlStateLocation",
        "Example 1",
        "nerdlet.setConfig",
        "Enable account picker without cross-account support",
        "Enable account picker with cross-account support",
        "Enable action controls",
        "Enable filter bar",
        "Enable time picker with default values",
        "Enable time picker with custom values",
        "Disable nerdlet header",
        "Set custom header title and metadata",
        "Set custom header title with parent",
        "nerdlet.setUrlState",
        "Constants",
        "nerdlet.ACCOUNT_PICKER_DEFAULT_VALUES",
        "nerdlet.ACCOUNT_PICKER_VALUE",
        "nerdlet.ACTION_CONTROL_BUTTON_TYPES",
        "nerdlet.HEADER_TYPE",
        "nerdlet.TIME_PICKER_DEFAULT_RANGES",
        "nerdlet.TIME_PICKER_RANGE",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:59:49Z",
      "title": "nerdlet",
      "updated_at": "2021-01-29T02:00:54Z",
      "type": "developer",
      "external_id": "40ff4375254b82e757321599780b9d7184a30ee7",
      "document_type": "page",
      "popularity": 1,
      "body": "A set of methods to interact with the platform. Usage import { nerdlet } from 'nr1' Copy API methods nerdlet.getSetUrlStateLocation Returns a location object. Location objects can be passed into <Link to={location} /> component to navigate inside the platform. When navigated to that location, properties from urlState argument will be able to be read from NerdletStateContext.Consumer. This method behaves like React‚Äôs setState(), meaning that it performs a shallow merge between the current URL state and the provided value in the urlState parameter. function ( urlState : Object // New nerdlet URL state. ) => {Object Example 1 1 nerdlet.getSetUrlStateLocation({ 2 foo: 'bar', 3 }); Copy nerdlet.setConfig Updates the current nerdlet's configuration. This method behaves like React‚Äôs setState(), meaning that it performs a shallow merge between the current config state and the provided config. function ( config : {Object // New nerdlet config ) => undefined Enable account picker without cross-account support 1 nerdlet.setConfig({ 2 accountPicker: true, 3 }); Copy Enable account picker with cross-account support 1 nerdlet.setConfig({ 2 accountPicker: true, 3 accountPickerValues: [ 4 nerdlet.ACCOUNT_PICKER_VALUE.CROSS_ACCOUNT, 5 ...nerdlet.ACCOUNT_PICKER_DEFAULT_VALUES, 6 ], 7 }); Copy Enable action controls 1 nerdlet.setConfig({ 2 actionControls: true, 3 actionControlButtons: [ 4 { 5 label: 'Favorite', 6 type: nerdlet.ACTION_CONTROL_BUTTON_TYPES.SECONDARY, 7 hint: 'Add entity to my favorites', 8 iconType: Icon.TYPE.PROFILES__EVENTS__FAVORITE, 9 onClick: () => this.onFavoriteEntity(), 10 }, 11 ], 12 }); Copy Enable filter bar 1 nerdlet.setConfig({ 2 filterBar: true, 3 }); Copy Enable time picker with default values 1 nerdlet.setConfig({ 2 timePicker: true, 3 timePickerRanges: nerdlet.TIME_PICKER_DEFAULT_RANGES, 4 }); Copy Enable time picker with custom values 1 nerdlet.setConfig({ 2 timePicker: true, 3 timePickerRanges: [ 4 nerdlet.TIME_PICKER_RANGE.NONE, 5 { 6 label: 'Last 15 days', 7 offset: 1000 * 60 * 60 * 24 * 15, 8 }, 9 nerdlet.TIME_PICKER_RANGE.CUSTOM, 10 ], 11 }); Copy Disable nerdlet header 1 nerdlet.setConfig({ 2 header: false, 3 }); Copy Set custom header title and metadata 1 nerdlet.setConfig({ 2 headerType: nerdlet.HEADER_TYPE.CUSTOM, 3 headerTitle: 'My custom header title', 4 headerTitleMetadata: 'My custom header title metadata', 5 }); Copy Set custom header title with parent 1 nerdlet.setConfig({ 2 headerType: nerdlet.HEADER_TYPE.CUSTOM, 3 headerTitle: 'My custom header title', 4 headerParentTitle: 'Parent nerdlet I want to redirect to', 5 headerParentLocation: navigation.openNerdlet({ 6 id: 'my-nerdlet-to-redirect-to', 7 }), 8 }); Copy nerdlet.setUrlState Updates the current nerdlet's URL state that can be read from NerdletStateContext.Consumer. If you wish to update nerdlet's state without persisting its value in the url, use React's built-in setState(). This method behaves like React‚Äôs setState(), meaning that it performs a shallow merge between the current URL state and the provided state in the urlState parameter. If you wish to navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( urlState : Object, // New nerdlet URL state. urlStateOptions : {Object // Options for the URL state. ) => void Example 1 1 nerdlet.setUrlState({ 2 foo: 'bar', 3 }); Copy Constants nerdlet.ACCOUNT_PICKER_DEFAULT_VALUES [ { id : \" authorized-accounts \" } ] nerdlet.ACCOUNT_PICKER_VALUE { CROSS_ACCOUNT : { id : \" cross-account \" } } nerdlet.ACTION_CONTROL_BUTTON_TYPES { PRIMARY : \" primary \", SECONDARY : \" secondary \", TERTIARY : \" tertiary \" } nerdlet.HEADER_TYPE { CUSTOM : \" custom \", ENTITY : \" entity \" } nerdlet.TIME_PICKER_DEFAULT_RANGES [ { label : \" 30 minutes \", offset : 1800000 }, { label : \" 60 minutes \", offset : 3600000 }, { label : \" 3 hours \", offset : 10800000 }, { label : \" 6 hours \", offset : 21600000 }, { label : \" 12 hours \", offset : 43200000 }, { label : \" 24 hours \", offset : 86400000 }, { label : \" 3 days \", offset : 259200000 }, { label : \" 7 days \", offset : 604800000 }, { label : \" Set custom \", offset : \" Custom \" } ] nerdlet.TIME_PICKER_RANGE { CUSTOM : { label : \" Set custom \", offset : \" Custom \" }, NONE : { label : \" Default \", offset : null } }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.98238,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Enable <em>time</em> <em>picker</em> with default values",
        "body": " favorites&#x27;, 8 iconType: Icon.TYPE.PROFILES__EVENTS__FAVORITE, 9 onClick: () =&gt; this.onFavoriteEntity(), 10 }, 11 ], 12 }); Copy Enable filter bar 1 nerdlet.setConfig({ 2 filterBar: true, 3 }); Copy Enable <em>time</em> <em>picker</em> with default values 1 nerdlet.setConfig({ 2 <em>timePicker</em>: true, 3 <em>timePicker</em>"
      },
      "id": "5efa997128ccbce039307dbd"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies üç™"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-01-31T02:57:34Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.581276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic One <em>apps</em>",
        "body": ": <em>PlatformStateContext</em>: provides read access to the platform URL state variables. Example: <em>time</em>Range in the <em>time</em> <em>picker</em>. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state."
      },
      "id": "5efa989e28ccbc4071307de5"
    }
  ],
  "/automate-workflows/diagnose-problems/error-alerts": [
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [‚úî] Parsing and validating Deployment configuration success [‚úî] Provisioner success [‚úî] Installing On-Host instrumentation success [‚úî] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.664734,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ". In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This <em>demo</em> scenario is part of our <em>Demo</em> Catalog and will simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "5f97897864441f14936ed88e"
    },
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2021-01-31T02:55:32Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds‚Äîor 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time‚Äîless than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.325703,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select <em>Explore</em>"
      },
      "id": "5f9789dde7b9d23fd65c94fa"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/c33-pillar-details/New-Relic-TechDemo-ImprovePerformance-C33.png",
      "url": "https://newrelic.com/resources/webinars/live-demo-improve-performance-reliability-and-scale",
      "sections": [
        "Improve Performance, Reliability and Scale with New Relic One",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-01-31T06:40:15Z",
      "title": "Weekly Live Demo: Improve Performance, Reliability and Scale with New Relic One",
      "updated_at": "2021-01-31T06:40:15Z",
      "type": "storefront",
      "external_id": "da322a2e0413a8a540347ec1539dc77ec5d5d9cd",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon WEEKLY LIVE DEMO Improve Performance, Reliability and Scale with New Relic One Every Wednesday at¬†11 a.m. PT / 2 p.m. ET Format:¬†One hour (5-minute overview, 45 minutes demo, 10 minutes Q&A) Interested in learning more about New Relic One before you decide to sign up? Attend this weekly demo of New Relic One led by a member of our Solutions Engineering team to get a detailed tour of the observability platform. Learn why over 16,000 customers use New Relic One to: Collect metrics, events, logs, and traces across your entire software environment - Eliminate data silos and cut through complexity by bringing all of your telemetry data onto one platform. Find and fix issues faster - Draw meaningful connections within a complex sea of data by automatically highlighting dependencies, so you can respond to incidents faster and with better context. Run more efficiently and reliably - Get a comprehensive view of your server and host health, as well as the applications and services they depend on. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 24.277737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly Live <em>Demo</em>: Improve Performance, Reliability and Scale with New Relic One",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5ed26da4196a6761a165884b"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/kr/request-demo",
      "sections": [
        "ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞",
        "Í∏∞ÏóÖÏ†ïÎ≥¥",
        "Í≥†Í∞ùÎ¨∏Ïùò",
        "Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏"
      ],
      "published_at": "2021-01-31T04:11:54Z",
      "title": "Request Demo",
      "updated_at": "2021-01-07T14:41:26Z",
      "type": "",
      "external_id": "eba55c740b0a5077de3c90126c802b60d5ce7926",
      "popularity": 1,
      "body": "logo-newrelic Search Ï†úÌíà ÏöîÍ∏à ÏÜîÎ£®ÏÖò ÏßÄÏõê ÏÑºÌÑ∞ Ï†ïÎ≥¥ iOS ÎòêÎäî AndroidÏö© Îâ¥Î†êÎ¶≠ ¬†¬† iOSÏö© Îâ¥Î†êÎ¶≠ Insights Ïï± Search icon Ïã†Ï≤≠ÌïòÍ∏∞ Î°úÍ∑∏Ïù∏ÌïòÍ∏∞ Ï†úÌíà Îâ¥Î†êÎ¶≠ One ÌîåÎû´Ìèº Í∞úÏöî Telemetry Data Platform Full-Stack Observability Applied Intelligence ÏÜîÎ£®ÏÖò Ï£ºÏ†úÎ≥Ñ Îç∞Î∏åÏòµÏä§ ÌÅ¥ÎùºÏö∞Îìú ÎèÑÏûÖ ÌÅ¥ÎùºÏö∞Îìú ÎÑ§Ïù¥Ìã∞Î∏å ÎîîÏßÄÌÑ∏ Í≥†Í∞ù Í≤ΩÌóò Tool ÌÜµÌï© ÏóÖÏ¢ÖÎ≥Ñ Ïù¥Ïª§Î®∏Ïä§ Î∞è Î¶¨ÌÖåÏùº ÎØ∏ÎîîÏñ¥ Í≥µÍ≥µ Î∂ÄÎ¨∏ Í∏∞Ïà†Î≥Ñ Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes ÏßÄÏõê ÏÑºÌÑ∞ ÌôïÏù∏ÌïòÍ∏∞ Docs Îâ¥Î†êÎ¶≠Ïóê Í∏∞Î∞òÌïú Íµ¨Ï∂ï Ïò§Ìîà ÏÜåÏä§ ÌîÑÎ°úÏ†ùÌä∏ ÏÇ¥Ìé¥Î≥¥Í∏∞ ÍµêÏú° ÎèÑÏõÄ ÏöîÏ≤≠ÌïòÍ∏∞ Ïª§ÎÆ§ÎãàÌã∞ Ìè¨Îüº Í∏ÄÎ°úÎ≤å Í∏∞Ïà† ÏßÄÏõê Ï†ÑÎ¨∏Í∞Ä ÏÑúÎπÑÏä§ Ï†ïÎ≥¥ Í≥†Í∞ù Ìè¨Ï∂òÏùò 'Í∏ÄÎ°úÎ≤å 500ÎåÄ Í∏∞ÏóÖ‚ÄôÏóêÏÑú Ï§ëÏÜåÍ∏∞ÏóÖÍπåÏßÄ, Ï†Ñ ÏÑ∏Í≥Ñ 17,000Ïó¨ Í∏∞ÏóÖÎì§Ïù¥ Îâ¥Î†êÎ¶≠ÏùÑ ÏÇ¨Ïö©ÌïòÍ≥† ÏûàÏäµÎãàÎã§. Î∏îÎ°úÍ∑∏ Îâ¥Î†êÎ¶≠Í≥º ÎîîÏßÄÌÑ∏ Ïù∏ÌÖîÎ¶¨Ï†ÑÏä§Ïùò ÏÑ∏Í≥ÑÍ∞Ä Ï†úÍ≥µÌïòÎäî ÏµúÏã† Îâ¥Ïä§, ÌåÅ Î∞è ÌÜµÏ∞∞ÏùÑ ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§. ¬†¬† Close icon Îâ¥Î†êÎ¶≠ Ï†ïÎ≥¥ ÌöåÏÇ¨ ÏÜåÍ∞ú Í≤ΩÏòÅÏßÑ Î™®ÏûÑ Î∞è Ïù¥Î≤§Ìä∏ Ï∞∏Í≥† ÏûêÎ£å ¬† Ìà¨ÏûêÏûê Ï†ïÎ≥¥ Îâ¥Ïä§Î£∏ ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ïó∞ÎùΩ Ï†ïÎ≥¥ logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞ ÏïÑÎûò¬†ÏñëÏãùÏùÑ¬†ÏÇ¨Ïö©Ìï¥¬†ÏßÄÍ∏à¬†ÎßûÏ∂§Ìòï¬†ÎùºÏù¥Î∏å¬†Îç∞Î™®Î•º¬†ÏöîÏ≤≠ÌïòÏã≠ÏãúÏò§. Í∏∞ÏóÖÏ†ïÎ≥¥ Ï±ÑÏö© Î∞è Î¨∏Ìôî ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ìà¨ÏûêÏûê Ï†ïÎ≥¥ NewRelic.org Í≥µÍ∏âÏóÖÏ≤¥ Ìè¨ÌÑ∏ Í≥†Í∞ùÎ¨∏Ïùò Ïó∞ÎùΩ Ï†ïÎ≥¥ Îç∞Î™® Ïã†Ï≤≠ÌïòÍ∏∞ Ïù¥Î≤§Ìä∏ Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏ Deutsch English Fran√ßais Êó•Êú¨Ë™û ÏÑúÎπÑÏä§ Ïù¥Ïö©ÏïΩÍ¥Ä DMCA Ï†ïÏ±Ö Í∞úÏù∏Ï†ïÎ≥¥ Ï≤òÎ¶¨Î∞©Ïπ® Ïø†ÌÇ§ Ï†ïÏ±Ö 2015ÎÖÑ ÏòÅÍµ≠ ÎÖ∏Ïòà Î∞©ÏßÄÎ≤ï ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 17.37285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request <em>Demo</em>"
      },
      "id": "5fdc3078196a679498213956"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/request-demo",
      "sections": [
        "Request a live demo.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-01-31T05:05:14Z",
      "title": "Request a New Relic Demo | New Relic",
      "updated_at": "2021-01-04T13:42:55Z",
      "type": "",
      "external_id": "3106a7a9ae5e77d7d4c56815b91f8933a4faeb1f",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Request a live demo. Use the form below to request your personalized live demo. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 13.740908,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request a New Relic <em>Demo</em> | New Relic",
        "sections": "Request a live <em>demo</em>.",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5786ed3ce621f423f2e9cf78"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "Automate workflows",
      "updated_at": "2021-01-30T01:54:22Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.13608,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> workflows",
        "sections": "<em>Automatically</em> <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em>",
        "body": " Toolkit. Guides to <em>automate</em> workflows Quickly <em>tag</em> resources 5 min Add tags to apps for easy filtering Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em> 30 min See how easy it is to leverage automation in <em>your</em> DevOps environment! Set up New Relic using the Kubernetes operator 20"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-mutation/",
      "sections": [
        "NerdGraphMutation",
        "Usage",
        "Examples",
        "Do a mutation",
        "Do mutation and refetch query",
        "Props",
        "Example 1",
        "Methods",
        "NerdGraphMutation.render",
        "NerdGraphMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "NerdGraphMutation",
      "updated_at": "2021-01-29T01:58:06Z",
      "type": "developer",
      "external_id": "12d0744f112e48cd91b3d640657329423ab2faec",
      "document_type": "page",
      "popularity": 1,
      "body": "A generic NerdGraph mutation component that allows you to mutate anything from NerdGraph. Usage import { NerdGraphMutation } from 'nr1' Copy Examples Do a mutation 1 NerdGraphMutation.mutate({ 2 mutation: ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity( 5 guid: $guid 6 tags: { key: \"team\", values: [\"ui\"] } 7 ) { 8 errors { 9 message 10 } 11 } 12 } 13 `, 14 variables: { 15 guid: 'XXXXXXXXXXX', 16 }, 17 }); Copy Do mutation and refetch query 1 function render() { 2 const mutation = ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 5 errors { 6 message 7 } 8 } 9 } 10 `; 11 const variables = { 12 guid: 'XXXXXXXXXXX', 13 tags: { key: 'team', values: ['ui'] }, 14 }; 15 16 // NOTE: Sometimes mutations take awhile so doing a refetch immediatly after a mutate 17 // doesn't show any change. 18 return ( 19 <NerdGraphQuery query={query} variables={variables}> 20 {({ data, refetch }) => ( 21 <> 22 <RenderData data={data} /> 23 <Button 24 onClick={() => 25 NerdGraphMutation.mutate({ 26 mutation, 27 variables, 28 }).then(refetch) 29 } 30 > 31 Mutate 32 </Button> 33 </> 34 )} 35 </NerdGraphQuery> 36 ); 37 } Copy Props childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined mutationrequiredstring|object GraphQL mutation, either as a string or a GraphQL document parsed into an AST by graphql-tag. Example 1 1 import { ngql } from 'nr1'; 2 3 const mutation = ngql` 4 mutation($guid: EntityGuid!) { 5 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 6 errors { 7 message 8 } 9 } 10 } 11 `; Copy variablesobject Object containing all of the variables your mutation needs to execute. Methods NerdGraphMutation.render function () => undefined NerdGraphMutation.mutate Static method to use NerdGraphMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any NerdGraphMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.64944,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " by graphql-<em>tag</em>. Example 1 1 import { ngql } from &#x27;nr1&#x27;; 2 3 const mutation = ngql` 4 mutation($guid: EntityGuid!) { 5 <em>tagging</em>AddTagsToEntity(guid: $guid, tags: $tags) { 6 errors { 7 message 8 } 9 } 10 } 11 `; Copy variablesobject Object containing all of the variables <em>your</em> mutation needs to execute. Methods"
      },
      "id": "5efa999c64441fe20b5f7e06"
    },
    {
      "category_2": "Core concepts",
      "nodeid": 29366,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "Use tags to help organize and find your data",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "How tags are added",
        "Use tags to filter the UI",
        "Custom queries and charts",
        "For more help"
      ],
      "title": "Use tags to help organize and find your data",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data",
      "external_id": "377d38d0b4b47ae77db599de89577b8d2725e01e",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data",
      "published_at": "2021-01-31T10:23:45Z",
      "updated_at": "2021-01-23T16:37:44Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Core concepts",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use tags to improve organization and findability of your observability data. ",
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). And you can also add your own custom tags. You can use tags in the UI to filter down to relevant data, as shown here: Here you can see an accountId tag being used to filter workloads for a specific account. You can use tags to: Help organize data coming from a large number of sources and/or to a large number of New Relic accounts Identity teams, roles, environment, or regions to know who‚Äôs responsible for what (see example use cases) Better organize and search dashboards and workloads Tags are useful for organizing data at a high level. If you wanted to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events would be a better solution. At New Relic, tags were previously called \"labels.\" You may sometimes see \"label\" used in our code; for example, some of our APM agent config files use a label config option for tags. Keep reading to learn more about tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, read the best practices below to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you‚Äôll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Be consistent with capitalization. For example, avoid using both env: staging and env: Staging (although tag searching is case-insensitive in the UI and API) Tips on cross-team implementation: One reason for using tags is to improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Keep this reference manual up-to-date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity‚Äôs name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can apply tags via the UI and API or you can add tags using APM agent configuration: C SDK: not available Go .NET Node.js PHP Python Ruby Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Use tags to filter the UI Use the filter field at the top of the entity explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Entity explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity‚Äôs metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's ellipsis icon. OR Select an entity. Near the top of the page, select the information icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries and charts As explained in Tag sources, some attributes are available as tags. You can query attributes and create custom charts using NRQL. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.00009,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>tags</em> to help organize and find <em>your</em> data",
        "sections": "Use <em>tags</em> to help organize and find <em>your</em> data",
        "info": "How to use <em>tags</em> to improve organization and findability <em>of</em> <em>your</em> observability data. ",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;new-relic-one&#x2F;use-new-relic-one&#x2F;core-concepts&#x2F;use-<em>tags</em>-help-organize-find-<em>your</em>-data",
        "body": " reports that identify entities that are non-compliant with <em>your</em> <em>tagging</em> standards. <em>Tag</em> examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible"
      },
      "id": "600c50d8e7b9d2a186a8f1d3"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:03:13Z",
      "title": "New Relic Developers",
      "updated_at": "2021-01-30T01:38:00Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 25 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.3875,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Automate</em> common tasks",
        "body": " source 15 min APIs, agents, OS emitters - get any data <em>Automate</em> common tasks 20 min Use the New Relic CLI to <em>tag</em> apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to <em>your</em> app 20 min Add a time picker to a sample"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "category_2": "Examples",
      "nodeid": 34236,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "NerdGraph tagging API tutorial",
        "Read tags for an entity",
        "Add tags for an entity",
        "Remove a tag from an entity",
        "Delete specific tag values for an entity",
        "Replace all tag values for an entity",
        "For more help"
      ],
      "title": "NerdGraph tagging API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "c4b8fbf4f75b862f2b6e3caad723935febb89815",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial",
      "published_at": "2021-01-31T06:26:17Z",
      "updated_at": "2020-11-25T11:45:09Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to manage tags attached to your entities.  ",
      "body": "You can add tags to your data to help improve data organization and findability. Learn more about tagging at New Relic. This doc explains how to use our NerdGraph API to add and manage tags. For a guide to automating tags using our CLI tool, see our developer site. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to find the entity and then fetch its tags. Use NerdGraph's tag API to read the existing tags and their values. In this example, our entity is a browser app called Cookie Checkout: { actor { entitySearch (query: \"name like 'Cookie Checkout'\") { results { entities { tags { key values } } } } } } The actual values vary depending on your data. Use the New Relic GraphiQL explorer to experiment with queries. Add tags for an entity To add new tags for an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity you want to tag. Use the taggingAddTagsToEntity mutation to add a tag with a value to the entity. In this example, we have a browser application called Cookie Checkout owned by a UI team. We want to add a team tag with a ui value to this instance. Once the tag is added, we can filter by the tag team:ui and find the Cookie Checkout app in the New Relic One UI. mutation { taggingAddTagsToEntity ( guid: \"ENTITY_GUID\", tags: { key: \"team\", values: [\"ui\"]}) { errors { message } } } Remove a tag from an entity To delete a tag and all of its associated values from an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagFromEntity mutation. The following example mutation removes the team tag from an entity: mutation { taggingDeleteTagFromEntity ( guid: \"ENTITY_GUID\", tagKeys: [\"team\"]) { errors { message } } } Delete specific tag values for an entity Instead of deleting an entire tag and all of its values, you can delete a single tag value. Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagValuesFromEntity mutation. The following example mutation deletes the ui value from the tag key: mutation { taggingDeleteTagValuesFromEntity ( guid: \"ENTITY_GUID\", tagValues : [{key: \"team\" value: \"ui\"}]) { errors { message } } } Because tagValues is an array, you can delete multiple specific values from a single entity in one mutation. Replace all tag values for an entity To replace all the existing values for a tag with new ones: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingReplaceTagsOnEntity mutation. In this example, the Cookie Checkout browser application was transferred from the ui team to the cookie-dev team. You can replace the tag values for team with the following mutation: mutation { taggingReplaceTagsOnEntity ( guid: \"ENTITY_GUID\", tags: {key: \"team\" values: [\"cookie-dev\"]}) { errors { message } } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.95158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph <em>tagging</em> API tutorial",
        "sections": "NerdGraph <em>tagging</em> API tutorial",
        "info": "Use New Relic&#x27;s NerdGraph (our GraphQL API) to manage <em>tags</em> attached to <em>your</em> entities.  ",
        "body": "FromEntity mutation. The following example mutation removes the team <em>tag</em> from an entity: mutation { <em>taggingDeleteTag</em>FromEntity ( guid: &quot;ENTITY_GUID&quot;, <em>tag</em>Keys: [&quot;team&quot;]) { errors { message } } } Delete specific <em>tag</em> values for an entity Instead of deleting an <em>entire</em> <em>tag</em> and all of its values, you can delete a single"
      },
      "id": "5d8024fc28ccbcc5e9499cf1"
    }
  ],
  "/automate-workflows/5-mins-tag-resources": [
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:03:13Z",
      "title": "New Relic Developers",
      "updated_at": "2021-01-30T01:38:00Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 25 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.49509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Getting started with <em>New</em> <em>Relic</em> and Terraform",
        "body": " source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "Automate workflows",
      "updated_at": "2021-01-30T01:54:22Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.75485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " Toolkit. Guides to automate workflows Quickly <em>tag</em> resources 5 min Add <em>tags</em> to apps for easy filtering Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up <em>New</em> <em>Relic</em> using the Kubernetes operator 20"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.43471,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " application. You should copy it or write it down. Step 6 of 10 Add a simple <em>tag</em> to your application. Now that you have the GUID, you can point the <em>New</em> <em>Relic</em> <em>CLI</em> directly at your application. Adding a <em>tag</em> is the simplest way to try out the <em>CLI</em> capabilities (don&#x27;t worry, <em>tags</em> can be deleted by using"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-mutation/",
      "sections": [
        "NerdGraphMutation",
        "Usage",
        "Examples",
        "Do a mutation",
        "Do mutation and refetch query",
        "Props",
        "Example 1",
        "Methods",
        "NerdGraphMutation.render",
        "NerdGraphMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "NerdGraphMutation",
      "updated_at": "2021-01-29T01:58:06Z",
      "type": "developer",
      "external_id": "12d0744f112e48cd91b3d640657329423ab2faec",
      "document_type": "page",
      "popularity": 1,
      "body": "A generic NerdGraph mutation component that allows you to mutate anything from NerdGraph. Usage import { NerdGraphMutation } from 'nr1' Copy Examples Do a mutation 1 NerdGraphMutation.mutate({ 2 mutation: ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity( 5 guid: $guid 6 tags: { key: \"team\", values: [\"ui\"] } 7 ) { 8 errors { 9 message 10 } 11 } 12 } 13 `, 14 variables: { 15 guid: 'XXXXXXXXXXX', 16 }, 17 }); Copy Do mutation and refetch query 1 function render() { 2 const mutation = ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 5 errors { 6 message 7 } 8 } 9 } 10 `; 11 const variables = { 12 guid: 'XXXXXXXXXXX', 13 tags: { key: 'team', values: ['ui'] }, 14 }; 15 16 // NOTE: Sometimes mutations take awhile so doing a refetch immediatly after a mutate 17 // doesn't show any change. 18 return ( 19 <NerdGraphQuery query={query} variables={variables}> 20 {({ data, refetch }) => ( 21 <> 22 <RenderData data={data} /> 23 <Button 24 onClick={() => 25 NerdGraphMutation.mutate({ 26 mutation, 27 variables, 28 }).then(refetch) 29 } 30 > 31 Mutate 32 </Button> 33 </> 34 )} 35 </NerdGraphQuery> 36 ); 37 } Copy Props childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined mutationrequiredstring|object GraphQL mutation, either as a string or a GraphQL document parsed into an AST by graphql-tag. Example 1 1 import { ngql } from 'nr1'; 2 3 const mutation = ngql` 4 mutation($guid: EntityGuid!) { 5 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 6 errors { 7 message 8 } 9 } 10 } 11 `; Copy variablesobject Object containing all of the variables your mutation needs to execute. Methods NerdGraphMutation.render function () => undefined NerdGraphMutation.mutate Static method to use NerdGraphMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any NerdGraphMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.67844,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " by graphql-<em>tag</em>. Example 1 1 import { ngql } from &#x27;nr1&#x27;; 2 3 const mutation = ngql` 4 mutation($guid: EntityGuid!) { 5 taggingAdd<em>Tags</em>ToEntity(guid: $guid, <em>tags</em>: $<em>tags</em>) { 6 errors { 7 message 8 } 9 } 10 } 11 `; Copy variablesobject Object containing all of the variables your mutation needs to execute. Methods"
      },
      "id": "5efa999c64441fe20b5f7e06"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/32r7lf1gmda1w/promo-image.1608575562.png",
      "url": "https://learn.newrelic.com/go-deeper-advanced-alerting-nrql-alerts",
      "sections": [
        "Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you‚Äôll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance s",
        "About this workshop"
      ],
      "published_at": "2021-01-31T02:20:03Z",
      "title": "Go Deeper: Advanced Alerting & NRQL Alerts",
      "updated_at": "2021-01-30T01:39:35Z",
      "type": "",
      "external_id": "a44bc2bed49a8b258b97a438df3e7a0bbcf7095a",
      "popularity": 1,
      "body": "Sign In Go Deeper: Advanced Alerting & NRQL Alerts Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you‚Äôll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios. Register | FREE Already registered? Sign In About this workshop You‚Äôve mastered Alerting Fundamentals and want to know more about alerting? Join this highly practical and engaging session where we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.¬†¬† With scenario based labs, you‚Äôll create specific policies and conditions for typical use cases across the full stack, use tags to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.¬† The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements.¬† Agenda and Labs Effective Alerting strategies¬† SLO‚Äôs, SLA‚Äôs and Thresholds Use Cases and labs:¬† Alerting on SLA‚Äôs Alerting on variable performance -Dynamic Baseline Alerting Using tags to dynamically target Entities NRQL Alerts; Outlier detection, and other use cases Lab: Alert on Multiple issues (Static),¬† Lab: Alert on Synthetic performance (Dynamic),¬† Lab: Alert on Outlier behaviour (Outlier - Facets) Notifying the right team: Channels, Test Channels and Webhooks¬† Lab: Webhook Challenge Alerts and Dashboarding¬† Lab: Charting alerts Managing Alerts and Conditions REST API and Muting Rules Go Deeper: Advanced Alerting & NRQL Alerts Event Date Spaces left Go Deeper: Advanced Alerting & NRQL Alerts Feb. 25, 2021, 10 a.m. - Feb. 25, 2021, noon GMT 131 Go Deeper: Advanced Alerting & NRQL Alerts Feb. 25, 2021, 10 a.m. - Feb. 25, 2021, noon PST 120 About this workshop You‚Äôve mastered Alerting Fundamentals and want to know more about alerting? Join this highly practical and engaging session where we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.¬†¬† With scenario based labs, you‚Äôll create specific policies and conditions for typical use cases across the full stack, use tags to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.¬† The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements.¬† Agenda and Labs Effective Alerting strategies¬† SLO‚Äôs, SLA‚Äôs and Thresholds Use Cases and labs:¬† Alerting on SLA‚Äôs Alerting on variable performance -Dynamic Baseline Alerting Using tags to dynamically target Entities NRQL Alerts; Outlier detection, and other use cases Lab: Alert on Multiple issues (Static),¬† Lab: Alert on Synthetic performance (Dynamic),¬† Lab: Alert on Outlier behaviour (Outlier - Facets) Notifying the right team: Channels, Test Channels and Webhooks¬† Lab: Webhook Challenge Alerts and Dashboarding¬† Lab: Charting alerts Managing Alerts and Conditions REST API and Muting Rules Live events Go Deeper: Advanced Alerting & NRQL Alerts Event Date Spaces left Go Deeper: Advanced Alerting & NRQL Alerts Feb. 25, 2021, 10 a.m. - Feb. 25, 2021, noon GMT 131 Go Deeper: Advanced Alerting & NRQL Alerts Feb. 25, 2021, 10 a.m. - Feb. 25, 2021, noon PST 120 ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.21992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", use <em>tags</em> to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.¬† The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements"
      },
      "id": "600789b728ccbc0c0a3f6fa8"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/sparkline-table-row-cell/",
      "sections": [
        "SparklineTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Example 2",
        "Props",
        "shape",
        "Methods",
        "SparklineTableRowCell.render",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:56:29Z",
      "title": "SparklineTableRowCell",
      "updated_at": "2021-01-31T02:34:28Z",
      "type": "developer",
      "external_id": "8a9151a59bd3d13851ec9b97e44f7ff073946e60",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a table row cell showing a sparkline. Sparklines can either come from a NRQL query (thus providing accountId and query), or from a predefined data passed in the chart format. In either case, all props are 1:1 compatible with the <NrqlQuery> format type CHART. A common case to render one row per NRQL facet, is to perform the query outside of the table, then pass the result as items (returned data from a <NrqlQuery> is an array, that can be directly used as the input items of a table). Once rendering the sparkline, you need to re-wrap the data in an array, in order to build, from a series, a new entire set of data. Usage import { SparklineTableRowCell } from 'nr1' Copy Examples Example 1 1 function render() { 2 const items = [ 3 { 4 accountId: 1, 5 query: 6 \"SELECT count(*) FROM Transaction WHERE entityGuid = '‚Ä¶' TIMESERIES\", 7 }, 8 ]; 9 10 return ( 11 <Table> 12 <TableHeader> 13 <TableHeaderCell>Sparkline</TableHeaderCell> 14 </TableHeader> 15 16 {({ item }) => ( 17 <TableRow> 18 <SparklineTableRowCell 19 accountId={item.accountId} 20 query={item.query} 21 /> 22 </TableRow> 23 )} 24 </Table> 25 ); 26 } Copy Example 2 1 <NrqlQuery 2 accountId={1} 3 query=\"SELECT count(*) FROM Transaction FACET entityGuid TIMESERIES UNTIL 5 MINUTES AGO\" 4 > 5 {({ loading, error, data }) => { 6 if (loading || error) { 7 return null; 8 } 9 10 return ( 11 <Table items={data}> 12 <TableHeader> 13 <TableHeaderCell>Entity GUID</TableHeaderCell> 14 <TableHeaderCell>Transactions</TableHeaderCell> 15 </TableHeader> 16 17 {({ item }) => ( 18 <TableRow> 19 <TableRowCell>{item.metadata.name}</TableRowCell> 20 <SparklineTableRowCell data={[item]} /> 21 </TableRow> 22 )} 23 </Table> 24 ); 25 }} 26 </NrqlQuery>; Copy Props accountIdnumber Sets the account ID to perform the query. classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. dataobject[] Data is an array of objects where each object represents a series to be drawn. Each series comprises visualization metadata and an array of data points. Example 1 1 const data = [ 2 { 3 metadata: { 4 id: 'series-1', 5 name: 'Serie 1', 6 color: '#a35ebf', 7 viz: 'main', 8 units_data: { 9 x: 'TIMESTAMP', 10 y: 'BYTES', 11 }, 12 }, 13 data: [ 14 { 15 x: 1612037495447, 16 y: 21400, 17 }, 18 { 19 x: 1612041095447, 20 y: 12200, 21 }, 22 { 23 x: 1612044695447, 24 y: 9300, 25 }, 26 { 27 x: 1612048295447, 28 y: 14500, 29 }, 30 { 31 x: 1612051895447, 32 y: 27500, 33 }, 34 { 35 x: 1612055495447, 36 y: 24700, 37 }, 38 ], 39 }, 40 { 41 metadata: { 42 id: 'series-2', 43 name: 'Serie 2', 44 color: '#85c956', 45 viz: 'main', 46 units_data: { 47 x: 'TIMESTAMP', 48 y: 'BYTES', 49 }, 50 }, 51 data: [ 52 { 53 x: 1612037495447, 54 y: 8800, 55 }, 56 { 57 x: 1612041095447, 58 y: 1400, 59 }, 60 { 61 x: 1612044695447, 62 y: 4600, 63 }, 64 { 65 x: 1612048295447, 66 y: 5200, 67 }, 68 { 69 x: 1612051895447, 70 y: 14100, 71 }, 72 { 73 x: 1612055495447, 74 y: 19300, 75 }, 76 ], 77 }, 78 { 79 metadata: { 80 id: 'events', 81 name: 'Events', 82 color: 'red', 83 viz: 'event', 84 }, 85 data: [ 86 { 87 x0: 1612041095447, 88 x1: 1612044695447, 89 }, 90 { 91 x0: 1612051895447, 92 x1: 1612051895447, 93 }, 94 ], 95 }, 96 ]; Copy onClickfunction Callback fired any time the user clicks on the table cell. function ( event : Event ) => undefined querystring NRQL query used for fetching data. The query is performed against the provided accountId. styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring Methods SparklineTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1894.4412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " &lt;<em>TableHeaderCell</em>&gt;Sparkline&lt;&#x2F;<em>TableHeaderCell</em>&gt; 14 &lt;&#x2F;<em>TableHeader</em>&gt; 15 16 {({ item }) =&gt; ( 17 &lt;<em>TableRow</em>&gt; 18 &lt;Sparkline<em>TableRowCell</em> 19 accountId={item.accountId} 20 query={item.query} 21 &#x2F;&gt; 22 &lt;&#x2F;<em>TableRow</em>&gt; 23 )} 24 &lt;&#x2F;<em>Table</em>&gt; 25 ); 26 } Copy Example 2 1 &lt;NrqlQuery 2 accountId={1} 3 query=&quot;SELECT count"
      },
      "id": "5efa9906196a67b8837663fa"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/user-table-row-cell/",
      "sections": [
        "UserTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "shape",
        "Methods",
        "UserTableRowCell.render",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:59:50Z",
      "title": "UserTableRowCell",
      "updated_at": "2021-01-29T01:59:32Z",
      "type": "developer",
      "external_id": "765e8c8ba01ca8ae96c8e45e2223941812e17294",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a row table cell showing a particular user. This cell takes the user object as its children, which is in turn compatible with the NerdGraph user object (needing, at the very least, the name and gravatar fields). Usage import { UserTableRowCell } from 'nr1' Copy Examples Example 1 function render() { const items = [ { name: 'John Doe', gravatar: 'https://secure.gravatar.com/avatar/79988df068cb4d952284a3395412dc4f', }, ]; return ( <Table items={items}> <TableHeader> <TableHeaderCell>User</TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <UserTableRowCell value={item} /> </TableRow> )} </Table> ); } 1 function render() { 2 const items = [ 3 { 4 name: 'John Doe', 5 gravatar: 6 'https://secure.gravatar.com/avatar/79988df068cb4d952284a3395412dc4f', 7 }, 8 ]; 9 10 return ( 11 <Table items={items}> 12 <TableHeader> 13 <TableHeaderCell>User</TableHeaderCell> 14 </TableHeader> 15 16 {({ item }) => ( 17 <TableRow> 18 <UserTableRowCell value={item} /> 19 </TableRow> 20 )} 21 </Table> 22 ); 23 } Copy Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. onClickfunction Callback fired any time the user clicks on the table cell. function ( event : Event ) => undefined styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring valuerequiredshape User object, that requires (at least), the name and gravatar fields. This object matches with the user structure obtained from NerdGraph. shape namerequiredstring gravatarrequiredstring Methods UserTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1756.263,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " render() { const items = [ { name: &#x27;John Doe&#x27;, gravatar: &#x27;https:&#x2F;&#x2F;secure.gravatar.com&#x2F;avatar&#x2F;79988df068cb4d952284a3395412dc4f&#x27;, }, ]; return ( &lt;<em>Table</em> items={items}&gt; &lt;<em>TableHeader</em>&gt; &lt;<em>TableHeaderCell</em>&gt;User&lt;&#x2F;<em>TableHeaderCell</em>&gt; &lt;&#x2F;<em>TableHeader</em>&gt; {({ item }) =&gt; ( &lt;<em>TableRow</em>&gt; &lt;User<em>TableRowCell</em> value={item"
      },
      "id": "5efa98d464441f3b815f7e72"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/entity-title-table-row-cell/",
      "sections": [
        "EntityTitleTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "shape",
        "Methods",
        "EntityTitleTableRowCell.render",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "EntityTitleTableRowCell",
      "updated_at": "2021-01-29T01:56:48Z",
      "type": "developer",
      "external_id": "624657ff4b10659dfcb70e034f47ec8d28609706",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a row table cell showing the title of a particular entity. This cell takes the entity object as its children, which is in turn compatible with the NerdGraph entity object (needing, at the very least, the name and reporting fields). If alertable, you should also query for alertSeverity. Usage import { EntityTitleTableRowCell } from 'nr1' Copy Examples Example 1 function render() { const items = [ { name: 'Login service', alertSeverity: 'CRITICAL', reporting: true, }, ]; return ( <Table items={items}> <TableHeader> <TableHeaderCell>User</TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> </TableRow> )} </Table> ); } 1 function render() { 2 const items = [ 3 { 4 name: 'Login service', 5 alertSeverity: 'CRITICAL', 6 reporting: true, 7 }, 8 ]; 9 10 return ( 11 <Table items={items}> 12 <TableHeader> 13 <TableHeaderCell>User</TableHeaderCell> 14 </TableHeader> 15 16 {({ item }) => ( 17 <TableRow> 18 <EntityTitleTableRowCell value={item} /> 19 </TableRow> 20 )} 21 </Table> 22 ); 23 } Copy Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. onClickfunction Callback fired any time the user clicks on the cell. function ( event : Event ) => undefined styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring valuerequiredshape Entity object, that requires (at least), the name and reporting fields. This object matches with the user structure obtained from NerdGraph. shape namerequiredstring alertSeveritystring reportingrequiredboolean Methods EntityTitleTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1755.571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "&lt;&#x2F;<em>TableHeaderCell</em>&gt; 14 &lt;&#x2F;<em>TableHeader</em>&gt; 15 16 {({ item }) =&gt; ( 17 &lt;<em>TableRow</em>&gt; 18 &lt;EntityTitle<em>TableRowCell</em> value={item} &#x2F;&gt; 19 &lt;&#x2F;<em>TableRow</em>&gt; 20 )} 21 &lt;&#x2F;<em>Table</em>&gt; 22 ); 23 } Copy Props classNamestring Appends class names to the <em>component</em>. Should be used only for positioning and spacing purposes. onClickfunction Callback"
      },
      "id": "5efa98d4196a67923f766450"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table/",
      "sections": [
        "Table",
        "Usage",
        "Examples",
        "Basic",
        "Sorting",
        "Query with Table",
        "Props",
        "Methods",
        "Table.render",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:58:33Z",
      "title": "Table",
      "updated_at": "2021-01-29T01:59:31Z",
      "type": "developer",
      "external_id": "878b3ab08dbd0a7df42558a970648013adde957f",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a table with a fixed header and rows. The table implements the following features: Flexible layout: table headers accept a variety of sizes to enable fluid and fixed layouts. You can find more information on how to customize your columns checking TableHeaderCell. Sorting: items passed can be internally sorted by the table according to the current sorting state of the table. You can find more information about sorting by checking TableHeaderCell. Row selection: rows can be selected through checkboxes on the right hand side. You can find more information in the selected prop. Row actions: contextual actions can be triggered per row, enabling users to achieve functionality over them. You can find more information on how to add them in TableRow. Custom pre-defined cells: some very common patterns for cells (entity title, metrics, etc.) are already provided by the platform, so that you only need to return it as part of your row. Virtualization: cells are only rendered if they are shown on screen. This enables the table to work with a large dataset with almost no performance penalty. Usage import { Table } from 'nr1' Copy Examples Basic class Example extends React.Component { _getActions() { return [ { label: 'Action 1', disabled: true, onClick: (evt, { item, index }) => { alert(`Action 1:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); }, }, { label: 'Action 2', onClick: (evt, { item, index }) => { alert(`Action 2:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); }, }, ]; } _getItems() { return [ { name: 'Melton Garcia', gender: 'Male', company: 'Comtest', phone: '+1 (867) 477-3284', selected: true, }, { name: 'Finley Mendez', gender: 'Male', company: 'Anarco', phone: '+1 (817) 438-3205', selected: false, }, { name: 'Coleen Salinas', gender: 'Female', company: 'Macronaut', phone: '+1 (962) 419-3856', selected: true, }, ]; } render() { return ( <Table items={this._getItems()} selected={({ item }) => item.selected} onSelect={(evt, { item }) => (item.selected = evt.target.checked)} > <TableHeader> <TableHeaderCell value={({ item }) => item.name} width=\"50%\"> Name </TableHeaderCell> <TableHeaderCell value={({ item }) => item.gender}> Gender </TableHeaderCell> <TableHeaderCell value={({ item }) => item.company}> Company </TableHeaderCell> <TableHeaderCell value={({ item }) => item.phone} width=\"fit-content\" alignmentType={TableRowCell.ALIGNMENT_TYPE.RIGHT} > Phone </TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow actions={this._getActions()}> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.gender}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.phone}</TableRowCell> </TableRow> )} </Table> ); } } 1 class Example extends React.Component { 2 _getActions() { 3 return [ 4 { 5 label: 'Action 1', 6 disabled: true, 7 onClick: (evt, { item, index }) => { 8 alert(`Action 1:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); 9 }, 10 }, 11 { 12 label: 'Action 2', 13 onClick: (evt, { item, index }) => { 14 alert(`Action 2:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); 15 }, 16 }, 17 ]; 18 } 19 20 _getItems() { 21 return [ 22 { 23 name: 'Melton Garcia', 24 gender: 'Male', 25 company: 'Comtest', 26 phone: '+1 (867) 477-3284', 27 selected: true, 28 }, 29 { 30 name: 'Finley Mendez', 31 gender: 'Male', 32 company: 'Anarco', 33 phone: '+1 (817) 438-3205', 34 selected: false, 35 }, 36 { 37 name: 'Coleen Salinas', 38 gender: 'Female', 39 company: 'Macronaut', 40 phone: '+1 (962) 419-3856', 41 selected: true, 42 }, 43 ]; 44 } 45 46 render() { 47 return ( 48 <Table 49 items={this._getItems()} 50 selected={({ item }) => item.selected} 51 onSelect={(evt, { item }) => (item.selected = evt.target.checked)} 52 > 53 <TableHeader> 54 <TableHeaderCell value={({ item }) => item.name} width=\"50%\"> 55 Name 56 </TableHeaderCell> 57 <TableHeaderCell value={({ item }) => item.gender}> 58 Gender 59 </TableHeaderCell> 60 <TableHeaderCell value={({ item }) => item.company}> 61 Company 62 </TableHeaderCell> 63 <TableHeaderCell 64 value={({ item }) => item.phone} 65 width=\"fit-content\" 66 alignmentType={TableRowCell.ALIGNMENT_TYPE.RIGHT} 67 > 68 Phone 69 </TableHeaderCell> 70 </TableHeader> 71 72 {({ item }) => ( 73 <TableRow actions={this._getActions()}> 74 <TableRowCell>{item.name}</TableRowCell> 75 <TableRowCell>{item.gender}</TableRowCell> 76 <TableRowCell>{item.company}</TableRowCell> 77 <TableRowCell>{item.phone}</TableRowCell> 78 </TableRow> 79 )} 80 </Table> 81 ); 82 } 83 } Copy Sorting class Example extends React.Component { constructor() { super(...arguments); this.state = { column_0: TableHeaderCell.SORTING_TYPE.ASCENDING, }; } _getItems() { return [ { name: 'Melton Garcia', gender: 'Male', company: 'Comtest', phone: '+1 (867) 477-3284', selected: true, }, { name: 'Finley Mendez', gender: 'Male', company: 'Anarco', phone: '+1 (817) 438-3205', selected: false, }, { name: 'Coleen Salinas', gender: 'Female', company: 'Macronaut', phone: '+1 (962) 419-3856', selected: true, }, ]; } _onClickTableHeaderCell(key, event, sortingData) { this.setState({ [key]: sortingData.nextSortingType }); } render() { return ( <Table items={this._getItems()} selected={({ item }) => item.selected} onSelect={(evt, { item }) => (item.selected = evt.target.checked)} > <TableHeader> <TableHeaderCell value={({ item }) => item.name} sortable sortingType={this.state.column_0} sortingOrder={1} onClick={this._onClickTableHeaderCell.bind(this, 'column_0')} > Name </TableHeaderCell> <TableHeaderCell value={({ item }) => item.gender} sortable sortingType={this.state.column_1} sortingOrder={0} onClick={this._onClickTableHeaderCell.bind(this, 'column_1')} > Gender </TableHeaderCell> <TableHeaderCell value={({ item }) => item.company} sortable sortingType={this.state.column_2} sortingOrder={2} onClick={this._onClickTableHeaderCell.bind(this, 'column_2')} > Company </TableHeaderCell> <TableHeaderCell value={({ item }) => item.phone}> Phone </TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.gender}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.phone}</TableRowCell> </TableRow> )} </Table> ); } } 1 class Example extends React.Component { 2 constructor() { 3 super(...arguments); 4 5 this.state = { 6 column_0: TableHeaderCell.SORTING_TYPE.ASCENDING, 7 }; 8 } 9 10 _getItems() { 11 return [ 12 { 13 name: 'Melton Garcia', 14 gender: 'Male', 15 company: 'Comtest', 16 phone: '+1 (867) 477-3284', 17 selected: true, 18 }, 19 { 20 name: 'Finley Mendez', 21 gender: 'Male', 22 company: 'Anarco', 23 phone: '+1 (817) 438-3205', 24 selected: false, 25 }, 26 { 27 name: 'Coleen Salinas', 28 gender: 'Female', 29 company: 'Macronaut', 30 phone: '+1 (962) 419-3856', 31 selected: true, 32 }, 33 ]; 34 } 35 36 _onClickTableHeaderCell(key, event, sortingData) { 37 this.setState({ [key]: sortingData.nextSortingType }); 38 } 39 40 render() { 41 return ( 42 <Table 43 items={this._getItems()} 44 selected={({ item }) => item.selected} 45 onSelect={(evt, { item }) => (item.selected = evt.target.checked)} 46 > 47 <TableHeader> 48 <TableHeaderCell 49 value={({ item }) => item.name} 50 sortable 51 sortingType={this.state.column_0} 52 sortingOrder={1} 53 onClick={this._onClickTableHeaderCell.bind(this, 'column_0')} 54 > 55 Name 56 </TableHeaderCell> 57 <TableHeaderCell 58 value={({ item }) => item.gender} 59 sortable 60 sortingType={this.state.column_1} 61 sortingOrder={0} 62 onClick={this._onClickTableHeaderCell.bind(this, 'column_1')} 63 > 64 Gender 65 </TableHeaderCell> 66 <TableHeaderCell 67 value={({ item }) => item.company} 68 sortable 69 sortingType={this.state.column_2} 70 sortingOrder={2} 71 onClick={this._onClickTableHeaderCell.bind(this, 'column_2')} 72 > 73 Company 74 </TableHeaderCell> 75 <TableHeaderCell value={({ item }) => item.phone}> 76 Phone 77 </TableHeaderCell> 78 </TableHeader> 79 80 {({ item }) => ( 81 <TableRow> 82 <TableRowCell>{item.name}</TableRowCell> 83 <TableRowCell>{item.gender}</TableRowCell> 84 <TableRowCell>{item.company}</TableRowCell> 85 <TableRowCell>{item.phone}</TableRowCell> 86 </TableRow> 87 )} 88 </Table> 89 ); 90 } 91 } Copy Query with Table 1 <EntitiesByDomainTypeQuery entityDomain=\"APM\" entityType=\"APPLICATION\"> 2 {({ error, data, fetchMore }) => { 3 if (!data.entities.length && error) { 4 return 'Error!'; 5 } 6 return ( 7 <Table items={data.entities} rowCount={data.count} onLoadMore={fetchMore}> 8 <TableHeader> 9 <TableHeaderCell value={({ item }) => item.name}> 10 name 11 </TableHeaderCell> 12 <TableHeaderCell value={({ item }) => item.id}> 13 entityGuid 14 </TableHeaderCell> 15 <TableHeaderCell value={({ item }) => item.accountId}> 16 accountId 17 </TableHeaderCell> 18 </TableHeader> 19 {({ item }) => ( 20 <TableRow> 21 <EntityTitleTableRowCell value={item} /> 22 <TableRowCell>{item.guid}</TableRowCell> 23 <TableRowCell>{item.accountId}</TableRowCell> 24 </TableRow> 25 )} 26 </Table> 27 ); 28 }} 29 </EntitiesByDomainTypeQuery>; Copy Props children(node|function)[] Contents of the table. Table can only contain as children <TableHeader> and a function returning <TableRow>s. function () => undefined classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. compactboolean DEFAULT false Establishes whether the table should render in compact mode (compact mode has narrower rows). In general, use the standard mode, since compact is reserved for data representation, e.g. in a dashboard. itemsany[] DEFAULT [] The items to be used when rendering. They are required when rendering items with a render callback. Each item can have any structure and type possible, and will the corresponding one will be provided when rendering each element list. mainColumnnumber DEFAULT 0 Column containing the main data identifying the row. Often the first column (index 0) is the relevant one, but actions (like favorites) could be placed before it. onLoadMorefunction Callback fired when more items must be loaded. This happens when you're lazy loading the items and the items that are about to render cannot be found in the items array. This callback should be used to fetch/load the missing items from the backend or other sources. The returned Promise should be resolved once item data has finished loading. It will be used to determine when to refresh the list with the newly-loaded data. This callback may be called multiple times in reaction to a single scroll event. function ( cursor : {Object // Items to load. ) => undefined onSelectfunction Function called when the user clicks over a row checkbox. It is called with the event of the checkbox, as well as with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. When the user selects or unselects the header checkbox (select / unselect all), the callback will be called once for every item, representing individual clicks over each row. The header checkbox state is automatically controlled by the table. function () => undefined rowCountnumber Number of rows. By default it's equal to length of array passed in the items prop. You should specify the rowCount when you know the total number of items but you want to lazy load them while scrolling. selectedfunction Function that returns whether a row is selected. It needs to return a boolean representing the state of the row. It is called with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. function ( args : {Object ) => undefined spacingTypeenum[] Spacing property. Spacing is defined as a tuple of zero to four values, which follow the same conventions as CSS properties like margin or padding. To omit a value, use SPACING_TYPE.OMIT. <Array of <One of Table.SPACING_TYPE.EXTRA_LARGE , Table.SPACING_TYPE.LARGE , Table.SPACING_TYPE.MEDIUM , Table.SPACING_TYPE.NONE , Table.SPACING_TYPE.OMIT , Table.SPACING_TYPE.SMALL , > > styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. Methods Table.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1738.054,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Table</em>",
        "sections": "<em>Table</em>",
        "body": "={<em>TableRowCell</em>.ALIGNMENT_TYPE.RIGHT} &gt; Phone &lt;&#x2F;<em>TableHeaderCell</em>&gt; &lt;&#x2F;<em>TableHeader</em>&gt; {({ item }) =&gt; ( &lt;<em>TableRow</em> actions={this._getActions()}&gt; &lt;<em>TableRowCell</em>&gt;{item.name}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;<em>TableRowCell</em>&gt;{item.gender}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;<em>TableRowCell</em>&gt;{item.company}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;<em>TableRowCell</em>&gt;{item.phone}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;&#x2F;<em>TableRow</em>&gt; )} &lt;&#x2F;<em>Table</em>"
      },
      "id": "5efa98d428ccbcebbd307dfb"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/metric-table-row-cell/",
      "sections": [
        "MetricTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "shape",
        "Methods",
        "MetricTableRowCell.render",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:55:31Z",
      "title": "MetricTableRowCell",
      "updated_at": "2021-01-29T01:58:05Z",
      "type": "developer",
      "external_id": "b3f3bb23254c69af9c2c0f5350018bae35f5506c",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a row table cell showing a particular metric. The metric is formatted according to the unit passed. Units are 1:1 compatible with the ones supported by <NrqlQuery> format type CHART. Unit and prefix formatting is automatically picked for you so that it is consistent with the rest of the platform. Metrics are automatically aligned to the left, and ellipsified from the right, which is the standard way for presenting them. Usage import { MetricTableRowCell } from 'nr1' Copy Examples Example 1 function render() { const items = [ { value: 123456789, }, ]; return ( <Table items={items}> <TableHeader> <TableHeaderCell>User</TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <MetricTableRowCell type={MetricTableRowCell.TYPE.BITS} value={item.value} /> </TableRow> )} </Table> ); } 1 function render() { 2 const items = [ 3 { 4 value: 123456789, 5 }, 6 ]; 7 8 return ( 9 <Table items={items}> 10 <TableHeader> 11 <TableHeaderCell>User</TableHeaderCell> 12 </TableHeader> 13 14 {({ item }) => ( 15 <TableRow> 16 <MetricTableRowCell 17 type={MetricTableRowCell.TYPE.BITS} 18 value={item.value} 19 /> 20 </TableRow> 21 )} 22 </Table> 23 ); 24 } Copy Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. onClickfunction Callback fired any time the user clicks on the table cell. function ( event : Event ) => undefined styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring typeenum DEFAULT MetricTableRowCell . TYPE . UNKNOWN Unit of the provided metric. Will be used for auto-formatting the numerical value. <One of MetricTableRowCell.TYPE.APDEX , MetricTableRowCell.TYPE.BITS , MetricTableRowCell.TYPE.BITS_PER_MS , MetricTableRowCell.TYPE.BITS_PER_SECOND , MetricTableRowCell.TYPE.BYTES , MetricTableRowCell.TYPE.BYTES_PER_MS , MetricTableRowCell.TYPE.BYTES_PER_SECOND , MetricTableRowCell.TYPE.COUNT , MetricTableRowCell.TYPE.HERTZ , MetricTableRowCell.TYPE.MS , MetricTableRowCell.TYPE.PAGES_PER_SECOND , MetricTableRowCell.TYPE.PERCENTAGE , MetricTableRowCell.TYPE.REQUESTS_PER_SECOND , MetricTableRowCell.TYPE.SECONDS , MetricTableRowCell.TYPE.TIMESTAMP , MetricTableRowCell.TYPE.UNKNOWN , > valuerequirednumber Metric value, always in the shape of a number. Methods MetricTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1700.5315,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "}&gt; &lt;<em>TableHeader</em>&gt; &lt;<em>TableHeaderCell</em>&gt;User&lt;&#x2F;<em>TableHeaderCell</em>&gt; &lt;&#x2F;<em>TableHeader</em>&gt; {({ item }) =&gt; ( &lt;<em>TableRow</em>&gt; &lt;Metric<em>TableRowCell</em> type={Metric<em>TableRowCell</em>.TYPE.BITS} value={item.value} &#x2F;&gt; &lt;&#x2F;<em>TableRow</em>&gt; )} &lt;&#x2F;<em>Table</em>&gt; ); } 1 function render() { 2 const items = [ 3 { 4 value: 123456789, 5 }, 6 ]; 7 8 return ( 9 &lt;<em>Table</em>"
      },
      "id": "5efa98d5e7b9d2c0397bab3c"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps",
        "Permissions for managing applications",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:55:31Z",
      "title": "Build apps",
      "updated_at": "2021-01-31T02:35:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Permissions for managing applications ¬† Learn about permissions for subscribing to apps Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 403.09802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, query, and mutate <em>data</em> using <em>NerdStorage</em> 45 min <em>NerdStorage</em> is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. Add a time picker to your <em>app</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/user-storage-mutation/",
      "sections": [
        "UserStorageMutation",
        "Usage",
        "Examples",
        "Write document",
        "Delete document",
        "Delete collection",
        "Props",
        "Methods",
        "UserStorageMutation.render",
        "UserStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:58:33Z",
      "title": "UserStorageMutation",
      "updated_at": "2021-01-29T01:58:05Z",
      "type": "developer",
      "external_id": "1f38ffb2681d23040587f4b46a5db3bffeff7206",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update a user scoped document in NerdStorage. Usage import { UserStorageMutation } from 'nr1' Copy Examples Write document 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 3 collection: 'mycollection', 4 documentId: 'mydocumentID', 5 document: { 6 name: 'John', 7 surname: 'Doe', 8 }, 9 }); Copy Delete document 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, 3 collection: 'mycollection', 4 documentId: 'mydocumentID', 5 }); Copy Delete collection 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.DELETE_COLLECTION, 3 collection: 'mycollection', 4 }); Copy Props actionTyperequiredenum Type of action to perform. <One of UserStorageMutation.ACTION_TYPE.DELETE_COLLECTION , UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined collectionstring Name of the collection to mutate. documentobject NerdStorage document. Documents are restricted to 64KB in size. documentIdstring ID of the document to mutate. Methods UserStorageMutation.render function () => undefined UserStorageMutation.mutate Static method to use UserStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any UserStorageMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.0589,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Save, delete, or update a user scoped document in <em>NerdStorage</em>. Usage import { UserStorageMutation } from &#x27;nr1&#x27; Copy Examples Write document 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 3 collection: &#x27;mycollection&#x27;, 4 documentId: &#x27;mydocumentID&#x27;, 5"
      },
      "id": "5efa993c196a67066b766466"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/account-storage-mutation/",
      "sections": [
        "AccountStorageMutation",
        "Usage",
        "Examples",
        "Write document",
        "Delete document",
        "Delete collection",
        "Props",
        "Methods",
        "AccountStorageMutation.render",
        "AccountStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "AccountStorageMutation",
      "updated_at": "2021-01-29T01:54:06Z",
      "type": "developer",
      "external_id": "ebcf287cdc8712a7a0f6c95b60e49a5e5d3fac66",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update an account scoped document in NerdStorage. In order to successfully perform this operation, the user must have the right permissions. Usage import { AccountStorageMutation } from 'nr1' Copy Examples Write document 1 AccountStorageMutation.mutate({ 2 accountId: 1, 3 actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 document: { 7 name: 'John', 8 surname: 'Doe', 9 }, 10 }); Copy Delete document 1 AccountStorageMutation.mutate({ 2 accountId: 1, 3 actionType: AccountStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 }); Copy Delete collection 1 AccountStorageMutation.mutate({ 2 accountId: 1, 3 actionType: AccountStorageMutation.ACTION_TYPE.DELETE_COLLECTION, 4 collection: 'mycollection', 5 }); Copy Props accountIdnumber Account ID. actionTyperequiredenum Type of action to perform. <One of AccountStorageMutation.ACTION_TYPE.DELETE_COLLECTION , AccountStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined collectionstring Name of the collection to mutate. documentobject NerdStorage document. Documents are restricted to 64KB in size. documentIdstring ID of the document to mutate. Methods AccountStorageMutation.render function () => undefined AccountStorageMutation.mutate Static method to use AccountStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any AccountStorageMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.00858,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Save, delete, or update an account scoped document in <em>NerdStorage</em>. In order to successfully perform this operation, the user must have the right permissions. Usage import { AccountStorageMutation } from &#x27;nr1&#x27; Copy Examples Write document 1 AccountStorageMutation.mutate({ 2 accountId: 1, 3"
      },
      "id": "5efa997364441f8d055f7e61"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/entity-storage-mutation/",
      "sections": [
        "EntityStorageMutation",
        "Usage",
        "Examples",
        "Write document",
        "Delete document",
        "Delete collection",
        "Props",
        "Methods",
        "EntityStorageMutation.render",
        "EntityStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "EntityStorageMutation",
      "updated_at": "2021-01-29T01:55:32Z",
      "type": "developer",
      "external_id": "da00b0c5ac105e1bdff9a733569cfa006d7dd65c",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update an entity scoped document in NerdStorage. In order to successfully perform this operation, the user must have the right permissions. Usage import { EntityStorageMutation } from 'nr1' Copy Examples Write document 1 EntityStorageMutation.mutate({ 2 entityGuid: 'MTIzNDU2fEZPT3xCQVJ8OTg3NjU0Mzcz', 3 actionType: EntityStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 document: { 7 name: 'John', 8 surname: 'Doe', 9 }, 10 }); Copy Delete document 1 EntityStorageMutation.mutate({ 2 entityGuid: 'MTIzNDU2fEZPT3xCQVJ8OTg3NjU0Mzcz', 3 actionType: EntityStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 }); Copy Delete collection 1 EntityStorageMutation.mutate({ 2 entityGuid: 'MTIzNDU2fEZPT3xCQVJ8OTg3NjU0Mzcz', 3 actionType: EntityStorageMutation.ACTION_TYPE.DELETE_COLLECTION, 4 collection: 'mycollection', 5 }); Copy Props actionTyperequiredenum Type of action to perform. <One of EntityStorageMutation.ACTION_TYPE.DELETE_COLLECTION , EntityStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , EntityStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined collectionstring Name of the collection to mutate. documentobject NerdStorage document. Documents are restricted to 64KB in size. documentIdstring ID of the document to mutate. entityGuidstring GUID of the entity in which the collection is stored. Methods EntityStorageMutation.render function () => undefined EntityStorageMutation.mutate Static method to use EntityStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any EntityStorageMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 295.36362,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Save, delete, or update an entity scoped document in <em>NerdStorage</em>. In order to successfully perform this operation, the user must have the right permissions. Usage import { EntityStorageMutation } from &#x27;nr1&#x27; Copy Examples Write document 1 EntityStorageMutation.mutate({ 2 entityGuid"
      },
      "id": "5efa999d196a67d9ff76645e"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/user-storage-query/",
      "sections": [
        "UserStorageQuery",
        "Usage",
        "Examples",
        "Query collection",
        "Query document",
        "Imperative query",
        "Props",
        "Methods",
        "UserStorageQuery.render",
        "UserStorageQuery.query",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:58:32Z",
      "title": "UserStorageQuery",
      "updated_at": "2021-01-29T01:59:30Z",
      "type": "developer",
      "external_id": "0dc4a654bfbd6a4f08ad284a030b7c273b4288e5",
      "document_type": "page",
      "popularity": 1,
      "body": "Query NerdStorage for user scoped data. Retrieve an entire collection or a single document. Usage import { UserStorageQuery } from 'nr1' Copy Examples Query collection 1 <UserStorageQuery collection=\"foo\"> 2 {({ loading, error, data }) => { 3 if (loading) { 4 return <Spinner />; 5 } 6 7 if (error) { 8 return 'Error!'; 9 } 10 11 return <pre>{JSON.stringify(data, null, 4)}</pre>; 12 }} 13 </UserStorageQuery>; Copy Query document 1 <UserStorageQuery collection=\"foo\" documentId=\"bar\"> 2 {({ loading, error, data }) => { 3 if (loading) { 4 return <Spinner />; 5 } 6 7 if (error) { 8 return 'Error!'; 9 } 10 11 return <pre>{JSON.stringify(data, null, 4)}</pre>; 12 }} 13 </UserStorageQuery>; Copy Imperative query 1 UserStorageQuery.query({ 2 collection: 'mycollection', 3 documentId: 'mydocumentID', 4 }).then(({ data }) => console.log(data)); Copy Props childrenfunction Render prop function as a child. function ( queryResult : {Object // Results of the query. ) => undefined collectionrequiredstring Name of the collection to query. documentIdstring ID of the document to retrieve. If omitted, the whole collection is returned. fetchPolicyTypeenum DEFAULT UserStorageQuery . FETCH_POLICY_TYPE . CACHE_AND_NETWORK Fetch policy to be used for the query. Allows you to specify how you want your query to interact with the cached data. CACHE_AND_NETWORK: The query returns your initial data from the cache if available. However, regardless of whether or not the full data is in your cache, the query always makes a request using your network interface and returns the updated data. This option is not available when using the static query() method of the component. CACHE_FIRST: The query makes a request using your network interface only if the data for your query is not already in the cache. CACHE_ONLY: The query never makes a request using your network interface. Instead it returns the data available in the cache. If the data for your query does not exist in the cache, then an error is thrown. NETWORK_ONLY: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. NO_CACHE: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. Unlike the NETWORK_ONLY policy, it does not write any data to the cache after the query completes. <One of UserStorageQuery.FETCH_POLICY_TYPE.CACHE_AND_NETWORK , UserStorageQuery.FETCH_POLICY_TYPE.CACHE_FIRST , UserStorageQuery.FETCH_POLICY_TYPE.CACHE_ONLY , UserStorageQuery.FETCH_POLICY_TYPE.NETWORK_ONLY , UserStorageQuery.FETCH_POLICY_TYPE.NO_CACHE , > pollIntervalnumber DEFAULT 0 Interval in milliseconds to poll for new data. Methods UserStorageQuery.render function () => undefined UserStorageQuery.query A static method to use UserStorageQuery as a Promise instead of as a React component. function ( props : Object // An object containing the query options. Any UserStorageQuery prop is a valid option except children and pollInterval. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.9426,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Query <em>NerdStorage</em> for user scoped <em>data</em>. Retrieve an entire collection or a single document. Usage import { UserStorageQuery } from &#x27;nr1&#x27; Copy Examples Query collection 1 &lt;UserStorageQuery collection=&quot;foo&quot;&gt; 2 {({ loading, error, <em>data</em> }) =&gt; { 3 if (loading) { 4 return &lt;Spinner &#x2F;&gt;; 5 } 6 7 if (error"
      },
      "id": "5efa98d4196a67b6e4766432"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "sections": [
        "Charts",
        "Query New Relic data",
        "Craft custom data",
        "Metadata",
        "Data",
        "Tip",
        "Special States",
        "Configure your chart",
        "Chart Groups",
        "Next Step",
        "This site uses cookies üç™"
      ],
      "title": "Charts",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure"
      ],
      "external_id": "67f2919065eb0e710d863bdbd106db85463cc788",
      "image": "",
      "url": "https://developer.newrelic.com/components/charts/",
      "published_at": "2021-01-31T02:52:16Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use charts in your NR1 app.",
      "body": "In your application, you can display data in charts, like those used elsewhere in New Relic's user interface. The New Relic One SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply that data to your chart, using props. Query New Relic data In some cases, you want to fetch data from New Relic's database. For example, you may want to display a line chart which plots the number of transactions your application receives over time. With your chart component, set the accountId and query props to query your New Relic data using NRQL: <LineChart accountId={1234} query=\"SELECT count(*) FROM Transaction\" />; Copy Alternatively, you can fetch data with a NrqlQuery and set the data prop: <NrqlQuery accountId={1234} query=\"SELECT count(*) FROM Transaction\"> {({ data }) => <LineChart data={data} />} </NrqlQuery>; Copy If you're looking to visualize New Relic data, such as your web application's response times or your server's throughput, querying data in your charts is the way to go. But what if you want to create charts that aren't focused on New Relic data? The data prop is flexible enough that you can supply any arbitrary data, as long as it matches the standardized format. Craft custom data Whether you use custom data sets or the results of a NrqlQuery, a chart's data prop must be an array of objects where each object has both of the following fields: metadata: Defines how the chart presents its data data: An array of data points that appear on the chart For example, create a chart consisting of a line between two points by supplying two x-y coordinates in its data field: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, ]; <LineChart data={data} />; Copy This LineChart plots a line between coordinates (0, 0) and (20, 10). Use x-y coordinates for all two-dimensional chart formats. For other formats, which you'll learn more about later, use other types of data points. Because data accepts an array, you can supply two series to the same chart: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, { metadata: { id: 'series-2', name: 'My second series', viz: 'main', color: 'red', }, data: [ { x: 0, y: 50, }, { x: 20, y: 100, }, ], }, ]; <LineChart data={data} />; Copy In this example, you create a single chart with two series. The first series contains the line from the last example. The second series contains a line between points (0, 50) and (20, 100). When using two series in a single chart, like this, you may want to define how the chart represents each series. Use metadata to define those elements. Metadata A series's metadata defines certain features of the series, itself, such as how it should be displayed in your chart. metadata consists of the following attributes: Attribute Description id The series's identifier. Two series having the same id are considered the same series, regardless of where they are located. In general, use a unique id for each series. However, if you use the same series for multiple charts, keeping the id consistent can help with some cross-chart functionality, like simultaneously highlighting multiple charts. name The series's name. name is used in legends, tooltips, and other areas to indicate which series you‚Äôre looking at. color The series's color. Most visualizations use this value to differentiate series. Some visualizations, like BillboardChart or JsonChart, ignore it. Use any valid CSS color representation, such as #RRGGBB, hsl(HHH, SS%, LL%), or rgba(RR, GG, BB, .AA). Avoid tweaking the alpha value, when possible, because charts use alpha to highlight or dim certain series. viz The series's visual style. While you most often use main, this field accepts several options: main: Show the series based on chart's type. For instance, a LineChart shows the series as a line, and an AreaChart shows the series as an area. line: Show the series as a line, regardless of the chart's type. This setting applies only to AreaChart and ScatterChart. Other chart types will not show the series. area: Show the series as an area, regardless of the chart's type. This setting applies only to LineChart and ScatterChart. Other chart types will not show the series. event: Show the series as an event, regardless of the chart's type. Charts represent an event as a vertical area behind the main visualization. Events are often used to show alerts. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. target-line: Show the series as a vertical line. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. units_data You can assign a unit type to each axis on a chart. The chart will present data according to the unit type you set with units_data. To set unit_data, pass a JSON object with maps the axis to one of the following unit types: UNKNOWN: The chart displays the series with no special units. COUNT: Each value in the chart represents a count. The chart formats values with their International System prefix. For example, \"k\" represents thousands, \"M\" represents millions, and \"G\" represents billions. PERCENTAGE: Each value in the chart represents a percentage. Typically, you provide values ranging from 0 to 1. The chart formats a value of 1 as \"100%\", a value of 2 as \"200%\", and a value of 0.01 as \"1%\". MS: Each value in the chart represents some number of milliseconds. The chart represents values higher than 1 as a human-readable time duration. For example, 60000 is represented as \"1 minute\". The chart represents values lower than 1 using SI prefixes. For example, 0.001 is represented as 1 Œºs. TIMESTAMP: Each value in the chart represents a timestamp, the number milliseconds since midnight UTC on January 1, 1970, the UNIX Epoch. The chart formats each value as a date. BITS: Each value in the chart represents some number of bits. The chart formats these values using \"b\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb\". BITS_PER_SECOND: Each value in the chart represents some number of bits per second. The chart formats these values using \"b/s\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb/s\". BYTES: Each value in the chart represents some number of bytes. The chart formats these values using \"B\". For example, the chart displays 1000 as \"1 kB\". BYTES_PER_SECOND: Each value in the chart represents some number of bytes per second. The chart formats these values using \"B/s\". For example, the chart displays 1000 as \"1 kB/s\". So, to represent the y-axis for your series in bits, set the y-value in units_data: { \"units_data\": { \"y\": \"BITS\" } } Data While a data series can contain any arbitrary values, a chart only uses values which adhere to its type. So, create your data points according to the chart type: Series Type Example Description Unidimensional [{ \"y\": 10 }, { \"y\": 20 }] The chart plots data points using y values. Use this format with BarChart, BillboardChart, PieChart, StackedBarChart. Two-dimensional [ { \"x\": 10, \"y\": 20 }, { \"x\": 20, \"y\": 30 } ] The chart plots data points using x and y values. Use this format with AreaChart, LineChart, ScatterChart, SparklineChart, Funnel [{ \"label1\": 10, \"label2\": 20 }] The chart plots data according to labels. Use this format with FunnelChart. Table [{ \"jobType\": \"SIMPLE\", \"count\": 18 }] The chart plots data according to table columns. You must specify table columns in the metadata. Use this format with TableChart. Event [ { \"x0\": 0, \"x1\": 5 }, { \"x0\": 10, \"x1\": 15 } ] The chart plots the event's width based on x0 and x1 values. Histogram [ { \"x0\": 10, \"x1\": 20, \"y\": 100 }, { \"x0\": 30, \"x1\": 40, \"y\": 150 } ] The chart plots the series's width based on x0 and x1 and height based on y. Use this format with HistogramChart and HeatmapChart. Tip JsonChart is a special case because it processes any valid data. For example, you can set an arbitrary JSON object for the chart's data: const data = { data: [ { id: 1, name: 'Foo', price: 123, tags: ['Bar', 'Eek'], stock: { warehouse: 300, retail: 20, } } ], } <JsonChart data={data} /> Copy Special States In previous sections, you learned that a chart's data is an array of series. But you can use special values to present special chart states: null or undefined: Indicates the chart is ‚Äúloading‚Äù its data. In this state, the chart shows a placeholder data set. []: Indicates there is no data to show. The chart states, \"No chart data available\". Configure your chart As you've seen, you use query or data to supply data to your chart, but you can configure other aspects of your chart, too, such as visual settings and click and hover event listeners. Read the documentation for the chart you're using for more specific information. Chart Groups Under some circumstances, you might want to synchronize events, such as dragging or scrubbing, across multiple charts. To do this, use a ChartGroup. All charts in a ChartGroup synchronize their events: <ChartGroup> <Stack> <StackItem> <LineChart accountId={1} query=\"SELECT count(*) FROM Transaction SINCE 1 hour ago\" /> </StackItem> <StackItem> <AreaChart accountId={1} query=\"SELECT count(*) FROM Synthetics SINCE 1 day ago\" /> </StackItem> </Stack> </ChartGroup>; Copy Ideally, group charts that are conceptually related, and separate charts that are conceptually unrelated. Next Step Read the documentation specific to the chart you'd like to use to learn specifics about that chart's behavior and configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 248.74246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "How to use charts in your <em>NR1</em> app.",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "In your application, you can display data in charts, like those used elsewhere in New Relic&#x27;s user interface. The New Relic <em>One</em> SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply"
      },
      "id": "5fdab9f1e7b9d2e1e8df9221"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies üç™"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-01-31T02:57:34Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.51805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to New Relic <em>One</em> SDK",
        "sections": "Intro to New Relic <em>One</em> SDK",
        "info": "Intro to New Relic <em>One</em> SDK",
        "tags": "New Relic <em>One</em> apps",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.80042,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>One</em> <em>CLI</em> common commands",
        "sections": "New Relic <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the New Relic <em>One</em> <em>CLI</em>.",
        "body": " The name of a particular channel. Examples $ <em>nr1</em> update $ <em>nr1</em> update somechannel <em>nr1</em> create Create a new component Creates a new component from our template (either a <em>Nerdpack</em>, Nerdlet, launcher, or <em>catalog</em>). The <em>CLI</em> will walk you through this process. To learn more about Nerdpacks and their <em>file</em> <em>structure</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "category_2": "Measure DevOps success",
      "nodeid": 34966,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs",
        "For more help"
      ],
      "title": "Automate instrumentation",
      "category_0": "Solutions and best practices",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "91b25e8572d235c7f95963650848fc6ab6cf4b39",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation",
      "published_at": "2021-01-31T10:52:43Z",
      "updated_at": "2020-12-01T22:24:21Z",
      "breadcrumb": "Contents / Solutions and best practices / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Capture tangible, measurable metrics from before and after deployments to optimize your DevOps team. ",
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors‚Äîand more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.19696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ", the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic <em>applications</em>. 3. Leverage the power of APIs Now"
      },
      "id": "5f5e0c14196a67e25fce6a8a"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies üç™"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2021-01-31T02:53:23Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ nerdlets ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss ‚îú‚îÄ‚îÄ node_modules ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler ‚îú‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ package-lock.json ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.89557,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "sections": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "info": "An overview of the <em>Nerdpack</em> <em>File</em> <em>Structure</em>",
        "tags": "<em>file</em> <em>structure</em>",
        "body": " building guides and the New Relic <em>One</em> <em>CLI</em> command reference. <em>Nerdpack</em> <em>file</em> <em>structure</em> When you generate a <em>Nerdpack</em> template using the <em>nr1</em> create command, it has the following <em>file</em> <em>structure</em>: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <em>nr1</em>.json"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps",
        "Permissions for managing applications",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:55:31Z",
      "title": "Build apps",
      "updated_at": "2021-01-31T02:35:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Permissions for managing applications ¬† Learn about permissions for subscribing to apps Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.29523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em>",
        "body": " from your account and <em>add</em> it to a dropdown menu in an application <em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em> 45 min <em>NerdStorage</em> is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. <em>Add</em> a time picker to your app"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/user-storage-mutation/",
      "sections": [
        "UserStorageMutation",
        "Usage",
        "Examples",
        "Write document",
        "Delete document",
        "Delete collection",
        "Props",
        "Methods",
        "UserStorageMutation.render",
        "UserStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:58:33Z",
      "title": "UserStorageMutation",
      "updated_at": "2021-01-29T01:58:05Z",
      "type": "developer",
      "external_id": "1f38ffb2681d23040587f4b46a5db3bffeff7206",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update a user scoped document in NerdStorage. Usage import { UserStorageMutation } from 'nr1' Copy Examples Write document 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 3 collection: 'mycollection', 4 documentId: 'mydocumentID', 5 document: { 6 name: 'John', 7 surname: 'Doe', 8 }, 9 }); Copy Delete document 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, 3 collection: 'mycollection', 4 documentId: 'mydocumentID', 5 }); Copy Delete collection 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.DELETE_COLLECTION, 3 collection: 'mycollection', 4 }); Copy Props actionTyperequiredenum Type of action to perform. <One of UserStorageMutation.ACTION_TYPE.DELETE_COLLECTION , UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined collectionstring Name of the collection to mutate. documentobject NerdStorage document. Documents are restricted to 64KB in size. documentIdstring ID of the document to mutate. Methods UserStorageMutation.render function () => undefined UserStorageMutation.mutate Static method to use UserStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any UserStorageMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.41486,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Save, delete, or update a user scoped document in <em>NerdStorage</em>. Usage import { UserStorageMutation } from &#x27;nr1&#x27; Copy Examples Write document 1 UserStorageMutation.<em>mutate</em>({ 2 actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 3 collection: &#x27;mycollection&#x27;, 4 documentId: &#x27;mydocumentID&#x27;, 5"
      },
      "id": "5efa993c196a67066b766466"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/account-storage-mutation/",
      "sections": [
        "AccountStorageMutation",
        "Usage",
        "Examples",
        "Write document",
        "Delete document",
        "Delete collection",
        "Props",
        "Methods",
        "AccountStorageMutation.render",
        "AccountStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "AccountStorageMutation",
      "updated_at": "2021-01-29T01:54:06Z",
      "type": "developer",
      "external_id": "ebcf287cdc8712a7a0f6c95b60e49a5e5d3fac66",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update an account scoped document in NerdStorage. In order to successfully perform this operation, the user must have the right permissions. Usage import { AccountStorageMutation } from 'nr1' Copy Examples Write document 1 AccountStorageMutation.mutate({ 2 accountId: 1, 3 actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 document: { 7 name: 'John', 8 surname: 'Doe', 9 }, 10 }); Copy Delete document 1 AccountStorageMutation.mutate({ 2 accountId: 1, 3 actionType: AccountStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 }); Copy Delete collection 1 AccountStorageMutation.mutate({ 2 accountId: 1, 3 actionType: AccountStorageMutation.ACTION_TYPE.DELETE_COLLECTION, 4 collection: 'mycollection', 5 }); Copy Props accountIdnumber Account ID. actionTyperequiredenum Type of action to perform. <One of AccountStorageMutation.ACTION_TYPE.DELETE_COLLECTION , AccountStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined collectionstring Name of the collection to mutate. documentobject NerdStorage document. Documents are restricted to 64KB in size. documentIdstring ID of the document to mutate. Methods AccountStorageMutation.render function () => undefined AccountStorageMutation.mutate Static method to use AccountStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any AccountStorageMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.38599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Save, delete, or update an account scoped document in <em>NerdStorage</em>. In order to successfully perform this operation, the user must have the right permissions. Usage import { AccountStorageMutation } from &#x27;nr1&#x27; Copy Examples Write document 1 AccountStorageMutation.<em>mutate</em>({ 2 accountId: 1, 3"
      },
      "id": "5efa997364441f8d055f7e61"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/entity-storage-mutation/",
      "sections": [
        "EntityStorageMutation",
        "Usage",
        "Examples",
        "Write document",
        "Delete document",
        "Delete collection",
        "Props",
        "Methods",
        "EntityStorageMutation.render",
        "EntityStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "EntityStorageMutation",
      "updated_at": "2021-01-29T01:55:32Z",
      "type": "developer",
      "external_id": "da00b0c5ac105e1bdff9a733569cfa006d7dd65c",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update an entity scoped document in NerdStorage. In order to successfully perform this operation, the user must have the right permissions. Usage import { EntityStorageMutation } from 'nr1' Copy Examples Write document 1 EntityStorageMutation.mutate({ 2 entityGuid: 'MTIzNDU2fEZPT3xCQVJ8OTg3NjU0Mzcz', 3 actionType: EntityStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 document: { 7 name: 'John', 8 surname: 'Doe', 9 }, 10 }); Copy Delete document 1 EntityStorageMutation.mutate({ 2 entityGuid: 'MTIzNDU2fEZPT3xCQVJ8OTg3NjU0Mzcz', 3 actionType: EntityStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 }); Copy Delete collection 1 EntityStorageMutation.mutate({ 2 entityGuid: 'MTIzNDU2fEZPT3xCQVJ8OTg3NjU0Mzcz', 3 actionType: EntityStorageMutation.ACTION_TYPE.DELETE_COLLECTION, 4 collection: 'mycollection', 5 }); Copy Props actionTyperequiredenum Type of action to perform. <One of EntityStorageMutation.ACTION_TYPE.DELETE_COLLECTION , EntityStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , EntityStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined collectionstring Name of the collection to mutate. documentobject NerdStorage document. Documents are restricted to 64KB in size. documentIdstring ID of the document to mutate. entityGuidstring GUID of the entity in which the collection is stored. Methods EntityStorageMutation.render function () => undefined EntityStorageMutation.mutate Static method to use EntityStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any EntityStorageMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.4039,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Save, delete, or update an entity scoped document in <em>NerdStorage</em>. In order to successfully perform this operation, the user must have the right permissions. Usage import { EntityStorageMutation } from &#x27;nr1&#x27; Copy Examples Write document 1 EntityStorageMutation.<em>mutate</em>({ 2 entityGuid"
      },
      "id": "5efa999d196a67d9ff76645e"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/user-storage-query/",
      "sections": [
        "UserStorageQuery",
        "Usage",
        "Examples",
        "Query collection",
        "Query document",
        "Imperative query",
        "Props",
        "Methods",
        "UserStorageQuery.render",
        "UserStorageQuery.query",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:58:32Z",
      "title": "UserStorageQuery",
      "updated_at": "2021-01-29T01:59:30Z",
      "type": "developer",
      "external_id": "0dc4a654bfbd6a4f08ad284a030b7c273b4288e5",
      "document_type": "page",
      "popularity": 1,
      "body": "Query NerdStorage for user scoped data. Retrieve an entire collection or a single document. Usage import { UserStorageQuery } from 'nr1' Copy Examples Query collection 1 <UserStorageQuery collection=\"foo\"> 2 {({ loading, error, data }) => { 3 if (loading) { 4 return <Spinner />; 5 } 6 7 if (error) { 8 return 'Error!'; 9 } 10 11 return <pre>{JSON.stringify(data, null, 4)}</pre>; 12 }} 13 </UserStorageQuery>; Copy Query document 1 <UserStorageQuery collection=\"foo\" documentId=\"bar\"> 2 {({ loading, error, data }) => { 3 if (loading) { 4 return <Spinner />; 5 } 6 7 if (error) { 8 return 'Error!'; 9 } 10 11 return <pre>{JSON.stringify(data, null, 4)}</pre>; 12 }} 13 </UserStorageQuery>; Copy Imperative query 1 UserStorageQuery.query({ 2 collection: 'mycollection', 3 documentId: 'mydocumentID', 4 }).then(({ data }) => console.log(data)); Copy Props childrenfunction Render prop function as a child. function ( queryResult : {Object // Results of the query. ) => undefined collectionrequiredstring Name of the collection to query. documentIdstring ID of the document to retrieve. If omitted, the whole collection is returned. fetchPolicyTypeenum DEFAULT UserStorageQuery . FETCH_POLICY_TYPE . CACHE_AND_NETWORK Fetch policy to be used for the query. Allows you to specify how you want your query to interact with the cached data. CACHE_AND_NETWORK: The query returns your initial data from the cache if available. However, regardless of whether or not the full data is in your cache, the query always makes a request using your network interface and returns the updated data. This option is not available when using the static query() method of the component. CACHE_FIRST: The query makes a request using your network interface only if the data for your query is not already in the cache. CACHE_ONLY: The query never makes a request using your network interface. Instead it returns the data available in the cache. If the data for your query does not exist in the cache, then an error is thrown. NETWORK_ONLY: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. NO_CACHE: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. Unlike the NETWORK_ONLY policy, it does not write any data to the cache after the query completes. <One of UserStorageQuery.FETCH_POLICY_TYPE.CACHE_AND_NETWORK , UserStorageQuery.FETCH_POLICY_TYPE.CACHE_FIRST , UserStorageQuery.FETCH_POLICY_TYPE.CACHE_ONLY , UserStorageQuery.FETCH_POLICY_TYPE.NETWORK_ONLY , UserStorageQuery.FETCH_POLICY_TYPE.NO_CACHE , > pollIntervalnumber DEFAULT 0 Interval in milliseconds to poll for new data. Methods UserStorageQuery.render function () => undefined UserStorageQuery.query A static method to use UserStorageQuery as a Promise instead of as a React component. function ( props : Object // An object containing the query options. Any UserStorageQuery prop is a valid option except children and pollInterval. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.24277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Query</em> collection",
        "body": "<em>Query</em> <em>NerdStorage</em> for user scoped <em>data</em>. Retrieve an entire collection or a single document. Usage import { UserStorage<em>Query</em> } from &#x27;nr1&#x27; Copy Examples <em>Query</em> collection 1 &lt;UserStorage<em>Query</em> collection=&quot;foo&quot;&gt; 2 {({ loading, error, <em>data</em> }) =&gt; { 3 if (loading) { 4 return &lt;Spinner &#x2F;&gt;; 5 } 6 7 if (error"
      },
      "id": "5efa98d4196a67b6e4766432"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "Automate workflows",
      "updated_at": "2021-01-30T01:54:22Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 761.22925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": ", and a command-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation solutions in our Developer"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:03:13Z",
      "title": "New Relic Developers",
      "updated_at": "2021-01-30T01:38:00Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 25 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 760.6345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Getting started with <em>New</em> <em>Relic</em> and Terraform",
        "body": " source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 682.71655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the <em>New</em> <em>Relic</em> <em>CLI</em> is a good candidate for automation. In this 5-minute guide, you use the <em>New</em> <em>Relic</em> <em>CLI</em> to add multiple tags to one"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2021-01-31T02:21:06Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2021-01-02T01:38:56Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 522.19336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Live Learncast: <em>New</em> <em>Relic</em> One Programmability",
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of <em>New</em> <em>Relic</em> One Programmability. This training will introduce you to the key concepts and walk you through developing <em>New</em> <em>Relic</em> Applications.",
        "body": " available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of <em>New</em> <em>Relic</em> <em>CLI</em> and Environment setup 2. Familiarization with <em>New</em> <em>Relic</em> One"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/resources/webinars/Build-nerdlet-New-Relic-One-programmability-EMEA-200520?video=past-webinar",
      "sections": [
        "During the webinar you will learn:",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-01-31T06:06:33Z",
      "title": "Build a Nerdlet with New Relic One Programmability",
      "updated_at": "2021-01-01T04:37:32Z",
      "type": "storefront",
      "external_id": "8e6acf295e0921c9d6ddbb015cf6a7ab1829c8cf",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Build a nerdlet with New Relic One programmability Webinar Build a nerdlet with New Relic One programmability ¬† Learn how to build an application using data available in New Relic. Watch this exclusive 60 minute session to get an introduction to the fundamentals of New Relic One programmability and walk through the key concepts of developing New Relic applications. Training is delivered by a New Relic facilitator, who will guide you through the creation of an app from scratch. ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Executing New Relic CLI commands Making GraphQL and web service requests. During the webinar you will learn: Installation of New Relic CLI and environment setup Familiarisation with New Relic One application component model and lifecycle Advanced UI construction and data processing Individual self paced experimentation and Open Source example deployment. Request a demo COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 460.02563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a Nerdlet with <em>New</em> <em>Relic</em> One Programmability",
        "body": " topics: Installing the <em>New</em> <em>Relic</em> command-line interface (<em>CLI</em>) on local workstation Setting <em>New</em> <em>Relic</em> API developer access credentials Executing <em>New</em> <em>Relic</em> <em>CLI</em> commands Making GraphQL and web service requests. During the webinar you will learn: Installation of <em>New</em> <em>Relic</em> <em>CLI</em> and environment setup"
      },
      "id": "5ed2fe08e7b9d263f7c70718"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "category_2": "Ingest APIs",
      "nodeid": 35471,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert data to metrics",
        "Ingest APIs",
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs",
        "For more help"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "ae5c9ba870768ae1c06f28b22b30d4343fdb6f7c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-manage-data/ingest-apis/telemetry-sdks-report-custom-telemetry-data",
      "published_at": "2021-01-31T06:29:07Z",
      "updated_at": "2021-01-17T13:08:56Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Ingest APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Report custom telemetry data with New Relic's open-source Telemetry SDKs.",
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. To use our Telemetry SDKs and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Requirements and compatibility To build with the Telemetry SDKs, you will need an Insights insert key. New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.66072,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "sections": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "info": "Report custom <em>telemetry</em> data with New Relic&#x27;s open-source <em>Telemetry</em> <em>SDKs</em>.",
        "category_0": "<em>Telemetry</em> Data Platform",
        "category_2": "Ingest <em>APIs</em>",
        "body": "Our <em>Telemetry</em> SDKs are an open source set of <em>API</em> client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the <em>Metric</em> <em>API</em>, <em>Trace</em> <em>API</em>, Log <em>API</em>, and <em>Event</em> <em>API</em>. We offer open-source integrations for <em>telemetry</em> tools like Prometheus, Istio",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data Platform &#x2F; Ingest and manage data &#x2F; Ingest APIs"
      },
      "id": "5fef080a196a676559213932"
    },
    {
      "category_2": "OpenTelemetry",
      "nodeid": 41826,
      "sections": [
        "Open source telemetry integrations",
        "Get started",
        "OpenTelemetry",
        "Dropwizard",
        "Istio",
        "Kamon",
        "Micrometer",
        "OpenCensus",
        "Prometheus",
        "OpenTelemetry: Advanced configuration",
        "Change endpoints",
        "EU region",
        "Infinite Tracing",
        "For more help"
      ],
      "title": "OpenTelemetry: Advanced configuration",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Open source telemetry integrations",
      "external_id": "131cfb404af65784f59d6764fe88a9619af68360",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-advanced-configuration",
      "published_at": "2021-01-31T13:35:43Z",
      "updated_at": "2021-01-31T13:35:43Z",
      "breadcrumb": "Contents / Integrations / Open source telemetry integrations / OpenTelemetry",
      "document_type": "page",
      "popularity": 1,
      "body": "In some cases, you may need to change the default settings related to OpenTelemetry. Here are some advanced configurations that are available. Change endpoints You can change the New Relic endpoints where you send your data. By default, New Relic OpenTelemetry exporters send data to these US data centers: Spans: https://trace-api.newrelic.com/trace/v1 Metrics: https://metric-api.newrelic.com/metric/v1 You may need to override these default endpoints to send data to the EU region or to use Infinite Tracing. EU region To send telemetry data to New Relic‚Äôs endpoints in the EU region, use the following: These URLs don't apply to Infinite Tracing Spans: https://trace-api.eu.newrelic.com/trace/v1 Metrics: https://metric-api.eu.newrelic.com/trace/v1 Infinite Tracing If you are setting up Infinite Tracing, you need to override the default span endpoint and send telemetry data to the New Relic trace observer: Follow the steps in Set up the trace observer to get the value for YOUR_TRACE_OBSERVER_URL. Use the value of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your OpenTelemetry integrations use the AlwaysOn sampler. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.16745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Open source <em>telemetry</em> integrations",
        "category_1": "Open source <em>telemetry</em> integrations",
        "body": " centers: Spans: https:&#x2F;&#x2F;<em>trace</em>-<em>api</em>.newrelic.com&#x2F;<em>trace</em>&#x2F;v1 Metrics: https:&#x2F;&#x2F;<em>metric</em>-<em>api</em>.newrelic.com&#x2F;<em>metric</em>&#x2F;v1 You may need to override these default endpoints to send data to the EU region or to use Infinite Tracing. EU region To send <em>telemetry</em> data to New Relic‚Äôs endpoints in the EU region, use",
        "breadcrumb": "Contents &#x2F; Integrations &#x2F; Open source <em>telemetry</em> integrations &#x2F; Open<em>Telemetry</em>"
      },
      "id": "6016b22f196a679f2313474c"
    },
    {
      "category_2": "Intro to APIs",
      "nodeid": 2151,
      "sections": [
        "Get started",
        "Intro to APIs",
        "Types of New Relic API keys",
        "Manage API keys in UI",
        "Overview of API keys",
        "User key",
        "License key",
        "Browser key",
        "REST API key",
        "Insights insert key",
        "Insights query key",
        "Admin key",
        "For more help"
      ],
      "title": "Types of New Relic API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "external_id": "7642ec789132dd9f20604844a8d6aad2a12baa59",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/types-new-relic-api-keys",
      "published_at": "2021-01-31T06:49:51Z",
      "updated_at": "2021-01-31T06:49:51Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Types of New Relic API keys, who can use them, and how to add, update, or delete API keys.",
      "body": "New Relic has several different APIs that each require their own type of API key to use. This resource describes our API keys, what they're used for, and how to access them. Manage API keys in UI Here's a direct link to the API keys UI page. To find this from the New Relic UI: From the account dropdown, select Account settings. Select API keys. Overview of API keys The table below summarizes our available API keys and their uses. Some keys are able to be used by more than one API. If you're using a specific API, see the docs for that API to understand which keys are required and recommended. Key type What it's for Where to access User key (aka \"personal API key\") Used for NerdGraph (our GraphQL API) and for accessing REST API endpoints (dependent on user permissions). API keys UI License key Allows ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. API keys UI Insights insert key (aka \"Insert key\") Allows ingestion of events via HTTPS request from our metric, log, trace, and event APIs and the tools that use those APIs. Go to the API keys UI and click Insights insert key. Browser key Allows ingestion of browser monitoring data. API keys UI Mobile key (aka \"mobile app token\") Allows mobile monitoring data to be sent to New Relic. See Mobile app token. REST API key Note: we recommend using the user key instead because it has fewer limitations. The REST API key is for using our REST APIs for Alerts, APM, Browser, Infrastructure alerts, as well as Mobile REST APIs and the API Explorer. Go to the API keys UI and click REST API key. Admin API key As of December 4, 2020, all existing admin keys have been migrated to be user keys. For more information, see Admin key and User key below. API keys UI (will appear as user keys) Insights query key (aka \"Query key\") This key allows use of the Insights query API. Note: we now recommend using NerdGraph to query New Relic data. Go to the API keys UI and click Insights query key. User key New Relic user keys (previously referred to as \"personal API keys\") are required for NerdGraph (our GraphQL API), which allows you to query most New Relic data and do some types of configuration. User keys also let you use our REST API, with restrictions based on your permissions. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a user key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select User. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a user key Go to the API keys UI. In the row of the user key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a user key Go to the API keys UI. In the row of the user key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. In December 2020, user keys supplanted Admin API keys. For details, see Admin API key. License key New Relic license keys allow the ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. If you're using a specific API, see the docs for that API to understand which keys are required or recommended. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a license key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select License. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a license key Go to the API keys UI. In the row of the license key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a license API key Go to the API keys UI. In the row of the license key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Browser key The browser key allows the ingestion of data from New Relic browser monitoring. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a browser key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select Browser. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a browser key Go to the API keys UI. In the row of the browser API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a browser key Go to the API keys UI. In the row of the browser API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. REST API key We recommend using a user key to use the REST API because that key has fewer limitations. You can use a REST API key with our REST API and the API Explorer. For parent accounts with sub-accounts, each sub-account must use its own REST API key. Availability: Each New Relic account can have only one REST API key. Activate or change REST API key Go to the API keys UI and select REST API key. Click Regenerate REST API key. Click (Show key) to view your account's new REST API key. Copy your account's REST API key to use with New Relic's REST API. View REST API keys To view REST API keys: Go to the API keys UI and select REST API key. Click (Show key) to view your account's new REST API key. Delete REST API key To delete your account's REST API key: Before you delete an API key, make sure you have the correct account or sub-account. Go to the API keys UI and select REST API key. Select the delete [trash can icon] icon for the REST API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Insights insert key The Insights insert key (aka the \"Insert key\") is required for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. Generate an Insights insert key Go to the API keys UI and select Insights insert keys. Next to the Insert keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights insert key Go to the API keys UI and select Insights insert keys. Under Insert Keys, find the key you want to modify. Select Edit or Delete. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. Generate an Insights query key You must have access to the UIs you plan to query and the correct permissions in order to register or modify this key. Insights query keys are generated per account; they're not associated with a specific user. This means that any user in an account with access to a query key can use it. To register this key: Go to the API keys UI and select Insights query keys. Next to the Query Keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights query key To edit or delete this key: Go to the API keys UI page and select Insights query keys. Under Query Keys, find the key you want to modify. Select Edit or Delete. Admin key As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don‚Äôt need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says ‚ÄúMigrated from an admin user key‚Äù in the key table, so you‚Äôll be able to find them easily. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.2599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Types of New Relic <em>API</em> keys",
        "sections": "Intro to <em>APIs</em>",
        "info": "Types of New Relic <em>API</em> keys, who can use them, and how to add, update, or delete <em>API</em> keys.",
        "category_0": "<em>APIs</em>",
        "category_2": "Intro to <em>APIs</em>",
        "body": " APIs. <em>API</em> keys UI Insights insert key (aka &quot;Insert key&quot;) Allows ingestion of events via HTTPS request from our <em>metric</em>, log, <em>trace</em>, and <em>event</em> APIs and the tools that use those APIs. Go to the <em>API</em> keys UI and click Insights insert key. Browser key Allows ingestion of browser monitoring data. <em>API</em> keys"
      },
      "id": "5d7485b128ccbc1b5c32ad31"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13806,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Report custom event data",
        "Overview of reporting custom events and attributes",
        "Send custom events and attributes",
        "Extend data retention",
        "For more help"
      ],
      "title": "Report custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "afb5f5a81ae06b22935d98c470ed9cabd7c9da6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/report-custom-event-data",
      "published_at": "2021-01-31T10:05:22Z",
      "updated_at": "2020-07-26T05:52:23Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the options for sending custom event data to New Relic. ",
      "body": "New Relic products report a variety of default event data to your account. This document will explain how to report your own custom events and attributes. Overview of reporting custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. Reporting custom events allows you to create more useful and customized queries and charts of your data, and is a key part of optimizing how New Relic works for you. Before beginning, it's important to know that reporting a large number of custom events and/or attributes can cause degraded query performance, or cause you to approach or pass data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile agent Use the mobile agent API to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn about how to extend how long events are retained in your account, see Event data retention. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.76603,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>event</em> data",
        "sections": "<em>Event</em> data sources",
        "info": "An overview of the options for sending custom <em>event</em> data to New Relic. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "Custom <em>events</em>",
        "body": " the Flex integration tool to report your own custom <em>event</em> data. Mobile <em>agent</em> Use the mobile <em>agent</em> <em>API</em> to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck <em>event</em> via the $util.insights tools. For ways to report other types of custom data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em>",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; Custom events"
      },
      "id": "5e8e7f9de7b9d2aa122cf0f6"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2021-01-31T04:06:56Z",
      "updated_at": "2021-01-23T15:02:43Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.28233,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for custom <em>event</em> data",
        "sections": "Additional <em>Event</em> <em>API</em> requirements",
        "info": "For New Relic, general limits and requirements for reporting custom <em>events</em> and attributes. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "Custom <em>events</em>",
        "body": "You can report custom events to New Relic in several ways, including the New Relic <em>Event</em> <em>API</em>, APM <em>agent</em> APIs, Browser <em>agent</em> APIs, and the Mobile <em>SDK</em>. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; Custom events"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies üç™"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-01-31T02:56:28Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.08383,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users&#x27; configuration settings"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault",
        "This site uses cookies üç™"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2021-01-31T02:55:32Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.19857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Using NerdStorageVault in your <em>apps</em>",
        "info": "Intro to NerdStorageVault on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data"
      },
      "id": "5f865b55196a675792bd5340"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies üç™"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-01-31T02:57:34Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.19857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": "To help you build <em>New</em> <em>Relic</em> <em>One</em> applications, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch <em>New</em> <em>Relic</em> or third-party data"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps",
        "Permissions for managing applications",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:55:31Z",
      "title": "Build apps",
      "updated_at": "2021-01-31T02:35:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Permissions for managing applications ¬† Learn about permissions for subscribing to apps Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.700676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Build <em>apps</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. Add a time picker to your <em>app</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies üç™"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2021-01-31T02:54:25Z",
      "updated_at": "2020-12-04T02:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.375435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": "If you&#x27;ve decided to build a custom <em>app</em> or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your <em>app</em>, you might have some additional setup"
      },
      "id": "5efa9973e7b9d242237bab39"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-01-31T02:57:35Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.05585,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (<em>command</em> line interface). This page explains how to use¬†<em>CLI</em> <em>commands</em>¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-01-31T02:56:28Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.5195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.93103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>command</em> followed by the same arguments you used to create them. [ { &quot;Key&quot;: &quot;tag1&quot;, &quot;Values&quot;: [&quot;true&quot;] }, { &quot;Key&quot;: &quot;tag2&quot;, &quot;Values&quot;: [&quot;test&quot;] }, { &quot;Key&quot;: &quot;tag3&quot;, &quot;Values&quot;: [&quot;testing&quot;] } &#x2F;&#x2F; ... ] Copy Next steps Have a look at all the <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>. For example, you could create a <em>New</em> <em>Relic</em>"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.66203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " apply to any <em>CLI</em> <em>command</em>, which is useful when switching between accounts. Run the profiles add <em>command</em>: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_<em>NEW_RELIC</em>_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.21902,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2021-01-31T02:21:06Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2021-01-02T01:38:56Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.7377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic <em>Applications</em>.",
        "body": " A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps",
        "Permissions for managing applications",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:55:31Z",
      "title": "Build apps",
      "updated_at": "2021-01-31T02:35:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Permissions for managing applications ¬† Learn about permissions for subscribing to apps Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.443954,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Permissions</em> for <em>managing</em> <em>applications</em>",
        "body": " Publish and deploy <em>apps</em> 30 min Start sharing the <em>apps</em> you build <em>Permissions</em> for <em>managing</em> applications ¬† Learn about <em>permissions</em> for subscribing to <em>apps</em> Set up your development environment 20 min Prepare to build <em>apps</em> and contribute to this site"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "category_2": "Get started",
      "nodeid": 3241,
      "sections": [
        "Plugins for New Relic",
        "Get started",
        "Install plugins",
        "Custom dashboards and custom views",
        "Plugin security",
        "Limited access to legacy plugins",
        "Open community",
        "Third-party content",
        "Source code",
        "Access to license keys",
        "Access rights",
        "Plugin storage",
        "For more help"
      ],
      "title": "Plugin security",
      "category_0": "Plugins",
      "type": "docs",
      "category_1": "Plugins for New Relic",
      "external_id": "6d55258e161104037c0f84b6501aa3e525a39dd8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/plugins/plugins-new-relic/get-started/plugin-security",
      "published_at": "2021-01-31T06:45:11Z",
      "updated_at": "2021-01-27T04:52:10Z",
      "breadcrumb": "Contents / Plugins / Plugins for New Relic / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "For an overview of security measures for plugins published in New Relic's Plugin Central, start here.",
      "body": "Limited access For an even better experience than plugins, go to: newrelic.com/integrations: Integrate the on-host and cloud systems you already use with New Relic, so you can filter and analyze data, create dashboards, and set alerts within a single platform. developer.newrelic.com: Use developer tools to collect data from any source, automate workflows, build apps, and use our APIs. Limited access to legacy plugins As of December 2, 2020, plugin access has been limited to accounts that have accessed a legacy plugin in the past 30 days. The legacy plugin experience will reach end of life (EoL) as of June 16, 2021. For more information, see our Explorers Hub post. Open community New Relic's Plugins tool been designed to be open and extensible, so that any New Relic user, developer, technology vendor, or partner may publish publicly accessible plugins within Plugin Central. Anyone who has a New Relic account can install and use these plugins through their New Relic user interface. Exception: Plugins in Plugin Central are not supported with accounts that host data in the EU region data center. Having an open community where users both create and consume plugins can raise questions surrounding security. This document intends to address any security considerations for using these plugins. For more information about New Relic's security measures, see our security and data privacy documentation, or visit the New Relic security website. Third-party content For some plugins, New Relic, Inc. is the publisher, and will be clearly identified as the publisher. However, as an open resource, many plugins are created by our partners and third-party developers. Every plugin in the Plugin Central directory clearly identifies whether it was published by a New Relic developer or by a third party. We require plugin publishers to provide an About link to their website, documentation about what the plugin is for and how to use it, and a link to obtain support when using the plugin. We also require plugin publishers to review and accept the Developer Terms of Service Agreement before they can make their plugin publicly accessible. You can review all information provided by the publisher before installing any plugin. Only those plugins that identify New Relic, Inc. as the publisher fall under New Relic's posted privacy policy. For more information, see the New Relic security website. For other plugins, refer to the publisher's security and compliance statements. Source code If you have any concerns about plugins developed with the SDKs for plugins, you can review the source code and verify that the plugin agents behave as expected. The plugin agent's code is light, and it can be reviewed in minutes. Access to license keys Always keep your New Relic license key private. Typically access to your license key is needed only to record metric data or deployments for your applications, hosts, or plugins that are monitored by New Relic, not to introduce new data or code. No other access is allowed. Access rights When developing a plugin agent, authors and publishers need to consider the environment in which they will be run. You should do everything possible to reduce the level of permissions your plugin users need to grant to the agent in order for it to run correctly. In particular: Unless it is absolutely necessary, do not require su or sudo permissions in order to install your agent or support software on your users' computers. In this situation, the requirements should be limited in scope and well-documented. For additional information about access rights for plugin users, see the documentation about installing a plugin. When running your agent on the users' computers, do not require su or sudo permissions. The components (instances) your plugin agent is monitoring should only need to grant read-only permissions in order for your agent to perform its actions. As much as possible, the components (instances) your plugin agent is monitoring should be able to reduce the levels of information and access needed. When documenting your plugin, describe what level of permissions your plugin agent requires from the components (instances) it is monitoring and why this is necessary. Following these steps will make it easier for your plugin users to install your agent and increase their confidence that your agent cannot harm their components or instances being monitored. This will also reduce the likelihood of user problems if your agent has any serious bugs or other defects. Plugin storage Plugins only need access to their monitored systems and New Relic simply to report metrics. You may want to consider running plugin agents in sequestered systems with limited network access that allow no more than the minimum required network access. Also, data retention for plugins follows New Relic's standard policies. If you have any concerns about deploying any plugin from Plugin Central, follow your organization's guidelines. If for any reason you do not trust the source of an existing plugin, try creating your own version. For more help If you need more help, check out these support and learning resources: Review the documentation provided by the plugin publisher, or contact the publisher's support resources (identified in the plugin's Get support link). Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.938034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " tools to collect data from any source, automate workflows, build <em>apps</em>, and use our APIs. Limited access to legacy plugins As of December 2, 2020, plugin access has been limited to accounts that have accessed a legacy plugin in the past 30 days. The legacy plugin experience will reach end of life"
      },
      "id": "540a9264c75d073d3d00063c"
    },
    {
      "category_2": "Intro to APIs",
      "nodeid": 2151,
      "sections": [
        "Get started",
        "Intro to APIs",
        "Types of New Relic API keys",
        "Manage API keys in UI",
        "Overview of API keys",
        "User key",
        "License key",
        "Browser key",
        "REST API key",
        "Insights insert key",
        "Insights query key",
        "Admin key",
        "For more help"
      ],
      "title": "Types of New Relic API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "external_id": "7642ec789132dd9f20604844a8d6aad2a12baa59",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/types-new-relic-api-keys",
      "published_at": "2021-01-31T06:49:51Z",
      "updated_at": "2021-01-31T06:49:51Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Types of New Relic API keys, who can use them, and how to add, update, or delete API keys.",
      "body": "New Relic has several different APIs that each require their own type of API key to use. This resource describes our API keys, what they're used for, and how to access them. Manage API keys in UI Here's a direct link to the API keys UI page. To find this from the New Relic UI: From the account dropdown, select Account settings. Select API keys. Overview of API keys The table below summarizes our available API keys and their uses. Some keys are able to be used by more than one API. If you're using a specific API, see the docs for that API to understand which keys are required and recommended. Key type What it's for Where to access User key (aka \"personal API key\") Used for NerdGraph (our GraphQL API) and for accessing REST API endpoints (dependent on user permissions). API keys UI License key Allows ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. API keys UI Insights insert key (aka \"Insert key\") Allows ingestion of events via HTTPS request from our metric, log, trace, and event APIs and the tools that use those APIs. Go to the API keys UI and click Insights insert key. Browser key Allows ingestion of browser monitoring data. API keys UI Mobile key (aka \"mobile app token\") Allows mobile monitoring data to be sent to New Relic. See Mobile app token. REST API key Note: we recommend using the user key instead because it has fewer limitations. The REST API key is for using our REST APIs for Alerts, APM, Browser, Infrastructure alerts, as well as Mobile REST APIs and the API Explorer. Go to the API keys UI and click REST API key. Admin API key As of December 4, 2020, all existing admin keys have been migrated to be user keys. For more information, see Admin key and User key below. API keys UI (will appear as user keys) Insights query key (aka \"Query key\") This key allows use of the Insights query API. Note: we now recommend using NerdGraph to query New Relic data. Go to the API keys UI and click Insights query key. User key New Relic user keys (previously referred to as \"personal API keys\") are required for NerdGraph (our GraphQL API), which allows you to query most New Relic data and do some types of configuration. User keys also let you use our REST API, with restrictions based on your permissions. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a user key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select User. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a user key Go to the API keys UI. In the row of the user key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a user key Go to the API keys UI. In the row of the user key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. In December 2020, user keys supplanted Admin API keys. For details, see Admin API key. License key New Relic license keys allow the ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. If you're using a specific API, see the docs for that API to understand which keys are required or recommended. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a license key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select License. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a license key Go to the API keys UI. In the row of the license key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a license API key Go to the API keys UI. In the row of the license key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Browser key The browser key allows the ingestion of data from New Relic browser monitoring. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a browser key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select Browser. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a browser key Go to the API keys UI. In the row of the browser API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a browser key Go to the API keys UI. In the row of the browser API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. REST API key We recommend using a user key to use the REST API because that key has fewer limitations. You can use a REST API key with our REST API and the API Explorer. For parent accounts with sub-accounts, each sub-account must use its own REST API key. Availability: Each New Relic account can have only one REST API key. Activate or change REST API key Go to the API keys UI and select REST API key. Click Regenerate REST API key. Click (Show key) to view your account's new REST API key. Copy your account's REST API key to use with New Relic's REST API. View REST API keys To view REST API keys: Go to the API keys UI and select REST API key. Click (Show key) to view your account's new REST API key. Delete REST API key To delete your account's REST API key: Before you delete an API key, make sure you have the correct account or sub-account. Go to the API keys UI and select REST API key. Select the delete [trash can icon] icon for the REST API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Insights insert key The Insights insert key (aka the \"Insert key\") is required for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. Generate an Insights insert key Go to the API keys UI and select Insights insert keys. Next to the Insert keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights insert key Go to the API keys UI and select Insights insert keys. Under Insert Keys, find the key you want to modify. Select Edit or Delete. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. Generate an Insights query key You must have access to the UIs you plan to query and the correct permissions in order to register or modify this key. Insights query keys are generated per account; they're not associated with a specific user. This means that any user in an account with access to a query key can use it. To register this key: Go to the API keys UI and select Insights query keys. Next to the Query Keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights query key To edit or delete this key: Go to the API keys UI page and select Insights query keys. Under Query Keys, find the key you want to modify. Select Edit or Delete. Admin key As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don‚Äôt need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says ‚ÄúMigrated from an admin user key‚Äù in the key table, so you‚Äôll be able to find them easily. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.80365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Manage</em> API keys in UI",
        "body": " GraphQL API), which allows you to query most New Relic data and do some types of configuration. User keys also let you use our REST API, with restrictions based on your <em>permissions</em>. The instructions below are for <em>managing</em> keys in the UI. For <em>managing</em> keys via API, see Manage keys with NerdGraph"
      },
      "id": "5d7485b128ccbc1b5c32ad31"
    },
    {
      "image": "https://newrelic.com/dam/new-relic/opengraph/newrelic_og_image.png",
      "url": "https://newrelic.com/resources/webinars/NR-One-Programmability-191126",
      "sections": [
        "During this session we will review the following topics:",
        "Related Links",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-01-31T04:15:28Z",
      "title": "New Relic One Programmability Online Training",
      "updated_at": "2021-01-01T04:20:52Z",
      "type": "storefront",
      "external_id": "f583edb88ca2d2430ca297364eac839705311616",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Video New Relic One Programmability Online Training 46:59 ¬† Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. Prerequisites This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.¬† Must have: Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager role to deploy Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests JavaScript layouts ¬† During this session we will review the following topics: Installation of New Relic CLI and Environment setup Familiarisation with New Relic One Application component model and lifecycle Advanced UI construction and data processing Individual self paced experimentation and Open Source example deployment Request a Demo Related Links Case Study La plus grande brasserie au monde se tourne vers New Relic pour que la bi√®re continue de couler √† flots dans l‚Äô√®re num√©rique Webinar Introduction to Custom Apps on New Relic One eBook Understanding the 3 Phases of DevOps Maturity Article Black Friday Is Coming: Are Your Sites and Apps Ready? eBook DevOps ‚Äì so geht es richtig : Best Practices zur √úberwindung von Erfolgshindernissen eBook DevOps Done Right: Best Practices to Knock Down Barriers to Success eBook Creating a Framework for Digital Media Success Article 7 Requirements for Monitoring Cloud Apps and Infrastructure COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.510345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.¬† Must have: <em>Permissions</em> to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> role to deploy"
      },
      "id": "5ece92cb28ccbc3012c1356a"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-01-31T02:57:35Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.35085,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " and publish your application, see¬†our guide on Deploying your <em>New</em> <em>Relic</em> <em>One</em> app. Get started nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (Nerdpack, Nerdlet, launcher, or <em>catalog</em>). nr1"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:03:13Z",
      "title": "New Relic Developers",
      "updated_at": "2021-01-30T01:38:00Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 25 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.40555,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Getting started with <em>New</em> <em>Relic</em> and Terraform",
        "body": " to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local <em>New</em> <em>Relic</em> <em>One</em> <em>Catalog</em> Start the guide Get inspired Add a table to your app 30 min Add a table to your <em>New</em> <em>Relic</em> <em>One</em> app Collect data - any"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-01-31T02:56:28Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.5195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.24423,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.93103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>command</em> followed by the same arguments you used to create them. [ { &quot;Key&quot;: &quot;tag1&quot;, &quot;Values&quot;: [&quot;true&quot;] }, { &quot;Key&quot;: &quot;tag2&quot;, &quot;Values&quot;: [&quot;test&quot;] }, { &quot;Key&quot;: &quot;tag3&quot;, &quot;Values&quot;: [&quot;testing&quot;] } &#x2F;&#x2F; ... ] Copy Next steps Have a look at all the <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>. For example, you could create a <em>New</em> <em>Relic</em>"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    }
  ],
  "/explore-docs/nerdstoragevault": [
    {
      "nodeid": 41516,
      "sections": [
        "Recent Announcements",
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "type": "docs",
      "external_id": "abfc5ea05724ba8d4c31198fa9d7b162d0d969da",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/store-data-encrypted-storage-solution-nerdstoragevault",
      "published_at": "2021-01-31T12:09:41Z",
      "updated_at": "2020-12-09T00:13:59Z",
      "breadcrumb": "Contents / What's New",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 384.74255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "NerdGraph allows you to <em>access</em> your <em>New</em> <em>Relic</em> <em>data</em>, but when you want to fetch third-party <em>data</em>, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and <em>encrypted</em> <em>storage</em> location where you can safely store",
        "breadcrumb": "Contents &#x2F; What&#x27;s <em>New</em>"
      },
      "id": "5fc9989a28ccbc05264a267e"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies üç™"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-01-31T02:56:28Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.4871,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> <em>access</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use Nerd<em>Storage</em> SDK <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of <em>data</em>, including users&#x27; configuration settings"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-01-31T02:57:35Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.12857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference",
        "info": "An overview of the CLI to help you build, deploy, and manage <em>New</em> <em>Relic</em> <em>apps</em>.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>app</em>",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> <em>app</em>, you must install the <em>New</em> <em>Relic</em> <em>One</em> CLI. The CLI helps you build, publish, and manage your <em>New</em> <em>Relic</em> <em>app</em>. We provide a variety of tools for building <em>apps</em>, including the <em>New</em> <em>Relic</em> <em>One</em> CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies üç™"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2021-01-31T02:54:25Z",
      "updated_at": "2020-12-04T02:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.732697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": ", publish it to <em>New</em> <em>Relic</em> <em>One</em>, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create <em>one</em> of our popular open source <em>apps</em>. You learn to add a custom query to an <em>app</em> and view it in a table, then add that <em>data</em> to a map. Contribute"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies üç™"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2021-01-31T02:53:23Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ nerdlets ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss ‚îú‚îÄ‚îÄ node_modules ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler ‚îú‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ package-lock.json ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.914555,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Generate Nerdpack <em>components</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": " a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the <em>New</em> <em>Relic</em> <em>One</em> CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack <em>components</em>, see our <em>app</em>"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/automate-workflows/diagnose-problems/high-response-times": [
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [‚úî] Parsing and validating Deployment configuration success [‚úî] Provisioner success [‚úî] Installing On-Host instrumentation success [‚úî] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.664734,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ". In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This <em>demo</em> scenario is part of our <em>Demo</em> Catalog and will simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "5f97897864441f14936ed88e"
    },
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Tip",
        "Extra Credit",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2021-01-31T02:54:25Z",
      "updated_at": "2021-01-16T01:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: Tip If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash Copy An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash Copy java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash Copy java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Extra Credit Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.6585,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "5f97897964441f26ff6ed879"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/c33-pillar-details/New-Relic-TechDemo-ImprovePerformance-C33.png",
      "url": "https://newrelic.com/resources/webinars/live-demo-improve-performance-reliability-and-scale",
      "sections": [
        "Improve Performance, Reliability and Scale with New Relic One",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-01-31T06:40:15Z",
      "title": "Weekly Live Demo: Improve Performance, Reliability and Scale with New Relic One",
      "updated_at": "2021-01-31T06:40:15Z",
      "type": "storefront",
      "external_id": "da322a2e0413a8a540347ec1539dc77ec5d5d9cd",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon WEEKLY LIVE DEMO Improve Performance, Reliability and Scale with New Relic One Every Wednesday at¬†11 a.m. PT / 2 p.m. ET Format:¬†One hour (5-minute overview, 45 minutes demo, 10 minutes Q&A) Interested in learning more about New Relic One before you decide to sign up? Attend this weekly demo of New Relic One led by a member of our Solutions Engineering team to get a detailed tour of the observability platform. Learn why over 16,000 customers use New Relic One to: Collect metrics, events, logs, and traces across your entire software environment - Eliminate data silos and cut through complexity by bringing all of your telemetry data onto one platform. Find and fix issues faster - Draw meaningful connections within a complex sea of data by automatically highlighting dependencies, so you can respond to incidents faster and with better context. Run more efficiently and reliably - Get a comprehensive view of your server and host health, as well as the applications and services they depend on. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 24.277737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly Live <em>Demo</em>: Improve Performance, Reliability and Scale with New Relic One",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5ed26da4196a6761a165884b"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/kr/request-demo",
      "sections": [
        "ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞",
        "Í∏∞ÏóÖÏ†ïÎ≥¥",
        "Í≥†Í∞ùÎ¨∏Ïùò",
        "Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏"
      ],
      "published_at": "2021-01-31T04:11:54Z",
      "title": "Request Demo",
      "updated_at": "2021-01-07T14:41:26Z",
      "type": "",
      "external_id": "eba55c740b0a5077de3c90126c802b60d5ce7926",
      "popularity": 1,
      "body": "logo-newrelic Search Ï†úÌíà ÏöîÍ∏à ÏÜîÎ£®ÏÖò ÏßÄÏõê ÏÑºÌÑ∞ Ï†ïÎ≥¥ iOS ÎòêÎäî AndroidÏö© Îâ¥Î†êÎ¶≠ ¬†¬† iOSÏö© Îâ¥Î†êÎ¶≠ Insights Ïï± Search icon Ïã†Ï≤≠ÌïòÍ∏∞ Î°úÍ∑∏Ïù∏ÌïòÍ∏∞ Ï†úÌíà Îâ¥Î†êÎ¶≠ One ÌîåÎû´Ìèº Í∞úÏöî Telemetry Data Platform Full-Stack Observability Applied Intelligence ÏÜîÎ£®ÏÖò Ï£ºÏ†úÎ≥Ñ Îç∞Î∏åÏòµÏä§ ÌÅ¥ÎùºÏö∞Îìú ÎèÑÏûÖ ÌÅ¥ÎùºÏö∞Îìú ÎÑ§Ïù¥Ìã∞Î∏å ÎîîÏßÄÌÑ∏ Í≥†Í∞ù Í≤ΩÌóò Tool ÌÜµÌï© ÏóÖÏ¢ÖÎ≥Ñ Ïù¥Ïª§Î®∏Ïä§ Î∞è Î¶¨ÌÖåÏùº ÎØ∏ÎîîÏñ¥ Í≥µÍ≥µ Î∂ÄÎ¨∏ Í∏∞Ïà†Î≥Ñ Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes ÏßÄÏõê ÏÑºÌÑ∞ ÌôïÏù∏ÌïòÍ∏∞ Docs Îâ¥Î†êÎ¶≠Ïóê Í∏∞Î∞òÌïú Íµ¨Ï∂ï Ïò§Ìîà ÏÜåÏä§ ÌîÑÎ°úÏ†ùÌä∏ ÏÇ¥Ìé¥Î≥¥Í∏∞ ÍµêÏú° ÎèÑÏõÄ ÏöîÏ≤≠ÌïòÍ∏∞ Ïª§ÎÆ§ÎãàÌã∞ Ìè¨Îüº Í∏ÄÎ°úÎ≤å Í∏∞Ïà† ÏßÄÏõê Ï†ÑÎ¨∏Í∞Ä ÏÑúÎπÑÏä§ Ï†ïÎ≥¥ Í≥†Í∞ù Ìè¨Ï∂òÏùò 'Í∏ÄÎ°úÎ≤å 500ÎåÄ Í∏∞ÏóÖ‚ÄôÏóêÏÑú Ï§ëÏÜåÍ∏∞ÏóÖÍπåÏßÄ, Ï†Ñ ÏÑ∏Í≥Ñ 17,000Ïó¨ Í∏∞ÏóÖÎì§Ïù¥ Îâ¥Î†êÎ¶≠ÏùÑ ÏÇ¨Ïö©ÌïòÍ≥† ÏûàÏäµÎãàÎã§. Î∏îÎ°úÍ∑∏ Îâ¥Î†êÎ¶≠Í≥º ÎîîÏßÄÌÑ∏ Ïù∏ÌÖîÎ¶¨Ï†ÑÏä§Ïùò ÏÑ∏Í≥ÑÍ∞Ä Ï†úÍ≥µÌïòÎäî ÏµúÏã† Îâ¥Ïä§, ÌåÅ Î∞è ÌÜµÏ∞∞ÏùÑ ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§. ¬†¬† Close icon Îâ¥Î†êÎ¶≠ Ï†ïÎ≥¥ ÌöåÏÇ¨ ÏÜåÍ∞ú Í≤ΩÏòÅÏßÑ Î™®ÏûÑ Î∞è Ïù¥Î≤§Ìä∏ Ï∞∏Í≥† ÏûêÎ£å ¬† Ìà¨ÏûêÏûê Ï†ïÎ≥¥ Îâ¥Ïä§Î£∏ ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ïó∞ÎùΩ Ï†ïÎ≥¥ logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞ ÏïÑÎûò¬†ÏñëÏãùÏùÑ¬†ÏÇ¨Ïö©Ìï¥¬†ÏßÄÍ∏à¬†ÎßûÏ∂§Ìòï¬†ÎùºÏù¥Î∏å¬†Îç∞Î™®Î•º¬†ÏöîÏ≤≠ÌïòÏã≠ÏãúÏò§. Í∏∞ÏóÖÏ†ïÎ≥¥ Ï±ÑÏö© Î∞è Î¨∏Ìôî ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ìà¨ÏûêÏûê Ï†ïÎ≥¥ NewRelic.org Í≥µÍ∏âÏóÖÏ≤¥ Ìè¨ÌÑ∏ Í≥†Í∞ùÎ¨∏Ïùò Ïó∞ÎùΩ Ï†ïÎ≥¥ Îç∞Î™® Ïã†Ï≤≠ÌïòÍ∏∞ Ïù¥Î≤§Ìä∏ Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏ Deutsch English Fran√ßais Êó•Êú¨Ë™û ÏÑúÎπÑÏä§ Ïù¥Ïö©ÏïΩÍ¥Ä DMCA Ï†ïÏ±Ö Í∞úÏù∏Ï†ïÎ≥¥ Ï≤òÎ¶¨Î∞©Ïπ® Ïø†ÌÇ§ Ï†ïÏ±Ö 2015ÎÖÑ ÏòÅÍµ≠ ÎÖ∏Ïòà Î∞©ÏßÄÎ≤ï ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 17.37285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request <em>Demo</em>"
      },
      "id": "5fdc3078196a679498213956"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/request-demo",
      "sections": [
        "Request a live demo.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-01-31T05:05:14Z",
      "title": "Request a New Relic Demo | New Relic",
      "updated_at": "2021-01-04T13:42:55Z",
      "type": "",
      "external_id": "3106a7a9ae5e77d7d4c56815b91f8933a4faeb1f",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Request a live demo. Use the form below to request your personalized live demo. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 13.740908,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request a New Relic <em>Demo</em> | New Relic",
        "sections": "Request a live <em>demo</em>.",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5786ed3ce621f423f2e9cf78"
    }
  ],
  "/automate-workflows/diagnose-problems": [
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Tip",
        "Extra Credit",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2021-01-31T02:54:25Z",
      "updated_at": "2021-01-16T01:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: Tip If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash Copy An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash Copy java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash Copy java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Extra Credit Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.6585,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "5f97897964441f26ff6ed879"
    },
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2021-01-31T02:55:32Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds‚Äîor 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time‚Äîless than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.325703,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select <em>Explore</em>"
      },
      "id": "5f9789dde7b9d23fd65c94fa"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/c33-pillar-details/New-Relic-TechDemo-ImprovePerformance-C33.png",
      "url": "https://newrelic.com/resources/webinars/live-demo-improve-performance-reliability-and-scale",
      "sections": [
        "Improve Performance, Reliability and Scale with New Relic One",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-01-31T06:40:15Z",
      "title": "Weekly Live Demo: Improve Performance, Reliability and Scale with New Relic One",
      "updated_at": "2021-01-31T06:40:15Z",
      "type": "storefront",
      "external_id": "da322a2e0413a8a540347ec1539dc77ec5d5d9cd",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon WEEKLY LIVE DEMO Improve Performance, Reliability and Scale with New Relic One Every Wednesday at¬†11 a.m. PT / 2 p.m. ET Format:¬†One hour (5-minute overview, 45 minutes demo, 10 minutes Q&A) Interested in learning more about New Relic One before you decide to sign up? Attend this weekly demo of New Relic One led by a member of our Solutions Engineering team to get a detailed tour of the observability platform. Learn why over 16,000 customers use New Relic One to: Collect metrics, events, logs, and traces across your entire software environment - Eliminate data silos and cut through complexity by bringing all of your telemetry data onto one platform. Find and fix issues faster - Draw meaningful connections within a complex sea of data by automatically highlighting dependencies, so you can respond to incidents faster and with better context. Run more efficiently and reliably - Get a comprehensive view of your server and host health, as well as the applications and services they depend on. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 24.277737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly Live <em>Demo</em>: Improve Performance, Reliability and Scale with New Relic One",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5ed26da4196a6761a165884b"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/kr/request-demo",
      "sections": [
        "ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞",
        "Í∏∞ÏóÖÏ†ïÎ≥¥",
        "Í≥†Í∞ùÎ¨∏Ïùò",
        "Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏"
      ],
      "published_at": "2021-01-31T04:11:54Z",
      "title": "Request Demo",
      "updated_at": "2021-01-07T14:41:26Z",
      "type": "",
      "external_id": "eba55c740b0a5077de3c90126c802b60d5ce7926",
      "popularity": 1,
      "body": "logo-newrelic Search Ï†úÌíà ÏöîÍ∏à ÏÜîÎ£®ÏÖò ÏßÄÏõê ÏÑºÌÑ∞ Ï†ïÎ≥¥ iOS ÎòêÎäî AndroidÏö© Îâ¥Î†êÎ¶≠ ¬†¬† iOSÏö© Îâ¥Î†êÎ¶≠ Insights Ïï± Search icon Ïã†Ï≤≠ÌïòÍ∏∞ Î°úÍ∑∏Ïù∏ÌïòÍ∏∞ Ï†úÌíà Îâ¥Î†êÎ¶≠ One ÌîåÎû´Ìèº Í∞úÏöî Telemetry Data Platform Full-Stack Observability Applied Intelligence ÏÜîÎ£®ÏÖò Ï£ºÏ†úÎ≥Ñ Îç∞Î∏åÏòµÏä§ ÌÅ¥ÎùºÏö∞Îìú ÎèÑÏûÖ ÌÅ¥ÎùºÏö∞Îìú ÎÑ§Ïù¥Ìã∞Î∏å ÎîîÏßÄÌÑ∏ Í≥†Í∞ù Í≤ΩÌóò Tool ÌÜµÌï© ÏóÖÏ¢ÖÎ≥Ñ Ïù¥Ïª§Î®∏Ïä§ Î∞è Î¶¨ÌÖåÏùº ÎØ∏ÎîîÏñ¥ Í≥µÍ≥µ Î∂ÄÎ¨∏ Í∏∞Ïà†Î≥Ñ Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes ÏßÄÏõê ÏÑºÌÑ∞ ÌôïÏù∏ÌïòÍ∏∞ Docs Îâ¥Î†êÎ¶≠Ïóê Í∏∞Î∞òÌïú Íµ¨Ï∂ï Ïò§Ìîà ÏÜåÏä§ ÌîÑÎ°úÏ†ùÌä∏ ÏÇ¥Ìé¥Î≥¥Í∏∞ ÍµêÏú° ÎèÑÏõÄ ÏöîÏ≤≠ÌïòÍ∏∞ Ïª§ÎÆ§ÎãàÌã∞ Ìè¨Îüº Í∏ÄÎ°úÎ≤å Í∏∞Ïà† ÏßÄÏõê Ï†ÑÎ¨∏Í∞Ä ÏÑúÎπÑÏä§ Ï†ïÎ≥¥ Í≥†Í∞ù Ìè¨Ï∂òÏùò 'Í∏ÄÎ°úÎ≤å 500ÎåÄ Í∏∞ÏóÖ‚ÄôÏóêÏÑú Ï§ëÏÜåÍ∏∞ÏóÖÍπåÏßÄ, Ï†Ñ ÏÑ∏Í≥Ñ 17,000Ïó¨ Í∏∞ÏóÖÎì§Ïù¥ Îâ¥Î†êÎ¶≠ÏùÑ ÏÇ¨Ïö©ÌïòÍ≥† ÏûàÏäµÎãàÎã§. Î∏îÎ°úÍ∑∏ Îâ¥Î†êÎ¶≠Í≥º ÎîîÏßÄÌÑ∏ Ïù∏ÌÖîÎ¶¨Ï†ÑÏä§Ïùò ÏÑ∏Í≥ÑÍ∞Ä Ï†úÍ≥µÌïòÎäî ÏµúÏã† Îâ¥Ïä§, ÌåÅ Î∞è ÌÜµÏ∞∞ÏùÑ ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§. ¬†¬† Close icon Îâ¥Î†êÎ¶≠ Ï†ïÎ≥¥ ÌöåÏÇ¨ ÏÜåÍ∞ú Í≤ΩÏòÅÏßÑ Î™®ÏûÑ Î∞è Ïù¥Î≤§Ìä∏ Ï∞∏Í≥† ÏûêÎ£å ¬† Ìà¨ÏûêÏûê Ï†ïÎ≥¥ Îâ¥Ïä§Î£∏ ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ïó∞ÎùΩ Ï†ïÎ≥¥ logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞ ÏïÑÎûò¬†ÏñëÏãùÏùÑ¬†ÏÇ¨Ïö©Ìï¥¬†ÏßÄÍ∏à¬†ÎßûÏ∂§Ìòï¬†ÎùºÏù¥Î∏å¬†Îç∞Î™®Î•º¬†ÏöîÏ≤≠ÌïòÏã≠ÏãúÏò§. Í∏∞ÏóÖÏ†ïÎ≥¥ Ï±ÑÏö© Î∞è Î¨∏Ìôî ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ìà¨ÏûêÏûê Ï†ïÎ≥¥ NewRelic.org Í≥µÍ∏âÏóÖÏ≤¥ Ìè¨ÌÑ∏ Í≥†Í∞ùÎ¨∏Ïùò Ïó∞ÎùΩ Ï†ïÎ≥¥ Îç∞Î™® Ïã†Ï≤≠ÌïòÍ∏∞ Ïù¥Î≤§Ìä∏ Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏ Deutsch English Fran√ßais Êó•Êú¨Ë™û ÏÑúÎπÑÏä§ Ïù¥Ïö©ÏïΩÍ¥Ä DMCA Ï†ïÏ±Ö Í∞úÏù∏Ï†ïÎ≥¥ Ï≤òÎ¶¨Î∞©Ïπ® Ïø†ÌÇ§ Ï†ïÏ±Ö 2015ÎÖÑ ÏòÅÍµ≠ ÎÖ∏Ïòà Î∞©ÏßÄÎ≤ï ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 17.37285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request <em>Demo</em>"
      },
      "id": "5fdc3078196a679498213956"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/request-demo",
      "sections": [
        "Request a live demo.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-01-31T05:05:14Z",
      "title": "Request a New Relic Demo | New Relic",
      "updated_at": "2021-01-04T13:42:55Z",
      "type": "",
      "external_id": "3106a7a9ae5e77d7d4c56815b91f8933a4faeb1f",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Request a live demo. Use the form below to request your personalized live demo. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 13.740908,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request a New Relic <em>Demo</em> | New Relic",
        "sections": "Request a live <em>demo</em>.",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5786ed3ce621f423f2e9cf78"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-01-31T02:56:28Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.80011,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-01-31T02:57:35Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.79973,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (<em>command</em> line interface). This page explains how to use¬†<em>CLI</em> <em>commands</em>¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.11133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>command</em> followed by the same arguments you used to create them. [ { &quot;Key&quot;: &quot;tag1&quot;, &quot;Values&quot;: [&quot;true&quot;] }, { &quot;Key&quot;: &quot;tag2&quot;, &quot;Values&quot;: [&quot;test&quot;] }, { &quot;Key&quot;: &quot;tag3&quot;, &quot;Values&quot;: [&quot;testing&quot;] } &#x2F;&#x2F; ... ] Copy Next steps Have a look at all the <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>. For example, you could create a <em>New</em> <em>Relic</em>"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.82247,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and <em>configuration</em> to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " apply to any <em>CLI</em> <em>command</em>, which is useful when switching between accounts. Run the profiles add <em>command</em>: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_<em>NEW_RELIC</em>_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.46153,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 526.06024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " our other <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> docs for <em>commands</em> specific to <em>Nerdpack</em> set-up, <em>Nerdpack</em> subscriptions, <em>CLI</em> configuration, plugins, or catalogs. <em>Command</em> details nr1 help See <em>commands</em> and get details Shows all nr1 <em>commands</em> by default. To get details about a specific <em>command</em>, run nr1 help <em>COMMAND</em>_NAME. Usage"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-01-31T02:57:35Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.20146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " and publish your application, see¬†our guide on Deploying your <em>New</em> <em>Relic</em> <em>One</em> app. Get started nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (<em>Nerdpack</em>, Nerdlet, launcher, or catalog). nr1"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-01-31T02:56:28Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.5195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2021-01-31T02:21:06Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2021-01-02T01:38:56Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.75832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Live Learncast: <em>New</em> <em>Relic</em> <em>One</em> Programmability",
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of <em>New</em> <em>Relic</em> <em>One</em> Programmability. This training will introduce you to the key concepts and walk you through developing <em>New</em> <em>Relic</em> Applications.",
        "body": " A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the <em>New</em> <em>Relic</em> <em>command</em>-line interface (<em>CLI</em>) on local workstation Setting <em>New</em> <em>Relic</em> API developer access credentials"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies üç™"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2021-01-31T02:53:23Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ nerdlets ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss ‚îú‚îÄ‚îÄ node_modules ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler ‚îú‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ package-lock.json ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.50139,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> file structure",
        "sections": "<em>Nerdpack</em> file structure",
        "info": "An overview of the <em>Nerdpack</em> File Structure",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " application with a monitored entity For basic component definitions, see our component reference. Generate <em>Nerdpack</em> components There are two ways to generate a <em>Nerdpack</em> template: Generate a <em>Nerdpack</em>: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select <em>Nerdpack</em> to create a <em>Nerdpack</em> template that includes"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-01-31T02:56:28Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.85828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "Automate workflows",
      "updated_at": "2021-01-30T01:54:22Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.96179,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": ", and a <em>command</em>-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation solutions in our Developer"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-01-31T02:57:35Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.60751,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (<em>command</em> line interface). This page explains how to use¬†<em>CLI</em> <em>commands</em>¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "category_2": "Containerized private minions release notes",
      "nodeid": 41951,
      "sections": [
        "Synthetics private minion release notes",
        "Containerized private minions release notes",
        "Containerized Private Minion (CPM) 3.0.33",
        "Improvements",
        "Features"
      ],
      "title": "Containerized Private Minion (CPM) 3.0.33",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "Synthetics private minion release notes",
      "external_id": "a1ba2d8ba39c96e19c2eaa4d4f9db4e5835eb0e7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/synthetics-release-notes/containerized-private-minions-release-notes/containerized-private-minion-cpm-3033",
      "published_at": "2021-01-31T12:29:30Z",
      "updated_at": "2021-01-29T06:31:37Z",
      "breadcrumb": "Contents / Release notes / Synthetics private minion release notes / Containerized private minions release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:¬† Thursday, January 28, 2021 - 04:00 Improvements Prevent blacklisted resources from causing timeouts on Synthetics Checks Prevents long running background requests from failing a monitor if the pageLoadEvent is detected. Common examples include Google Analytics and bam.nr-data.net. Features Added functionality where $browser.waitForAndFindElement() now returns a WebElementPromise, so users can issue commands to the webElement that is returned from the promise. To update to this version, see Install and update CPM versions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.29462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "[RSS] Released on:¬† Thursday, January 28, 2021 - 04:00 Improvements Prevent blacklisted resources from causing timeouts on Synthetics Checks Prevents long running background requests from failing a monitor if the pageLoadEvent is detected. <em>Common</em> examples include Google Analytics and bam.nr"
      },
      "id": "6013abca28ccbccc141ed5a9"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.61047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": "Access the <em>New</em> <em>Relic</em> platform from the comfort of your terminal. You can use the <em>New</em> <em>Relic</em> <em>CLI</em> to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the <em>CLI</em> to automate <em>common</em> tasks in your DevOps workflow. This guide walks you through"
      },
      "id": "5efa999c196a67c4e1766461"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies üç™"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-01-31T02:56:28Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.95798,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "nerdstorage <em>components</em>",
        "body": ": AccountStorage<em>Query</em> and AccountStorage<em>Mutation</em> Entity access: EntityStorage<em>Query</em> and EntityStorage<em>Mutation</em> Each of these <em>components</em> can operate declaratively (for example, as part of your React rendering <em>methods</em>) or imperatively (by using the <em>static</em> <em>methods</em> for <em>query</em> and <em>mutation</em>). For more information"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "category_2": "API guides",
      "nodeid": 11521,
      "sections": [
        "Java agent",
        "Getting started",
        "Installation",
        "Additional installation",
        "Heroku",
        "Configuration",
        "Attributes",
        "Features",
        "Instrumentation",
        "Custom instrumentation",
        "API guides",
        "Async instrumentation",
        "Troubleshooting",
        "Guide to using the Java agent API",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples",
        "For more help"
      ],
      "title": "Guide to using the Java agent API ",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Java agent",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "external_id": "a31c751c7c29dd46effac2e568f7c0a92b033b18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "published_at": "2021-01-31T08:21:44Z",
      "updated_at": "2021-01-31T08:21:43Z",
      "breadcrumb": "Contents / APM agents / Java agent / API guides",
      "document_type": "page",
      "popularity": 1,
      "info": "A goal-focused guide to New Relic's Java agent API, with links to relevant sections of the complete API documentation on GitHub.",
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() For more on obtaining references to the current transaction and other API classes, see Obtain references. API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) For more on obtaining references to the current transaction and other API classes, see Obtain references. API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events to Insights. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the first call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.40969,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: <em>Static</em> <em>methods</em> on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "5a3137f4e621f4576cf1e35f"
    },
    {
      "category_2": "Java agent release notes",
      "nodeid": 11976,
      "sections": [
        "APM agent release notes",
        "Go agent release notes",
        "Java agent release notes",
        ".NET agent release notes",
        "Node.js agent release notes",
        "PHP agent release notes",
        "Python agent release notes",
        "Ruby agent release notes",
        "C SDK release notes",
        "Java Agent 3.36.0",
        "Improvements",
        "Fixes"
      ],
      "title": "Java Agent 3.36.0",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "APM agent release notes",
      "external_id": "f94f5c53e522a9835ea42514e90d9a39e81fd050",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360",
      "published_at": "2021-01-31T07:41:51Z",
      "updated_at": "2018-04-14T23:39:35Z",
      "breadcrumb": "Contents / Release notes / APM agent release notes / Java agent release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:¬† Wednesday, February 15, 2017 - 09:55 Download Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic‚Äôs built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 47.60558,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug"
      },
      "id": "58a53cf38e9c0f755a81db4e"
    },
    {
      "category_2": "PHP agent API",
      "nodeid": 11821,
      "sections": [
        "PHP agent",
        "Getting started",
        "Installation",
        "Advanced installation",
        "Configuration",
        "API guides",
        "PHP agent API",
        "Attributes",
        "Features",
        "Frameworks and libraries",
        "Troubleshooting",
        "newrelic_add_custom_tracer",
        "Requirements",
        "Description",
        "Parameters",
        "Return value(s)",
        "Example(s)",
        "Instrument a function",
        "Instrument a method within a class",
        "Instrument a method within a namespaced class",
        "For more help"
      ],
      "title": "newrelic_add_custom_tracer (PHP agent API)",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "PHP agent",
      "external_id": "12242c1e6fe8cb70e2d42ff670cad04c01e9317e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer",
      "published_at": "2021-01-31T07:50:37Z",
      "updated_at": "2019-09-30T22:55:59Z",
      "breadcrumb": "Contents ¬ª APM agents / PHP agent / PHP agent API",
      "document_type": "api_doc",
      "popularity": 1,
      "info": "New Relic PHP agent API call to add custom instrumentation to particular methods in your app code. ",
      "body": "newrelic_add_custom_tracer(string $function_name) Specify functions or methods for the agent to instrument with custom instrumentation. Requirements Compatible with all agent versions. Description Specify functions or methods for the agent to target for custom instrumentation. This is the API equivalent of the newrelic.transaction_tracer.custom setting. You cannot apply custom tracing to internal PHP functions. Parameters Parameter Description $function_name string Required. The name can be formatted either as function_name for procedural functions, or as \"ClassName::method\" for methods. Both static and instance methods will be instrumented if the method syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument a function function example_function() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"example_function\"); } } Instrument a method within a class class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"ExampleClass::example_method\"); } } } Instrument a method within a namespaced class namespace Foo\\Bar; class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"Foo\\\\Bar\\\\ExampleClass::example_method\"); } } } Alternatively, on PHP 5.5 or later, the ::class syntax can be used instead: namespace Foo\\Bar { class ExampleClass { function example_method() { // ... } } } namespace { use Foo\\Bar; if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(Bar::class . \"::example_method\"); } } }",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 26.037733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument a <em>method</em> within a class",
        "info": "New Relic PHP agent API call to add custom instrumentation to particular <em>methods</em> in your app code. ",
        "body": " <em>static</em> and instance <em>methods</em> will be instrumented if the <em>method</em> syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument"
      },
      "id": "58ca4191e621f45edd466e7a"
    },
    {
      "nodeid": 9691,
      "sections": [
        "Introduction to New Relic Mobile (Unity)",
        "Contents",
        "Monitor mobile app performance",
        "Install and configure",
        "Use Unity SDK API",
        "Send custom events and attributes to Insights",
        "Track custom network requests",
        "Uninstall plugin",
        "Unity release notes",
        "For more help"
      ],
      "title": "Introduction to New Relic Mobile (Unity)",
      "type": "docs",
      "external_id": "9e03a54ec6df360532302d4dfe7484070f8ba80c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/introduction-new-relic-mobile-unity",
      "published_at": "2021-01-31T13:37:09Z",
      "updated_at": "2020-07-25T00:44:01Z",
      "breadcrumb": "Contents",
      "document_type": "page",
      "popularity": 1,
      "body": "Legacy feature This document is for historical reference. Unity is no longer supported for new customers. Contents Monitor mobile app performance The New Relic Unity plugin allows Unity developers to embed a New Relic Mobile agent (iOS or Android) in a Unity app build for mobile devices to monitor your app's performance. The plugin is written in C#, but it includes the native iOS and Android agents that embed the appropriate files for your build. Features New Relic Mobile Features Comprehensive performance data View your mobile app's performance Overview page for summary information about active sessions, or drill down to detailed information, including (note limitations below): Interaction times and trace details Crash reporting Devices Operating systems Detailed network views Available by using the API to track custom network requests For iOS apps, receive automatic instrumentation for networking for any parts of the app that are native and non-Unity (using standard Apple networking components such as NSURLConnection) Examine HTTP errors and network failures (such as DNS lookups, timeouts, SSL errors, etc.) and server error traces. Usage details at a glance Compare performance between versions of your app with detailed information for memory, CPU (iOS only), interaction speed, network requests per minute, and network failures. View a monthly report with a bar chart tracking the number of devices running your app for each month over the last year. Mobile SDK API options Use the Unity API to: Create and complete interactions Record custom metrics Send custom events to Insights Track custom network requests Known limitations The New Relic Unity plugin does not automatically instrument interactions. You must use the Unity API to track specific interactions. The New Relic Unity plugin does not automatically instrument network requests. You must use the Unity API to track network calls. Android builds: Unity still generates an Eclipse project, but Android Studio can import the Eclipse project. Install and configure The Unity plugin includes iOS and Android agent files that will embed the appropriate files for your build. To instrument interactions and network requests, you must use the Unity API to manually instrument your code. Install the Unity plugin As part of the installation process, New Relic Mobile automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile project you monitor in New Relic Mobile. For Admins with existing New Relic accounts, follow these steps to install and configure your Unity application. (If you do not have a New Relic account, see New Relic Mobile.) Go to rpm.newrelic.com/mobile. From the mobile apps index, select Add a new app. From the Get started page, select Unity as the platform for mobile monitoring. Type a name for your mobile project, then select Continue. Continue with the procedures to configure the Unity plugin. Configure the Unity plugin These procedures to configure your app also appear on the Get started page in the New Relic UI. Install NewRelic-Unity-Plugin.unitypackage into your project by going to Assets > Import package > Custom package... and selecting NewRelic-Unity-Plugin.unitypackage. Create a new GameObject in your project's initial scene by going to GameObject > Create empty and naming it NewRelicAgent. Add NewRelicAgent.cs script (located in Assets/Plugins) to the NewRelicAgent GameObject: Drag it on top of NewRelicAgent in the Hierarchy tab. OR Click Add Component button, then select New Relic Agent from the Scripts option. In the Inspector tab, set the iOS or Android application token from your New Relic Mobile apps. (Recommendation: Keep New Relic Mobile apps on separate platforms.) Build for your platform (iOS or Android), then open the resulting project (Xcode or Eclipse). For Eclipse, import the generated project into Android Studio. Android only: Ensure that your app requests the INTERNET permission through the Player Settings inspector window. In Other Settings, Configuration, ensure the Internet access dropdown is set to Required. This will result in the following permission added to the app's manifest: <uses-permission android:name=\"android.permission.INTERNET\" /> Run your app in an emulator or device to generate data. Check New Relic Mobile to ensure the data is reporting to your account. Configure crash reporting The New Relic Unity plugin cannot automatically upload dSYMs for iOS crash reporting. You must manually upload dSYMs once your iOS unity app is built for release. If the application is bitcode enabled, follow the procedures for bitcode enabled apps once the your iOS app is submitted to Apple. If you are building an Android app with ProGuard enabled, you must follow similar steps. The ProGuard mapping must be uploaded to New Relic so crash reports can be de-obfuscated. For more information, see Android agent crash reporting. Optional: Change the logging level Six logging levels are available for mobile apps monitoring: NONE ERROR WARNING INFO VERBOSE DEBUG Recommendation: Set the logging level from the Unity Inspector tab. Use Unity SDK API Use the New Relic Unity SDK API to further configure and extend the plugin's instrumentation. Create and complete interactions To start an interaction: string interactionIdentifier = NewRelicAgent.StartInteractionWithName(\"new interaction\"); To stop the current interaction: NewRelicAgent.StopCurrentInteraction(interactionIdentifier); Interactions work in conjuction with method tracing. To trace a method insert startTracingMethod, insert at the start of the method to trace, and insert endTracingMethodWithTimer at each exit point of the method. To start tracing a method: Timer methodTimer = new Timer(); NewRelicAgent.StartTracingMethod(\"MethodName\",\"ClassName\",methodTimer,NewRelicAgent.NRTraceType.None); To end tracing a method, use the same timer as the startTracingMethod:> NewRelicAgent.EndTracingMethodWithTimer(methodTimer); Set a custom build identifier Custom build identifiers are set as the Application Build property in the inspector pane for the NewRelicAgent game object, under the New Relic Agent (Script) settings. Execute a demo crash If you have trouble getting your project to crash, use the New Relic Unity plugin API to execute a demo crash. Recommendation: Add this line of code to a button click event handler as applicable: NewRelicAgent.CrashNow(\"message\")> Record custom metrics With the custom metric API, you can record arbitrary numerical data and named events. Custom metrics can help to track high level events specific to your application. You can use several API calls to record custom metrics that provide different levels of detail. To create a custom metric, use this method: NewRelicAgent.RecordMetricWithName(String name, String category) The name parameter is the textual name of the metric that will appear in the user interface for New Relic Mobile. Using clear, concise metric names will help you get the most out of the metrics. The guidelines for naming a custom metric include: Use case and white space characters appropriate for display in the user interface. Metric names are rendered as-is. Capitalize the metric name. Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. If you want to specify more details about a custom metric, three other API methods are available: NewRelicAgent.RecordMetricWithName(String name, String category, double value) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits, string countUnits) With these methods, you can record additional details: Parameter Description count The number of times the event has happened totalValue The total value of the recording exclusiveValue The exclusive value of the recording; for example, if the total value contains measurements accounted for elsewhere countUnit Unit of measurement for the metric count, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS valueUnit Unit of measurement for the metric value, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS To view the custom metrics you collect, follow standard procedures to create custom dashboards. Send custom events and attributes to Insights The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following static methods in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. Methods that return boolean results return true if they succeed, or false if the operation did not complete. The following methods are available for custom attributes and events: RecordEvent (name, attributes) NewRelicAgent.RecordEvent (string name, string dictionary attributes) Records a custom Insights event. Includes a list of attributes specified as a map. SetAttribute (name, value) NewRelicAgent.SetAttribute (string name, string value) NewRelicAgent.SetAttribute (string name, double value) Creates an attribute with the specified text name and text/float value. SetAttribute overwrites its previous value and type each time it is called. Examples boolean attributeSet = NewRelicAgent.SetAttribute(\"username\", \"SampleUserName\"); boolean attributeSet = NewRelicAgent.SetAttribute(\"rate\", 9999.99); IncrementAttribute (name [, value]) public static boolean IncrementAttribute(String name); public static boolean incrementAttribute(String name, double value) If value is not specified, this method increments the count for the specified attribute by 1. If the attribute does not exist, it creates the attribute with a value of 1. If value is specified, the method will increment the attribute by the specified amount. Examples boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\"); boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\", 9999.99, false); RemoveAttribute (name) NewRelicAgent.RemoveAttribute(String name) Removes the specified attribute. Example boolean attributeRemoved = NewRelicAgent.RemoveAttribute(\"rate\"); removeAllAttributes NewRelicAgent.removeAllAttributes() Removes all attributes from the session. Example boolean attributesRemoved = NewRelicAgent.RemoveAllAttributes(); Track custom network requests New Relic Mobile's API provides several methods to track network requests and network failures. For example, use the noticeHttpTransaction family of methods to record HTTP transactions with several available levels of detail. If a network request fails, you can record details about the failure with noticeNetworkFailure. NoticeNetworkRequest NewRelicAgent.NoticeNetworkRequest (\"http://newrelic.com\", \"GET\", timer, null, 200, 1024, 8192, bytes, httpParameters); Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST statusCode The statusCode of the HTTP response, such as 200 for OK timer A timer created when the network request was started bytesSent The number of bytes sent in the request bytesReceived The number of bytes received in the response responseBody The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. params Additional parameters included in an HTTP Error metric if the HTTP transaction is an error. NoticeNetworkFailure NewRelicAgent.NoticeNetworkFailure(String url, String httpMethod, Timer timer, NewRelicAgent.NetworkFailureCode failureCode, String message) Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST timer A timer created when the network request was started exception The exception that occurred. New Relic Mobile can automatically translate many common exceptions into network failure types. failure The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Uninstall plugin To uninstall the Unity plugin, use the project console to remove all related files and resources that were installed with the Unity package: Delete NewRelicAgent object from the Hierarchy pane of the Unity project console. From All Scripts, delete all the scripts that start with newrelic. Then do the following as applicable: From Assets > Plugin > iOS, delete the NewRelicIos, NewRelicUnityPlugin, post-build, and restore-framework files. Then remove the mod_pbxproj and NewRelicAgent.framework directories. From Assets > Plugin > Android, delete the newrelic.android and NewRelicAndroid files. Then remove the LICENSE and README directories. Unity release notes These release notes are for historical reference. Unity is no longer supported for new customers. Unity plugin 1.2.0 Released on: Monday, March 13, 2017 - 13:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.2.0.zip Notes: Updated Unity plugin to iOS agent 5.9.0 and Android agent 5.9.0 Unity plugin 1.1.0 Released on: Tuesday, September 6, 2016 - 14:53 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.1.0.zip Notes: Updated Unity plugin to iOS agent 5.8.0 and Android agent 5.7.1 Unity plugin 1.0.1 Released on: Monday, August 8, 2016 - 14:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.1.zip Notes: Bundle Android class rewriter JAR file (version 5.6.1) into the Unity package. Unity plugin 1.0.0 Released on: Wednesday, May 25, 2016 - 14:00 Download URL: http://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.0.zip Notes: This plugin provides New Relic Mobile agent support for iOS and Android applications built with Unity. It also gives Unity developers access to New Relic crash reporting. It provides information about app performance, sessions, devices, operating systems, and more. It also includes APIs for custom instrumentation to gain deeper insights into specific areas of your app. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 14.9752245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following <em>static</em> <em>methods</em> in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. <em>Methods</em> that return boolean results return"
      },
      "id": "5c52cbec8e9c0f0b286080ec"
    }
  ],
  "/automate-workflows/get-started-terraform": [
    {
      "category_2": "OpenTelemetry",
      "nodeid": 41846,
      "sections": [
        "Open source telemetry integrations",
        "Get started",
        "OpenTelemetry",
        "Dropwizard",
        "Istio",
        "Kamon",
        "Micrometer",
        "OpenCensus",
        "Prometheus",
        "View your OpenTelemetry data in New Relic",
        "Explorer: Get the big picture along with the details",
        "Summary page",
        "Distributed Tracing",
        "Transactions",
        "Databases",
        "Externals",
        "Errors",
        "Metrics Explorer",
        "Data explorer and query builder",
        "For more help"
      ],
      "title": "View your OpenTelemetry data in New Relic",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Open source telemetry integrations",
      "external_id": "695e0989659ebf5535d88c532cb25b30a31155d5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/view-your-opentelemetry-data-new-relic",
      "published_at": "2021-01-31T12:43:41Z",
      "updated_at": "2021-01-31T12:43:41Z",
      "breadcrumb": "Contents / Integrations / Open source telemetry integrations / OpenTelemetry",
      "document_type": "page",
      "popularity": 1,
      "body": "After you import OpenTelemetry data into New Relic, you can use a variety of tools to analyze it. Take a look at these UI options: Explorer Data explorer and query builder Explorer: Get the big picture along with the details The New Relic explorer is a good place to get overview information about your applications, as well as detailed information, such as distributed tracing. To get started with the explorer: Open https://one.newrelic.com, and go to explorer. Using the filter bar at the top, narrow your searches: Limit results to OpenTelemetry entities with the following: After the OpenTelemetry filter, you can add another filter for your service based on the service.name attributes you've used. For example, to find CartService: Click the service you want to know more about, and if you need help understanding the data, see the explanations below. Summary page The opening page of the explorer is the Summary page listing various golden signals about your entity. Golden signals are key monitoring details such as response time, throughput, and error rate. By using this information, you can quickly decide if you need to dig deeper. Distributed Tracing When you access distributed tracing through the explorer, you are looking at traces that include that service. Once you‚Äôre in that service, you can filter spans to find the ones you want. For example, to query service.name or trace.id, you can use the following: service.name = YOUR_SERVICE_NAME trace.id = YOUR_TRACE_ID For more ways to filter and analyze your spans, see our distributed tracing UI page. If you prefer to search traces across all New Relic accounts in your organization, you can go outside explorer: https://one.newrelic.com > Apps > Favorites > Distributed tracing. Transactions Use Transactions to identify slow or error transactions that might be causing a spike in the response time of your application. From the transaction summary page, you can get a list of transactions by selecting See transactions table. Databases The Databases page shows an application's database and cache data. The page shows individual database transactions as a sortable table, and shows operations, throughput, and response time as charts. Externals Externals captures calls to out-of-process services such as web services, resources in the cloud, and other network entities. Errors On this page, you can see total errors, as well as charts showing error count and error rate. Metrics Explorer For selected OpenTelemetry languages, you can see information about your metrics in this section. Also, if you are using the Prometheus exporter with OpenTelemetry, you can view your metric data here. Data explorer and query builder Explore your metrics and traces using the data explorer, or write your own queries in query builder using NRQL. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.1984,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " of the explorer is the Summary page listing various <em>golden</em> <em>signals</em> about your entity. <em>Golden</em> <em>signals</em> are key monitoring details such as response time, throughput, and error rate. By using this information, you can quickly decide if you need to dig deeper. Distributed Tracing When you access distributed"
      },
      "id": "6016a5fd28ccbc2038077515"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:03:13Z",
      "title": "New Relic Developers",
      "updated_at": "2021-01-30T01:38:00Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 25 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.44806,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Getting started with New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Get Started with <em>Terraform</em> Get coding Create a free account 5 min Create custom events Define, visualize, and get <em>alerts</em> on the data you want using custom events Start the guide 7 min Add tags to apps Add tags"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "nodeid": 37421,
      "sections": [
        "Applied intelligence",
        "Proactive detection",
        "Incident intelligence",
        "Incident workflows",
        "Proactive Detection with Applied Intelligence",
        "Why it matters",
        "How it works",
        "Requirements",
        "Set up Proactive Detection",
        "Mute notifications (Slack only)",
        "Use Proactive Detection Slack messages",
        "View overview of anomalies",
        "Use anomaly events with NRDB",
        "Send Proactive Detection events to Incident Intelligence",
        "Webhook payload and examples",
        "Data limits",
        "For more help"
      ],
      "title": "Proactive Detection with Applied Intelligence",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "Applied intelligence",
      "external_id": "c4b5a2b1288ec80d3f45508b73d0ed3f595af064",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/proactive-detection-applied-intelligence",
      "published_at": "2021-01-31T05:07:20Z",
      "updated_at": "2021-01-31T05:07:19Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / Applied intelligence / Proactive detection",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how Proactive Detection in New Relic notifies you of unusual app behavior. Get notified in Slack or set up a custom webhook.",
      "body": "With Applied Intelligence's Proactive Detection, you can be notified of unusual app behavior and access an automatic analysis of this unusual behavior. You can have notifications for anomalies delivered in Slack, or you can set up a webhook to deliver messages when you need them. These events are automatically available in NRDB for dashboarding, alerting, and integration with Incident Intelligence. To use Proactive Detection and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With Proactive Detection, Applied Intelligence delivers insights about anomalies in your production system, along with an automatic analysis of the anomaly. When an anomaly is detected, you can view it in an overview of anomalies, or we'll send notifications directly to your Slack channel or a webhook. How it works Proactive Detection uses the following methods to detect anomalies in your app data: Proactive Detection monitors metric data reported by an APM agent, building a model of your typical application dynamics, and focuses on key golden signals: throughput, response time, and errors. If one of these golden signals shows anomalous behavior, the system flags it and tracks recovery to normal behavior. The system adapts to changes in your data, and continuously updates models based on new data. Receiving notifications: We send notifications when we detect anomalous changes in throughput, error rate, or response time. The notifications are sent to selected Slack channels, or sent via webhook. When the anomaly goes back to normal, a recovery message is sent. If you don't want to receive notifications, you can choose to just save the events to NRDB. Anomaly analysis: For each anomaly, we provide a link in Slack to an analyze anomaly page. This page generates automatic insights into the anomaly. The page is also available from the anomalies tab, which lists recent anomalies. This page uses your existing APM and Proactive Detection data to provide explanations as to the cause of the anomaly. Activity stream: Inside the activity stream on the New Relic One homepage and the APM Summary page you will see relevant anomalies for applications that you've configured with Proactive Detection. Clicking on any of the anomaly events in the activity stream will bring up the analysis page for that anomaly. Applications will not always generate anomalies, so it can be normal to not receive any detections. Requirements To use Proactive Detection, ensure you have: An APM agent installed on applications to monitor To receive notifications in Slack, you'll need to ask your IT administrator to install the Applied Intelligence application into your Slack workspace. For more details, see Data limits. Set up Proactive Detection You can configure this feature in the Proactive Detection UI: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Proactive Detection to go to Configuration. Click Add a configuration. Input the following information into the form: Choose a name for your configuration that helps you easily identify it from others in your account. Select an account. Select up to 1,000 applications. Note that certain applications with low throughput might not be good candidates for Proactive Detection, as they can be more sensitive to smaller amounts of data fluctuation. Select the golden signals you would like to monitor for anomalies. Set up for Slack To use Proactive Detection with Slack: Select Slack. Choose which Slack channel receives notifications. You can select any existing public or private channel. This prompts the workflow to add the Applied Intelligence Slack application to your selected channel. To create a new channel, do that directly in Slack first. If you experience an error when assigning Slack channels, make sure that the New Relic AI Slack application has been added to your Slack workspace. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Set up for webhooks To use Proactive Detection with webhooks: Select Webhook. Input the following information into the form: Provide the webhook URL. Provide optional custom headers. Choose to edit the custom payload, or enable using the default payload. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Set up without notifications To use Proactive Detection when you don't need to receive notifications: Select No notifications. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Mute notifications (Slack only) In Slack, detections coming from specific applications can be muted temporarily or permanently. The entire channel can also be muted temporarily. This is useful in the case of an incident or when the channel should otherwise not be interrupted. To mute in Slack, select Mute this app‚Äôs warnings or Mute all warnings, then select the duration. We will resume sending notifications for any detections once the muting duration has completed. Muting an application permanently removes it from the configuration. To add it back in, go to one.newrelic.com, in the top nav click Alerts & AI, then click Proactive Detection, and select the configuration to edit. Muting Proactive Detection notifications does not affect alerts. Use Proactive Detection Slack messages Each anomaly message has several key pieces of information you can use to learn more about and start troubleshooting the potential issue: The application name and a link to more information about it in New Relic One. The metric experiencing an anomaly and a link to its details in New Relic One. A graph of the metric over time to provide a visual understanding of the anomaly‚Äôs behavior and degree. An Analyze button that navigates to an analysis page in Applied Intelligence that identifies key attributes that are unique to the anomaly, anomalies found upstream or downstream, and any other relevant signals. Once an anomaly has returned to normal, we send a recovery notification with the option to provide feedback. Your feedback provides our development team with input to help us improve detection quality. In the case of feedback provided on throughput anomalies, an evaluation is run each hour based on feedback to fit a more suitable model. If we helped you, you can select Yes or No. View overview of anomalies In addition to notifications for anomalies that give you information via Slack or webhook, you can view more information about the anomalies in your environment via the Anomalies tab on the Alerts & AI Overview page. That tab provides a list of all the recent anomalies from every configuration in the selected account, and you can select an anomaly for a detailed analysis. Use anomaly events with NRDB Once you configure Proactive Detection, anomaly events will be sent to New Relic‚Äôs database (NRDB). You can query NRDB for Proactive Detection anomaly events and use them in conjunction with other Applied Intelligence tools. Query for Proactive Detection events from NRDB You can use NRQL to query NRDB for any Proactive Detection events recorded over the previous 7 days: FROM ProactiveDetection SELECT * Attribute Description anomaly.deliveredAt Number The time at which the anomaly event was initially recorded, in epoch milliseconds. Example: 1584366819000 anomaly.description String A brief description of the anomaly event. Example: Non-web throughput has returned to normal anomaly.endedAt String The time at which the anomalous period ended, in epoch milliseconds. Example: 1584366819000 anomaly.startedAt Number The time at which the anomalous period began, in epoch milliseconds. Example: 1584366819000 anomaly.type The type of data that was analyzed, including error_rate, response_time.web, response_time.non_web, throughput.web, or throughput.non_web. anomaly.status The state of the anomaly as the NRDB event is inserted, including open or close. anomaly.uuid A unique identifier for the NRDB anomaly event. Example: 4ee3b908-d323-4677-94c8-339762c931bc anomaly.id ID of the anomaly associated with the event. Example: 56341b5608bf68e1 entity.accountId Number The ID of the account for the entity. entity.domain Enum The domain for the entity. Example: APM entity.domainId String The id used to uniquely identify the entity within the domain. entity.guid String The guid used to uniquely identify the entity across all products. entity.name String The name of the entity. Example: Laura's coffee service Send Proactive Detection events to Incident Intelligence You can send Proactive Detection events to Incident Intelligence to be processed and correlated with other activity in your system: Create an alert condition for your NRQL query that pulls proactive detection events from NRDB. Configure a new incident intelligence source for your condition. (Optional) Create Decision logic to correlate future anomalies with related events. Webhook payload and examples Proactive Detection sends the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Proactive Detection, use these examples of the webhook body format and JSON schema. Attribute Description category Enum The category of data that was analyzed. Categories include web throughput, non-web throughput, web transactions, non-web transactions, and error class. data List The time series data leading up to the detection. data[].timestamp Number The timestamp of the data point in epoch milliseconds. Example: 1584366819000 data[].unit String The unit describing the value of the data point. Data units include count, milliseconds, and error_rate. data[].value Number The value of the data point. Example: 1.52 detectionType Enum The type of data that was analyzed. Types include latency, throughput, and error_rate. entity Object The entity that reported the unusual data. entity.accountId Number The ID for the entity's account. entity.domain Enum The domain for the entity. Example: APM entity.domainId String The id used to uniquely identify the entity within the domain. entity.guid String The guid used to uniquely identify the entity across all products. entity.name String The name of the entity. Example: Laura‚Äôs coffee service entity.link String A link to view the entity. Example: https://rpm.newrelic.com/accounts/YOUR_ACCOUNT_ID/applications/987654321‚Äù severity Enum A description of how unusual of a change occurred, including NORMAL, WARNING, or CRITICAL. version String Version used to describe the data being provided. Example: v1 JSON schema example Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). Template: { \"version\": \"{{version}}\", \"entity\": { \"type\": \"{{entity.type}}\", \"name\": \"{{entity.name}}\", \"link\": \"{{entity.link}}\", \"entityGuid\": \"{{entity.entityGuid}}\", \"domainId\": \"{{entity.domainId}}\", \"domain\": \"{{entity.domain}}\", \"accountId\": {{entity.accountId}} }, \"detectionType\": \"{{detectionType}}\", \"category\": \"{{category}}\", \"data\": [{{#each data}} { \"value\": {{value}}, \"unit\": \"{{unit}}\", \"timestamp\": {{timestamp}} } {{#unless @last}},{{/unless}} {{/each}}] } Sample payload: { \"version\": \"v1\", \"entity\": { \"type\": \"APPLICATION\", \"name\": \"My Application\", \"link\": \"https://rpm.newrelic.com/accounts/ACCOUNT_ID/applications/123\", \"entityGuid\": \"foo\", \"domainId\": \"123\", \"domain\": \"APM\", \"accountId\": YOUR_ACCOUNT_ID }, \"detectionType\": \"metric\", \"category\": \"web throughput\", \"severity\": \"CRITICAL\", \"data\": [ { \"value\": 100, \"unit\": \"count\", \"timestamp\": 1584047560917 } , { \"value\": 99, \"unit\": \"count\", \"timestamp\": 1584047620917 } , { \"value\": 0, \"unit\": \"count\", \"timestamp\": 1584047680917 } ] } Data limits In addition to requirements, data limits include: APM app transactions per month: up to 100 million included free Monitored APM applications: limited to 1,000 per configuration Slack configurations: limited to 200 per account Webhook configurations: limited to 200 per account Configurations without notifications: limited to 200 per account For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.06299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Mute <em>notifications</em> (Slack only)",
        "info": "Learn how Proactive Detection in New Relic <em>notifies</em> you of unusual app behavior. Get <em>notified</em> in Slack or set up a custom webhook.",
        "category_0": "<em>Alerts</em> and Applied Intelligence",
        "body": ", and focuses on key <em>golden</em> <em>signals</em>: throughput, response time, and errors. If one of these <em>golden</em> <em>signals</em> shows anomalous behavior, the system flags it and tracks recovery to normal behavior. The system adapts to changes in your data, and continuously updates models based on new data. Receiving",
        "breadcrumb": "Contents &#x2F; <em>Alerts</em> and Applied Intelligence &#x2F; Applied intelligence &#x2F; Proactive detection"
      },
      "id": "5f344fad196a6775d3fbd704"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "Automate workflows",
      "updated_at": "2021-01-30T01:54:22Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.190186,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Getting started with New Relic and <em>Terraform</em>",
        "body": "When building today&#x27;s complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including <em>Terraform</em>, AWS CloudFormation"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "image": "https://newrelic.com/content/dam/hercules-qa/platform_appliedintelligence_experience_july2020.png",
      "url": "https://newrelic.com/platform/applied-intelligence",
      "sections": [
        "Applied Intelligence",
        "Applied Intelligence includes:",
        "Proactive Detection",
        "Incident Intelligence",
        "Faster to connect, faster to value",
        "Automatic anomaly detection",
        "See all anomalies in one place with access to deeper analysis",
        "Correlate incidents to reduce alert noise and fatigue",
        "Correlate incidents with your own decision logic",
        "Get transparency into why incidents are correlated",
        "Diagnose and respond faster with incident intelligence",
        "Escalate incidents to the right responders faster",
        "No changes to your existing incident response workflow",
        "Experience Applied Intelligence",
        "Free access to New Relic. Forever.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-01-31T02:49:54Z",
      "title": "New Relic AI | New Relic",
      "updated_at": "2021-01-04T01:41:53Z",
      "type": "",
      "external_id": "a5a1b6dba51c420ad389a483c040bd729518a2f4",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Applied Intelligence Detect, understand, and resolve incidents faster with the easiest-to-use, most powerful AIOps capabilities that reduce alert noise and find insights in the data that would go unnoticed without machine learning. Sign up for free Applied Intelligence includes: Proactive Detection Detect anomalies before they become incidents. Automatically receive real-time failure warnings delivered straight to the tools where you already work, including your Slack channels. Learn more about what you get with Proactive Detection. ¬† Incident Intelligence Reduce alert fatigue and prioritize the issues that matter most. With a powerful correlation engine that makes alerts more meaningful and actionable, you can fix issues faster and with more confidence. Learn more about what you get with Incident Intelligence. Faster to connect, faster to value Connect the tools you already use with our simple configuration UI, webhooks and APIs, including Slack, PagerDuty, Splunk, Grafana, Prometheus and Amazon CloudWatch. Or you can integrate with your incident management tools of choice. Ingest alerts, incidents and event data from any source, and you'll start seeing the benefits of anomaly detection and automatic noise reduction right away. Automatic anomaly detection Get notified about potential problems in your tools of choice before they turn into incidents. Applied Intelligence proactively monitors your services for anomalies based on SRE golden signals‚Äîsuch as latency, errors, and traffic‚Äîand notifies you with real-time failure warnings and actionable details so you can investigate faster. See all anomalies in one place with access to deeper analysis Visualize and troubleshoot all anomalies across your environment from a single page, with the ability to instantly view critical details for each one. Anomaly analysis includes key attributes that caused spikes, related signals to investigate root cause by looking at what happened around the anomaly, and visibility into upstream and downstream dependencies. Correlate incidents to reduce alert noise and fatigue Automatically group and prioritize your alerts and incident data to decrease noise and focus on what matters most. Applied Intelligence establishes relationships between incidents and includes flapping detection and smart suppression to reduce noise from low-priority alerts by as much as 90 percent. Correlate incidents with your own decision logic Build and gauge the impact of your own correlation logic with an intuitive decision builder that makes it simple to tell New Relic AI what data to compare and correlate, then previews its potential impact. You can create logic based on any event attribute, adjust frequency and duration thresholds, and even choose out-of-the-box similarity algorithms, so you get full flexibility and control. Get transparency into why incidents are correlated AIOps tools shouldn‚Äôt be a black box. Applied Intelligence provides full transparency into why and how issues are correlated, so you have confidence in the ML models that reduce noise while ensuring that critical signals don‚Äôt go unnoticed. Diagnose and respond faster with incident intelligence Applied Intelligence enriches correlated incidents with deeper context and metadata, so you can understand the issue and take action to resolve it. Alerts are automatically classified based on golden signals and related components of your environments are identified, so you can quickly determine the probable cause and isolate the source of the problem. Escalate incidents to the right responders faster Route correlated incidents to the team members best equipped to respond and make noisy, misdirected alerts a thing of the past. Applied Intelligence suggests responders based on your data, and gives you the flexibility to easily determine where and how you send issues to your teams. ¬† No changes to your existing incident response workflow Connect your incident management tools as destinations quickly and easily. Applied Intelligence delivers correlated, enriched incidents into tools like PagerDuty, OpsGenie, ServiceNow, and more, so you don‚Äôt need to reinvent your on-call workflow. ¬† Experience Applied Intelligence Applied Intelligence delivers guidance and analysis that makes it faster and easier than ever to detect, understand and resolve incidents. Free access to New Relic. Forever. Monitoring your stack should never include host-based guessing games or hidden costs‚Äîjust simple pricing with no surprises. Sign up now Customers trust New Relic. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.039185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Correlate incidents to reduce <em>alert</em> noise and fatigue",
        "body": " and metadata, so you can understand the issue and take action to resolve it. <em>Alerts</em> are automatically classified based on <em>golden</em> <em>signals</em> and related components of your environments are identified, so you can quickly determine the probable cause and isolate the source of the problem. Escalate"
      },
      "id": "5f2275e8196a6707f7b53d24"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/1qf2g217c4q7m/promo-image.1608575584.png",
      "url": "https://learn.newrelic.com/getting-started-with-dashboards-nrql",
      "sections": [
        "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations.",
        "About this workshop"
      ],
      "published_at": "2021-01-31T02:20:02Z",
      "title": "Getting started with Dashboards & NRQL",
      "updated_at": "2021-01-31T02:18:49Z",
      "type": "",
      "external_id": "20be8b6c5a3882e951f9dfd70354ea7ceaa38c7c",
      "popularity": 1,
      "body": "Sign In Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. Register | FREE Already registered? Sign In About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.¬† These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.¬† Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.¬†¬† In this hands-on session, you‚Äôll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.¬† Using a sandbox account you‚Äôll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.¬† You‚Äôll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.¬† Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL Feb. 9, 2021, noon - Feb. 9, 2021, 2 p.m. PST 82 Getting started with Dashboards & NRQL Feb. 16, 2021, 1 p.m. - Feb. 16, 2021, 3 p.m. GMT 111 About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.¬† These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.¬† Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.¬†¬† In this hands-on session, you‚Äôll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.¬† Using a sandbox account you‚Äôll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.¬† You‚Äôll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.¬† Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Live events Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL Feb. 9, 2021, noon - Feb. 9, 2021, 2 p.m. PST 82 Getting started with Dashboards & NRQL Feb. 16, 2021, 1 p.m. - Feb. 16, 2021, 3 p.m. GMT 111 ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.69963,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with Dashboards &amp; <em>NRQL</em>",
        "sections": "Learn to use the <em>Data</em> Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of <em>NRQL</em>. Progress to working directly with <em>NRQL</em> to create a wider range of charts and visualizations.",
        "body": " you‚Äôll get familiar with <em>NRQL</em> <em>syntax</em>, work with the Query Builder to build your own queries and charts, and create <em>data</em> rich dashboards.¬† You‚Äôll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and <em>data</em>"
      },
      "id": "5fe29f8528ccbcf532f15668"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Create NRQL alert conditions",
        "Create a NRQL alert condition",
        "NRQL alert syntax",
        "NRQL alert threshold examples",
        "Nested aggregation NRQL alerts",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Evaluation offset",
        "Fill data gaps",
        "How to edit data gap values:",
        "Gap filling options:",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2021-01-31T14:34:38Z",
      "updated_at": "2021-01-31T14:34:38Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions, but not baseline or static Include an optional FACET clause in your NRQL syntax depending on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ‚Äã‚Äã‚Äã‚Äã‚Äã Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)‚Äã‚Äã Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. The default streaming aggregation window duration is 1 minute. The minimum aggregation window is 30 seconds. The maximum is 15 minutes. Baseline thresholds don't support configurable aggregation window durations. They use the 1 minute default. You can adjust the evaluation offset to coordinate the streaming algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. If your data is sporadic or has aggregation windows that may not have data, you can fill those gaps with a custom value or the last known value. The default value is None. To learn more about gap filling and how to request access to it, see this announcement Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you can't use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Evaluation offset For data that consistently takes longer to arrive, you can use offset evaluation to consistently delay the NRQL condition evaluation. Waiting longer increases accuracy, but also increases latency. The aggregation window and offset evaluation toggles let you choose how to handle gaps in your streaming alerts data. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the event type data comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with None, the last value received, or a static value. How to edit data gap values: In the NRQL conditions UI under Condition settings > Advanced signal settings > fill data gaps with, and then choose None, Last known value, or Custom static value. In the Nerdgraph API (preferred), you'll find this node located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue In the REST API Explorer, you'll see this under the \"signal\" section of the Alert NRQL conditions API. Gap filling options: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.81503,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> alert conditions",
        "sections": "<em>NRQL</em> alert <em>syntax</em>",
        "info": "How to define thresholds that trigger alert notifications based on your <em>NRQL</em> queries.",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;alerts-applied-intelligence&#x2F;new-relic-alerts&#x2F;alert-conditions&#x2F;create-<em>nrql</em>-alert-conditions",
        "body": ". <em>NRQL</em> alert <em>syntax</em> Here&#x27;s the basic <em>syntax</em> for creating all <em>NRQL</em> alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2021-01-31T04:06:56Z",
      "updated_at": "2021-01-23T15:02:43Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.5285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for custom event <em>data</em>",
        "sections": "Event <em>data</em> sources",
        "category_1": "Event <em>data</em> sources",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;insights-<em>data</em>-sources&#x2F;custom-<em>data</em>&#x2F;insights-custom-<em>data</em>-requirements-limits",
        "body": " may apply based on the method you use. General requirements When reporting custom events and attributes, follow these general requirements for supported <em>data</em> types, naming <em>syntax</em>, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Event <em>data</em> sources &#x2F; Custom events"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    },
    {
      "nodeid": 41296,
      "sections": [
        "Recent Announcements",
        "Build high-resolution charts using sliding windows"
      ],
      "title": "Build high-resolution charts using sliding windows",
      "type": "docs",
      "external_id": "8e7ed7ec7cfcd89b4c88c66f2c07a42f8ea90f94",
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/build-high-resolution-charts-using-sliding-windows",
      "published_at": "2021-01-31T12:55:36Z",
      "updated_at": "2020-11-03T19:18:50Z",
      "breadcrumb": "Contents / What's New",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "Sliding windows enable you to increase chart resolution without losing the intent of the result by reducing the timeseries aggregate size, as shown below. Highly variable results can also be smoothed out by increasing the aggregate size, without losing resolution. Sliding windows generate charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. The first duration associated with TIMESERIES defines the size of the aggregation windows, which defines how many results are captured per window. The second duration associated with SLIDE BY, defines the step size between each aggregation, which then defines the charts resolution. NRQL syntax follows the following format: SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units PromQL-style queries are translated into NRQL sliding window queries. For example, rate(request_count[5m]) over the past 60 minutes with a 1-minute window overlap would be translated into the NRQL query below: SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.51187,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". The second duration associated with SLIDE BY, defines the step size between each aggregation, which then defines the charts resolution. <em>NRQL</em> <em>syntax</em> follows the following format: SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units PromQL-style queries are translated into <em>NRQL</em> sliding window"
      },
      "id": "5fa1ad1ae7b9d219479de187"
    },
    {
      "category_2": "Get started",
      "nodeid": 11431,
      "sections": [
        "NRQL: New Relic Query Language",
        "Get started",
        "NRQL query tools",
        "NRQL query tutorials",
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Start using NRQL",
        "NRQL query examples",
        "NRQL syntax",
        "For more help"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "NRQL: New Relic Query Language",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "external_id": "d44be2c7df7addda8679b4c842015223cfcbd1a3",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "published_at": "2021-01-31T08:02:01Z",
      "updated_at": "2020-09-24T08:40:20Z",
      "breadcrumb": "Contents / Query your data / NRQL: New Relic Query Language / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to New Relic Query Language (NRQL) and how to use it.",
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder: Advanced mode is a NRQL query interface Basic mode provides a simplified query experience that doesn't require knowledge of NRQL but that uses NRQL to generate results New Relic Insights NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in both New Relic One and New Relic Insights. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction New Relic Browser events, like PageView New Relic Mobile events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, Browser, and Mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. To explore your data without having to use NRQL, use the basic mode of New Relic One query builder. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by New Relic APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of Browser data Here's a NRQL query of PageView data, which is reported by New Relic Browser. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and Browser events over the last three days:‚Äã SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... This query returns the minimum, average, and maximum duration for New Relic Browser PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 71.96573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, New Relic&#x27;s query language",
        "sections": "What <em>data</em> can you query with <em>NRQL</em>?",
        "info": "An introduction to New Relic Query Language (<em>NRQL</em>) and how to use it.",
        "category_0": "Query your <em>data</em>",
        "category_1": "<em>NRQL</em>: New Relic Query Language",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;query-your-<em>data</em>&#x2F;<em>nrql</em>-new-relic-query-language&#x2F;get-started&#x2F;introduction-<em>nrql</em>-new-relics-query-language",
        "body": "One way to query your New Relic <em>data</em> is with the New Relic Query Language (<em>NRQL</em>). This resource explains what <em>NRQL</em> is, when and how you can use it, and basic <em>syntax</em> rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see <em>NRQL</em> <em>syntax</em>",
        "breadcrumb": "Contents &#x2F; Query your <em>data</em> &#x2F; <em>NRQL</em>: New Relic Query Language &#x2F; Get started"
      },
      "id": "5f2abd47196a67747343fbe1"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "category_2": "Intro to APIs",
      "nodeid": 2151,
      "sections": [
        "Get started",
        "Intro to APIs",
        "Types of New Relic API keys",
        "Manage API keys in UI",
        "Overview of API keys",
        "User key",
        "License key",
        "Browser key",
        "REST API key",
        "Insights insert key",
        "Insights query key",
        "Admin key",
        "For more help"
      ],
      "title": "Types of New Relic API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "external_id": "7642ec789132dd9f20604844a8d6aad2a12baa59",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/types-new-relic-api-keys",
      "published_at": "2021-01-31T06:49:51Z",
      "updated_at": "2021-01-31T06:49:51Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Types of New Relic API keys, who can use them, and how to add, update, or delete API keys.",
      "body": "New Relic has several different APIs that each require their own type of API key to use. This resource describes our API keys, what they're used for, and how to access them. Manage API keys in UI Here's a direct link to the API keys UI page. To find this from the New Relic UI: From the account dropdown, select Account settings. Select API keys. Overview of API keys The table below summarizes our available API keys and their uses. Some keys are able to be used by more than one API. If you're using a specific API, see the docs for that API to understand which keys are required and recommended. Key type What it's for Where to access User key (aka \"personal API key\") Used for NerdGraph (our GraphQL API) and for accessing REST API endpoints (dependent on user permissions). API keys UI License key Allows ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. API keys UI Insights insert key (aka \"Insert key\") Allows ingestion of events via HTTPS request from our metric, log, trace, and event APIs and the tools that use those APIs. Go to the API keys UI and click Insights insert key. Browser key Allows ingestion of browser monitoring data. API keys UI Mobile key (aka \"mobile app token\") Allows mobile monitoring data to be sent to New Relic. See Mobile app token. REST API key Note: we recommend using the user key instead because it has fewer limitations. The REST API key is for using our REST APIs for Alerts, APM, Browser, Infrastructure alerts, as well as Mobile REST APIs and the API Explorer. Go to the API keys UI and click REST API key. Admin API key As of December 4, 2020, all existing admin keys have been migrated to be user keys. For more information, see Admin key and User key below. API keys UI (will appear as user keys) Insights query key (aka \"Query key\") This key allows use of the Insights query API. Note: we now recommend using NerdGraph to query New Relic data. Go to the API keys UI and click Insights query key. User key New Relic user keys (previously referred to as \"personal API keys\") are required for NerdGraph (our GraphQL API), which allows you to query most New Relic data and do some types of configuration. User keys also let you use our REST API, with restrictions based on your permissions. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a user key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select User. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a user key Go to the API keys UI. In the row of the user key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a user key Go to the API keys UI. In the row of the user key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. In December 2020, user keys supplanted Admin API keys. For details, see Admin API key. License key New Relic license keys allow the ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. If you're using a specific API, see the docs for that API to understand which keys are required or recommended. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a license key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select License. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a license key Go to the API keys UI. In the row of the license key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a license API key Go to the API keys UI. In the row of the license key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Browser key The browser key allows the ingestion of data from New Relic browser monitoring. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a browser key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select Browser. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a browser key Go to the API keys UI. In the row of the browser API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a browser key Go to the API keys UI. In the row of the browser API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. REST API key We recommend using a user key to use the REST API because that key has fewer limitations. You can use a REST API key with our REST API and the API Explorer. For parent accounts with sub-accounts, each sub-account must use its own REST API key. Availability: Each New Relic account can have only one REST API key. Activate or change REST API key Go to the API keys UI and select REST API key. Click Regenerate REST API key. Click (Show key) to view your account's new REST API key. Copy your account's REST API key to use with New Relic's REST API. View REST API keys To view REST API keys: Go to the API keys UI and select REST API key. Click (Show key) to view your account's new REST API key. Delete REST API key To delete your account's REST API key: Before you delete an API key, make sure you have the correct account or sub-account. Go to the API keys UI and select REST API key. Select the delete [trash can icon] icon for the REST API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Insights insert key The Insights insert key (aka the \"Insert key\") is required for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. Generate an Insights insert key Go to the API keys UI and select Insights insert keys. Next to the Insert keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights insert key Go to the API keys UI and select Insights insert keys. Under Insert Keys, find the key you want to modify. Select Edit or Delete. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. Generate an Insights query key You must have access to the UIs you plan to query and the correct permissions in order to register or modify this key. Insights query keys are generated per account; they're not associated with a specific user. This means that any user in an account with access to a query key can use it. To register this key: Go to the API keys UI and select Insights query keys. Next to the Query Keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights query key To edit or delete this key: Go to the API keys UI page and select Insights query keys. Under Query Keys, find the key you want to modify. Select Edit or Delete. Admin key As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don‚Äôt need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says ‚ÄúMigrated from an admin user key‚Äù in the key table, so you‚Äôll be able to find them easily. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.41245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Types of <em>New</em> <em>Relic</em> <em>API</em> <em>keys</em>",
        "sections": "Types of <em>New</em> <em>Relic</em> <em>API</em> <em>keys</em>",
        "info": "Types of <em>New</em> <em>Relic</em> <em>API</em> <em>keys</em>, who can use them, and how to add, update, or delete <em>API</em> <em>keys</em>.",
        "category_0": "<em>APIs</em>",
        "category_2": "Intro to <em>APIs</em>",
        "body": " a REST <em>API</em> <em>key</em> with our REST <em>API</em> and the <em>API</em> Explorer. For parent accounts with sub-accounts, each sub-<em>account</em> must use its own REST <em>API</em> <em>key</em>. Availability: Each <em>New</em> <em>Relic</em> <em>account</em> can have only <em>one</em> REST <em>API</em> <em>key</em>. Activate or change REST <em>API</em> <em>key</em> Go to the <em>API</em> keys UI and select REST <em>API</em> <em>key</em>. Click"
      },
      "id": "5d7485b128ccbc1b5c32ad31"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-01-31T02:57:35Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.08026,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (command line interface). This page explains how to use¬†<em>CLI</em> commands¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.95221,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " apply to any <em>CLI</em> command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial <em>account</em> for the US region $ newrelic profiles add -n tutorial --<em>apiKey</em> YOUR_<em>NEW_RELIC_USER_KEY</em> -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.71007,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " of your entities. Before you begin For this guide you need a <em>New</em> <em>Relic</em> user <em>key</em>: You can view and create them in the <em>API</em> keys UI. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "category_2": "Monitor examples",
      "nodeid": 8911,
      "sections": [
        "Synthetics REST API",
        "Monitor examples",
        "Label examples",
        "Secure credentials examples",
        "Manage synthetic monitors via REST API",
        "Features",
        "Monitor types in API",
        "Use the API",
        "Script API for scripted browser and API test monitors",
        "Scripted browser example",
        "For more help"
      ],
      "title": "Manage synthetic monitors via REST API",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Synthetics REST API",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/apis/synthetics-rest-api/monitor-examples/manage-synthetics-monitors-rest-api",
      "external_id": "51661d38d4f7bc96718e58bd02f9e71162a0e5a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/manage-synthetics-monitors-rest-api",
      "published_at": "2021-01-31T14:15:59Z",
      "updated_at": "2021-01-24T00:15:06Z",
      "breadcrumb": "Contents / APIs / Synthetics REST API / Monitor examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use the New Relic Synthetics REST API to create, delete, and manage monitors.",
      "body": "Use the Synthetics REST API to create and manage synthetic monitors of all types: ping, simple browser, scripted browser, and API test monitors. All synthetic monitoring data is available via the REST API. To use the Synthetics REST API, you must have a user role that allows that capability and a user key. For an overview of all available New Relic APIs, see Intro to APIs. Features The newest version of the Synthetics API (v3) adds these features: Synthetics API (v3) Features Options field for POST and PUT request You can specify the options for SIMPLE and BROWSER type monitors, similar to the way these options are available in the UI. PATCH request You can update only the fields of a monitor you want to change, rather than having to specify the entire monitor entity in a PUT. You can also specify the OPTION, assuming you are using the appropriate type of monitor. More detail with 400 Bad Request errors As of v3, the Synthetics API attempts to return as much information as possible when a validation failure occurs. This will help you figure out what might be wrong with the request. The API runs all validations and returns any failed validation messages, rather than failing on the first validation error as occurred in previous API versions. Pagination Large API responses are properly paginated. You can also use NRQL queries to analyze past changes made via the API. Monitor types in API These are the monitor types and how they're referred to in the API: Monitor type API name Ping SIMPLE Simple browser BROWSER Scripted browser SCRIPT_BROWSER API test SCRIPT_API Use the API To use the Synthetics REST API, you must have the ability to manage synthetics monitors and use a user key (the REST API key won't work). This API can be used for all Synthetics monitors. (Additional API methods for scripted browser and API test monitors are also available to update the script associated with those monitors.) All Synthetics data is available via the API. API examples show cURL commands. For US-based accounts, use the following endpoint: https://synthetics.newrelic.com/synthetics/api For EU-based accounts, use the following endpoint: https://synthetics.eu.newrelic.com/synthetics/api The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Get all monitors To view a list of all the monitors in your New Relic account, send a GET request to $API_ENDPOINT/v3/monitors. For example: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"monitors\": [ { \"id\": \"2a1bc369-7654-489d-918e-f6g135h7i2jk\", \"name\": \"monitor1\", \"type\": \"BROWSER\", \"frequency\": 60, \"uri\": \"http://example.com\", \"locations\": [ \"AWS_US_WEST_1\" ], \"status\": \"DISABLED\", \"slaThreshold\": 7, \"options\": {}, \"modifiedAt\": \"2016-09-26T23:12:46.981+0000\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"userId\": 0, \"apiVersion\": \"0.2.2\" } ], \"count\": 1 } Query arguments: offset: The monitor count offset. Defaults to 0. For example, if you have 40 monitors and you use an offset value of 20, it will return monitors 21-40. limit: The number of results per page, maximum 100. Defaults to 20. You can include these in your cURL command as follows: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors \\ -G -d 'offset=20&limit=100' The headers include a Link to help you easily page your monitors. For example: <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=0&limit=20>; rel=\"first\", <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=40&limit=20>; rel=\"last\" Get a specific monitor To view a single Synthetics monitor, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } An invalid monitor ID will return 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your Synthetics account, send a POST request to $API_ENDPOINT/v3/monitors with a JSON payload that describes the monitor. All fields in the following example are required unless stated otherwise: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, \"options\": { \"validationString\": string [only valid for SIMPLE and BROWSER types], \"verifySSL\": boolean (true, false) [only valid for SIMPLE and BROWSER types], \"bypassHEADRequest\": boolean (true, false) [only valid for SIMPLE types], \"treatRedirectAsFailure\": boolean (true, false) [only valid for SIMPLE types] } } In addition, to add the script for a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Replace the Synthetics REST API attributes in the following example with your specific values: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\", \"status\" : \"enabled\", \"slaThreshold\" : \"1.0\"}' A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example: the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. All fields are required. However, the TYPE of the monitor cannot be changed. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\", \"type\": \"monitor type\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Patch an existing monitor To patch an existing monitor in New Relic, send a PATCH request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PATCH -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\" }' PATCH requests are intended to update individual attributes of your New Relic Synthetics monitor rather than updating the entire entity, so you may provide only the attributes you want to update. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds, or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic Synthetics, send a DELETE request to $API_ENDPOINT/v3/monitors/$MONITOR_ID: curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE $API_ENDPOINT/v3/monitors/$MONITOR_ID A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response 404 Not Found: The specified monitor does not exist. Get a list of valid locations To retrieve the list of valid locations in New Relic Synthetics, use the following command: curl -v \\ -X GET -H 'Api-Key:$API_KEY' $API_ENDPOINT/v1/locations Script API for scripted browser and API test monitors In addition to the general API, there are several API methods for the scripted Browsers (SCRIPT_BROWSER) and API test browsers (SCRIPT_API). These examples show cURL commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script. For example: curl -v -H 'Api-Key: $API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID/script A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic Synthetics with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the $MONITOR_UUID/script endpoint. For more information, refer to the example. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script with a JSON payload that contains the scriptText (required). scriptPayload='{\"scriptText\":BASE64 encoded string}' curl -v -X PUT \\ -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' \\ $API_ENDPOINT/v3/monitors/$MONITOR_UUID/script \\ -d $scriptPayload If you are using private locations with verified script execution enabled, see script locations with verified script execution. A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Using private location scripts with verified script execution When creating or updating monitors for private locations that have verified script execution turned on, you must use scriptLocations to set the password: { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } The password used to generate the HMAC string must match the password set for the private location. If you have multiple locations with Verified script execution enabled each location must have the HMAC calculated. When generating the HMAC string, use the SHA256 algorithm with the script and password. Here's an example for the script: var assert = require('assert'); assert.equal('1', '1'); This example uses password as the password for the scriptLocation: curl -v -X PUT -H 'Api-Key: '$API_KEY' -H 'content-type: application/json' $API_ENDPOINT}/v3/monitors/$MONITOR_ID/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4ZQ==\"} ]}' You must remove the last newline character from both the script and the calculated HMAC value before encoding in BASE64. Calculation steps: Calculate the HMAC value from the script. One way is to use: cat script | openssl dgst -sha256 -hmac \"password\" > hmac Remove the newline character if one was added by openssl. Encode the HMAC in BASE64 without line breaks. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows cURL commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Bash script example This example shows the bash script that will create the SCRIPTED_BROWSER monitor. In some cases you may want to use -w 0, which will disable line wrapping: base64 -w 0 $scriptfile #!/bin/bash # API key from your account settings API_KEY='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' https://synthetics.newrelic.com/synthetics/api/v3/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload=\"{\\\"scriptText\\\":\\\"$encoded\\\"}\" curl -s -X PUT -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.31641,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage synthetic monitors via REST <em>API</em>",
        "sections": "Synthetics REST <em>API</em>",
        "info": "Use the <em>New</em> <em>Relic</em> Synthetics REST <em>API</em> to create, delete, and manage monitors.",
        "category_0": "<em>APIs</em>",
        "category_1": "Synthetics REST <em>API</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>apis</em>&#x2F;synthetics-rest-<em>api</em>&#x2F;monitor-examples&#x2F;manage-synthetics-monitors-rest-<em>api</em>",
        "body": " a list of all the monitors in your <em>New</em> <em>Relic</em> <em>account</em>, send a GET request to $<em>API</em>_ENDPOINT&#x2F;v3&#x2F;monitors. For example: curl -v \\ -H &#x27;<em>Api</em>-<em>Key</em>:$<em>API_KEY</em>&#x27; $<em>API</em>_ENDPOINT&#x2F;v3&#x2F;monitors A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { &quot;monitors",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; Synthetics REST <em>API</em> &#x2F; Monitor examples"
      },
      "id": "58e350fb0711e82e9d7366ae"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/apis/navigation/",
      "sections": [
        "navigation",
        "Usage",
        "API methods",
        "navigation.getOpenEntityLocation",
        "Example",
        "navigation.getOpenLauncherLocation",
        "Example 1",
        "Example 2",
        "navigation.getOpenNerdletLocation",
        "navigation.getOpenOverlayLocation",
        "navigation.getOpenStackedEntityLocation",
        "navigation.getOpenStackedNerdletLocation",
        "Example 3",
        "navigation.getReplaceNerdletLocation",
        "navigation.openEntity",
        "navigation.openLauncher",
        "navigation.openNerdlet",
        "navigation.openOverlay",
        "navigation.openStackedEntity",
        "navigation.openStackedNerdlet",
        "navigation.replaceNerdlet",
        "Type definitions",
        "Nerdlet",
        "UrlStateOptions",
        "Overlay",
        "Launcher",
        "Location",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:59:50Z",
      "title": "navigation",
      "updated_at": "2021-01-29T01:59:34Z",
      "type": "developer",
      "external_id": "89f86c8e0d7f52bf769051e74d77d86893306716",
      "document_type": "page",
      "popularity": 1,
      "body": "Usage import { navigation } from 'nr1' Copy API methods navigation.getOpenEntityLocation Returns a location object that can be used to redirect to an entity in its corresponding launcher (default: Explorer launcher). Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( entityGuid : string // GUID of the entity to open. ) => Location Example 1 const entityGuid = 'Mxka102Ak'; 2 3 const location = navigation.getOpenEntityLocation(entityGuid); Copy navigation.getOpenLauncherLocation Returns a location object that can be used to redirect to a given launcher. You can also specify nerdlet and stacked nerdlets with given states to be opened in this launcher. If nerdlet is not specified, the root nerdlet of the given launcher will be opened. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( launcher : Launcher // Launcher to open. ) => Location Example 1 1 const launcher = { 2 id: 'nr1-core.explorer', 3 }; 4 5 const location = navigation.getOpenLauncherLocation(launcher); Copy Example 2 1 // You can also specify a nerdlet and stacked nerdlets to be opened. 2 // You can combine artifacts from different nerdpacks. 3 const launcher = { 4 id: '074e8260-fa9c-4d71-f7a0-51835417a423.my-launcher-id', 5 nerdlet: { 6 id: 'nr1-core.listing', 7 }, 8 stackedNerdlets: [ 9 { 10 id: 'dashboards.list', 11 }, 12 ], 13 }; 14 15 const location = navigation.getOpenLauncherLocation(launcher); Copy navigation.getOpenNerdletLocation Returns a location object that can be used to open a given nerdlet with a given state. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( nerdlet : Nerdlet // Nerdlet to replace current nerdlet with. ) => Location Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 const location = navigation.getOpenNerdletLocation(nerdlet); Copy Example 2 1 // You can also specify nerdlet's state. 2 const nerdlet = { 3 id: 'dashboards.list', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 const location = navigation.getOpenNerdletLocation(nerdlet); Copy navigation.getOpenOverlayLocation Returns a location object that can be used to trigger opening overlay. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( overlay : Overlay // Overlay you want to open. ) => Location Example 1 const overlay = { 2 id: 'nr1-core.search', 3 }; 4 5 const location = navigation.getOpenOverlayLocation(overlay); Copy navigation.getOpenStackedEntityLocation Returns a location object that can be used to trigger opening entity in a stacked nerdlet. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( entityGuid : string // GUID of the entity to open. ) => Location Example 1 const entityGuid = 'Mxka102Ak'; 2 3 const location = navigation.getOpenStackedEntityLocation(entityGuid); Copy navigation.getOpenStackedNerdletLocation Returns a location object that can be used to trigger opening stacked nerdlet with a given state. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( nerdlet : Nerdlet // Nerdlet to open as stacked nerdlet. ) => Location Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 const location = navigation.getOpenStackedNerdletLocation(nerdlet); Copy Example 2 1 // You can also specify nerdlet's state. 2 const nerdletWithState = { 3 id: 'dashboards.list', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 const location = navigation.getOpenStackedNerdletLocation(nerdletWithState); Copy Example 3 1 // If you want to open nerdlet from the current nerdpack then you can omit its nerdpackId. 2 const nerdletWithState = { 3 id: 'my-nerdlet-id', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 const location = navigation.getOpenStackedNerdletLocation(nerdletWithState); Copy navigation.getReplaceNerdletLocation Returns a location object that can be used to replace current nerdlet. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( nerdlet : Nerdlet // Nerdlet to replace current nerdlet with. ) => Location Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 const location = navigation.getReplaceNerdletLocation(nerdlet); Copy Example 2 1 // If the nerdlet you want to replace with is in the current nerdpack then you can omit its nerdpackId. 2 const nerdlet = { 3 id: 'my-nerdlet-id', 4 }; 5 6 const location = navigation.getReplaceNerdletLocation(nerdlet); Copy Example 3 1 // You can also specify nerdlet's state. 2 const nerdlet = { 3 id: 'my-nerdlet-id', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 const location = navigation.getReplaceNerdletLocation(nerdlet); Copy navigation.openEntity Opens an entity in its corresponding launcher (default: Explorer launcher). To navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( entityGuid : string, // GUID of the entity to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => undefined Example 1 const entityGuid = 'Mxka102Ak'; 2 3 navigation.openEntity(entityGuid); Copy navigation.openLauncher Opens launcher inside the platform. You can also specify nerdlet and stacked nerdlets with given states to be opened in this launcher. If nerdlet is not specified, the root nerdlet of the given launcher will be opened. If you wish to navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( launcher : Launcher, // Launcher to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => void Example 1 1 const launcher = { 2 id: 'nr1-core.explorer', 3 }; 4 5 navigation.openLauncher(launcher); Copy Example 2 1 // You can also specify a nerdlet and stacked nerdlets to be opened. 2 // You can combine artifacts from different nerdpacks. 3 const launcher = { 4 id: '074e8260-fa9c-4d71-f7a0-51835417a423.my-launcher-id', 5 nerdlet: { 6 id: 'nr1-core.listing', 7 }, 8 stackedNerdlets: [ 9 { 10 id: 'dashboards.list', 11 }, 12 ], 13 }; 14 15 navigation.openLauncher(launcher); Copy navigation.openNerdlet Opens a nerdlet in the current launcher. If nerdlet.urlState is provided, it will be shallow-merged with the initial state of the nerdlet. If you wish to navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( nerdlet : Nerdlet, // Nerdlet to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => void Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 navigation.openNerdlet(nerdlet); Copy Example 2 1 // You can also specify nerdlet's state. 2 const nerdletWithState = { 3 id: 'dashboards.list', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 const location = navigation.getOpenNerdletLocation(nerdletWithState); Copy navigation.openOverlay Opens an overlay on top of the current launcher. If overlay.urlState is provided, it will be shallow-merged with the initial state of the overlay. If you wish to navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( overlay : Overlay, // Overlay you want to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => void Example 1 const overlay = { 2 id: 'nr1-core.search', 3 }; 4 5 navigation.openOverlay(overlay); Copy navigation.openStackedEntity Opens a stacked nerdlet with entity open in it. If triggered from a stacked nerdlet that is not the last one on the stack, the stacked nerdlet aboves it will be replaced. To navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( entityGuid : string, // GUID of the entity to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => undefined Example 1 // Opens stacked entity. 2 const entityGuid = 'Mxka102Ak'; 3 4 navigation.openStackedEntity(entityGuid); Copy navigation.openStackedNerdlet Opens a stacked nerdlet with given state above current one. If triggered from a stacked nerdlet that is not the last one on the stack, the stacked nerdlets above it will be replaced. If you wish to navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( nerdlet : Nerdlet, // Nerdlet to open as stacked nerdlet. urlStateOptions : UrlStateOptions // Options for the URL state. ) => void Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 navigation.openStackedNerdlet(nerdlet); Copy Example 2 1 // You can also specify nerdlet's state. 2 const nerdletWithState = { 3 id: '074e8260-fa9c-4d71-f7a0-51835417a423.my-nerdlet-id', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 navigation.openStackedNerdlet(nerdlet); Copy Example 3 1 // If you want to open nerdlet from the current nerdpack then you can omit its nerdpackId. 2 const nerdletWithState = { 3 id: 'my-nerdlet-id', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 navigation.openStackedNerdlet(nerdlet); Copy navigation.replaceNerdlet Replaces the nerdlet that is calling this API method. If you wish to navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( nerdlet : Nerdlet, // GUID of the entity to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => void Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 navigation.replaceNerdlet(nerdlet); Copy Example 2 1 // If the nerdlet you want to replace with is in the current nerdpack then you can omit its nerdpackId. 2 const nerdlet = { 3 id: 'my-nerdlet-id', 4 }; 5 6 navigation.replaceNerdlet(nerdlet); Copy Example 3 1 // You can also specify nerdlet's state. 2 const nerdlet = { 3 id: 'my-nerdlet-id', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 navigation.replaceNerdlet(nerdlet); Copy Type definitions Nerdlet { id : string, // Id of the nerdlet. You can specify the full nerdlet id: <nerdpack-id> . <nerdlet-id> (i.e. \"8ba28fe4-5362-4f7f-8f9a-4b8c6c39d8a6.my-nerdlet\") or simply <nerdlet-id> (i.e. \"my-nerdlet\"). In the latter case, the nerdlet will be treated as if it belongs to the current nerdpack, meaning that the nerdpack id is automatically added by the platform. urlState : Object, // State of the nerdlet which is persisted in the url. } UrlStateOptions { replaceHistory : boolean, // If true, the current entry in the browser history will be replaced with the new one. } Overlay { id : string, // Id of the overlay to be opened, for example nr1-core.search. urlState : Object, // State of the overlay which is persisted in the url. } Launcher { id : string, // Id of the launcher, for example nr1-core.explorer. nerdlet : Nerdlet, // Nerdlet to be opened in the launcher. If not provided, the root nerdlet of the launcher will be opened. stackedNerdlets : Nerdlet[], // Nerdlet to be opened as stacked nerdlets. } Location { pathname : string, // String representing the path to link to. search : string, // String representing query parameters. hash : string, // String to put in the URL as hash, e.g. #entities. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 437.56036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdlet</em>",
        "body": " with the <em>new</em> <em>one</em>. } Overlay { id : string, &#x2F;&#x2F; Id of the overlay to be opened, for example nr1-core.search. urlState : Object, &#x2F;&#x2F; State of the overlay which is persisted in the url. } <em>Launcher</em> { id : string, &#x2F;&#x2F; Id of the <em>launcher</em>, for example nr1-core.explorer. <em>nerdlet</em> : <em>Nerdlet</em>, &#x2F;&#x2F; <em>Nerdlet</em> to be opened"
      },
      "id": "5efa98d464441f683d5f7e3e"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advance configurations",
        "Extend webpack configuration",
        "Proxy browser setup",
        "Summary",
        "This site uses cookies üç™"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2020-12-04T01:59:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advance configurations Extend webpack configuration You can use our .extended-webpackrc.js file to extend the webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Proxy browser setup Generally, you don't need to know how your application code is loaded in New Relic One. But understanding how this works can help you if you encounter issues (for example, with a proxy or browser setup). When developing, your code is served from your local laptop by using an nr-local.net subdomain. This domain points to 127.0.0.1, and will use a variety of ports to connect, including 9973. In order to load third-party code into the platform, (both in development and production), New Relic One uses an <IFRAME>, as well as a separate domain (a subdomain of nr-ext.net) to perform the load, relying on same-domain policy to sandbox the code. For this reason, your network administrator may need to enable access to: Any subdomain of nr-local.net, or, at the very least, to any domain of the shape of <UserId>.nr-local.net, where UserId is a 32-hexadecimal character identifier that is unique to the user logged into the platform (you can use [0-9a-f]{32} to discriminate it). Any subdomain of nr-ext.net, or, at the very least, to any domain in the shape of <NerdpackUuid>.g <NerdpackGid>.nr-ext.net, where NerdpackUuid is the UUID assigned to your package, and NerdpackGid is zero, or a positive integer (you can use 0|[1-9]\\d+ to discriminate it). Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 395.46838,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "!&quot; application The <em>CLI</em> allows you to run a local version of <em>New</em> <em>Relic</em> <em>One</em>. You can develop your application locally before you publish it in <em>New</em> <em>Relic</em> <em>One</em>. If you followed all the steps in the <em>CLI</em> quick start, you now have files under a <em>new</em> directory named after your <em>nerdpack</em> project. Here&#x27;s how you edit"
      },
      "id": "5efa9973196a67d16d76645c"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 275.77353,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common commands",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a <em>new</em> component Creates a <em>new</em> component from our template (either a <em>Nerdpack</em>, <em>Nerdlet</em>, <em>launcher</em>, or catalog). The <em>CLI</em> will walk you through this process. To learn more about Nerdpacks and their <em>file</em> <em>structure</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies üç™"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2021-01-31T02:54:25Z",
      "updated_at": "2020-12-04T02:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.76767,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": ". At the end of the Quick start, you have a project consisting of the following: A <em>Nerdpack</em> - The package containing all the files required by your application. It contains two types of files that you customize to build your app: <em>Nerdlets</em>, and the <em>launcher</em>. <em>One</em> or more <em>Nerdlet</em> files - A specific UI view"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-01-31T02:57:35Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.12137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " and publish your application, see¬†our guide on Deploying your <em>New</em> <em>Relic</em> <em>One</em> app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (<em>Nerdpack</em>, <em>Nerdlet</em>, <em>launcher</em>, or catalog). nr1"
      },
      "id": "5efa989e28ccbc535a307dd0"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-01-31T02:57:35Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.37917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (<em>command</em> line interface). This page explains how to use¬†<em>CLI</em> <em>commands</em>¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-01-31T02:56:28Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.85828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.11133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>command</em> followed by the same arguments you used to create them. [ { &quot;Key&quot;: &quot;tag1&quot;, &quot;Values&quot;: [&quot;true&quot;] }, { &quot;Key&quot;: &quot;tag2&quot;, &quot;Values&quot;: [&quot;test&quot;] }, { &quot;Key&quot;: &quot;tag3&quot;, &quot;Values&quot;: [&quot;testing&quot;] } &#x2F;&#x2F; ... ] Copy Next steps Have a look at all the <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>. For example, you could create a <em>New</em> <em>Relic</em>"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "category_2": "Install plugins",
      "nodeid": 1746,
      "sections": [
        "Plugins for New Relic",
        "Get started",
        "Install plugins",
        "Custom dashboards and custom views",
        "Install from Plugin Central",
        "Limited access to legacy plugins",
        "Requirements",
        "Access rights",
        "License key",
        "Typical plugin installation procedures",
        "Install an NPI-compatible plugin",
        "Install with Chef or Puppet",
        "For more help"
      ],
      "title": "Install from Plugin Central",
      "category_0": "Plugins",
      "type": "docs",
      "category_1": "Plugins for New Relic",
      "external_id": "39aab41e1b08717e112b24833407aad71a8d73e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/plugins/plugins-new-relic/install-plugins/install-plugin-central",
      "published_at": "2021-01-31T11:26:02Z",
      "updated_at": "2021-01-27T05:44:56Z",
      "breadcrumb": "Contents / Plugins / Plugins for New Relic / Install plugins",
      "document_type": "page",
      "popularity": 1,
      "info": "Plugins in New Relic's Plugin Central include instructions for how to install, use, troubleshoot, and uninstall, as well as a link to support resources.",
      "body": "Limited access For an even better experience than plugins, go to: newrelic.com/integrations: Integrate the on-host and cloud systems you already use with New Relic, so you can filter and analyze data, create dashboards, and set alerts within a single platform. developer.newrelic.com: Use developer tools to collect data from any source, automate workflows, build apps, and use our APIs. Limited access to legacy plugins As of December 2, 2020, plugin access has been limited to accounts that have accessed a legacy plugin in the past 30 days. The legacy plugin experience will reach end of life (EoL) as of June 16, 2021. For more information, see our Explorers Hub post. Requirements Each plugin in Plugin Central includes its own procedures for how to install, use, troubleshoot, and uninstall it. In order to use a plugin, first verify that your environment meets the plugin's documented requirements. Then follow the plugin's procedures to install the plugin agent on one or more hosts in your monitored environment, or to configure a SaaS plugin as directed by your SaaS provider. As a standard security measure for data collection, your application server must support SHA-2 (256-bit). We do not support SHA-1. Also, plugins in Plugin Central are not supported with accounts that host data in the EU region data center. Access rights When using an agent from Plugin Central, deploy the agent giving the fewest possible permissions in order for the plugin agent to function successfully. Unless the plugin publisher gives specific instructions, you should run the plugin agent as a non-privileged user; do not use su or sudo privileges. This applies to both installing and using the agent. If the plugin agent needs credentials for the component (instance) that it is monitoring, create a custom set of credentials just for the monitoring agent to use. These should be separate from any other production credentials. The custom credentials should grant the fewest possible permissions while still allowing the agent to gather the data it needs. For example, for most plugin agents, you should only need to grant read-only access to your components or instances so the plugin agent cannot modify your system in any way. Also, with many agents, you should only need to grant access to read performance and administration data, not necessarily end customer or other sensitive data. For more information, see Plugin security. License key As part of any plugin installation process, you need your New Relic license key. When you are logged into the Plugins UI, the plugin's installation page in Plugin Central also shows your license key so you can easily copy it to your clipboard. If plugins have been published by SaaS providers, they must have access to the New Relic license key for each individual account. They can capture this information when provisioning new customers via the New Relic Partner API, or they can provide a mechanism for customers to share their existing New Relic license key. Typical plugin installation procedures Installation requirements depend on the type of plugin. For example, a Java plugin agent has different requirements than a Ruby plugin agent. Before you use a plugin, review the documentation that the plugin's publisher provides about the agent's installation requirements. To install any plugin from Plugin Central: Go to one.newrelic.com > More > Plugins. From the Plugin Central directory, select the plugin's title or its Get started button. From the plugin's details page, select the Download or Continue button. Follow the plugin's specific instructions to get your plugin installed and running. After you start running a plugin, it collects and sends data to New Relic, usually within five minutes. The plugin name will automatically appear in the Plugins UI, where you can select and view its summary metrics and dashboards. Install an NPI-compatible plugin The New Relic Platform Installer (NPI) is a command line utility that helps you easily download, configure, and manage a plugin by installing it with a single command. After you install the NPI tool, you can use it to install any plugins that are compatible with it. Install the plugin Plugins that are compatible with the New Relic Platform Installer include an NPI compatible label. If you have not already installed the NPI tool: Go to one.newrelic.com > More > Plugins, then select any plugin listed as NPI compatible. From the selected plugin's Installation page in the UI, click the link that says * Requires New Relic Platform Installer (NPI) - Get it here. From the dropdown that opens, select your operating system. Copy the command that appears, then run it in your terminal to install the NPI tool. Unix-based systems: If you need to set a default user, in your terminal, run: ./npi set user <USER NAME> Once you have installed the NPI tool, you can install any NPI compatible plugin. Go to one.newrelic.com > More > Plugins, then select any plugin listed as NPI compatible. From the selected plugin's Installation page in the UI, follow the procedures to copy the specific plugin's installation command. In your terminal, change to the directory ~/newrelic-npi, then paste and run the install command. Manage plugins with the NPI tool To view information that helps you manage NPI-compatible plugins: For usage and commands, help and version flags, and setup examples, run the command --help from the directory ~/newrelic-npi. For a list of plugins that are NPI-compatible, run the command ./npi available. If you need to include proxy settings in your configuration (for both the NPI tool and the plugin's newrelic.json file), use these commands: ./npi config set proxy_host <HOST> ./npi config set proxy_port <PORT> ./npi config set proxy_username <USER NAME> ./npi config set proxy_password <PASSWORD> To view the full path for a plugin, run a where command. This is useful for viewing log files or locating a plugin on your filesystem so you can manually configure it. Troubleshoot NPI-compatible plugins In addition to the troubleshooting procedures provided by the plugin publisher, follow these troubleshooting guidelines when installing NPI-compatible plugins. Duplicate plugins Problem: If you install a plugin and then install the same plugin again through the NPI tool, you will have two versions of the plugin installed. Solution: Delete the older version of the plugin, and then install the NPI-compatible version using the NPI tool. Procedures to delete plugins typically appear in the README file or in other documentation that the plugin publisher provides. Error message ./npi: line 1: bin/node: No such file or directory Problem: The architecture script that you selected when you installed the NPI tool does not match your operating system (for example, x86 instead of x64). Solution: Install the NPI tool using the correct script for your operating system. Error message -bash: ./npi: No such file or directory Problem: You cannot run NPI commands. Solution: You can only access the NPI tool from the location where it was installed. To solve this problem, navigate to the directory ~/newrelic-npi, and run the command again. Insufficient privileges to run background processes Problem: If you try to set a plugin to run as a background process, you might see a message that you have insufficient privileges. Solution: The plugin creates an /etc/init.d script on Linux and a Windows service on Windows, both of which require escalated privileges to run. To solve this problem: Linux: Run the command with sudo in front of it. Windows: Run the command as an administrator. Install with Chef or Puppet In addition to standard installation procedures, you can install plugins with Chef and Puppet configuration management tools. These tools automate plugin installation and make it easier to manage plugins with the rest of your server software. Chef cookbooks Plugins in Plugin Central may come bundled with a Chef script, or you can write your own. If a Chef script is provided, this does not mean you are required to use it to install the plugin. Before installing a plugin using Chef, add the Chef cookbook for New Relic Plugins: Procedures: See Chef's cookbook documentation. New Relic Plugins cookbook: See Chef's community site for newrelic_plugins. Requirements and dependencies: See New Relic's GitHub repo for installing plugins with Chef. Then, to install a plugin using Chef: Configure Chef with the plugin details. Run Chef to install the plugin. Chef cookbooks and recipes define roles for specific server configurations. For example, a web server can have the role web_server which includes all of the software and configuration needed for a web server. Here is an example of creating a Chef role for a server running the Wikipedia Java example plugin: name \"newrelic_wikipedia_example_java_plugin\" description \"Server running the New Relic Plugins Wikipedia Example Java Plugin\" run_list( \"recipe[newrelic_plugins::wikipedia_example_java]\" ) default_attributes( \"newrelic\" => { \"license_key\" => \"NEW_RELIC_LICENSE_KEY\", \"wikipedia_example_java\" => { \"install_path\" => \"/path/to/plugin\", \"user\" => \"newrelic\" } } ) Puppet modules Plugins in Plugin Central may come bundled with a Puppet script, or you can write your own. If a Puppet script is provided, this does not mean you are required to use it to install the plugin. Before installing a plugin using Puppet, add New Relic's Puppet module for plugins: Procedures: See Puppet's module documentation. New Relic plugin modules: See the Puppet Forge community site. Requirements and dependencies: See New Relic's GitHub repo for installing plugins with Puppet. Then, to install a plugin using Puppet: Configure Puppet with the plugin details. Run Puppet to install the plugin. Puppet modules contain manifest files that are a collection of classes for configuring a server. For example, a web server can be assigned several classes for the necessary software for a web server. Here is an example of using a Puppet class for a server running the Wikipedia Java example plugin: class { 'newrelic_plugins::wikipedia_example_java': license_key => 'NEW_RELIC_LICENSE_KEY', install_path => '/path/to/plugin', user => 'newrelic' } For more help If you need more help, check out these support and learning resources: Review the documentation provided by the plugin publisher, or contact the publisher's support resources (identified in the plugin's Get support link). Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.96368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install from <em>Plugin</em> Central",
        "sections": "<em>Plugins</em> for <em>New</em> <em>Relic</em>",
        "info": "<em>Plugins</em> in <em>New</em> <em>Relic&#x27;s</em> <em>Plugin</em> Central include instructions for how to install, use, troubleshoot, and uninstall, as well as a link to support resources.",
        "category_0": "<em>Plugins</em>",
        "category_1": "<em>Plugins</em> for <em>New</em> <em>Relic</em>",
        "category_2": "Install <em>plugins</em>",
        "body": "-compatible <em>plugin</em> The <em>New</em> <em>Relic</em> Platform Installer (NPI) is a <em>command</em> line utility that helps you easily download, configure, and manage a <em>plugin</em> by installing it with a single <em>command</em>. After you install the NPI tool, you can use it to install any plugins that are compatible with it. Install the <em>plugin</em>",
        "breadcrumb": "Contents &#x2F; Plugins &#x2F; Plugins for <em>New</em> <em>Relic</em> &#x2F; Install plugins"
      },
      "id": "5f2ef803e7b9d2c97cc9de91"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-01-31T02:53:24Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.82247,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " apply to any <em>CLI</em> <em>command</em>, which is useful when switching between accounts. Run the profiles add <em>command</em>: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_<em>NEW_RELIC</em>_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles"
      },
      "id": "5efa999c196a67c4e1766461"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "category_2": "Core concepts",
      "nodeid": 41906,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Introduction",
        "Why a new dashboards API?",
        "From REST endpoints to graphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "external_id": "b5ac1e396f08a48f318a283be906aa8b9bca7310",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph",
      "published_at": "2021-01-31T13:15:31Z",
      "updated_at": "2021-01-30T05:06:03Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Core concepts",
      "document_type": "page",
      "popularity": 1,
      "body": "Introduction In case you haven‚Äôt heard, NerdGraph is New Relic‚Äôs unified API in a graphQL flavor. The new dashboards API follows this unified approach and is exposed through Nerdgraph for user consumption. Why a new dashboards API? Dashboards in New Relic One embrace the entity concept and are now an entity in New Relic‚Äôs entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features, with many more coming: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to graphQL queries/mutations One of the main benefits from a graphQL API is that it provides a complete and understandable description of the APIs data. By using NerdGraph GraphiQL explorer, you can discover graphQL types and fields along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new graphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic‚Äôs entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } You can list all the dashboards by the creator‚Äôs email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } You can list all the dashboards by the creator‚Äôs userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = 2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity guid. Then you can access all the dashboard properties that you are interested in by adding them in the graphQL query. In the example below we are only interested in the entity guid and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in graphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although graphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields. Moreover, there is a doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard guid and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory. For more information, there is a doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity guid. mutation { dashboardDelete { status errors { type description } } } Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what‚Äôs the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.6426,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dashboards API migration: from Insights API to <em>Nerdgraph</em>",
        "sections": "From REST endpoints to graphQL <em>queries</em>&#x2F;<em>mutations</em>",
        "body": " that illustrate how the old REST endpoints map to the new graphQL queries or <em>mutations</em>. List (GET) -&gt; entitySearch <em>query</em> Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic‚Äôs entity ecosystem. You can list all the dashboard entities you have access"
      },
      "id": "6014e93c64441f4eea3e17bc"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-mutation/",
      "sections": [
        "NerdGraphMutation",
        "Usage",
        "Examples",
        "Do a mutation",
        "Do mutation and refetch query",
        "Props",
        "Example 1",
        "Methods",
        "NerdGraphMutation.render",
        "NerdGraphMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "NerdGraphMutation",
      "updated_at": "2021-01-29T01:58:06Z",
      "type": "developer",
      "external_id": "12d0744f112e48cd91b3d640657329423ab2faec",
      "document_type": "page",
      "popularity": 1,
      "body": "A generic NerdGraph mutation component that allows you to mutate anything from NerdGraph. Usage import { NerdGraphMutation } from 'nr1' Copy Examples Do a mutation 1 NerdGraphMutation.mutate({ 2 mutation: ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity( 5 guid: $guid 6 tags: { key: \"team\", values: [\"ui\"] } 7 ) { 8 errors { 9 message 10 } 11 } 12 } 13 `, 14 variables: { 15 guid: 'XXXXXXXXXXX', 16 }, 17 }); Copy Do mutation and refetch query 1 function render() { 2 const mutation = ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 5 errors { 6 message 7 } 8 } 9 } 10 `; 11 const variables = { 12 guid: 'XXXXXXXXXXX', 13 tags: { key: 'team', values: ['ui'] }, 14 }; 15 16 // NOTE: Sometimes mutations take awhile so doing a refetch immediatly after a mutate 17 // doesn't show any change. 18 return ( 19 <NerdGraphQuery query={query} variables={variables}> 20 {({ data, refetch }) => ( 21 <> 22 <RenderData data={data} /> 23 <Button 24 onClick={() => 25 NerdGraphMutation.mutate({ 26 mutation, 27 variables, 28 }).then(refetch) 29 } 30 > 31 Mutate 32 </Button> 33 </> 34 )} 35 </NerdGraphQuery> 36 ); 37 } Copy Props childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined mutationrequiredstring|object GraphQL mutation, either as a string or a GraphQL document parsed into an AST by graphql-tag. Example 1 1 import { ngql } from 'nr1'; 2 3 const mutation = ngql` 4 mutation($guid: EntityGuid!) { 5 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 6 errors { 7 message 8 } 9 } 10 } 11 `; Copy variablesobject Object containing all of the variables your mutation needs to execute. Methods NerdGraphMutation.render function () => undefined NerdGraphMutation.mutate Static method to use NerdGraphMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any NerdGraphMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.55112,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraphMutation</em>",
        "sections": "Do <em>mutation</em> and refetch <em>query</em>",
        "body": " errors { 6 message 7 } 8 } 9 } 10 `; 11 const variables = { 12 guid: &#x27;XXXXXXXXXXX&#x27;, 13 tags: { key: &#x27;team&#x27;, values: [&#x27;ui&#x27;] }, 14 }; 15 16 &#x2F;&#x2F; NOTE: Sometimes <em>mutations</em> take awhile so doing a refetch immediatly after a mutate 17 &#x2F;&#x2F; doesn&#x27;t show any change. 18 return ( 19 &lt;NerdGraph<em>Query</em> <em>query</em>={<em>query</em>"
      },
      "id": "5efa999c64441fe20b5f7e06"
    },
    {
      "nodeid": 37711,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "NerdGraph API: NRQL condition alerts",
        "Steps to create a NRQL condition",
        "NRQL static condition",
        "NRQL baseline condition",
        "NRQL outlier condition",
        "Update a condition",
        "Update mutations",
        "List and filter NRQL conditions",
        "Singular NRQL condition queries",
        "Update the description",
        "Delete conditions",
        "For more help"
      ],
      "title": "NerdGraph API: NRQL condition alerts ",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "86591bd20017930f1e4eef1b1a76e3806298dbb9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-nrql-condition-alerts",
      "published_at": "2021-01-31T08:39:06Z",
      "updated_at": "2021-01-13T21:53:48Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alerts and Nerdgraph",
      "document_type": "page",
      "popularity": 1,
      "info": "Examples of how to use the NerdGraph API explorer to create alert conditions, queries, and mutations.",
      "body": "You can manage alerts conditions using our GraphQL NerdGraph API. Here are some conditions queries and mutations you can develop in our NerdGraph API explorer. See the NerdGraph introduction for help getting started with NerdGraph API explorer. This document covers the following: Steps to create a NRQL condition NRQL static condition NRQL baseline condition NRQL outlier condition Update a condition Update mutations List and filter NRQL conditions Singular NRQL condition queries Create a description Delete conditions Steps to create a NRQL condition Follow these steps: Decide which condition type you want to create (see NRQL Condition threshold types). Find your relevant policyID by doing one of the following: Use the NerdGraph policies API. Go to one.newrelic.com, in the top nav click Alerts & AI, then click Policies. Choose a policy. Find the ID under the policy name. Provide the appropriate mutation for your NRQL condition type and the relevant values. The NerdGraph GraphiQL explorer is the best place to find up-to-date documentation about the per-field specifics of the NerdGraph NRQL Conditions API. For example, questions like \"What does the valueFunction field accept?\" are best answered with the inline NerdGraph documentation. NRQL static condition Here's an example of creating a static condition: mutation { alertsNrqlConditionStaticCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Low Host Count - Catastrophic\" enabled: true nrql: { query: \"SELECT uniqueCount(host) from Transaction where appName='my-app-name'\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 2 thresholdOccurrences: AT_LEAST_ONCE thresholdDuration: 600 operator: BELOW priority: CRITICAL } valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 86400 }) { id name } } NRQL baseline condition Here's an example of creating a baseline condition: mutation { alertsNrqlConditionBaselineCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Baseline Condition\" enabled: true baselineDirection: UPPER_ONLY nrql: { query: \"SELECT average(duration) FROM Transaction\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 13 thresholdDuration: 180 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name baselineDirection } } NRQL outlier condition Here's an example of creating an outlier condition: mutation { alertsNrqlConditionOutlierCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Outlier Condition\" enabled: true expectedGroups: 4 openViolationOnGroupOverlap: false nrql: { query: \"SELECT average(duration) FROM Transaction FACET httpResponseCode\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 1 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name expectedGroups openViolationOnGroupOverlap } } Update a condition Complete the following: Determine the type of your existing condition by requesting the type field in a nrqlConditionsSearch query like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id type } } } } } } The type returned is what you use for your update mutation. For example, if the type returned is STATIC, use alertsNrqlConditionStaticUpdate. If the type returned is BASELINE, use alertsNrqlConditionBaselineUpdate. If the type returned is OUTLIER, use alertsNrqlConditionOutlierUpdate. Provide the id of your condition to your relevant condition type mutation. Note that you can only update conditions of the relevant type. Only provide update mutations for the fields you want to update. Fields you don't provide in the update are not touched. Update mutations Only fields that you provide in the update are changed. In the following example, baselineDirection returns unchanged, but name is updated. mutation { alertsNrqlConditionBaselineUpdate(id: YOUR_CONDITION_ID, accountId: YOUR_ACCOUNT_ID, condition: { name: \"Your updated name\" }) { id name baselineDirection } } List and filter NRQL conditions To list or filter your NRQL conditions, use the nrqlConditionsSearch query in NerdGraph. Use cursor pagination The basic of list functionality for NRQL conditions allows you to paginate through your NRQL conditions as well as request the total count of conditions per account. The nrqlConditionsSearch query utilizes cursor pagination to paginate through resources. The idea behind cursor pagination is that the client will request a cursor in a programmatic loop until the cursor comes back empty. An initial list response will look something like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nextCursor nrqlConditions { id name type } totalCount } } } } } This example returns a JSON response like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nextCursor\": \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", \"nrqlConditions\": [ { \"id\": \"4432\", \"name\": \"Baseline Condition\", \"type\": \"BASELINE\" }, { \"id\": \"443\", \"name\": \"A static condition\", \"type\": \"STATIC\" }, // more conditions here in reality ], \"totalCount\": 435 } } } } }, } In order to paginate through conditions in the response, have the client request the cursor to be returned until the nextCursor returns from the response as null: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(cursor: \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", ) { nextCursor nrqlConditions { id name type } totalCount } } } } } Request type-specific fields Certain fields are only available on specific NRQL condition types. The main reason that mutations are split between the different condition types is because they have minor differences between the fields they accept. For example, valueFunction is only relevant for static NRQL conditions and baselineDirection is only relevant on baseline NRQL conditions. But if these fields are only available on these certain condition types, how do we return them in a list of all of our condition types? The answer is a GraphQL convention known as inline fragments. Inline fragments allow you to access the data on a specific type of NRQL condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id name type ...on AlertsNrqlStaticCondition { valueFunction } ...on AlertsNrqlBaselineCondition { baselineDirection } ...on AlertsNrqlOutlierCondition { expectedGroups } } } } } } } In the previous example query, we are asking GraphQL to do the hard work for us to determine which NRQL conditions are the correct type. So, when the returned type is a static condition, it will return the valueFunction in the object. When the returned type is a baseline condition, it will return baselineDirection instead, and when the type is an outlier condition, it will return expectedGroups. Here is an example response: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nrqlConditions\": [ { \"baselineDirection\": \"UPPER_ONLY\", \"id\": \"342\", \"name\": \"My baseline condition\", \"type\": \"BASELINE\" }, { \"id\": \"553\", \"name\": \"My static condition\", \"type\": \"STATIC\", \"valueFunction\": \"SINGLE_VALUE\" }, { \"expectedGroups\": 4, \"id\": \"802\", \"name\": \"My outlier condition\", \"type\": \"OUTLIER\" } ] } } } } } } Filter NRQL conditions You can filter NRQL conditions with the searchCriteria argument of the nrqlConditionsSearch query: Here's an example of filtering NRQL conditions with matching by name. This query returns NRQL conditions that match the provided name. Note that this match is case insensitive. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(searchCriteria: { name: \"Baseline Condition\" }) { nrqlConditions { id name type } } } } } } Singular NRQL condition queries You can use the NRQL condition API to query for a singular condition. Run the nrqlCondition query in the alerts namespace. Similar to type specific fields on the nrqlConditionSearch query, you can also use these inline fragments to request fields that are restricted to a NRQL condition type. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: YOUR_CONDITION_ID) { id name ...on AlertsNrqlStaticCondition { valueFunction } } } } } } Update the description This will walk you through the procedure to create a description for a NRQL alert condition. 1. Get all the conditions for a policy: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditions(policyId: YOUR_POLICY_ID) { nextCursor results { id name description enabled nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { duration operator priority timeFunction threshold } type violationTimeLimitSeconds } } } } } } 2. Get the details for a single condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: \"YOUR_CONDITION_ID\") { description id enabled name nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { operator priority threshold thresholdDuration thresholdOccurrences } type violationTimeLimitSeconds } } } } } 3. Create a mutation with the description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { description } } Here's an example mutation with an included example description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tag.commandLine}} \\n entityGuid : {{tag.entityGuid}} \\n entityName : {{tag.entityName}} \\n fullHostname : {{tag.fullHostname}} \\n instanceType : {{tag.instanceType}} \\n processDisplayName : {{tag.processDisplayName}}\"}) { description } } Delete conditions You can use the alertsConditionDelete mutation to delete any type of condition. You can only request the id field on a delete mutation; for example: mutation { alertsConditionDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CONDITION_ID) { id } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.33783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: NRQL condition alerts ",
        "sections": "Update <em>mutations</em>",
        "info": "Examples of how to use the <em>NerdGraph</em> API explorer to create alert conditions, <em>queries</em>, and <em>mutations</em>.",
        "body": "You can manage alerts conditions using our GraphQL <em>NerdGraph</em> API. Here are some conditions queries and <em>mutations</em> you can develop in our <em>NerdGraph</em> API explorer. See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. This document covers the following: Steps to create",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; New Relic Alerts &#x2F; Alerts and <em>Nerdgraph</em>"
      },
      "id": "5f2dee1128ccbc562e88dfc1"
    },
    {
      "category_2": "Intro to APIs",
      "nodeid": 2151,
      "sections": [
        "Get started",
        "Intro to APIs",
        "Types of New Relic API keys",
        "Manage API keys in UI",
        "Overview of API keys",
        "User key",
        "License key",
        "Browser key",
        "REST API key",
        "Insights insert key",
        "Insights query key",
        "Admin key",
        "For more help"
      ],
      "title": "Types of New Relic API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "external_id": "7642ec789132dd9f20604844a8d6aad2a12baa59",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/types-new-relic-api-keys",
      "published_at": "2021-01-31T06:49:51Z",
      "updated_at": "2021-01-31T06:49:51Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Types of New Relic API keys, who can use them, and how to add, update, or delete API keys.",
      "body": "New Relic has several different APIs that each require their own type of API key to use. This resource describes our API keys, what they're used for, and how to access them. Manage API keys in UI Here's a direct link to the API keys UI page. To find this from the New Relic UI: From the account dropdown, select Account settings. Select API keys. Overview of API keys The table below summarizes our available API keys and their uses. Some keys are able to be used by more than one API. If you're using a specific API, see the docs for that API to understand which keys are required and recommended. Key type What it's for Where to access User key (aka \"personal API key\") Used for NerdGraph (our GraphQL API) and for accessing REST API endpoints (dependent on user permissions). API keys UI License key Allows ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. API keys UI Insights insert key (aka \"Insert key\") Allows ingestion of events via HTTPS request from our metric, log, trace, and event APIs and the tools that use those APIs. Go to the API keys UI and click Insights insert key. Browser key Allows ingestion of browser monitoring data. API keys UI Mobile key (aka \"mobile app token\") Allows mobile monitoring data to be sent to New Relic. See Mobile app token. REST API key Note: we recommend using the user key instead because it has fewer limitations. The REST API key is for using our REST APIs for Alerts, APM, Browser, Infrastructure alerts, as well as Mobile REST APIs and the API Explorer. Go to the API keys UI and click REST API key. Admin API key As of December 4, 2020, all existing admin keys have been migrated to be user keys. For more information, see Admin key and User key below. API keys UI (will appear as user keys) Insights query key (aka \"Query key\") This key allows use of the Insights query API. Note: we now recommend using NerdGraph to query New Relic data. Go to the API keys UI and click Insights query key. User key New Relic user keys (previously referred to as \"personal API keys\") are required for NerdGraph (our GraphQL API), which allows you to query most New Relic data and do some types of configuration. User keys also let you use our REST API, with restrictions based on your permissions. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a user key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select User. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a user key Go to the API keys UI. In the row of the user key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a user key Go to the API keys UI. In the row of the user key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. In December 2020, user keys supplanted Admin API keys. For details, see Admin API key. License key New Relic license keys allow the ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. If you're using a specific API, see the docs for that API to understand which keys are required or recommended. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a license key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select License. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a license key Go to the API keys UI. In the row of the license key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a license API key Go to the API keys UI. In the row of the license key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Browser key The browser key allows the ingestion of data from New Relic browser monitoring. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a browser key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select Browser. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a browser key Go to the API keys UI. In the row of the browser API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a browser key Go to the API keys UI. In the row of the browser API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. REST API key We recommend using a user key to use the REST API because that key has fewer limitations. You can use a REST API key with our REST API and the API Explorer. For parent accounts with sub-accounts, each sub-account must use its own REST API key. Availability: Each New Relic account can have only one REST API key. Activate or change REST API key Go to the API keys UI and select REST API key. Click Regenerate REST API key. Click (Show key) to view your account's new REST API key. Copy your account's REST API key to use with New Relic's REST API. View REST API keys To view REST API keys: Go to the API keys UI and select REST API key. Click (Show key) to view your account's new REST API key. Delete REST API key To delete your account's REST API key: Before you delete an API key, make sure you have the correct account or sub-account. Go to the API keys UI and select REST API key. Select the delete [trash can icon] icon for the REST API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Insights insert key The Insights insert key (aka the \"Insert key\") is required for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. Generate an Insights insert key Go to the API keys UI and select Insights insert keys. Next to the Insert keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights insert key Go to the API keys UI and select Insights insert keys. Under Insert Keys, find the key you want to modify. Select Edit or Delete. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. Generate an Insights query key You must have access to the UIs you plan to query and the correct permissions in order to register or modify this key. Insights query keys are generated per account; they're not associated with a specific user. This means that any user in an account with access to a query key can use it. To register this key: Go to the API keys UI and select Insights query keys. Next to the Query Keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights query key To edit or delete this key: Go to the API keys UI page and select Insights query keys. Under Query Keys, find the key you want to modify. Select Edit or Delete. Admin key As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don‚Äôt need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says ‚ÄúMigrated from an admin user key‚Äù in the key table, so you‚Äôll be able to find them easily. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.85341,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Insights <em>query</em> key",
        "body": " <em>query</em> key (aka &quot;<em>Query</em> key&quot;) This key allows use of the Insights <em>query</em> API. Note: we now recommend using <em>NerdGraph</em> to <em>query</em> New Relic data. Go to the API keys UI and click Insights <em>query</em> key. User key New Relic user keys (previously referred to as &quot;personal API keys&quot;) are required for <em>NerdGraph</em> (our"
      },
      "id": "5d7485b128ccbc1b5c32ad31"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "Collect data",
      "updated_at": "2021-01-30T01:52:06Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add custom attributes ¬† Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.96565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build <em>queries</em> with <em>NerdGraph</em>",
        "body": " custom attributes ¬† Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with <em>NerdGraph</em> 25 min Try <em>NerdGraph</em> and build the queries you need <em>Query</em> data with NRQL 10 min <em>Query</em> default data, custom events, and attributes"
      },
      "id": "5efa997328ccbc768c307de2"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "Automate workflows",
      "updated_at": "2021-01-30T01:54:22Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 6200.759,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>",
        "body": " <em>using</em> <em>Helm</em> <em>charts</em> 20 min Learn how to <em>set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> <em>Use</em> <em>New</em> <em>Relic</em> to diagnose problems 30 min Learn to diagnose problems <em>using</em> <em>New</em> <em>Relic</em>."
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Private locations",
      "nodeid": 8661,
      "sections": [
        "Synthetic monitoring",
        "Getting started",
        "Guides",
        "Using monitors",
        "Monitor scripting",
        "Administration",
        "Private locations",
        "UI pages",
        "Synthetics API",
        "Troubleshooting",
        "Verified script execution for private locations",
        "Passphrase security",
        "Enable verified script execution",
        "Change your passphrase",
        "Disable verified script execution",
        "Other (legacy)",
        "For more help"
      ],
      "title": "Verified script execution for private locations",
      "category_0": "Synthetic monitoring",
      "type": "docs",
      "category_1": "Synthetic monitoring",
      "external_id": "723335509e387f8d0ee69cf120f4d34bd8d31821",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/verified-script-execution-private-locations",
      "published_at": "2021-01-31T06:04:19Z",
      "updated_at": "2021-01-31T06:04:19Z",
      "breadcrumb": "Contents / Synthetic monitoring / Synthetic monitoring / Private locations",
      "document_type": "page",
      "popularity": 1,
      "info": "For added security, enable verified script execution to require a passphrase before assigning jobs to your minion in New Relic.",
      "body": "To prevent others from using your private minions to assign scripted browsers or API tests, add verified script execution. Then, any changes to your minions will require a passphrase that is known only to you. The private locations list in New Relic's UI includes a VSE column. A lock lock icon indicates that verified script execution has been set up for that location. Passphrase security Be sure to safeguard your private minion's passphrase. No other users on your account can view it, and it is never stored in New Relic's collector. This restriction includes New Relic support personnel. Because our collector never stores your passphrase, our support team cannot recover or reset your passphrase for you. If you forget your passphrase, you will need to change it in the minion Overview page, and then update each monitor assigned to that private location. Enable verified script execution To enable verified script execution for containerized private minions, do the following. Be sure to record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, then save. Set the passphrase in your Docker or Kubernetes environment: Docker: Add the MINION_VSE_PASSWORD environment variable to the Docker run command used to start your private minion: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -e \"MINION_VSE_PASSWORD=YOUR_PASSPHRASE\" -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Kubernetes: Set the synthetics.minionVsePassphrase value in the Helm install or upgrade command: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion \\ -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY \\ --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Be sure to record your passphrase in a secure place. Repeat steps 3 and 4 for each monitor you want to assign to your location. Change your passphrase To change your passphrase, do the following. Be sure to record your passphrase in a secure place. Update the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion. Then use the Docker run command to start a new minion with your updated MINION_VSE_PASSWORD environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -e \"MINION_VSE_PASSWORD=YOUR_PASSPHRASE\" -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Kubernetes: Use the Helm upgrade command to set your updated synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion \\ -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY \\ --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Go to one.newrelic.com > Synthetics > (assigned monitor) > Settings > General. From the list of private locations, select your location, type your new passphrase, and save. Repeat steps 2 and 3 for each monitor assigned to your location. Disable verified script execution To disable verified script execution for containerized private minions: Remove the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion container. Then use the Docker run command to start a new minion without the MINION_VSE_PASSWORD environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Kubernetes: Use the Helm upgrade command without the --set synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion \\ -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY \\ Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Clear the Enable verified script execution checkbox, then save. Other (legacy) If you are not using containerized private minions, do the following to enable verified script execution. Be sure to record your passphrase in a secure place. In your web browser, navigate to the minion Overview page at https://MINION_IP_ADDRESS (for example, https://1.2.3.4). Select the pencil pencil icon, then select Advanced settings (optional). Select the Verified script execution checkbox. Type a passphrase, then save. Record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, then save. From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each monitor you want to assign to your location. To change your passphrase or disable verified script execution, follow the same basic process to go to your minion's IP address and update its Advanced settings. Then go to one.newrelic.com to complete the process. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.1466,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Using</em> monitors",
        "info": "For added security, enable verified script execution to require a passphrase before assigning jobs to your minion in <em>New</em> <em>Relic</em>.",
        "body": " indicates that verified script execution has been <em>set</em> <em>up</em> for that location. Passphrase security Be sure to safeguard your private minion&#x27;s passphrase. No other users on your account can view it, and it is never stored in <em>New</em> <em>Relic</em>&#x27;s collector. This restriction includes <em>New</em> <em>Relic</em> support personnel"
      },
      "id": "5f31b774196a67c983fbd6fc"
    },
    {
      "category_2": "Private locations",
      "nodeid": 23821,
      "sections": [
        "Synthetic monitoring",
        "Getting started",
        "Guides",
        "Using monitors",
        "Monitor scripting",
        "Administration",
        "Private locations",
        "UI pages",
        "Synthetics API",
        "Troubleshooting",
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Stop or delete the CPM",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Docker image repository",
        "Additional considerations for CPM connection",
        "For more help"
      ],
      "title": "Install containerized private minions (CPMs)",
      "category_0": "Synthetic monitoring",
      "type": "docs",
      "category_1": "Synthetic monitoring",
      "external_id": "63c77c4ba313098967f23929294f2cbc2f8d31d3",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/img-integration-k8s@2x.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms",
      "published_at": "2021-01-31T07:25:28Z",
      "updated_at": "2021-01-08T06:33:13Z",
      "breadcrumb": "Contents / Synthetic monitoring / Synthetic monitoring / Private locations",
      "document_type": "page",
      "popularity": 1,
      "info": "Install New Relic's Docker-based private minion that accepts and runs the jobs assigned to your private locations",
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. To use CPMs and synthetic monitoring, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a Scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a Simple Browser or Scripted Browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a Runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and Memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com/charts If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion helm show values YOUR_REPO_NAME/synthetics-minion Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.07045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Using</em> monitors",
        "info": "Install <em>New</em> <em>Relic&#x27;s</em> Docker-based private minion that accepts and runs the jobs assigned to your private locations",
        "body": " and to receive monitors to execute. Ask your network administration if this is a problem and how to <em>set</em> <em>up</em> exceptions. Communicate with Synthetics via a proxy To <em>set</em> <em>up</em> communication with <em>New</em> <em>Relic</em> by proxy, <em>use</em> the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies"
      },
      "id": "5f31d981196a678103fbd731"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/1qf2g217c4q7m/promo-image.1608575584.png",
      "url": "https://learn.newrelic.com/getting-started-with-dashboards-nrql",
      "sections": [
        "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations.",
        "About this workshop"
      ],
      "published_at": "2021-01-31T02:20:02Z",
      "title": "Getting started with Dashboards & NRQL",
      "updated_at": "2021-01-31T02:18:49Z",
      "type": "",
      "external_id": "20be8b6c5a3882e951f9dfd70354ea7ceaa38c7c",
      "popularity": 1,
      "body": "Sign In Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. Register | FREE Already registered? Sign In About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.¬† These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.¬† Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.¬†¬† In this hands-on session, you‚Äôll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.¬† Using a sandbox account you‚Äôll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.¬† You‚Äôll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.¬† Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL Feb. 9, 2021, noon - Feb. 9, 2021, 2 p.m. PST 82 Getting started with Dashboards & NRQL Feb. 16, 2021, 1 p.m. - Feb. 16, 2021, 3 p.m. GMT 111 About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.¬† These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.¬† Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.¬†¬† In this hands-on session, you‚Äôll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.¬† Using a sandbox account you‚Äôll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.¬† You‚Äôll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.¬† Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Live events Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL Feb. 9, 2021, noon - Feb. 9, 2021, 2 p.m. PST 82 Getting started with Dashboards & NRQL Feb. 16, 2021, 1 p.m. - Feb. 16, 2021, 3 p.m. GMT 111 ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.798676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Learn to <em>use</em> the Data Explorer and Query Builder Basic Mode to create <em>charts</em> and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of <em>charts</em> and visualizations.",
        "body": "? Sign In About this workshop <em>New</em> <em>Relic</em> One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom <em>charts</em> and visualizations.¬† These <em>charts</em> can be combined to create powerful dashboards to help you correlate"
      },
      "id": "5fe29f8528ccbcf532f15668"
    },
    {
      "category_2": "Exceptions",
      "nodeid": 10646,
      "sections": [
        "Mobile monitoring UI",
        "Mobile App pages",
        "Network pages",
        "Exceptions",
        "Usage pages",
        "Crash analysis: Group and filter your crashes",
        "Use crash analysis features",
        "View the crash list",
        "Use the crash analysis workflow",
        "Configure crash report email settings",
        "For more help"
      ],
      "title": "Crash analysis: Group and filter your crashes",
      "category_0": "Mobile",
      "type": "docs",
      "category_1": "Mobile monitoring UI",
      "external_id": "32a11c727dacfa983ff7b4772776a210cc5ae2f0",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/mobile-crash-profiles.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/crash-analysis-group-filter-your-crashes",
      "published_at": "2021-01-31T09:04:05Z",
      "updated_at": "2021-01-31T09:04:05Z",
      "breadcrumb": "Contents / Mobile / Mobile monitoring UI / Exceptions",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's crash analysis features to identify and deal with DevOps issues for resolving unanticipated exceptions with mobile apps.",
      "body": "Mobile app crashes can result in users submitting negative reviews, which can affect your organization's reputation. Crashes can also result in users deleting your app altogether, which affects your organization's profitability. With the Crash analysis UI, you can identify and deal with one of the largest bottlenecks in the development lifecycle: the time it takes to resolve unanticipated exceptions. Use crash analysis features When your development team receives an emailed crash notification, they can select the email link to review detailed information about the crash in our user interface, or analyze chart data directly through a query. The individual Crash details page also includes tracking tools for your team to follow the issue from reporting to resolution. Our crash analysis feature helps developers to: Slice and dice your crash and network data (using groups and filters) to analyze trends leading to the crash. Understand a particular user's experience by using a custom attribute. Pinpoint when most crashes occur; for example, by filtering by Last Interaction, or by viewing the interaction trail in the Crash report page. Align issues with common characteristics in networks or devices. Examine specific problems in a crash report that may be buried in thread breakdown data, trace details, or the trail of user interactions in the crashed session. Quickly see trends from the Crash profiles tab. View the crash list To view the filterable Crash list in the New Relic UI: Go to one.newrelic.com > Mobile > (select an app) > Exceptions > Crash analysis. OR To view the filterable Crash analysis page directly from the mobile app's Overview page, select the Crash occurrences chart's title. Use any of our standard page functions to drill down into detailed information; for example, zoom into any area of a chart. Use the crash analysis workflow To get the most out of Mobile monitoring's Crash analysis UI, use this basic workflow. Start with the Crash rate percentage and Crash-free users percentage charts to see at a glance whether there are any unexpected spikes, dips, or patterns with crash time frames, or uneventful periods within the selected time period. Use the groups and filters to examine attributes (for crashes, devices, locations, or other custom attributes) in more detail. Use the Top 5 occurrences chart to identify patterns for the type of occurrence you selected from the groups and filters. Also correlate any general patterns for the selected type of occurrence to crash percentages that occurred during this time period. Optional: Query or share the chart data. Look for patterns in the Crash location table information, including location, exception type, date and number of occurrences, version, and number of users affected by the crash. Select a crash report from the table to view its interaction trail, its event trail, thread details for individual occurrences, attributes, and more. If necessary, resymbolicate or export the crash details to Xcode so you can debug your source code more easily. When finished, mark the crash occurrences as Resolved. Resolved crashes include a banner identifying who resolved the crash and when. Based on Mobile monitoring's data retention policies, you can filter by resolved crashes when you need to track back to historical information. Crash percentages charts: See patterns immediately. Start with the Crash rate percentage and Crash-free users percentage charts to see at a glance whether there are any unexpected spikes, dips, or patterns with crashes in general. For example: Are there any spikes near a recent version release? Is there a time period when the percentage of users has been affected significantly by the crash? (If the Crash-free users percentage chart is empty, there were no user sessions during the selected time period.) Groups and filters: Slice and dice the crash data. You can select a group, and then filter to specific data, including: Group the crash list by type of crash, device, location, or other custom attributes. Show open crashes, resolved crashes, or all crashes. Use the time picker to adjust the currently selected time period. Filter by a specific Version or by one or more attribute Filter, such as Last Interaction, App Build, or any of the longer list of standard and custom attributes). The selected filters appear at the top of the UI page. Top five occurrences: Analyze specific characteristics. Use the Top 5 occurrences chart to identify what types of crashes and how many occurred during the selected time period. This chart shows the top five crash occurrences by the group and filters you select. For example, you can group by email address (if instrumented as a custom attribute), then filter down to a specific email to examine that user's experience. To filter or group by other attributes, use the search window, or select any of the available filters. For example, filter by type of crash, device, a specific location, or any custom attributes. To look for other historical patterns, change the selected time period. one.newrelic.com > Mobile > (select an app) > Exceptions > Crash analysis: Here is an example of the Top 5 occurrences chart filtered by the Crash locations group. Select any groups or filters to analyze your crash data any way you want. Queries and image links: Query crash data and share charts with others. Mobile monitoring's Crash analysis charts use default attributes for mobile events, along with any custom attributes you have added to this event type. To view or share the data, click the ellipsis icon. Add to dashboard link: View the chart, and copy it to a new or existing dashboard. View query link: View the NRQL query used to calculate the chart data. Get as image link: Select this option to get a public URL of the chart, then share it using any media. Crash reports: Dive into the interaction trail, thread breakdown, and more. Supplementing the charts, the Crash report table lists crash types by location, and links them to relevant crash report details. Each row helps you find answers to questions such as: How many of this crash type or exception occurred within the selected time period? What is the most recent exception message? Does a specific app version have a higher (or lower) number of users affected? When did the exception first and last occur? one.newrelic.com > Mobile > (select an app) > Exceptions > Crash analysis: Sort on any column to analyze patterns in the Crash reports table, then select any report to review crash details. Sometimes it may be more useful to examine crash report data from lowest to highest. For example: Which exception has the fewest number of occurrences? When did a particular exception start (Earliest occurrence)? You can change the sort order or filter options to focus on just the types of exceptions that matter the most to you and your teams. Crash profiles: Quickly see key differences between crashed and crash-free accounts. Crash profiles provide quick, clear insight into your mobile crash data by surfacing any anomalies in your mobile application‚Äôs performance. Unexpected differences between attributes and behaviors are highlighted, illuminating key differences between crashed and crash-free accounts. You can quickly pinpoint key issues through drill-downs and filters for a fast, streamlined troubleshooting experience. one.newrelic.com > Mobile > (select an app) > Exceptions> Crash analysis > Crash profiles: Compare crashed and crash-free sessions. Crash event trail: See all the events leading up to a crash. The mobile monitoring crash event trail shows you the events leading up to a crash of a mobile app. These can be events monitored by default, or custom events you've created. For more information, see Crash event trail. Examine crash report details: Export to Xcode or resymbolicate your source code. From the Crash report table, you can drill down into a specific Crash report. From here you can: Examine the interaction trail from session start through the crash event. Explore the related thread breakdown. Select Export crash details so you can examine source code using Xcode. Resymbolicate the crash report for easier debugging. File a ticket, and resolve the crash. one.newrelic.com > Mobile > (select an app) > Crashes > Crash report: This is an example of an interaction trail that includes the option to resymbolicate the crash occurrence. To analyze and debug your source code using Xcode, select Export crash details. Configure crash report email settings To learn how to configure email settings, see Email settings. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.00212,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Use</em> crash analysis features",
        "info": "<em>Use</em> <em>New</em> <em>Relic&#x27;s</em> crash analysis features to identify and deal with DevOps issues for resolving unanticipated exceptions with mobile apps.",
        "body": "&#x27;s Crash analysis <em>charts</em> <em>use</em> default attributes for mobile events, along with any custom attributes you have added to this event type. To view or share the data, click the ellipsis icon. Add to dashboard link: View the <em>chart</em>, and copy it to a <em>new</em> or existing dashboard. View query link: View the NRQL"
      },
      "id": "58181a9a8e9c0f431dbd4fce"
    }
  ],
  "/collect-data/custom-events": [
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2021-01-31T04:06:56Z",
      "updated_at": "2021-01-23T15:02:43Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.842255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "For New Relic, general limits and requirements for reporting <em>custom</em> <em>events</em> and attributes. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;insights-data-sources&#x2F;<em>custom</em>-data&#x2F;insights-<em>custom</em>-data-requirements-limits",
        "body": "You can report <em>custom</em> <em>events</em> to New Relic in several ways, including the New Relic <em>Event</em> <em>API</em>, APM <em>agent</em> <em>APIs</em>, Browser <em>agent</em> <em>APIs</em>, and the Mobile SDK. This document contains general requirements and rules for inserting and using <em>custom</em> <em>events</em> and their associated attributes. Additional requirements",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    },
    {
      "category_2": "API guides",
      "nodeid": 11521,
      "sections": [
        "Java agent",
        "Getting started",
        "Installation",
        "Additional installation",
        "Heroku",
        "Configuration",
        "Attributes",
        "Features",
        "Instrumentation",
        "Custom instrumentation",
        "API guides",
        "Async instrumentation",
        "Troubleshooting",
        "Guide to using the Java agent API",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples",
        "For more help"
      ],
      "title": "Guide to using the Java agent API ",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Java agent",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "external_id": "a31c751c7c29dd46effac2e568f7c0a92b033b18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "published_at": "2021-01-31T08:21:44Z",
      "updated_at": "2021-01-31T08:21:43Z",
      "breadcrumb": "Contents / APM agents / Java agent / API guides",
      "document_type": "page",
      "popularity": 1,
      "info": "A goal-focused guide to New Relic's Java agent API, with links to relevant sections of the complete API documentation on GitHub.",
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() For more on obtaining references to the current transaction and other API classes, see Obtain references. API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) For more on obtaining references to the current transaction and other API classes, see Obtain references. API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events to Insights. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the first call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.990974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the Java <em>agent</em> <em>API</em> ",
        "sections": "Guide to using the Java <em>agent</em> <em>API</em>",
        "info": "A goal-focused guide to New Relic&#x27;s Java <em>agent</em> <em>API</em>, with links to relevant sections of the complete <em>API</em> documentation on GitHub.",
        "category_0": "APM <em>agents</em>",
        "category_1": "Java <em>agent</em>",
        "category_2": "<em>API</em> guides",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>agents</em>&#x2F;java-<em>agent</em>&#x2F;<em>api</em>-guides&#x2F;guide-using-java-<em>agent</em>-<em>api</em>",
        "body": " <em>events</em> NewRelic.get<em>Agent</em>().getInsights() Additional <em>API</em> functionality The following <em>APIs</em> provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording <em>custom</em> metrics, and sending <em>custom</em> <em>events</em> to Insights. If you want to... Use",
        "breadcrumb": "Contents &#x2F; APM agents &#x2F; Java <em>agent</em> &#x2F; <em>API</em> guides"
      },
      "id": "5a3137f4e621f4576cf1e35f"
    },
    {
      "category_2": "Instrumentation",
      "nodeid": 27991,
      "sections": [
        "Java agent",
        "Getting started",
        "Installation",
        "Additional installation",
        "Heroku",
        "Configuration",
        "Attributes",
        "Features",
        "Instrumentation",
        "Custom instrumentation",
        "API guides",
        "Async instrumentation",
        "Troubleshooting",
        "Java agent: Instrument Kafka message queues",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Enable Kafka distributed traces",
        "For more help"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Java agent",
      "external_id": "ff1393afda373deb02effb2ddaa1109837519210",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues",
      "published_at": "2021-01-31T06:57:21Z",
      "updated_at": "2021-01-31T06:57:20Z",
      "breadcrumb": "Contents / APM agents / Java agent / Instrumentation",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic for Java includes built-in Kafka monitoring, as well as advanced event and distributed tracing data collection. ",
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: kafka-clients-spans: enabled: true 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec){ Iterable<Header> headers = rec.headers().headers(\"newrelic\"); for(Header header: headers) { NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(new String(header.value(), StandardCharsets.UTF_8)); } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.84323,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Java <em>agent</em>: Instrument Kafka message queues",
        "sections": "Java <em>agent</em>",
        "info": "New Relic for Java includes built-in Kafka monitoring, as well as advanced <em>event</em> and distributed tracing data collection. ",
        "category_0": "APM <em>agents</em>",
        "category_1": "Java <em>agent</em>",
        "body": " <em>event</em>. The <em>agent</em> records up to 2000 <em>events</em> per harvest cycle, though you can change this value with max_samples_stored. Kafka <em>event</em> data is included in this pool. If you use the record<em>CustomEvent</em>() <em>API</em> call to send <em>custom</em> <em>events</em> to New Relic and you send more than 2000 <em>events</em>, the <em>agent</em> will discard",
        "breadcrumb": "Contents &#x2F; APM agents &#x2F; Java <em>agent</em> &#x2F; Instrumentation"
      },
      "id": "5f1d50ff28ccbc22616cd371"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/23m1bvitohob1/promo-image.1536276861.png",
      "url": "https://learn.newrelic.com/new-relic-apis",
      "sections": [
        "Learn how to use a variety of New Relic APIs, including the GraphQL API, the Insights Insert API, and the APM Agent API.",
        "About this course",
        "Curriculum"
      ],
      "published_at": "2021-01-31T02:20:03Z",
      "title": "New Relic APIs",
      "updated_at": "2021-01-02T01:37:53Z",
      "type": "",
      "external_id": "e85a8158d02fefc00692d0c34843df4cb3c8b873",
      "popularity": 1,
      "body": "Sign In This video is still being processed. Please check back later. New Relic APIs Learn how to use a variety of New Relic APIs, including the GraphQL API, the Insights Insert API, and the APM Agent API. Register | FREE Already registered? Sign In About this course In this course, you'll learn how to use a variety of New Relic APIs, including the GraphQL API, the Insights Insert API, and the APM Agent API. Learn how to use these powerful APIs to retrieve data from New Relic products, insert data into those products, and adjust settings.¬† Curriculum GraphQL API Intro to New Relic GraphQL API Learn how to use the New Relic GraphQL API, an efficient and flexible query language that gives you the power to request exactly the data you need. REST API Using the REST API Learn how to use the New Relic REST API to retrieve data from your account, extract data via GET requests, and change some account configurations. Managing Insights dashboards with the New Relic REST API Learn how to use the New Relic REST API to create dashboard templates to share across your organization, instantly create dashboards, and save JSON files for source control and backups. Manage your Categories and Labels with the REST API Use the REST API to manage multiple categories and labels.¬† Deployment Tracking Learn how to mark deployments on charts to understand the effect of human-initiated change, including deployments that cause problems and the associated fixes. Rest API Knowledge Check Knowledge check for the New Relic REST API. Insights API Custom Data Overview with Insights Learn about the types of data captured automatically within Insights and take your analysis to the next level by adding your own business data. Add important context to your existing data with custom attributes or import additional data sets with custom events for more detailed user analytics. Adding Custom Events with the Insights API Learn how to import data as JSON to the Insights API endpoint - enrich existing data streams and add important context to your data to make full use of Insights' capabilities and visualizations for analyzing your data in real time. APM Agent API Adding Custom Data with the APM Agent API Learn how to use the New Relic APM agent API to send custom data about your app for a more detailed and in-depth view of your app‚Äôs performance and the ways your users engage with your app. Adding Custom Attributes with the Ruby Agent API Learn how to use the New Relic Ruby agent API to add custom attributes about your app for a more detailed and in-depth view of your app‚Äôs performance and the ways your users engage with your app. Adding Custom Events with the Ruby Agent API Learn how to insert custom event data the New Relic language agent APIs, which you can then query in New Relic Insights. Course Evaluation: New Relic APIs About this course In this course, you'll learn how to use a variety of New Relic APIs, including the GraphQL API, the Insights Insert API, and the APM Agent API. Learn how to use these powerful APIs to retrieve data from New Relic products, insert data into those products, and adjust settings.¬† Curriculum GraphQL API Intro to New Relic GraphQL API Learn how to use the New Relic GraphQL API, an efficient and flexible query language that gives you the power to request exactly the data you need. REST API Using the REST API Learn how to use the New Relic REST API to retrieve data from your account, extract data via GET requests, and change some account configurations. Managing Insights dashboards with the New Relic REST API Learn how to use the New Relic REST API to create dashboard templates to share across your organization, instantly create dashboards, and save JSON files for source control and backups. Manage your Categories and Labels with the REST API Use the REST API to manage multiple categories and labels.¬† Deployment Tracking Learn how to mark deployments on charts to understand the effect of human-initiated change, including deployments that cause problems and the associated fixes. Rest API Knowledge Check Knowledge check for the New Relic REST API. Insights API Custom Data Overview with Insights Learn about the types of data captured automatically within Insights and take your analysis to the next level by adding your own business data. Add important context to your existing data with custom attributes or import additional data sets with custom events for more detailed user analytics. Adding Custom Events with the Insights API Learn how to import data as JSON to the Insights API endpoint - enrich existing data streams and add important context to your data to make full use of Insights' capabilities and visualizations for analyzing your data in real time. APM Agent API Adding Custom Data with the APM Agent API Learn how to use the New Relic APM agent API to send custom data about your app for a more detailed and in-depth view of your app‚Äôs performance and the ways your users engage with your app. Adding Custom Attributes with the Ruby Agent API Learn how to use the New Relic Ruby agent API to add custom attributes about your app for a more detailed and in-depth view of your app‚Äôs performance and the ways your users engage with your app. Adding Custom Events with the Ruby Agent API Learn how to insert custom event data the New Relic language agent APIs, which you can then query in New Relic Insights. Course Evaluation: New Relic APIs ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.512985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>APIs</em>",
        "sections": "Learn how to use a variety of New Relic <em>APIs</em>, including the GraphQL <em>API</em>, the Insights Insert <em>API</em>, and the APM <em>Agent</em> <em>API</em>.",
        "body": " about your app for a more detailed and in-depth view of your app‚Äôs performance and the ways your users engage with your app. Adding <em>Custom</em> <em>Events</em> with the Ruby <em>Agent</em> <em>API</em> Learn how to insert <em>custom</em> <em>event</em> data the New Relic language <em>agent</em> <em>APIs</em>, which you can then query in New Relic Insights. Course Evaluation: New Relic <em>APIs</em> ¬© 2021 powered by"
      },
      "id": "5c2eb923e621f428b7cca76f"
    },
    {
      "sections": [
        "Collect data from any source",
        "Agent APIs",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API",
        "Log API",
        "This site uses cookies üç™"
      ],
      "title": "Collect data from any source",
      "type": "developer",
      "tags": [
        "Agent API",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API"
      ],
      "external_id": "5bfb043fffe42ea4a78d5a90bf8e92aa8b8f8c33",
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/collect-data-from-any-source/",
      "published_at": "2021-01-31T02:54:25Z",
      "updated_at": "2020-12-04T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Open source emitters. APIs. New Relic agents. Get data from anywhere. ",
      "body": "New Relic products report a lot of data ‚Äúout of the box.‚Äù When you use products like APM, Browser, Mobile, Infrastructure monitoring, or an integration, by default you receive performance data. But you may want to bring data into New Relic that isn't collected by default. Maybe you want an API-based solution that doesn't require install of an agent. Maybe you want to bring telemetry data from another analysis service into New Relic. This page describes several ways to get data into New Relic. Step 1 of 6 Agent APIs If you use our APM, Browser, or Mobile agents to report data, you can use their associated APIs to report custom data. For example, if you monitor your application with the our APM Python agent, you can use the Python agent API to set up custom instrumentation. See the agent APIs. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language wrappers for our Trace API and Metric API (and eventually our Log API and Event API). These SDKs let you easily send metrics and trace data to New Relic without needing to install an agent. For customers, we offer open-source exporters and integrations that use the Telemetry SDKs to send metrics and trace data: Istio adaptor Prometheus OpenMetrics (for Docker | for Kubernetes) OpenCensus exporter (for Go | for Python) DropWizard exporter Micrometer exporter Want to build your own solution? See our Telemetry SDK docs. Step 3 of 6 Trace API Our Trace API lets you send distributed tracing data to New Relic and consolidate tracing data from multiple sources in one place. We accept trace data in two formats: Zipkin format New Relic format (if you don‚Äôt have Zipkin-format data, you‚Äôd use this) bash Copy $ curl -i -X POST https://trace-api.newrelic.com/trace/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -H 'Data-Format: newrelic' \\ > -H 'Data-Format-Version: 1' \\ > -d '[ $ { $ \"common\": { $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host123.test.com\" $ } $ }, $ \"spans\": [ $ { $ \"trace.id\": \"123456\", $ \"id\": \"ABC\", $ \"attributes\": { $ \"duration.ms\": 12.53, $ \"name\": \"/home\" $ } $ }, $ { $ \"trace.id\": \"123456\", $ \"id\": \"DEF\", $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host456.test.com\", $ \"duration.ms\": 2.97, $ \"name\": \"/auth\", $ \"parent.id\": \"ABC\" $ } $ } $ ] $ } $ ]' Step 4 of 6 Metric API You can use our Metric API to send metric data to New Relic from any source. bash Copy $ curl -i -X POST https://metric-api.newrelic.com/metric/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"metrics\": [ $ { $ \"name\": \"memory.heap\", $ \"type\": \"gauge\", $ \"value\": 2.3, $ \"timestamp\": 1531414060739, $ \"attributes\": { $ \"host.name\": \"dev.server.com\" $ } $ } $ ] $ } $ ]' Step 5 of 6 Event API For sending arbitrary events to New Relic, you can use our Event API. We save these events as a new event type, which can then be queried via NRQL. (Eventually, the Telemetry SDKs will support the Event API.) bash Copy $ curl -i -X POST https://insights-collector.newrelic.com/v1/accounts/$ACCOUNT_ID/events \\ > -H \"Content-Type: application/json\" \\ > -H \"x-insert-key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"eventType\": \"LoginEvent\", $ \"service\": \"login-service\", $ \"customerId\": \"xyz\" $ } $ ]' Step 6 of 6 Log API If our existing logging integrations don‚Äôt meet your needs, you can use our Log API to send any arbitrary log data to New Relic. (Eventually, the Telemetry SDKs will support the Log API.) bash Copy $ curl -i -X POST https://log-api.newrelic.com/log/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ \"logs\": [ $ { $ \"timestamp\": 1593538496000, $ \"message\": \"User xyz logged in\", $ \"service\": \"login-service\", $ \"hostname\": \"login.example.com\" $ } $ ] $ ]'",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.110897,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> <em>APIs</em>",
        "info": "Open source emitters. <em>APIs</em>. New Relic <em>agents</em>. Get data from anywhere. ",
        "tags": "<em>Agent</em> <em>API</em>",
        "body": " their associated <em>APIs</em> to report <em>custom</em> data. For example, if you monitor your application with the our APM Python <em>agent</em>, you can use the Python <em>agent</em> <em>API</em> to set up <em>custom</em> instrumentation. See the <em>agent</em> <em>APIs</em>. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language wrappers for our Trace <em>API</em> and Metric"
      },
      "id": "5efa997128ccbc3c9a307dfd"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps",
        "Permissions for managing applications",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:55:31Z",
      "title": "Build apps",
      "updated_at": "2021-01-31T02:35:37Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Publish and deploy apps 30 min Start sharing the apps you build Permissions for managing applications ¬† Learn about permissions for subscribing to apps Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 896.8237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Publish <em>and</em> deploy <em>apps</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, <em>query</em>, and mutate data using Nerd<em>Storage</em> 45 min Nerd<em>Storage</em> is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. Add a time picker to your <em>app</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-query/",
      "sections": [
        "NerdGraphQuery",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "Methods",
        "NerdGraphQuery.render",
        "NerdGraphQuery.query",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:56:28Z",
      "title": "NerdGraphQuery",
      "updated_at": "2021-01-29T01:58:06Z",
      "type": "developer",
      "external_id": "1ada6e056e031c141b2bb989e4ec200b3a7ce988",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One SDK provides Query components based on ApolloClient's query components. These components are an abstraction layer making it easier to query NerdGraph without worrying about configuring Apollo Client and, for the most common use cases, without having to write GraphQL queries. A generic NerdGraph Query component that allows you to query anything from NerdGraph. Usage import { NerdGraphQuery } from 'nr1' Copy Examples Example 1 1 function render() { 2 const query = ` 3 query($id: Int!) { 4 actor { 5 account(id: $id) { 6 name 7 } 8 } 9 } 10 `; 11 12 const variables = { 13 id: 1, 14 }; 15 16 return ( 17 <NerdGraphQuery query={query} variables={variables}> 18 {({ loading, error, data }) => { 19 if (loading) { 20 return <Spinner />; 21 } 22 23 if (error) { 24 return 'Error!'; 25 } 26 27 return <BlockText>{data.actor.account.name}</BlockText>; 28 }} 29 </NerdGraphQuery> 30 ); 31 } Copy Props childrenfunction Render prop function as a child. function ( queryResult : {Object // Results of the query. ) => undefined fetchPolicyTypeenum DEFAULT NerdGraphQuery . FETCH_POLICY_TYPE . CACHE_AND_NETWORK Fetch policy to be used for the query. Allows you to specify how you want your query to interact with the cached data. CACHE_AND_NETWORK: The query returns your initial data from the cache if available. However, regardless of whether or not the full data is in your cache, the query always makes a request using your network interface and returns the updated data. This option is not available when using the static query() method of the component. CACHE_FIRST: The query makes a request using your network interface only if the data for your query is not already in the cache. CACHE_ONLY: The query never makes a request using your network interface. Instead it returns the data available in the cache. If the data for your query does not exist in the cache, then an error is thrown. NETWORK_ONLY: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. NO_CACHE: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. Unlike the NETWORK_ONLY policy, it does not write any data to the cache after the query completes. <One of NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_AND_NETWORK , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_FIRST , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NETWORK_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NO_CACHE , > pollIntervalnumber DEFAULT 0 Interval in milliseconds to poll for new data. queryrequiredstring|object GraphQL query, either as a string or a GraphQL document parsed into an AST by the gql method of nr1. Example 1 1 import { ngql } from 'nr1'; 2 3 const query = ngql` 4 { 5 actor { 6 user { 7 id 8 email 9 name 10 } 11 } 12 } 13 `; Copy variablesobject Object containing all the variables your query needs to execute. Methods NerdGraphQuery.render function () => undefined NerdGraphQuery.query function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 747.5254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em> provides <em>Query</em> <em>components</em> based on ApolloClient&#x27;s <em>query</em> <em>components</em>. These <em>components</em> are an abstraction layer making it easier to <em>query</em> NerdGraph without worrying about configuring Apollo Client and, for the most common use cases, without having to write GraphQL queries. A generic"
      },
      "id": "5efa999d28ccbc6bfd307ddb"
    },
    {
      "category_2": "Install plugins",
      "nodeid": 3276,
      "sections": [
        "Plugins for New Relic",
        "Get started",
        "Install plugins",
        "Custom dashboards and custom views",
        "Use a Plugin Central plugin",
        "Limited access to legacy plugins",
        "View plugin dashboard details",
        "Delete a plugin",
        "For more help"
      ],
      "title": "Use a Plugin Central plugin",
      "category_0": "Plugins",
      "type": "docs",
      "category_1": "Plugins for New Relic",
      "external_id": "87cd571d7a3530a85d10babe6f32ab7ad68ca788",
      "image": "",
      "url": "https://docs.newrelic.com/docs/plugins/plugins-new-relic/install-plugins/use-plugin-central-plugin",
      "published_at": "2021-01-31T06:58:23Z",
      "updated_at": "2021-01-27T06:54:14Z",
      "breadcrumb": "Contents / Plugins / Plugins for New Relic / Install plugins",
      "document_type": "page",
      "popularity": 1,
      "info": "How to navigate the user interface for plugins you install from Plugin Central in New Relic One.",
      "body": "Limited access For an even better experience than plugins, go to: newrelic.com/integrations: Integrate the on-host and cloud systems you already use with New Relic, so you can filter and analyze data, create dashboards, and set alerts within a single platform. developer.newrelic.com: Use developer tools to collect data from any source, automate workflows, build apps, and use our APIs. Limited access to legacy plugins As of December 2, 2020, plugin access has been limited to accounts that have accessed a legacy plugin in the past 30 days. The legacy plugin experience will reach end of life (EoL) as of June 16, 2021. For more information, see our Explorers Hub post. View plugin dashboard details Each plugin in Plugin Central includes procedures for how to install, use, troubleshoot, and uninstall it. Plugins in Plugin Central are not supported with accounts that host data in the EU region data center. After you install a plugin, it starts to receive data, usually within five minutes. The plugin automatically appears with a short name and icon on your Plugins menu in New Relic One. You do not need to select it from Plugin Central. The amount and types of information on the plugin's summary page and dashboards depend on the specific plugin. For example, a plugin may have one or more components (instances) and one or more dashboards. To view summary and dashboard details about the plugin: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's summary page, review the list of components or instances, summary metrics, and list of Recent Events. To view dashboard details about any component or instance, select its name. Plugin summary Depending on the plugin, the summary includes: One or more components or instances (what the plugin agent is monitoring, typically a host/port pair) Zero to five summary metrics for the past three minutes (values such as average, total, minimum, maximum, standard deviation, rate, or count) with optional alerts Recent events list, including deployments, notifications, and alerts Other information about alert violations, events, and activity If your plugin has 100 or more components or instances, you can search for a specific component instance. Here is a summary of additional standard features. If you want to... Do this... View version information for a component's or instance's agent Mouse over the component's name. Change the sort order On the title row of the plugin's summary page, select the up or down arrow for a component (instance) or a summary metric's label. Show or hide items on the events and activity list Select an event icon, or select All. View details about an event On the events and activity list, select the link. View page details for a component or instance Select the name or a summary metric for the component (instance). Plugin dashboards Depending on the plugin, it may have one or more dashboards, and each dashboard may present data as a chart or a table. You can use any of New Relic's standard dashboard features to drill down into detailed information. The customized dashboards that show plugin data are part of the plugin. Users cannot add or remove these dashboards. This must be done by the author or publisher as part of a plugin update. Plugin alerts If the plugin publisher set Critical (red) or Caution (yellow) alert conditions for your plugin's components or instances, you can view details direct in the user interface. For example, you can: Select and view alert details. Change the existing thresholds. Set your alert notification options; for example, to receive email notifications for Critical events. Delete a plugin Each plugin in Plugin Central includes procedures for how to uninstall it. When you select the plugin's Download or Continue button, the plugin should include a README file or refer to other documentation resources. Remove plugin components (instances) At a minimum, your plugin must stop reporting data before you start uninstalling it. Make sure the health status for your plugin's components (instances) are gray. Depending on the plugin, there may be other dependencies before disabling or uninstalling it. For example, plugins from SaaS providers may have different requirements. Be sure to review the instructions that the plugin's publisher provides. Then, to remove individual components from your plugin, click the settings settings icon for each component (instance). Delete the plugin After you remove each component (instance) for the plugin, the plugin icon will automatically disappear from your Plugins menu in the New Relic UI. You do not need to do anything else to delete the plugin. If you are the plugin's publisher and need to delete the plugin from Plugin Central, go to support.newrelic.com. For more help If you need more help, check out these support and learning resources: Review the documentation provided by the plugin publisher, or contact the publisher's support resources (identified in the plugin's Get support link). Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 745.3711,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Plugins for <em>New</em> <em>Relic</em>",
        "info": "How to navigate the user interface for plugins you install from Plugin Central in <em>New</em> <em>Relic</em> <em>One</em>.",
        "category_1": "Plugins for <em>New</em> <em>Relic</em>",
        "body": "Limited access For an even better experience than plugins, go to: newrelic.com&#x2F;integrations: Integrate the on-host and cloud systems you already use with <em>New</em> <em>Relic</em>, so you can filter and analyze data, create dashboards, and set alerts within a single <em>platform</em>. developer.newrelic.com: Use developer",
        "breadcrumb": "Contents &#x2F; Plugins &#x2F; Plugins for <em>New</em> <em>Relic</em> &#x2F; Install plugins"
      },
      "id": "5f2ef9b3196a67c2a0fbd721"
    },
    {
      "category_2": "Developer reference",
      "nodeid": 3816,
      "sections": [
        "Plugin developer resources",
        "Develop plugins",
        "Developer reference",
        "Use the Plugin API",
        "Limited access to legacy plugins",
        "Before you begin",
        "Metric data POST",
        "Data aggregation",
        "Compression",
        "Examples",
        "API responses and error codes",
        "For more help"
      ],
      "title": "Use the Plugin API",
      "category_0": "Plugins",
      "type": "docs",
      "category_1": "Plugin developer resources",
      "external_id": "2fb371510478182c54061139c68d9d770a8acf7f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/plugins/plugin-developer-resources/developer-reference/use-plugin-api",
      "published_at": "2021-01-31T11:57:55Z",
      "updated_at": "2021-01-27T13:30:14Z",
      "breadcrumb": "Contents / Plugins / Plugin developer resources / Developer reference",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use the Plugin API in any language to create plugin agents in New Relic's Plugin Central directory.",
      "body": "Limited access For an even better experience than plugins, go to: newrelic.com/integrations: Integrate the on-host and cloud systems you already use with New Relic, so you can filter and analyze data, create dashboards, and set alerts within a single platform. developer.newrelic.com: Use developer tools to collect data from any source, automate workflows, build apps, and use our APIs. Limited access to legacy plugins As of December 2, 2020, plugin access has been limited to accounts that have accessed a legacy plugin in the past 30 days. The legacy plugin experience will reach end of life (EoL) as of June 16, 2021. For more information, see our Explorers Hub post. Before you begin Using a development language other than Ruby, .NET, or Java for a plugin agent means you do not have an SDK to work with, but you do have some benefits. This is a guide for plugin developers to get started with writing an agent in any language that can work directly with the Plugin API for Plugin Central. You can use any language you want, as long as it supports sending JSON through HTTP POST. This allows for better integration with your systems. For the same reason, it is the best option for SaaS-based plugin agents. However, if you are not using the Plugins SDK for Java. .NET, or Ruby, you have some additional setup and planning to do in developing a plugin agent. This includes: Error tracking on POST calls A method for tracking and aggregating data when a POST fails Your own support plans if a New Relic SDK for your language or development tools is not available Any publicly available plugins in the Plugin Central should come bundled with their source code if the executable code is not plain text. This allows you to both try out plugins and to review the code. Recommendation: Before authoring a plugin, install some existing plugins using the Java SDK, .NET SDK, or Ruby SDK to see how they are written. Metric data POST Metric data is sent as an HTTP POST of JSON data using this URI: https://platform-api.newrelic.com/platform/v1/metrics The MIME-type for the POST is application/json. The Plugins feature is designed to receive a continuous stream of metrics at a certain maximum speed, and to present this information on useful charts. The recommended frequency for sending data to Plugins is to send 60 seconds worth of data once a minute. Agents sending data more frequently than twice a minute on average may be subject to enforced limits on the number of metrics being saved. The following are recommended soft limits. Requests smaller than this will work; requests larger than this are subject to rejection or automatic data aggregation. As a hard cap, the total size of the POST payload should be no larger than 1MB (10^6 bytes). If the metric is \"expensive\" to calculate and does not change quickly, consider writing your plugin agent so that it skips some polling cycles to retrieve data and then sends the last value. This produces better results for your plugin users' dashboards. Type Limit Description Components 500 Number of distinct components currently tracked. Please note this is a per POST limit only. More than 500 components are able to report to an account simultaneously. Metrics per component 10,000 Total number of unique metrics per component. Take precautions to ensure metric names are not generated too dynamically. Even if the number of metrics being sent in each individual post is small, over time they may add up to a large number of unique metrics. When the number of metrics for a given component exceeds this limit, the server may start aggregating metrics together by globbing segments of the metric name with an asterisk (*). Metrics per post 20,000 Number of metrics sent per post. A post may send data for multiple components in a single request as long as the total number of metrics in the request does not exceed this limit. Frequency of post 2 per minute Frequency of update. Agents are expected to send data no more frequently than 1 per minute. Data aggregation The SDKs manage data aggregation in the event of a failed POST. If you are not using an SDK, you need to manage this yourself. Include all five metric values in a POST: min, max, total, count, and sum or squares. (Exception: This may not be necessary for monotonic metrics where short term variation is not an issue.) Recompute these values for the accumulating metric data as required by what is being measured, incrementing the duration accordingly, until a successful POST is sent. Compression Data can be sent in the following encoding formats: identity deflate gzip If data is sent compressed, make sure the Content-Encoding header specifies the type of encoding. Examples Here are some examples for developing plugins. Example JSON This is an example of the JSON that would be used to POST data to Plugins. The JSON data is a hash with two required keys at the top level: agent: A hash describing the agent that is reporting metrics data to Plugins. A POST can contain information for only one agent. Host and version are required. components: An array of components, each consisting of a hash of attributes for the individual component. Multiple components can be sent with a single. Each component has its own name, GUID, duration, and metrics. { \"agent\": { \"host\" : \"db.internal.your_company.com\", \"pid\" : 1234, \"version\" : \"1.0.0\" }, \"components\": [ { \"name\": \"Primary MySQL Database\", \"guid\": \"com.your_company_name.plugin_name\", \"duration\" : 60, \"metrics\" : { \"Component/ProductionDatabase[Queries/Second]\": 100, \"Component/AnalyticsDatabase[Queries/Second]\": { \"min\" : 2, \"max\" : 10, \"total\": 12, \"count\" : 2, \"sum_of_squares\" : 104 } } } ] } Pseudo-code template This is a pseudo-code example that works with the Plugin API. It can be used as a template for developing plugin agents. Initialization: // globals string platform_api_uri = \"https://platform-api.newrelic.com/platform/v1/metrics\" int poll_cycle = 60 // time in seconds string version = \"1.0.0\" // major_version.minor_version.patch_level string agent_host = get_host_name_where_this_process_is_running() string agent_pid = get_process_id_of_this_process() time last_poll_time // initialize if necessary initialize once create agent_hash with: agent_host agent_pid version for each newrelic_account do // just handling one account? then \"for each\" is unnecessary complexity for each monitored_component do create component_hash with: string guid = \"com.your_company.component_name_in_snake_case\" string name =\"Human Readable Component Name\" int duration = 0 // this will get updated each poll_cycle hash metrics_hash // this will be updated by populate_component_metrics_hash() end end end Loop: every poll_cycle seconds do for each newrelic_account do // just handling one account? then \"for each\" is unnecessary complexity clear hash_to_send add agent_hash to hash_to_send for each component do populate_component_metrics_hash() this component.metrics_hash(\"duration\") = time.now() - last_poll_time in seconds add component.metrics_hash to hash_to_send end json_to_send = serialize_to_json(hash_to_send) connection = open http_connection(platform_api_uri) add header(\"X-License-Key\",this newrelic_account.license_key) to connection add header(\"Content-Type\",\"application/json\") to connection add header(\"Accept\",\"application/json\") to connection set http_verb to \"POST\" for connection response = send(json_to_send) to connection case response.code when response_code = 200 clear component.metrics_hash last_poll_time = time.now() when response_code = 400 // your request was malformed // consider reporting a \"supportability\" metric which counts the number of 400 responses you get // for example \"Component/Supportability/http_error_codes/400\" // you can use this on a \"Supportability\" Dashboard that helps diagnose your agent when response_code = 403 // forbidden probably due to a bad license key // log error and shutdown the agent when response_code = 404 // invalid URL // you should never get this error for https://platform-api.newrelic.com/platform/v1/metrics when response_code = 405 // invalid method // HTTP verb should be \"POST\" when response_code = 413 // POST body too large // try splitting at component boundaries // split along metric name spaces // fail gracefully - consider reporting a supportability metric (see 400) when response_code = 500 // error on New Relic's collector // could be due to malformed data or system trouble // fail gracefully - consider reporting a supportability metric (see 400) when response_code = 503 or 504 // New Relic collector busy //- this happens by design from time-to-time // keep collecting metrics // do NOT reset last_poll_time // log error if the problem persists for several minutes end case end end Metric population: function populate_component_metrics_hash() // collect metrics from monitored component at any interval // if this is the first time collecting metrics, set last_poll_time to // time.now - metric duration, the time duration for which these metrics // were collected // // if you collect 2 or more metrics from the monitored component before data // is reported to Plugins either because your metric collection interval is // faster than poll_cycle or because your agent was unable to report metrics to // Plugins (for example a 503 http response), aggregate your data by storing: // total_value, max, min, count, sum_of_squares for each metric // // if the interval is longer than poll_cycle, retain the metrics and // report them each poll_cycle until they are updated end API responses and error codes Depending on whether you are using the Plugin API or an agent SDK for plugins, the HTTP responses and logging techniques may be different. For example, responses for the Plugin API are uncompressed JSON. Successful posts return this JSON: {\"status\":\"ok\"} The API does not support Accept-Encoding. Debugging logs To debug information, use either of these options: public static Logger getLogger(); OR public static void Logger setLogger(Logger logger) { LOGGER = logger; } Error codes If an error occurs, an appropriate status code is returned. The JSON returned is the hash key error with a detailed description of the error that occurred. For example: {\"error\":\"Failed to create agent with parameters=[...]\"} {\"error\":\"Missing metric data\"} {\"error\":\"Unable to parse body: Unexpected token RIGHT BRACE(}) at position 228.\"} Code Name Description 400 Bad request The request or headers are in the wrong format, or the URL is incorrect, or the GUID does not meet the validation requirements. 403 Unauthorized Authentication error (no license key header, or invalid license key). 404 Not found Invalid URL. 405 Method not allowed Returned if the method is an invalid or unexpected type (GET/POST/PUT/etc.). 413 Request entity too large Too many metrics were sent in one request, or too many components (instances) were specified in one request, or other single-request limits were reached. 500 Internal server error Unexpected server error. 502 Bad gateway All 50X errors mean there is a transient problem in the server completing requests, and no data has been retained. Clients are expected to resend the data after waiting one minute. The data should be aggregated appropriately, combining multiple timeslice data values for the same metric into a single aggregate timeslice data value. 503 Service unavailable See 502 description. 504 Gateway timeout See 502 description. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 649.36163,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "API responses <em>and</em> error codes",
        "info": "How to use the Plugin API in any language to create plugin agents in <em>New</em> <em>Relic&#x27;s</em> Plugin Central directory.",
        "body": "Limited access For an even better experience than plugins, go to: newrelic.com&#x2F;integrations: Integrate the on-host and cloud systems you already use with <em>New</em> <em>Relic</em>, so you can filter and analyze data, create dashboards, and set alerts within a single <em>platform</em>. developer.newrelic.com: Use developer"
      },
      "id": "5f33aaef28ccbcfce688dffd"
    },
    {
      "category_2": "Get started",
      "nodeid": 3241,
      "sections": [
        "Plugins for New Relic",
        "Get started",
        "Install plugins",
        "Custom dashboards and custom views",
        "Plugin security",
        "Limited access to legacy plugins",
        "Open community",
        "Third-party content",
        "Source code",
        "Access to license keys",
        "Access rights",
        "Plugin storage",
        "For more help"
      ],
      "title": "Plugin security",
      "category_0": "Plugins",
      "type": "docs",
      "category_1": "Plugins for New Relic",
      "external_id": "6d55258e161104037c0f84b6501aa3e525a39dd8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/plugins/plugins-new-relic/get-started/plugin-security",
      "published_at": "2021-01-31T06:45:11Z",
      "updated_at": "2021-01-27T04:52:10Z",
      "breadcrumb": "Contents / Plugins / Plugins for New Relic / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "For an overview of security measures for plugins published in New Relic's Plugin Central, start here.",
      "body": "Limited access For an even better experience than plugins, go to: newrelic.com/integrations: Integrate the on-host and cloud systems you already use with New Relic, so you can filter and analyze data, create dashboards, and set alerts within a single platform. developer.newrelic.com: Use developer tools to collect data from any source, automate workflows, build apps, and use our APIs. Limited access to legacy plugins As of December 2, 2020, plugin access has been limited to accounts that have accessed a legacy plugin in the past 30 days. The legacy plugin experience will reach end of life (EoL) as of June 16, 2021. For more information, see our Explorers Hub post. Open community New Relic's Plugins tool been designed to be open and extensible, so that any New Relic user, developer, technology vendor, or partner may publish publicly accessible plugins within Plugin Central. Anyone who has a New Relic account can install and use these plugins through their New Relic user interface. Exception: Plugins in Plugin Central are not supported with accounts that host data in the EU region data center. Having an open community where users both create and consume plugins can raise questions surrounding security. This document intends to address any security considerations for using these plugins. For more information about New Relic's security measures, see our security and data privacy documentation, or visit the New Relic security website. Third-party content For some plugins, New Relic, Inc. is the publisher, and will be clearly identified as the publisher. However, as an open resource, many plugins are created by our partners and third-party developers. Every plugin in the Plugin Central directory clearly identifies whether it was published by a New Relic developer or by a third party. We require plugin publishers to provide an About link to their website, documentation about what the plugin is for and how to use it, and a link to obtain support when using the plugin. We also require plugin publishers to review and accept the Developer Terms of Service Agreement before they can make their plugin publicly accessible. You can review all information provided by the publisher before installing any plugin. Only those plugins that identify New Relic, Inc. as the publisher fall under New Relic's posted privacy policy. For more information, see the New Relic security website. For other plugins, refer to the publisher's security and compliance statements. Source code If you have any concerns about plugins developed with the SDKs for plugins, you can review the source code and verify that the plugin agents behave as expected. The plugin agent's code is light, and it can be reviewed in minutes. Access to license keys Always keep your New Relic license key private. Typically access to your license key is needed only to record metric data or deployments for your applications, hosts, or plugins that are monitored by New Relic, not to introduce new data or code. No other access is allowed. Access rights When developing a plugin agent, authors and publishers need to consider the environment in which they will be run. You should do everything possible to reduce the level of permissions your plugin users need to grant to the agent in order for it to run correctly. In particular: Unless it is absolutely necessary, do not require su or sudo permissions in order to install your agent or support software on your users' computers. In this situation, the requirements should be limited in scope and well-documented. For additional information about access rights for plugin users, see the documentation about installing a plugin. When running your agent on the users' computers, do not require su or sudo permissions. The components (instances) your plugin agent is monitoring should only need to grant read-only permissions in order for your agent to perform its actions. As much as possible, the components (instances) your plugin agent is monitoring should be able to reduce the levels of information and access needed. When documenting your plugin, describe what level of permissions your plugin agent requires from the components (instances) it is monitoring and why this is necessary. Following these steps will make it easier for your plugin users to install your agent and increase their confidence that your agent cannot harm their components or instances being monitored. This will also reduce the likelihood of user problems if your agent has any serious bugs or other defects. Plugin storage Plugins only need access to their monitored systems and New Relic simply to report metrics. You may want to consider running plugin agents in sequestered systems with limited network access that allow no more than the minimum required network access. Also, data retention for plugins follows New Relic's standard policies. If you have any concerns about deploying any plugin from Plugin Central, follow your organization's guidelines. If for any reason you do not trust the source of an existing plugin, try creating your own version. For more help If you need more help, check out these support and learning resources: Review the documentation provided by the plugin publisher, or contact the publisher's support resources (identified in the plugin's Get support link). Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 635.5372,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Plugins for <em>New</em> <em>Relic</em>",
        "info": "For an overview of security measures for plugins published in <em>New</em> <em>Relic&#x27;s</em> Plugin Central, start here.",
        "category_1": "Plugins for <em>New</em> <em>Relic</em>",
        "body": "Limited access For an even better experience than plugins, go to: newrelic.com&#x2F;integrations: Integrate the on-host and cloud systems you already use with <em>New</em> <em>Relic</em>, so you can filter and analyze data, create dashboards, and set alerts within a single <em>platform</em>. developer.newrelic.com: Use developer",
        "breadcrumb": "Contents &#x2F; Plugins &#x2F; Plugins for <em>New</em> <em>Relic</em> &#x2F; Get started"
      },
      "id": "540a9264c75d073d3d00063c"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "Automate workflows",
      "updated_at": "2021-01-30T01:54:22Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.13376,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up New Relic using the <em>Kubernetes</em> <em>operator</em>",
        "body": " Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple &quot;Hello World&quot; Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Set up New Relic using the <em>Kubernetes</em> <em>operator</em> 20"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Create NRQL alert conditions",
        "Create a NRQL alert condition",
        "NRQL alert syntax",
        "NRQL alert threshold examples",
        "Nested aggregation NRQL alerts",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Evaluation offset",
        "Fill data gaps",
        "How to edit data gap values:",
        "Gap filling options:",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2021-01-31T14:34:38Z",
      "updated_at": "2021-01-31T14:34:38Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions, but not baseline or static Include an optional FACET clause in your NRQL syntax depending on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ‚Äã‚Äã‚Äã‚Äã‚Äã Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)‚Äã‚Äã Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. The default streaming aggregation window duration is 1 minute. The minimum aggregation window is 30 seconds. The maximum is 15 minutes. Baseline thresholds don't support configurable aggregation window durations. They use the 1 minute default. You can adjust the evaluation offset to coordinate the streaming algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. If your data is sporadic or has aggregation windows that may not have data, you can fill those gaps with a custom value or the last known value. The default value is None. To learn more about gap filling and how to request access to it, see this announcement Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you can't use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Evaluation offset For data that consistently takes longer to arrive, you can use offset evaluation to consistently delay the NRQL condition evaluation. Waiting longer increases accuracy, but also increases latency. The aggregation window and offset evaluation toggles let you choose how to handle gaps in your streaming alerts data. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the event type data comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with None, the last value received, or a static value. How to edit data gap values: In the NRQL conditions UI under Condition settings > Advanced signal settings > fill data gaps with, and then choose None, Last known value, or Custom static value. In the Nerdgraph API (preferred), you'll find this node located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue In the REST API Explorer, you'll see this under the \"signal\" section of the Alert NRQL conditions API. Gap filling options: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.025986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "sections": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "info": "How to define thresholds that trigger <em>alert</em> notifications based on your <em>NRQL</em> queries.",
        "category_0": "<em>Alerts</em> and Applied Intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "category_2": "<em>Alert</em> <em>conditions</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>alerts</em>-applied-intelligence&#x2F;new-relic-<em>alerts</em>&#x2F;<em>alert</em>-<em>conditions</em>&#x2F;create-<em>nrql</em>-<em>alert</em>-<em>conditions</em>",
        "body": "You can use <em>NRQL</em> queries to create <em>alert</em> <em>conditions</em>. Once you&#x27;ve defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts &amp; AI",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; New Relic Alerts &#x2F; <em>Alert</em> <em>conditions</em>"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "Alerts release notes",
      "nodeid": 41831,
      "sections": [
        "New Relic Platform release notes",
        "Alerts release notes",
        "APM release notes",
        "Cloud Integrations release notes",
        "Diagnostics release notes",
        "Mobile release notes",
        "Kubernetes integration release notes",
        "1-12-2021 : Alerts: NR1 Native NRQL Conditions Form Released",
        "New"
      ],
      "title": "1-12-2021 : Alerts: NR1 Native NRQL Conditions Form Released",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "New Relic Platform release notes",
      "external_id": "b707c795ff0c93e305eac40cd8d2aefef6483482",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/platform-release-notes/alerts-release-notes/1-12-2021-alerts-nr1-native-nrql-conditions-form-released",
      "published_at": "2021-01-31T13:26:05Z",
      "updated_at": "2021-01-16T15:19:08Z",
      "breadcrumb": "Contents / New Relic Platform Release Notes / Alerts release notes",
      "document_type": "release_notes_platform",
      "popularity": 1,
      "body": "[RSS] Released on:¬† January 12, 2021 New Alerts has released an updated UI for creating and managing NRQL Alert Conditions, all while maintaining existing functionality. Some notable changes include: Adds ability to visualize the aggregation window and evaluation offset of the NRQL Alert Condition within preview charts. Improved page rendering performance and user experience. Configure warning and critical thresholds with differing operators (above, below, equals) for static NRQL Alert Conditions. Allows violation time limit to be configured in minutes. NRQL Baseline Conditions will now display the threshold value in the UI. The ability to change the threshold type for previously saved NRQL conditions has been removed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.06734,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "1-12-2021 : <em>Alerts</em>: NR1 Native <em>NRQL</em> <em>Conditions</em> Form Released",
        "sections": "1-12-2021 : <em>Alerts</em>: NR1 Native <em>NRQL</em> <em>Conditions</em> Form Released",
        "category_2": "<em>Alerts</em> release notes",
        "body": "[RSS] Released on:¬† January 12, 2021 New Alerts has released an updated UI for creating and managing <em>NRQL</em> <em>Alert</em> <em>Conditions</em>, all while maintaining existing functionality. Some notable changes include: Adds ability to visualize the aggregation window and evaluation offset of the <em>NRQL</em> <em>Alert</em> Condition"
      },
      "id": "6001ff8528ccbcec6f3f6fc6"
    },
    {
      "category_2": "Get started",
      "nodeid": 35591,
      "sections": [
        "Prometheus integrations",
        "Get started",
        "Install and configure remote write",
        "Install and configure OpenMetrics",
        "View and query data",
        "Troubleshooting",
        "Send Prometheus metric data to New Relic",
        "Prometheus OpenMetrics or remote write integration?",
        "Prometheus remote write integration",
        "Scale your data and get moving quickly",
        "How it works",
        "Remote write compatibility and requirements",
        "Prometheus OpenMetrics integrations",
        "Reduce overhead and scale your data",
        "OpenMetrics integrations compatibility and requirements",
        "What's next",
        "For more help"
      ],
      "title": "Send Prometheus metric data to New Relic",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Prometheus integrations",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/integrations/prometheus-integrations/get-started/send-prometheus-metric-data-new-relic",
      "external_id": "6c428c6e9de90f131fdc412adc5ccfbf0eaf21a7",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/OpenMetrics%20Kube%20for%20Stitched%20Path.png",
      "url": "https://docs.newrelic.com/docs/integrations/prometheus-integrations/get-started/send-prometheus-metric-data-new-relic",
      "published_at": "2021-01-31T14:22:02Z",
      "updated_at": "2021-01-31T14:22:02Z",
      "breadcrumb": "Contents / Integrations / Prometheus integrations / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic's Prometheus integrations options. ",
      "body": "This page provides an overview of New Relic's Prometheus integration options and how they work. The information here will help you choose from among our options based on which one best fits your unique business needs. Prometheus OpenMetrics or remote write integration? We currently offer two integration options: Prometheus remote write integration and Prometheus OpenMetrics integration for Kubernetes or Docker. We recommend getting started with the remote write integration if you already have a Prometheus server install base. If you find it hard to manage your Prometheus cluster, or if you are getting started with integrating Prometheus Metrics, you should use OpenMetrics. Prometheus remote write integration Prometheus OpenMetrics for Kubernetes or Docker Benefits Use this if you currently have Prometheus servers and want an easy way to access your combined metrics from New Relic. It only takes one line of yaml in your Prometheus configuration. You'll be able to access your metrics through both New Relic and Prometheus. You don't need to make any additional adjustments for data to remain available in Prometheus. Federation: Allows you to combine data from multiple servers into a single source. Prometheus High Availability support: We de-duplicate data from HA-pairs on ingest. Use this if you‚Äôre looking for an alternative or replacement to a Prometheus server that stores all your metrics directly in New Relic. You won‚Äôt have to manage any Prometheus servers yourself. You don't need local storage. Keep in mind You will still need to manage your Prometheus servers, although you should be able to reduce your storage retention, and there‚Äôll be fewer query loads to the server. Slightly more complex setup. No support for High Availability replicas. The Kubernetes operator is not available for enhanced operations automation. Recommendations Evaluate your observability needs to manage your data volumes better: The scrape interval is the biggest factor influencing data volumes: select it based on your observability needs. For example, changing from 15s (default value) to 30s can reduce data volumes by 50%. Set your filters and configure data to target (see metrics or targets). Balance remote write(s) between one or more new relic accounts or sub-accounts to manage rate limits. Regardless of the option you chose, with our Prometheus integrations: You can use Grafana or other query tools via New Relic's Prometheus' API. You benefit from more nuanced security and user management options as part of New Relic One. The New Relic Telemetry Data Platform can be the centralized long-term data store for all your Prometheus metrics, allowing you to observe all your data in one place. You can execute queries to scale, supported by New Relic. Prometheus remote write integration The Prometheus remote write integration allows you to forward telemetry data from your existing Prometheus servers to New Relic. Once integrated, you can leverage the full range of options for setup and management, from raw data to queries, dashboards, and more. Scale your data and get moving quickly With the Prometheus remote write integration, you can: Store and visualize crucial metrics on a single platform Combine and group data across your entire software stack Get a fully connected view of the relationship between data about your software stack and the behaviors and outcomes you‚Äôre monitoring Connect your Grafana dashboards (optional). Prometheus remote write dashboard How it works Signup for New Relic is fast and free ‚Äî we won't even ask for a credit card number. Once logged in, you can get data flowing with a few simple steps: Generate your remote_write URL. Add the new remote_write URL to the configuration file for your Prometheus server. Restart your Prometheus server. Check for your data. Query and explore! Read the setup docs Add Prometheus data Remote write compatibility and requirements New Relic supports the Prometheus remote write integration for Prometheus versions 2.15.0 or newer. Prometheus OpenMetrics integrations New Relic‚Äôs Prometheus OpenMetrics integrations for Docker and Kubernetes allow you to scrape Prometheus endpoints and send the data to New Relic, so you can store and visualize crucial metrics on one platform. With these integrations, you can: Automatically identify a static list of endpoints. Collect metrics that are important to your business. Query and visualize this data in the New Relic UI. Connect your Grafana dashboards (optional). Kubernetes OpenMetrics dashboard Reduce overhead and scale your data Collect, analyze, and visualize your metrics data from any source, alongside your telemetry data, so you can correlate issues all in one place. Out-of-the-box integrations for open-source tools like Prometheus make it easy to get started, and eliminate the cost and complexity of hosting, operating, and managing additional monitoring systems. Prometheus OpenMetrics integrations gather all your data in one place, and New Relic stores the metrics from Prometheus. This integration helps remove the overhead of managing storage and availability of the Prometheus server. To learn more about how to scale your data without the hassles of managing Prometheus and a separate dashboard tool, see New Relic's Prometheus OpenMetrics integration blog post. Kubernetes In a Kubernetes environment, New Relic automatically discovers the endpoints in the same way that the Prometheus Kubernetes collector does it. The integration looks for the prometheus.io/scrape annotation or label. You can also identify additional static endpoints in the configuration. Docker The Prometheus OpenMetrics integration gathers all your data in one place, and New Relic stores the metrics from Prometheus. This integration helps remove the overhead of managing storage and availability of the Prometheus server. OpenMetrics integrations compatibility and requirements For Kubernetes and Docker OpenMetrics integrations, you should be aware of the following compatibility and requirements information. Kubernetes New Relic has contributed the Prometheus integration to the open source community under an Apache 2.0 license. This integration supports Prometheus protocol version 2 and Kubernetes versions 1.9 or higher. The integration was tested using Kubernetes 1.9, 1.11, and 1.13 on kops, GKE, and minikube. Limits apply to the metrics you send. For more details, see the metrics API documentation. Recommendation: Always run the scraper with one replica. Adding more replicas will result in duplicated data. Docker New Relic has contributed the Prometheus integration to the open source community under an Apache 2.0 license. This integration supports Prometheus protocol version 2. The integration was tested using Docker 1.9, 1.11, and 1.13 on kops, GKE, and minikube. Limits apply to the metrics you send. For details, see the metrics API documentation. What's next Ready to get moving? Here are some suggested next steps: Read the how-to for completing the remote write integration. Learn about Grafana support options. Explore the range of other options available as part of the Telemetry Data Platform. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.92269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " don&#x27;t need local storage. Keep in mind You will still need to manage your Prometheus servers, although you should be able to reduce your storage retention, and there‚Äôll be fewer query loads to the server. Slightly more complex setup. No support for High Availability replicas. The <em>Kubernetes</em> <em>operator</em>"
      },
      "id": "5f5c75d9196a67621bce6a52"
    },
    {
      "category_2": "Understand and use data",
      "nodeid": 37981,
      "sections": [
        "Elastic Container Service integration",
        "Get started",
        "Install",
        "Understand and use data",
        "Troubleshooting",
        "Recommended ECS alert conditions",
        "Recommended alert conditions",
        "For more help"
      ],
      "title": "Recommended ECS alert conditions",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Elastic Container Service integration",
      "external_id": "304f01e7a5c68e9ef4dc76782eb9ff6847854065",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/elastic-container-service-integration/understand-use-data/ecs-integration-recommended-alert-conditions",
      "published_at": "2021-01-31T11:55:13Z",
      "updated_at": "2020-08-06T00:29:40Z",
      "breadcrumb": "Contents / Integrations / Elastic Container Service integration / Understand and use data",
      "document_type": "page",
      "popularity": 1,
      "info": "Tips for useful alert conditions to set for New Relic's Amazon ECS integration. ",
      "body": "New Relic's ECS integration reports and displays performance data from your Amazon ECS environment. This document provides some recommended alert conditions for monitoring ECS performance. Recommended alert conditions Here are some recommended ECS alert conditions. To add these alerts, go to the Alerts UI and add the following NRQL alert conditions to an existing or new alert policy: High CPU usage NRQL: FROM ContainerSample SELECT cpuUsed / cpuLimitCores Critical: > 90% for 5 minutes High memory usage NRQL: FROM ContainerSample SELECT memoryUsageBytes / memorySizeLimitBytes Critical: > 80% for 5 minutes Restart count NRQL: FROM ContainerSample SELECT max(restartCount) - min(restartCount) Critical: > 5 for 5 minutes For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 54.430164,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "sections": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "info": "Tips for useful <em>alert</em> <em>conditions</em> to set for New Relic&#x27;s Amazon ECS integration. ",
        "body": " to the Alerts UI and add the following <em>NRQL</em> <em>alert</em> <em>conditions</em> to an existing or new <em>alert</em> policy: High CPU usage <em>NRQL</em>: FROM ContainerSample SELECT cpuUsed &#x2F; cpuLimitCores Critical: &gt; 90% for 5 minutes High memory usage <em>NRQL</em>: FROM ContainerSample SELECT memoryUsageBytes &#x2F; memorySizeLimitBytes Critical: &gt; 80"
      },
      "id": "5ee05e9e28ccbcef4f4c8dda"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:54:25Z",
      "title": "Collect data",
      "updated_at": "2021-01-30T01:52:06Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add custom attributes ¬† Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.02657,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " <em>custom</em> <em>attributes</em> ¬† Use <em>custom</em> <em>attributes</em> for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create <em>custom</em> events 5 min Define, visualize, and get alerts on the data you want using <em>custom</em> events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with <em>NRQL</em> 10 min Query default data, <em>custom</em> events, and <em>attributes</em>"
      },
      "id": "5efa997328ccbc768c307de2"
    },
    {
      "category_2": "Exceptions",
      "nodeid": 10646,
      "sections": [
        "Mobile monitoring UI",
        "Mobile App pages",
        "Network pages",
        "Exceptions",
        "Usage pages",
        "Crash analysis: Group and filter your crashes",
        "Use crash analysis features",
        "View the crash list",
        "Use the crash analysis workflow",
        "Configure crash report email settings",
        "For more help"
      ],
      "title": "Crash analysis: Group and filter your crashes",
      "category_0": "Mobile",
      "type": "docs",
      "category_1": "Mobile monitoring UI",
      "external_id": "32a11c727dacfa983ff7b4772776a210cc5ae2f0",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/mobile-crash-profiles.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/crash-analysis-group-filter-your-crashes",
      "published_at": "2021-01-31T09:04:05Z",
      "updated_at": "2021-01-31T09:04:05Z",
      "breadcrumb": "Contents / Mobile / Mobile monitoring UI / Exceptions",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's crash analysis features to identify and deal with DevOps issues for resolving unanticipated exceptions with mobile apps.",
      "body": "Mobile app crashes can result in users submitting negative reviews, which can affect your organization's reputation. Crashes can also result in users deleting your app altogether, which affects your organization's profitability. With the Crash analysis UI, you can identify and deal with one of the largest bottlenecks in the development lifecycle: the time it takes to resolve unanticipated exceptions. Use crash analysis features When your development team receives an emailed crash notification, they can select the email link to review detailed information about the crash in our user interface, or analyze chart data directly through a query. The individual Crash details page also includes tracking tools for your team to follow the issue from reporting to resolution. Our crash analysis feature helps developers to: Slice and dice your crash and network data (using groups and filters) to analyze trends leading to the crash. Understand a particular user's experience by using a custom attribute. Pinpoint when most crashes occur; for example, by filtering by Last Interaction, or by viewing the interaction trail in the Crash report page. Align issues with common characteristics in networks or devices. Examine specific problems in a crash report that may be buried in thread breakdown data, trace details, or the trail of user interactions in the crashed session. Quickly see trends from the Crash profiles tab. View the crash list To view the filterable Crash list in the New Relic UI: Go to one.newrelic.com > Mobile > (select an app) > Exceptions > Crash analysis. OR To view the filterable Crash analysis page directly from the mobile app's Overview page, select the Crash occurrences chart's title. Use any of our standard page functions to drill down into detailed information; for example, zoom into any area of a chart. Use the crash analysis workflow To get the most out of Mobile monitoring's Crash analysis UI, use this basic workflow. Start with the Crash rate percentage and Crash-free users percentage charts to see at a glance whether there are any unexpected spikes, dips, or patterns with crash time frames, or uneventful periods within the selected time period. Use the groups and filters to examine attributes (for crashes, devices, locations, or other custom attributes) in more detail. Use the Top 5 occurrences chart to identify patterns for the type of occurrence you selected from the groups and filters. Also correlate any general patterns for the selected type of occurrence to crash percentages that occurred during this time period. Optional: Query or share the chart data. Look for patterns in the Crash location table information, including location, exception type, date and number of occurrences, version, and number of users affected by the crash. Select a crash report from the table to view its interaction trail, its event trail, thread details for individual occurrences, attributes, and more. If necessary, resymbolicate or export the crash details to Xcode so you can debug your source code more easily. When finished, mark the crash occurrences as Resolved. Resolved crashes include a banner identifying who resolved the crash and when. Based on Mobile monitoring's data retention policies, you can filter by resolved crashes when you need to track back to historical information. Crash percentages charts: See patterns immediately. Start with the Crash rate percentage and Crash-free users percentage charts to see at a glance whether there are any unexpected spikes, dips, or patterns with crashes in general. For example: Are there any spikes near a recent version release? Is there a time period when the percentage of users has been affected significantly by the crash? (If the Crash-free users percentage chart is empty, there were no user sessions during the selected time period.) Groups and filters: Slice and dice the crash data. You can select a group, and then filter to specific data, including: Group the crash list by type of crash, device, location, or other custom attributes. Show open crashes, resolved crashes, or all crashes. Use the time picker to adjust the currently selected time period. Filter by a specific Version or by one or more attribute Filter, such as Last Interaction, App Build, or any of the longer list of standard and custom attributes). The selected filters appear at the top of the UI page. Top five occurrences: Analyze specific characteristics. Use the Top 5 occurrences chart to identify what types of crashes and how many occurred during the selected time period. This chart shows the top five crash occurrences by the group and filters you select. For example, you can group by email address (if instrumented as a custom attribute), then filter down to a specific email to examine that user's experience. To filter or group by other attributes, use the search window, or select any of the available filters. For example, filter by type of crash, device, a specific location, or any custom attributes. To look for other historical patterns, change the selected time period. one.newrelic.com > Mobile > (select an app) > Exceptions > Crash analysis: Here is an example of the Top 5 occurrences chart filtered by the Crash locations group. Select any groups or filters to analyze your crash data any way you want. Queries and image links: Query crash data and share charts with others. Mobile monitoring's Crash analysis charts use default attributes for mobile events, along with any custom attributes you have added to this event type. To view or share the data, click the ellipsis icon. Add to dashboard link: View the chart, and copy it to a new or existing dashboard. View query link: View the NRQL query used to calculate the chart data. Get as image link: Select this option to get a public URL of the chart, then share it using any media. Crash reports: Dive into the interaction trail, thread breakdown, and more. Supplementing the charts, the Crash report table lists crash types by location, and links them to relevant crash report details. Each row helps you find answers to questions such as: How many of this crash type or exception occurred within the selected time period? What is the most recent exception message? Does a specific app version have a higher (or lower) number of users affected? When did the exception first and last occur? one.newrelic.com > Mobile > (select an app) > Exceptions > Crash analysis: Sort on any column to analyze patterns in the Crash reports table, then select any report to review crash details. Sometimes it may be more useful to examine crash report data from lowest to highest. For example: Which exception has the fewest number of occurrences? When did a particular exception start (Earliest occurrence)? You can change the sort order or filter options to focus on just the types of exceptions that matter the most to you and your teams. Crash profiles: Quickly see key differences between crashed and crash-free accounts. Crash profiles provide quick, clear insight into your mobile crash data by surfacing any anomalies in your mobile application‚Äôs performance. Unexpected differences between attributes and behaviors are highlighted, illuminating key differences between crashed and crash-free accounts. You can quickly pinpoint key issues through drill-downs and filters for a fast, streamlined troubleshooting experience. one.newrelic.com > Mobile > (select an app) > Exceptions> Crash analysis > Crash profiles: Compare crashed and crash-free sessions. Crash event trail: See all the events leading up to a crash. The mobile monitoring crash event trail shows you the events leading up to a crash of a mobile app. These can be events monitored by default, or custom events you've created. For more information, see Crash event trail. Examine crash report details: Export to Xcode or resymbolicate your source code. From the Crash report table, you can drill down into a specific Crash report. From here you can: Examine the interaction trail from session start through the crash event. Explore the related thread breakdown. Select Export crash details so you can examine source code using Xcode. Resymbolicate the crash report for easier debugging. File a ticket, and resolve the crash. one.newrelic.com > Mobile > (select an app) > Crashes > Crash report: This is an example of an interaction trail that includes the option to resymbolicate the crash occurrence. To analyze and debug your source code using Xcode, select Export crash details. Configure crash report email settings To learn how to configure email settings, see Email settings. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.043365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "&#x27;s Crash analysis charts use default <em>attributes</em> for mobile events, along with any <em>custom</em> <em>attributes</em> you have added to this event type. To view or share the data, click the ellipsis icon. Add to dashboard link: View the chart, and copy it to a new or existing dashboard. View query link: View the <em>NRQL</em>"
      },
      "id": "58181a9a8e9c0f431dbd4fce"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:03:13Z",
      "title": "New Relic Developers",
      "updated_at": "2021-01-30T01:38:00Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 25 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.37814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " application Add <em>custom</em> <em>attributes</em> ¬† Use <em>custom</em> <em>attributes</em> for deeper analysis Show 25 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "category_2": "API guides",
      "nodeid": 11521,
      "sections": [
        "Java agent",
        "Getting started",
        "Installation",
        "Additional installation",
        "Heroku",
        "Configuration",
        "Attributes",
        "Features",
        "Instrumentation",
        "Custom instrumentation",
        "API guides",
        "Async instrumentation",
        "Troubleshooting",
        "Guide to using the Java agent API",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples",
        "For more help"
      ],
      "title": "Guide to using the Java agent API ",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Java agent",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "external_id": "a31c751c7c29dd46effac2e568f7c0a92b033b18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "published_at": "2021-01-31T08:21:44Z",
      "updated_at": "2021-01-31T08:21:43Z",
      "breadcrumb": "Contents / APM agents / Java agent / API guides",
      "document_type": "page",
      "popularity": 1,
      "info": "A goal-focused guide to New Relic's Java agent API, with links to relevant sections of the complete API documentation on GitHub.",
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() For more on obtaining references to the current transaction and other API classes, see Obtain references. API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) For more on obtaining references to the current transaction and other API classes, see Obtain references. API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events to Insights. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the first call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.53327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Attributes</em>",
        "body": " the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add <em>custom</em> <em>attributes</em>"
      },
      "id": "5a3137f4e621f4576cf1e35f"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2021-01-31T04:06:56Z",
      "updated_at": "2021-01-23T15:02:43Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.11565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> event data",
        "sections": "<em>Custom</em> events",
        "info": "For New Relic, general limits and requirements for reporting <em>custom</em> events and <em>attributes</em>. ",
        "category_2": "<em>Custom</em> events",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;insights-data-sources&#x2F;<em>custom</em>-data&#x2F;insights-<em>custom</em>-data-requirements-limits",
        "body": "You can report <em>custom</em> events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using <em>custom</em> events and their associated <em>attributes</em>. Additional requirements",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Event data sources &#x2F; <em>Custom</em> events"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies üç™"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2021-01-31T02:54:25Z",
      "updated_at": "2020-12-04T02:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.41741,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "body": ", publish it to New Relic One, and share it with others by subscribing accounts to it. <em>Map</em> pageviews by <em>region</em> takes you through the steps to create one of our popular open source apps. You learn to add a <em>custom</em> query to an <em>app</em> and <em>view</em> it in a table, then add that data to a <em>map</em>. Contribute"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "category_2": "Incident intelligence",
      "nodeid": 35686,
      "sections": [
        "Applied intelligence",
        "Proactive detection",
        "Incident intelligence",
        "Incident workflows",
        "Get started with Incident Intelligence",
        "How it works",
        "Set up Incident Intelligence",
        "1. Configure your environment (one-time)",
        "2. Configure sources",
        "3. Configure destinations",
        "Custom notification message",
        "4. Configure pathways",
        "Visual Timeline",
        "Related Activity",
        "Issue Summary",
        "Use decisions",
        "Use suggested responders",
        "EU and US datacenter and Incident Intelligence data",
        "For more help"
      ],
      "title": "Get started with Incident Intelligence",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "Applied intelligence",
      "external_id": "b4c4f1ea20303d95256e09ce99271f5302fa53f1",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/issue_feed.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence",
      "published_at": "2021-01-31T08:52:16Z",
      "updated_at": "2021-01-31T08:52:16Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / Applied intelligence / Incident intelligence",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about how to use Incident Intelligence to create an overview of all your alert incidents, their sources, and related events.",
      "body": "As part of Applied Intelligence, Incident Intelligence helps you correlate your incidents and reduce noise in your environment. It gives you an overview of all your incidents, their sources, and related events. To use Incident Intelligence and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. How it works After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Set up Incident Intelligence To enable Incident Intelligence, follow these four steps. Afterwards, issues should start to appear in your issue feed. 1. Configure your environment (one-time). 2. Configure sources. 3. Configure destinations. 4. Configure pathways. 1. Configure your environment (one-time) To set up an environment in Incident Intelligence, you need an administrator to select a New Relic account for it. This account should be the one your team is using. Who sets the environment? Only administrators, and only for accounts where they have admin privileges.‚Äã Can administrators set more than one environment? They can set one environment per master account and its sub-accounts.‚Äã More than one can be set if an administrator has privileges for more than one master account. Need to change the environment's associated account? Reach out to your account executive or our support team for help. Incident Intelligence is a cross-account product. This means you can send in data from any New Relic account or external source to correlate events. 2. Configure sources After setting up your environment, determine your incident sources. These are your data inputs. You can get data from any of the following sources: Alerts By integrating Incident Intelligence with your alerts violations, you can get context and correlations from what you're monitoring. To get data from alerts: From one.newrelic.com, click Alerts & AI, then click Go to Incident Intelligence. Click Sources and then choose New Relic Alerts. Select the policies you want to connect to Applied Intelligence, and click Connect. You can add additional alerts policies or remove policies you've already connected in Sources > New Relic Alerts. Adding alerts as a source will not affect your current configuration or notifications. PagerDuty You can integrate Incident Intelligence directly with your PagerDuty services to ingest, process, and enhance all of your PagerDuty incidents. To get data from PagerDuty: Make sure your PagerDuty API key has write access. From one.newrelic.com, click Alerts & AI, then click Go to Incident Intelligence. Click Sources and then choose PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. You can add additional services or remove services you've already connected in Sources > PagerDuty. Connecting PagerDuty services to Applied Intelligence will not affect your current services or notifications. Splunk By integrating Incident Intelligence with your Splunk log monitoring, you can: Use your environment's log data for searches and key term reports. Correlate alerts and search reports with your other metrics and incidents. Applied Intelligence supports Splunk Light, Splunk Cloud, and Splunk Enterprise version 6.3 and higher. To get data from Splunk: In your Splunk console, start a search for the relevant events. Save your search as an alert, configure your alert conditions, and then choose the webhook as the delivery method. Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Sources, then click Splunk. Copy the collector URL, and paste it into the webhook endpoint in the Splunk console. Optional: Use Splunk tokens to enrich alert data with Splunk metadata. Splunk metadata To enrich alerts data with your Splunk metadata, use Splunk tokens. This helps you leverage your search data, which includes metadata and values from the first row of search results. If you want to... Do this... Access search data Use the format $<fieldname>$. For example, use $app$ for the app context for the search. Access field values To access field values from the first result row that a search returns, use the format $result.<fieldname>$. For example, use $result.host$ for the host value and $result.sourcetype$ for the source type. Use variables You can leverage any of the Selected fields in the Splunk search and add any unique fields to the Selected fields to make the data available as a variable. The following fields will automatically provide hints to the correlation engine: app: parsed as APPLICATION_NAME application:parsed as APPLICATION_NAME application_name: parsed as APPLICATION_NAME cluster: parsed as CLUSTER_NAME computer: parsed as HOST_NAME Dc: parsed as DATACENTER_NAME datacenter: parsed as DATACENTER_NAME host: parsed as HOST_NAME host_name: parsed as HOST_NAME hostname: parsed as HOST_NAME transaction: parsed as EVENT_ID Transaction_id: parsed as EVENT_ID user: parsed as USER_NAME Prometheus Alertmanager By integrating Incident Intelligence with Prometheus Alertmanager, you can receive and correlate your Prometheus alerts with events from other sources. To integrate Prometheus Alertmanager: Set up your Alertmanager configuration file by running: ./alertmanager -config.file=simple.yml Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Sources, then click Prometheus Alertmanager. Copy the Prometheus Alertmanager URL, and paste it into the <webhook_config>/url section of your Alertmanager config file. Reload the Prometheus Alertmanager configuration with one of the two methods: Send a SIGHUP to the process. Send an HTTP POST request to the /-/reload endpoint. Grafana You can integrate Incident Intelligence with Grafana's notifications for insight into events across your applications and environment. Grafana's webhook notification is a simple way to send information over HTTP to a custom endpoint. To integrate Grafana as a new webhook: Log into your Grafana portal using Admin permissions, and choose Alerting. On the Grafana Notification Channels page, click New Channel > Webhook. Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Sources, then click Grafana. Copy the URL, and paste it into your new Grafana webhook. AWS You can integrate Incident Intelligence with Amazon CloudWatch to provide incident management for all of your AWS services. To integrate Amazon CloudWatch: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Sources, then click ‚Äã‚Äã‚Äã‚Äã‚ÄãAmazon Web Services. Copy the URL. Create a new Amazon SNS topic. Set CloudWatch to forward all Alarms state changes to that topic: In the Amazon CloudWatch UI, click Events > Event Pattern. Select Service Name > CloudWatch. Select Event Type > CloudWatch Alarm State Change. Select Targets > SNS Topic, and select your new Amazon SNS topic. Create a new subscription: In the Amazon AWS UI, click Create a Subscription. Select your new Amazon SNS topic. Select Protocol > choose HTTPS. In Endpoint, paste the URL you previously copied from the Applied Intelligence Sources. REST API Incident Intelligence supports a dedicated REST API interface that lets you integrate with additional systems. The interface allows instrumentation of your code or other monitoring solutions to report any kind of metric or event. A metric can be a raw data point such as CPU, memory, disk utilization, or business KPI. An event can be a monitoring alert, deployment event, incident, exceptions or any other change in state that you want to describe. You can also send any type of data to Incident Intelligence straight from your own systems or applications. The REST API supports secure token-based authentication and accepts JSON content as input. For more information on authentication and the full API reference, see REST API for New Relic Applied Intelligence. 3. Configure destinations Now that you've set up your sources, you can configure your destinations. These are the data outputs where you view your incidents. You can set destinations using any of the following methods: Send data to PagerDuty Recommended: Create a new PagerDuty service to use as a destination. Because PagerDuty services can also be used as sources, this can help you distinguish your data input from your output. To create a PagerDuty destination: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. If you've configured a PagerDuty source with an API key, you can use the same key. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. When you're ready, you can add policies for one or more PagerDuty destinations. You can also transfer the policies over from your existing services or leave them as sources if needed. From the Destinations > PagerDuty page, you can also: Review the permissions for your services. Click Authorize when you're done. Add or delete existing services from the PagerDuty destination. Edit permissions for any service. To configure your PagerDuty destinations, use the following settings: Configuration setting Description Trigger new incidents Required. Trigger correlated parent incidents so you can identify issues faster. Edit incident titles Required. Alter your incident titles to help you orient and understand issues. Add new integrations Required. Add integrations to enable incident creation for selected services. Add webhook extensions Add webhook extensions to sync user actions in PagerDuty to New Relic. This lets you update the correlated issue state. Auto-resolve correlated incidents When enabled, this will resolve and automatically close correlated parent/child incidents. Select a user to take actions in PagerDuty You need to select a user before you can enable deep integration with PagerDuty. Once you do, the user can: Add notes to incidents (required): Incident notes are used to enrich incidents with context. Acknowledge triggered incidents: When enabled, Applied Intelligence will acknowledge and correlate newly triggered incidents in PagerDuty before you're notified. Use the original escalation policy: When enabled, the escalation policy of the source service will be applied to each incident. Send data via webhook Incident Intelligence will send the event body in JSON format by HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). To configure Incident Intelligence to send data via webhook: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click Webhook. Required: Configure the unique webhook key, used in Applied Intelligence to refer to this webhook configuration and its specific settings. Required: Configure the destination endpoint where the webhook payload will be sent. Optional steps: Configure custom headers, which are key:value pairs of headers to be sent with the request. Example: \"Authentication\" \"Bearer\" <bearer token> Configure a custom payload template that can be used to map New Relic fields to match the destination tool's expected name and format. Configure priority mapping (critical, high, medium, or low), used to map New Relic's priorities to the priorities expected at the destination. Send data to ServiceNow Using ServiceNow as a destination enables you to push valuable violation data into new ServiceNow incident tickets. To configure Incident Intelligence to send data to ServiceNow: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click ServiceNow. Required: Enter a channel name. This is used internally in Applied Intelligence to identify the destination (for example, in Pathways). Required: Enter your ServiceNow credentials: Team domain (This must be unique. No two destinations can have the same domain). Username Password Follow the two-way integration on screen instructions: Open and download this XML file. In the ServiceNow sidebar menu, go to System Definition > Business Rule. Click the menu icon in one of the column headers, select Import XML, and upload the XML file you downloaded. The two way integration will allow the ServiceNow incident to be updated with changes to the Applied Intelligence issue. Closing a ServiceNow incident will close its corresponding New Relic issue. When a New Relic issue is resolved, the corresponding ServiceNow incident will be closed. Custom notification message Applied Intelligence uses a templating framework called Jinja2 in the customization section interface. The Value field must be in valid Jinja syntax. By default, the interface populates a set of default fields in ServiceNow. When you add a custom field, enter the ServiceNow field name you want to use. By default, ServiceNow adds u_ to the beginning of its custom values. When mapping to ServiceNow attributes, use the Column label value. Please note that the name needs to be lowercase separated by underscores. Go here to see the custom notification message attribute descriptions. Go here to see Jinja2 Useful Syntax. For examples of destination templates, webhook formats, and JSON schema, see the Incident Intelligence destination examples. 4. Configure pathways To control when and where you want to receive notifications from your incidents, you can configure pathways. To add a pathway: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Pathways, then click Add a pathway. In the query builder box, select an attribute, such as application/name. This can be from the list of all attributes available in PagerDuty incidents and New Relic alerts violations, or you can add your own attributes. Select a logical operator. For example, contains. Enter a specific value to complete the logical expression. To include all issues created by your sources, select Send everything. (Use this if you only use one PagerDuty service to manage all incidents.) To build more complex logic, use the AND/OR operators. Select one or more of your destinations. To edit or remove existing pathways, mouse over the pathway's name on the Pathways page. Visual Timeline The visual timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels Each timeline can show you up to 10 incidents. In addition, you‚Äôll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related Activity The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. This section will show you the Last Update, the Source location, its State, the number of Related Events, and where it Originated. You can also copy the Payload or click on Analyze for more information. Issue Summary The issue page is built to first provide the user with bottom line insights to understand the problem and minimize the time needed to resolve it. The following outlines each of the four sections on the issue page: The Analysis Summary: the analysis summary has two machine learning modules, the golden signals and the related components. The Suggested Responder: the suggested responder will tell you who to potentially reach out to on your team to solve a specific problem. The Impacted Entities: an entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. The Label Sets: label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. All four of these sections can show up together for each issue or separately. It will vary based on the data in the issue. In addition to these four sections, you can also take a look at anomaly overview and entity overview directly from the issue feed. If you hover over an impacted entity application, you‚Äôll notice both call to actions: anomaly overview and entity overview. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. Finally, the issue page contains deployment events. APM‚Äôs Deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the Impacted Entities that have deployments. There are two types of deployment events: deployments and related deployments. Click ‚ÄúShow all deployments‚Äù, to see all your deployment events when they arrive. Click a specific deployment to see its APM deployments page. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions. Use suggested responders If you‚Äôre using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback‚Äã on the suggestions. Directly within PagerDuty (both UI and API.) If you‚Äôre also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. This feature doesn't account for on-call availability at the time of incident. In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users‚Äô contact details. EU and US datacenter and Incident Intelligence data New Relic's Incident Intelligence service is performed solely in the United States. By using New Relic Incident Intelligence, you agree that New Relic may move your data to, and process your data in, the US region. This applies whether you store your data in New Relic's US region data center or in our EU region data center. If you elect to use the Suggested Responder feature and manage EU-based individuals, you may need to confirm that an appropriate data processing agreement is in place. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.85855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Applied</em> intelligence",
        "category_0": "Alerts and <em>Applied</em> Intelligence",
        "category_1": "<em>Applied</em> intelligence",
        "body": ", which are key:value pairs of headers to be sent with the request. Example: &quot;Authentication&quot; &quot;Bearer&quot; &lt;bearer token&gt; Configure a <em>custom</em> payload template that can be used to <em>map</em> New Relic fields to match the destination tool&#x27;s expected name and format. Configure priority mapping (critical, high"
      },
      "id": "5f2ed76f64441f827856a9c1"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/p03-product-image/browser/products_browsers_features_browserloadtime_sept2020_thumb.png",
      "url": "https://newrelic.com/products/browser-monitoring/features",
      "sections": [
        "New Relic Browser features",
        "Full Support for Google‚Äôs Core Web Vitals",
        "User Centric Perceived Performance",
        "Single Page App Route Changes",
        "Session Traces",
        "Browser Traces",
        "Page Load Time - Segmentation Chart",
        "Page Load Time - Histogram and Percentiles",
        "Geographic Reporting",
        "Page-Level AJAX Calls",
        "Page View Throughput",
        "Connect Browser with Backend Performance",
        "JavaScript Error Summary",
        "Errors by Browser",
        "Percentage of Page Views with Errors",
        "Source Map Support",
        "Best-in-class Customer Experience Monitoring",
        "Browser Throughput",
        "Browser Load Time - Segmentation Chart",
        "Browser Version Chart",
        "Error Instance Details",
        "AJAX Dashboard",
        "Calls by Page View",
        "Request Status Codes",
        "Data Transfer Per Request",
        "Quickly View App Health",
        "Custom dashboards",
        "Integrate with your ticketing system",
        "Alerting",
        "Filterable Geography",
        "U.S. and EU Data Regions",
        "SOC2 Audited",
        "Secure Data Center",
        "Continuous Monitoring",
        "Secure by Default",
        "Compliance Friendly",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-01-31T03:20:06Z",
      "title": "New Relic Browser | New Relic",
      "updated_at": "2021-01-03T01:40:25Z",
      "type": "",
      "external_id": "b30121e0e2deb44e52a48d9a83ca4f854e2fb470",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon New Relic Browser Overview Features Resources New Relic Browser features Sign up for free Page Load Performance JavaScript Errors Browser Performance AJAX Global Features Security Page Load Performance New Relic Browser is the world‚Äôs most deployed Real User Monitoring (RUM) solution because it‚Äôs easy to use, and instantly connects end-user experience with time spent in backend services. From easy-to-understand overviews to user-centric perceived performance metrics and events, Browser helps you benchmark and improve web performance and troubleshoot across your full stack. Full Support for Google‚Äôs Core Web Vitals By adding Cumulative Layout Shift, a score measuring the impact of sudden unexpected shifts in layout due to content dynamically resizing, we now offer full support for all three of Google‚Äôs Core Web Vitals for web health. Use NRQL to create dashboards for all three measurements, definitions below: Largest Contentful Paint (LCP) - measures loading performance First Input Delay (FID) - measures interactivity Cumulative Layout Shift (CLS) - measures visual stability User Centric Perceived Performance Web performance teams can use more modern metrics than just page load time to benchmark and improve end-user experience for their dynamic pages. Browser helps developers understand how code impacts customers, answering key questions on page performance. Monitor how long users wait for content to display (paint metrics), how long until users can interact with our page (interactivity metrics), and how long until marquee content renders (largest contentful paint). (see blogpost for more) Single Page App Route Changes View Single Page Application route change performance, regardless of what JavaScript framework you use. Powerful low-level instrumentation can even capture interactions beyond the route change that can be customized via API, allowing monitoring tailored to the architecture of your application, such as for custom frameworks. Session Traces Session Traces provide one of the most valuable assets an engineer requires - context. Beyond identifying long load times, and specific errors, Browser Session Traces provide the story that occurred both before and after an error or performance issue. Pivot from AJAX requests and JavaScript errors into a Session Trace and conversely pivot from a Session Trace out to a specific JavaScript error or Network error. Browser Traces Traces are snapshots of one user‚Äôs experience, surfaced as an outlier due to a longer than average load time. It provides details around when it took place, a segmented breakdown of where load time was spent, browser type, and the user‚Äôs geographic location. This report is excellent when dissecting areas of your application which are performing poorly for specific users. Page Load Time - Segmentation Chart Page load times capture metrics from the moment a user begins a transaction in the browser until the page completes loading. The reports show average page load time broken down into color-coded segments for: Request queuing, application code, network latency, DOM processing, and Page rendering. Page Load Time - Histogram and Percentiles Histograms and percentiles of browser page load times provide a holistic view of the speed of page loads, one that is not focused on averages alone. Histograms and percentiles surface every page load that occurred during a specified time window, providing the ability to drill into outliers that might have been overlooked otherwise. Geographic Reporting Understand how your end users‚Äô experience with your site varies by geographical region. Identify if more CDN‚Äôs are required, or if high value customers in specific parts of the world are having a negative experience with your site‚Äôs performance. Page-Level AJAX Calls For a specific page, see all the AJAX calls being made as well as the response time, throughput (rpm), total number of calls, error status codes, and average data transfer made for each one. Page View Throughput Throughput is measured in requests per per minute. Throughput metrics help you understand which pages are being called most frequently. Connect Browser with Backend Performance From the Page views report, you can select single page URL and see all of the associated backend APM transactions (if you have the APM Agent installed in your application). Quickly view the total call time, average response time, and call count for any individual backend transaction. You can also dive deeper into a particular transaction and see diagnostics within our APM reports. JavaScript Errors The JavaScript error dashboards help you identify production JavaScript errors impacting your users' experiences and begin pinpointing how to resolve them. JavaScript Error Summary This summary view gives you a high level understanding of the types of JavaScript errors happening, the frequency at which they occur, and the percentage of users affected by the errors. Errors by Browser For each type of error, this chart shows you which browsers are being impacted by the error and the relative contribution it is making to your total error volume. Percentage of Page Views with Errors For each type of error, this chart shows you the percentage of page views affected by it. This allows you to quickly assess the reach and impact a particular error has on your end users. Source Map Support Troubleshoot minified production JavaScript code, with source map support giving you full visibility to where in your code the front-end error is. Intuitive drag-and-drop lets you locate issues in a click, while API integrations work seamlessly with your build pipeline. Best-in-class Customer Experience Monitoring Crash analysis in New Relic Mobile lets you analyze the most impactful crashes and fix them faster. Source map support in New Relic Browser gives you more actionable visibility into front-end JS errors by showing you exactly where in the original source the error occurred, even if your code is minified. Browser Performance New Relic's Browser dashboards provide information about your end users' experience based on browser type and version, so you can understand where to focus your time testing and optimizing for performance. Browser Throughput Provides a snapshot of the average number of pageviews received per minute broken down by browser type. Browser Load Time - Segmentation Chart For each type of browser, a segmented view of time spent on request queuing, application code, network latency, DOM processing, and Page rendering. Browser Version Chart Helps you understand which versions of each browser type your customers come from based on throughput. Error Instance Details Error Instance details grabs a snapshot of a single error and captures the stack trace details available from the browser, focusing on the actionable components, down to the line of code. These are metrics are combined with unique browser combinations down to the version level, and unique url. JavaScript diagnostics doesn't get more granular than this. AJAX If your applications use AJAX to update parts of a webpage after the initial page load, our AJAX dashboards will provide you with the level of visibility you need to understand how those requests are performing and ultimately affecting your users‚Äô experience. AJAX Dashboard The main AJAX dashboard surfaces your site‚Äôs most resource intensive AJAX requests, filterable by time consumption, response time, throughput, callback time, and data transfer. From here you can drill into a particular call for detailed analysis. Calls by Page View Shows which page views are calling a particular server side controller, with page level detail around throughput, response time, total number of calls, and data transfer. Request Status Codes The status codes reporting indicates the return behavior from an AJAX call. A large number of non-200 status codes may indicate a problem with your AJAX endpoints. Data Transfer Per Request This shows data transfer which is requested and sent. Use this to look for correlations between high callback times and data transfer rates. Global Features The following features are used throughout New Relic‚Äôs product suite to help make our products easier to use and fit seamlessly into your existing workflows. Quickly View App Health New Relic uses color coded status indicators throughout to help you quickly spot performance issues. Custom dashboards Keep an eye on your most critical performance metrics quickly by adding them to a custom dashboard. Integrate with your ticketing system File tickets related to performance problems directly into your ticketing system.¬†Learn which ticketing systems we support. Alerting Check out our new Alerts Features¬†for Browser that report on JS error %, response time, throughput and much more! Filterable Geography Understand how your end users‚Äô experience with your site varies by geographical region, down to the city level. Identify how a CDN or ASN/ Internet Service Provider is performing in different regions. Security New Relic is committed to helping customers make their applications fast and secure. We take protecting our customers' data seriously, here's an overview of how we do it. U.S. and EU Data Regions Our global data-hosting structure consists of two regions: European Union and United States. You can select your preferred data region during the account setup process, regardless of your physical location. (Note: We do not support migration or aggregation of data across regions.) SOC2 Audited New Relic has successfully completed a SOC 2 audit of processes and controls relevant to security and availability. This audit reviews our security process and controls and provides both ourselves, and more importantly our customers an independent, third-party assurance that we are taking the appropriate steps to protect our systems and our customer‚Äôs data. Secure Data Center The infrastructure that runs the New Relic service and stores our customer‚Äôs data resides in a Tier III, SSAE-16 certified data center. Customer data is backed up on a regular basis. Continuous Monitoring New Relic employs both internal and third-party services to perform continuous security scanning on both our network and applications to ensure that our applications and servers remain secure. Secure by Default We strongly believe in the concept of ‚Äúsecure by default‚Äù. Customers have to explicitly enable settings within New Relic to authorize the sending of sensitive data. We want to make sure that you are not accidentally exposing anything that you don‚Äôt want to. Compliance Friendly New Relic can be configured to operate securely in regulated environments such as PCI, HIPAA, or SOX. In addition we are Swiss and EU Privacy Shield certified. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.785675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Percentage of <em>Page</em> <em>Views</em> with Errors",
        "body": "), how long until users can interact with our <em>page</em> (interactivity metrics), and how long until marquee content renders (largest contentful paint). (see blogpost for more) Single <em>Page</em> <em>App</em> Route Changes <em>View</em> Single <em>Page</em> Application route change performance, regardless of what JavaScript framework you"
      },
      "id": "5c66a952b5b9e17d23a27084"
    },
    {
      "category_2": "Additional standard features",
      "nodeid": 1921,
      "sections": [
        "Browser monitoring",
        "Getting started",
        "Guides",
        "Installation",
        "Configuration",
        "Browser agent and SPA API",
        "Page load timing resources",
        "Browser Pro features",
        "Additional standard features",
        "Performance quality",
        "Troubleshooting",
        "Browser Geography: Webpage performance by location",
        "Contents",
        "View performance data by region",
        "Use page functions",
        "View drill-down details",
        "For more help"
      ],
      "title": "Browser Geography: Webpage performance by location",
      "category_0": "Browser monitoring",
      "type": "docs",
      "category_1": "Browser monitoring",
      "external_id": "ccbfe8376f2aee5d35b31dbcee84ff1cbff5b094",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/geo_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browser-geography-webpage-performance-location",
      "published_at": "2021-01-31T10:55:29Z",
      "updated_at": "2020-08-15T09:25:45Z",
      "breadcrumb": "Contents / Browser monitoring / Browser monitoring / Additional standard features",
      "document_type": "page",
      "popularity": 1,
      "info": "Browser's Geography feature shows color-coded Apdex scores and page load performance for your end users' experience around the world.",
      "body": "Browser monitoring's Geography page provides a world view with color-coded Apdex scores and other performance information about your end users' experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load performance and historical performance. Contents View performance data by region Firewalls may have an impact on the geographical data collected about your end users. To view or sort the performance information by location: one.newrelic.com > Browser > (select an app) > Geo: This page provides a world view and drill-down details of color-coded performance information for geographic locations. Go to one.newrelic.com > Browser > (select an app) > Geo > Global (for a world view). OR Go to one.newrelic.com > Browser > (select an app) > Geo > (select a location) (for a specific location you identified in the Browser application settings). To drill down to a specific area, select a location from the list, or select any area on the geographical map. To view additional details about the selected location, select the Page load performance or Historical performance links. To return to the main Geography page, select X (Close). one.newrelic.com > Browser > (select an app) > Geo > (select a location): If you selected specific locations from Settings > Application settings, the Geography page includes tabs to view their performance data directly. Use page functions Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Geography page: If you want to... Do this... Change how the performance data appears Select your choice from the Sort by menu. Adjust the amount of information that appears Select or clear the Hide <% throughput checkbox (<1% for global view, <2% for selected locations). View a map of a specific location Do any of these as applicable: Select the location's name from the Geo > Global list. Select its physical location on the map. If you have pre-selected the location from Application settings, select its tab. View summary performance information about a specific location Mouse over any colored area. View drill-down details After you select a specific location, the Page load performance page shows: Average page load time in seconds Number of page views and active sessions as pages per minute (ppm) Recent browser traces if applicable one.newrelic.com > Browser > (select an app) > Geo > (select a location): After you select a specific location, you can view specific details about Page load performance and Historical performance. In addition, the Historical performance page shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Response time Apdex Throughput in pages per minute (ppm) For more help Additional documentation resources include the Page views page (details about end users' overall experience with your site). If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.78349,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>View</em> performance data by <em>region</em>",
        "info": "Browser&#x27;s Geography feature shows color-coded Apdex scores and <em>page</em> load performance for your end users&#x27; experience around the world.",
        "body": " performance and historical performance. Contents <em>View</em> performance data by <em>region</em> Firewalls may have an impact on the geographical data collected about your end users. To <em>view</em> or sort the performance information by location: one.newrelic.com &gt; Browser &gt; (select an <em>app</em>) &gt; Geo: This <em>page</em> provides a world"
      },
      "id": "561c8bbc827a6617ad000172"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubscribe apps",
        "Handle duplicate applications",
        "This site uses cookies üç™"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2021-01-31T02:54:26Z",
      "updated_at": "2020-12-04T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. bash Copy $ nr1 update Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. bash Copy $ nr1 catalog:submit Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubscribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.15036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "sections": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "info": "Start sharing and using the <em>custom</em> New Relic One <em>apps</em> you build",
        "tags": "publish <em>apps</em>",
        "body": " Relic engineers to provide visualizations we think you&#x27;ll want, like Cloud Optimizer, which analyzes your cloud environment, or <em>PageView</em> <em>Map</em>, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via"
      },
      "id": "5efa999de7b9d283e67bab8f"
    }
  ],
  "/components/charts": [
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies üç™"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-01-31T02:57:34Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.24198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "category_2": "Measure DevOps success",
      "nodeid": 34966,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs",
        "For more help"
      ],
      "title": "Automate instrumentation",
      "category_0": "Solutions and best practices",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "91b25e8572d235c7f95963650848fc6ab6cf4b39",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation",
      "published_at": "2021-01-31T10:52:43Z",
      "updated_at": "2020-12-01T22:24:21Z",
      "breadcrumb": "Contents / Solutions and best practices / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Capture tangible, measurable metrics from before and after deployments to optimize your DevOps team. ",
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors‚Äîand more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.995445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ", the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "5f5e0c14196a67e25fce6a8a"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-01-31T02:53:24Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 63.758663,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic One <em>CLI</em> common commands",
        "sections": "<em>nr1</em> help",
        "info": "An overview of common commands you can use with the New Relic One <em>CLI</em>.",
        "body": " The name of a particular channel. Examples $ <em>nr1</em> update $ <em>nr1</em> update somechannel <em>nr1</em> create Create a new component Creates a new component from our template (either a <em>Nerdpack</em>, Nerdlet, launcher, or catalog). The <em>CLI</em> will walk you through this process. To learn more about Nerdpacks and their <em>file</em> <em>structure</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies üç™"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2021-01-31T02:53:23Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ nerdlets ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss ‚îú‚îÄ‚îÄ node_modules ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler ‚îú‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ package-lock.json ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 63.758663,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "sections": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "info": "An overview of the <em>Nerdpack</em> <em>File</em> <em>Structure</em>",
        "tags": "<em>file</em> <em>structure</em>",
        "body": " building guides and the New Relic One <em>CLI</em> command reference. <em>Nerdpack</em> <em>file</em> <em>structure</em> When you generate a <em>Nerdpack</em> template using the <em>nr1</em> create command, it has the following <em>file</em> <em>structure</em>: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <em>nr1</em>.json"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "category_2": "Get started",
      "nodeid": 2481,
      "sections": [
        "Welcome to New Relic",
        "Get started",
        "New Relic University",
        "Glossary",
        "For more help"
      ],
      "title": "Glossary",
      "category_0": "Using New Relic",
      "type": "docs",
      "category_1": "Welcome to New Relic",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/using-new-relic/welcome-new-relic/get-started/glossary",
      "external_id": "b6199b4bb822a19cf31503ffe077d8a13b3632b8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary",
      "published_at": "2021-01-31T06:53:21Z",
      "updated_at": "2020-12-05T21:35:35Z",
      "breadcrumb": "Contents / Using New Relic / Welcome to New Relic / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "This glossary defines common New Relic terminology, and provides links to relevant content to help better understand each subject.",
      "body": "A glossary of common terminology you may encounter. account dropdown When you're logged into New Relic, the account dropdown menu displays your login name and is located at the top right of the UI. Clicking this gives you access to various account-related abilities. administrator A type of user role on a New Relic account. For more information, see Users. agent At New Relic, an agent is a piece of monitoring software that provides integrations with various technologies (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent API Some New Relic agents have agent APIs that allow you to extend the functionality of an agent. You can use the API to control, customize and extend the functionality of the agent. Here are some agent API docs: APM agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API Browser agent: Browser agent API Mobile agents: iOS SDK API Android SDK API aggregated metrics Aggregated metric data summarizes calls to specific methods in your application, including how many times each one was called and response times. In the New Relic UI, you see the class and method names along with their aggregate numbers. Metric data aggregation depends on the New Relic tool and your subscription level. For more information, see the documentation about data retention. aggregation function You can use NRQL query function, such as sum(), average(), or latest() to choose how the data points in an aggregation window should be processed into a single data point. The single aggregated data point is what's passed through the alert evaluation process. aggregation window Streaming alerts gathers data together into specific amounts of time. These windows of time are customizable. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. alert An alert communicates an event or incident that designated personnel can track through Alerts. For an explanation of how basic alerts concepts are related, see Concepts and workflow. alert condition An alert condition (or condition), identified by its unique numeric condition_id, contains the criteria for creating a violation. The condition includes the threshold that is set for a metric timeslice or a custom metric over time on a chosen target. For an explanation of how a condition relates to other basic alerts concepts, see Concepts and workflow. alert evaluation Streaming data is assessed on a set of aggregation windows to determine if an alert condition is violating or recovering. The aggregation window time is how long we'll collect data before running the NRQL query condition. The offset evaluation time is how long you want us to wait for late data before assessing it. If a window doesn't have any data points, it's treated as a gap for loss of signal. alert policy A collection of one or more conditions, one or more notification channels, and an Incident preference setting. If a condition contained within the policy opens a violation, an incident may be opened depending on the Incident preference setting. Notifications will then be sent to all channels attached to the policy. For an explanation of how a policy relates to other basic alerts concepts, see Concepts and workflow. apdex Apdex is an industry-standard way to measure users' satisfaction with the response time of an application or service. New Relic rates each response as Satisfied, Tolerated, or Frustrated, and uses these ratings to calculate an overall user satisfaction score. For more information, see Apdex: Measure user satisfaction. apdex_f The response time above which a transaction are rated frustrating. Defaults to four times apdex_t. Requests that complete in less than apdex_t are rated satisfied. Requests that take longer than apdex_t, but less than four times apdex_t (apdex_f), are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. apdex_t The response time above which a transaction is considered tolerable. The default value is 0.5 seconds, but you can change this in your Apdex settings. Requests that complete in less than apdex_t are rated satisfied. Requests that take more than apdex_t, but less than apdex_f, are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic's APIs. APM New Relic's APM (application performance monitoring) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. application For New Relic purposes, any program instrumented by New Relic. application ID Some New Relic solutions assign a monitored application a unique application ID, often shortened to app ID. When present, this ID is available in the UI. It is also reported as an attribute and can be queried. For how to determine this, see Find app ID. application name The name that New Relic combines with your license key to uniquely identify a particular app. For more information, see Name your application. Applied Intelligence (AI) Applied Intelligence (AI) helps you find, troubleshoot, and resolve problems more quickly. Specifically, it‚Äôs a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. Applied Intelligence includes Alerts, Incident Intelligence, and Proactive Detection. attribute Attributes are key-value pairs attached to data objects reported to New Relic. Attributes add detail, and they're similar to tags or labels in other SaaS software. You can explore this data by querying or searching via the UI or by using the data dictionary. Examples: APM reports a Transaction event. This includes timing data for the transaction in a duration attribute, which might have a value of .002. Our Infrastructure Monitoring reports a ProcessSample event. This includes a variety of CPU usage attributes, including a cpuSystemPercent attribute, which might have a value of .01. Our Telemetry SDK reports a Metric data type for storing metrics, with attached attributes like metricName and newrelic.source. Some New Relic tools allow you to report custom attributes to enhance your monitoring. For more information about attributes in APM, see Agent attributes. availability monitoring See Types of Synthetics monitors. browser The New Relic UI supports most browsers. For more information, see Supported browsers. For our end-user browser monitoring tool, see Browser Monitoring. Browser monitoring A Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. background external See web external. cloud-based integration New Relic offers cloud-based integrations with providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects data from New Relic agents running on an app server, mobile device, or end-user browser. While the agent is installed on a user's app server, the collectors are centrally located in New Relic's data center. In order to contact the collector, the agent must be able to reach New Relic's domains and IP addresses. (The exact domain or IP depends on the New Relic monitoring tool.) The collector receives and interprets this data, and stores it in a database. The data is then retrieved and presented in the New Relic UI and by our various REST APIs. Command line interface (CLI) Our command line interface (CLI) is a tool you can use to build a New Relic application. This is the same tool our own engineers use. Go here for quick start instructions. Go to our Developer site for sample apps and guides. compute unit (CU) A unit of measurement that determines your pricing for some New Relic products governed by our original product-based pricing plan. For more information, see Compute unit pricing. condition_id See alert condition. CPM (calls per minute) The number of calls your application receives each minute. This usually corresponds to the number of page views or external connections, and is usually the same as RPM (requests per minute). CPU burn The time consumed by code minus the wait time for a transaction. This is the time actually spent processing the transaction. It appears in the New Relic UI at the top of the transaction view for the agents that provide it (Ruby and PHP only). custom attribute A key-value pair added to a transaction or event in order to gain additional information about it. For more information, see custom attributes. custom dashboard A customizable dashboard with charts and tables that includes data from multiple New Relic data sources. For more information, see dashboards. custom event An event, in New Relic terms, is a data object with attached attributes. New Relic reports default event types, like Transaction and TransactionError. You can also create your own events. Events can be queried, and are used in some other features. You can generate custom events with APM agents, with the Browser agent, with the Mobile agent, and via the Event API. Alternatively, you can add custom attributes to some existing default New Relic events. custom instrumentation Custom instrumentation allows you to extend New Relic's monitoring to instrument code elements New Relic doesn't automatically instrument. Custom instrumentation is useful when your framework is not supported by New Relic, or when New Relic fails to pick up some element of your program. You can also use custom instrumentation to block a transaction from being reported entirely. For more information, see Custom instrumentation. custom metric Metric timeslice data that is manually recorded via an API call. Custom metrics allow you to record arbitrary metrics; for example, timing or computer resource data. All custom metric names must be prefixed with Custom/. For more information, see Custom metrics. Not to be confused with custom instrumentation data. data collector See collector. data explorer Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. For more on using the data explorer, see Introduction to the data explorer. degradation period When a data source enters a violating state, a degradation period of time begins. The degradation period is set in the condition's threshold. A violation will open if the source stays in a violating state for the entire degradation period. In addition: If the data source enters a non-violating state before the entire time has elapsed, the degradation period countdown is reset, and a violation does not open. If your alert condition threshold is configured as at least once in, the degradation period always lasts a single minute. dimensional metric A dimensional metric is a metric that has multiple attributes, also known as dimensions. At New Relic, we report dimensional metrics using the Metric data type. For more on other metric data types, see Metric data. Docker An open platform for distributed applications, which allows you to assemble multi-container portable apps. Infrastructure Monitoring includes integrated Docker monitoring. For more information about Docker, see the Docker website. downtime The period of time when customers cannot access your site and your app is not reporting to New Relic. For more information, see Synthetic Monitoring and Types of synthetic monitors. entity In New Relic, an entity is anything we can identify that has data you can monitor. An entity can be something you monitor directly, like applications and microservices, or indirectly, like data centers. You can identify one or more entities to be targets for alert conditions. In the Alerts API, the entity being monitored is identified with an entity_id. For more on this, see What are entities? event The word event is a general term that can have many meanings. At New Relic, event can have several meanings: At New Relic, event data is one of our core data types. Event data represents a record of a single event at a particular moment in time. Events can vary by type (for example, Transaction or Mobile, and will have associated attributes (for example, timestamp or transactionName). For more details, see Event data. For our infrastructure monitoring, the word event can be used to refer to important system and host activity. For example, a configuration change for a monitored host would be registered on Infrastructure's Events UI page. For alerts, the Events UI page displays a list of alerts-related incidents for your monitored entities. Events are reported for a violation opening and for closing. In some contexts, event can refer to any NRQL-queryable data type. For example, when you run a NRQL query, you will see a count of inspected events: this refers to a count of all data types queried. expected error An expected error is a common error that you don't want to affect your Apdex score or error rate. For more information, see Manage errors in APM. exporter At New Relic, an exporter is a type of integration that reports telemetry data to New Relic from a third-party (non-New Relic) telemetry tool. For examples, see Exporters, or search our integrations. Flex New Relic Flex is an application-agnostic, all-in-one integration. With it, you can build your own integration that collects metric data from a wide variety of services, and that can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text) to the terminal. It's a recommended way to create a custom integration, because it doesn't require coding skills. framework A framework is a structured collection of pre-defined functions, into which an application builder inserts their own code to build their application. A framework is not the same as a library. While a library is a collection of functions you can call as needed, a framework is a skeleton for your application. The functions in that framework then call your functions. For more about the distinction between a framework and a library, see What is the difference between a framework and a library?. New Relic automatically instruments many common frameworks. For more about the frameworks New Relic supports, see the agent-specific documentation: C SDK supported frameworks Go supported frameworks Java supported frameworks .NET supported frameworks Node.js supported frameworks PHP supported frameworks Python supported frameworks Ruby supported frameworks Full-Stack Observability The collection of features and tools you can use to easily analyze and troubleshoot problems across your entire software stack. For more information, read our Introduction to Full-Stack Observability. harvest cycle The period of time between each connection from a New Relic agent to the collector. Between harvest cycles, an agent collects and caches data. At the end of the cycle an agent reports those data to the collector, then begins a new harvest cycle. health status indicator Some New Relic UI pages have a health status indicator appearing next to an index of monitored entities. This is a colored bar (generally green, yellow, red, or gray) indicating the status of your app or other entity monitored by New Relic. It also indicates whether the entity has any alert policies assigned to it and whether there are any policy violations. In general, the colored bar will be green, yellow, red, or gray to indicate the health status. Exceptions: Our REST API (v2) uses orange instead of yellow for the application's health and reporting status. Service maps use different criteria for reporting the health of a connection between an app and an external service not monitored by New Relic (for example, a third party API). host At New Relic, a host means one of the following: A physical machine is a hardware-based device with dedicated physical resources, including memory, processing, and storage. Each machine has its own OS which applications run on. A virtual machine (VM) is the software implementation of a physical machine that executes programs like a physical machine. One or more virtual machines can run on a physical machine. Each virtual machine has its own OS and allocated virtual machine resources such as RAM and CPU. A cloud instance is a type of virtual machine that is run in the public cloud. In this context, virtual machines and cloud instances are different from Java Virtual Machines (JVMs) and containers. host ID Each host identified by APM is assigned a host ID. This ID is used to uniquely identify it, and to retrieve data about that host via the REST API. For more information, see List host ID. ignored error An error that you have told the APM agent not to report to the collector. For more information, see Manage errors in APM. incident An incident is a collection of one or more violations of the conditions defined in an alert policy. An incident record includes all of the open and close time stamps for each violation, as well as chart snapshots of the data being evaluated around the time of each violation. You can view detailed information from the Incidents pages in the user interface. You can also select your preference for how we roll up violations into the incident. For an explanation of how an incident relates to other basic alerts concepts, see Concepts and workflow. Infrastructure Monitoring By connecting changes in host performance to changes in your configuration, Infrastructure Monitoring provides real-time metrics and powerful analytics that reduce your mean-time-to-resolution (MTTR). Infrastructure is specifically designed for complex environments that need flexible, dynamic server monitoring, from a physical datacenter to thousands of Amazon Elastic Compute Cloud (Amazon EC2) instances and other types of integrations. Insights At New Relic, Insights used to be the primary way to query and chart your New Relic-reported data. Now, we have the improved query builder. instance ID Each instance identified by New Relic is assigned a unique instance ID. Instance IDs are most commonly found for JVMs (Java Virtual Machines), but can exist for each agent. This ID is used to uniquely identify it, and to retrieve data about that instance via the REST API. For more information, see List instance IDs. instrumentation The collection of data from an application or host. When New Relic instruments a framework, it detects the methods and calls used by that framework, and intelligently groups them together. integration At New Relic, an integration refers to a solution that integrates with a specific technology (like a web framework or a type of database). See Integrations. interaction In our Mobile Monitoring, an interaction is a specific code path initiated by a user interaction (usually a button press). An interaction is the mobile equivalent of a transaction, and like a transaction an interaction can be traced and monitored. interaction trace An interaction trace is a complete picture of a single interaction. With interaction traces, New Relic gives you much deeper visibility into a single slow interaction, which can help you understand a broader problem. Interaction traces are the mobile equivalent of a transaction trace. For more information, see Creating interactions (iOS) and Creating interactions (Android). inventory data Inventory data is information about the status or configuration of a service or host. Examples of inventory data include: Configuration settings Name of the host the service is on Amazon AWS region Port being used For more information, see Understand and use data. key transaction A web transaction that the user has marked as particularly important; for example, key business events (such as signups or purchase confirmations), or transactions with a high performance impact (such as searches). Key transactions have their own pages in the UI and other customized values. For more information, see Key transactions. launcher A launcher is a specific piece of code you can include when you create a New Relic One app. It creates the tile on the homepage that you click to launch the app. For more information, see the documentation about core UI components. log A log is a message about a system used to understand the activity of the system and to diagnose problems. For more information on how we use log data, see Log management. Log monitoring Our log management and monitoring features give you the tools to collect, process, explore, visualize, and alert on your log data using your existing log forwarder. With all of your log data in one place, you'll be able to make better decisions, detect and resolve problems more quickly, and see your logs in context to troubleshoot faster. Logs Our Logs feature is a scalable log management platform that allows you to connect your log data with the rest of your telemetry data. Pre-built plugins with some of the most common open-source logging tools make it simple to send your data from anywhere to New Relic. Logs in context Logs in context makes it easy to link to your log data with related data across the rest of our platform. Bringing all of this data together in a single tool allows you to quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. master account A master account is a New Relic account that has one or more subordinate accounts (sub-accounts). For details, see Account structure. metric A metric is a numeric measurement. Metric data is a broad category because there are several ways to make and report measurements. For more about how metrics are reported at New Relic, see New Relic data types. metric timeslice New Relic reports metrics in several ways. One variety of metric data is called metric timeslice data; this is the type of data used to generate many of the charts in APM, Mobile Monitoring, and Browser Monitoring (for more details, see metric timeslice data). Over time, metric timeslice data is aggregated into longer timeslice data records for more efficient storage. For more about how we aggregate this type of data, see Data aggregation. For how to query this type of data, see Query metric timeslice data. metric grouping issue A metric grouping issue occurs when an account sends too many differently named metric timeslice data points to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. For more information, see Metric grouping issues. minion The software that accepts monitor jobs from a private location. A minion is a packaged virtual appliance that runs in your hypervisor. For more information, see Private locations overview and install and configure private minions. Mobile Monitoring Mobile Monitoring allows you to monitor and manage the performance of your mobile apps on Android, iOS, tvOS, and other systems. Mobile Monitoring provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with New Relic's own mobile apps for Android, iPhone, and iPad. monitor For our Synthetic Monitoring, a monitor ensures your website or API endpoint is available. For more information, see Adding and editing monitors. NerdGraph NerdGraph is our GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. You can use our NerdGraph GraphiQL explorer to explore the schema and find definitions. With valid New Relic API key, you can try it out yourself at https://api.newrelic.com/graphiql. Nerdlet A Nerdlet is a component of a New Relic One application. It's a specific UI view, represented by a React JavaScript package. For more information, see Nerdpack file structure. Nerdpack A Nerdpack is a component of a New Relic One application. It's the package containing all the files needed by that application. For more information, see Nerdpack file structure. New Relic Edge with Infinite Tracing New Relic Edge with Infinite Tracing is a fully managed, distributed tracing service that observes 100% of your application traces, then provides actionable data so you can solve issues faster. For more information, see /docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works. New Relic One For more information, see Introduction to New Relic One. New Relic One catalog Our catalog is a collection of applications built on the New Relic One platform. The catalog includes custom apps we've built, public open source apps, and any apps that you buid. You can browse the catalog on New Relic One. NRQL (New Relic query language) NRQL is a query language, similar in form to SQL, that allows you to query the data stored in your New Relic account. non-web transaction APM identifies transactions as either web or non-web. When New Relic does not detect a transaction was initiated by a web request, this is called a non-web transaction. For more information, see Background processes and other non-web transactions. notification The message sent when an incident opens, is acknowledged, or closes. The type of notification is defined by the alert policy's notification channel. For an explanation of how notifications relate to other basic alerts concepts, see Concepts and workflow. notification channel Where we send a notification when an incident opens, is acknowledged, or closes. Available channels include email, mobile push notifications, webhooks, and more. on-host integration On-host integrations refer to integrations that reside on your own servers or hosts and that communicate with our infrastructure agent. For more information, see Introduction to on-host integrations. owner For accounts on our original pricing plan, this is a type of user role: the user who initially created the account. For more information, see Users. page load timing With page load timing, New Relic monitors the full load time for end-user browsers. New Relic's application agents dynamically inject JavaScript into the page, then capture the following key load points: Navigation start: The user initiates the transaction. First byte: The browser receives the requested page. DOM ready: The browser has finished parsing DOM. Page ready: Page loading is complete. Page load timing is sometimes referred to as RUM, or real user monitoring. Unlike standard RUM, page load timing also captures JavaScript errors and AJAX requests. For more information, see Page load timing process. parameter Deprecated term; see attribute. permalink A unique URL that links to a view of your application at a specific point in time. Permalinks are useful for troubleshooting and for sharing interesting time windows with colleagues. pinger The component of New Relic that connects to your website to verify your website is accessible. New Relic has pingers in Europe, Asia, and the United States. Each pinger attempts to contact your website at least once every two minutes. If enough pingers are unable to reach your website, your application will be considered down. For in-depth scriptable testing, including real browser tests and tests of API endpoints, see Synthetic Monitoring. Synthetic Monitoring includes free ping monitoring, which allows you to monitor your website from locations around the world. For more information, see Types of Synthetic monitors. Plugins Plugins provides an open platform to monitor critical information about your entire stack. New Relic partners, PaAS and SaAS providers, third-party vendors, and plugin users can: Quickly install and use publicly available plugins in Plugin Central. Develop your own plugin agents to collect the metric data that matters most to your business. Publish your plugins for public or private access. polling interval (AWS) Our Amazon integrations query your AWS services according to a polling interval, which varies depending on the integration. Each polling interval occurs for every AWS entity. For example, if you have thirteen Elastic Load Balancers (ELB), each one will be polled every five minutes. Depending on the AWS integration, there may be delays in the timing between the API request and the metric data returned. If you notice unusual delays, follow the integration troubleshooting procedures. PPM (pages per minute) The number of pages per minute your application serves. private location A Synthetic monitor feature that allows you to run Synthetic monitors from within your own systems by creating private minions. Private locations allow you to extend your Synthetic coverage to new geographical locations, and to monitor websites behind your firewall such as an intranet site. For more information, see Private locations overview. recovery period A recovery period of time begins when a data source enters a non-violating state after being in a violating state. The recovery period is set in the condition's threshold. A violation will close when a source remains in a non-violating state and the recovery period time has elapsed. If the data source enters a violating state before the time has elapsed, the recovery period clock will reset and the violation won't close. response time The duration of time between a request for service and a response. For more information, see Response time. restricted user A type of user role on a New Relic account. For more information, see Users. rollup Using the same application name for multiple applications. This allows you to combine data in APM, either from multiple applications, or from multiple instances of an application. For more information, see Rolling up app data. root span For distributed tracing, the root span is the first span in a trace. In many cases, the root span duration will represent the duration of the entire trace, or be very close to it. However, for more complex, modern systems that use a lot of asynchronous, non-blocking processes, this will not be true. For those systems, the root span‚Äôs duration may be significantly less than the duration of the trace. RPM The term RPM usually refers to the number of requests per minute your application receives from users. This is usually the same as CPM (calls per minute). Historically, some New Relic monitoring solutions, like APM and Browser Monitoring, used to contain RPM in the URL; for example, https://rpm.newrelic.com. This language use originally referred to Rails performance management because the first iteration of our product monitored Ruby on Rails applications. We monitor many more languages and systems than Ruby now. RUM (real user monitoring) See page load timing. runbook A runbook contains standard procedures and operations typically used by system administrators, network operations staff, and other personnel to handle outages, alert incidents, and other situations. If your organization stores runbook instructions as URLs, you can link this information to an alerts policy so your personnel has easy access to this information when an incident violates the defined policy thresholds. SAML (Security Assertion Markup Language) SAML is an XML-based data format for sharing authentication data between two parties. New Relic accounts must obtain a SAML certificate in order to enable Single Sign On for their users. For more information, see SAML service providers. Selenium Selenium is an open-source browser testing suite. Synthetics uses Selenium to test monitored websites with real browsers. For more information, see monitor types. service A service is a cluster of runtime server processes that accomplish a particular task, usually service requests. Unlike an application, a service is not usually invoked by a human. New Relic offers a variety of integrations that allow you to report data from your services. signal The stream of telemetry data that's watched and alerted on. You use NRQL queries to define a signal. signal filter When we receive data and it's routed to the streaming alerts platform, your NRQL WHERE clause will filter the data coming in. The filtered streaming data is what's evaluated for loss of signal violations, for example. span In a distributed trace, a span is a \"named, timed operation representing a contiguous segment of work in that trace\" (from OpenTracing.io definition). For distributed tracing, spans are displayed in the distributed tracing UI, and the data type Span is available to be queried. See also root span. SSL certificate SSL certificates encrypt data that is being transmitted. While New Relic refers to security certificates as SSL because it is a more commonly used term, all certificates adhere to industry standards for secure encryption in transit. SSO (single sign on) SSO (single sign on) allows you to manage user authentication in New Relic using an external SSO provider. For more information, see Setting up SSO. streaming algorithm This is what determines when the data in an aggregation window is processed. The streaming algorithm uses your server's clock time and the aggregation window size to trigger the alert evaluation process. sub-accounts See master account. Synthetic monitoring Synthetic monitoring allows you to monitor your website or API endpoint via automated, scriptable tools. Use free ping monitor to ensure your website is accessible, or expand your monitoring with browser monitors, which test your website with real browsers. Go further with scripting, to script browsers or API monitors for sophisticated testing. target A target is a resource or component monitored by a New Relic monitoring tool that has been identified in an alert condition. When the data source for that target crosses the defined critical threshold, we will open a violation. Depending on your policy's Incident preference setting, Alerts may create an incident record and send notifications through the defined channels. See also entity. tag Tags are key:value metadata added to monitored apps, hosts, dashboards, and other entities to help you organize your data at a high level. For details, see Tags. Telemetry Data Platform The collection of features and tools you can use to ingest, visualize, and alert on all your telemetry data in one place. For more information, read the Introduction to the Telemetry Data Platform. thresholds Thresholds are alert condition settings that define a violation. Threshold values include the value a data source must pass to trigger a violation and the time-related settings that define a violation; for example: Passing a certain value for at least x minutes Passing a certain value only once in x minutes While the data source passes a certain value, a degradation period starts. Likewise, when that data source stops passing a certain value, a recovery period starts. The durations of these two time periods are defined in the alert condition threshold settings. Thresholds have a required critical (red) threshold and an optional warning (yellow) threshold. In the UI, the entity's health status indicator will change to yellow or red when a threshold has been crossed and a violation will open. For more information, see Define thresholds. For an explanation of how thresholds relate to other basic Alerts concepts, see Concepts and workflow. throughput Throughput is a measurement of user activity for a monitored application. APM throughput and Browser Monitoring throughput are measured in different ways: APM: requests per minute (RPM) Browser: page views per minute (PPM) tier A tier can refer to how New Relic categorizes or visualizes the various agent language ecosystems that we support. For example: In APM, the color-coded categories that appear on your app's main Overview chart show response time spent in various functions, processes, or agents as tiers; for example, request queuing, garbage collection, Middleware, JVMs, etc. In New Relic labels, TIER can be used to define or classify the client-server architecture; for example, front-end and back-end tiers. Tier may also refer to our pricing tiers. time picker By default the New Relic UI shows data for the past 30 minutes, ending now. To change the time window, use the time picker. time range A time range can refer to a length of time selected in the New Relic UI. New Relic displays a time range depending on the range you select using the time picker. timeslice data See metric timeslice data. trace A trace is a description of how a request travels through a system. Trace data helps you understand the performance of your system and diagnose problems. For more information on how we use trace data, see New Relic data types. traffic light See health status. transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. For more information, see documentation about web transactions and non-web transactions. The term transaction is also sometimes used in Browser Monitoring. In that case, it primarily refers to activity beginning with a browser-side web request and ending with a complete page load. transaction trace A transaction trace is a complete picture of a single transaction, down to the database queries and exact invocation patterns. With transaction traces, New Relic gives you much deeper visibility into a single slow transaction, which can help you understand a broader problem. For more information, see Transaction traces. UI The New Relic user interface. For more information, see Standard page functions. user A user can refer to a specific user role in a New Relic account. For more information, see Users. UTC Universal Time Coordinated (UTC), or Coordinated Universal Time, is a standard timestamp for synchronizing time around the world. value function (metrics) The numeric value obtained from metric timeslice data; for example, an average, minimum, maximum, total, sample size, etc. violation A violation occurs when the entity monitored by an alert condition reports a value that crosses the thresholds defined in that condition. For an explanation of how violations relate to other basic alerts concepts, see Concepts and workflow. You can view a summary of the violations for a selected incident's page. You can also view the violations for a specific entity from the product's UI. web external Web external is the term applied to the portion of time spent in transactions to external applications from within the code of the application you are monitoring. That time can be a call to a third party company (a payment provider, for example) or it could be a call to another microservice within your own company. Web external demonstrates how performance is impacted by your code executing outside the application you are measuring. web transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. Web transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. For more information, see Web transactions and Non-web transactions. WebDriverJS WebDriver is a Selenium component, used to control Synthetics scripted browsers. Specifically, Synthetics uses WebDriverJS, a Node.js-based flavor of Selenium. For more information, see Writing scripted browsers and Scripted browser examples. workload A workload represents a group of entities that work together to provide a digital service. For more information, see Workloads. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 26.799454,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " by a React JavaScript package. For more information, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. <em>Nerdpack</em> A <em>Nerdpack</em> is a component of a New Relic One application. It&#x27;s the package containing all the files needed by that application. For more information, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. New Relic Edge with Infinite"
      },
      "id": "5d0314cd4bb81c77f2eedaea"
    }
  ]
}