---
path: '/build-apps/ab-test/platform-state-context'
title: 'Add PlatformStateContext to your nerdlet'
template: 'GuideTemplate'
description: 'Add PlatformStateContext to your nerdlet'
---

In this course, you're building a New Relic One application. This application shows telemetry data from a demo service that is running an A/B test so that it can reveal that data in charts, like a dashboard. Your New Relic application is different than a dashboard, however, because it does more than show New Relic data. It pulls external data, provides UI components and functionality, and even has its own small data stores. The purpose of this New Relic application is to present context so you can better understand the A/B test results and how those results tie in to your business objectives.

So far, you've built all your charts, organized them for improved usability, provided them with real data, and more. There are some final improvements you can make, using Platform API components. In this lesson, you learn how to take use values in the New Relic platform state.

<Steps>

<Step>

Change to the `add-platform-state-context` directory of the course repository:

```sh
cd nru-programmability-course/add-platform-state-context
```

This directory contains the code that we expect your application to have at this point in the course. By navigating to the correct directory at the start of each lesson, you leave your custom code behind, thereby protecting yourself from carrying incorrect code from one lesson to the next.

</Step>

<Step>

Open your Nerdlet's index.js file. All code you write in this lesson belongs in this file.

</Step>

<Step>

Import `PlatformStateContext`:

```js
import { AccountStorageMutation, AccountStorageQuery, BlockText, Button, ChartGroup, Select, SelectItem, Spinner, Grid, GridItem, HeadingText, LineChart, Modal, NerdGraphQuery, NerdGraphMutation, PlatformStateContext, PieChart, TableChart, NrqlQuery, TextField } from 'nr1';
```

</Step>

<Step>

Add a `PlatformStateContext.Consumer` to your `NewsletterSignups` component's `.render()` method:

```js
<PlatformStateContext.Consumer>
    {
        (platformState) => {
            return <NrqlQuery
                accountId={ACCOUNT_ID}
                query="SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES"
                pollInterval={60000}
            >
                {
                    ({ data }) => {
                        return <LineChart data={data} fullWidth />;
                    }
                }
            </NrqlQuery>
        }
    }
</PlatformStateContext.Consumer>
```

`PlatformStateContext.Consumer` provides access to the platform's URL state. This state contains two important values for you to use in this context:

- accountId
- timeRange

Notice that `NrqlQuery` uses a constant called `ACCOUNT_ID`. Instead of hardcoding an account identifier in your nerdlet, you can use `accountId` from the platform URL state.

</Step>

<Step>

Use `platformState.accountId` in your `NrqlQuery`:

```js
<PlatformStateContext.Consumer>
    {
        (platformState) => {
            return <NrqlQuery
                accountId={platformState.accountId}
                query="SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES"
                pollInterval={60000}
            >
                {
                    ({ data }) => {
                        return <LineChart data={data} fullWidth />;
                    }
                }
            </NrqlQuery>
        }
    }
</PlatformStateContext.Consumer>
```

Next, notice that your query uses a `SINCE` clause, which identifies the historical timeframe your query should fetch data from.

</Step>

<Step>

Utilize platform state's `timeRange`:

```js
<PlatformStateContext.Consumer>
    {
        (platformState) => {
            return <NrqlQuery
                accountId={platformState.accountId}
                query="SELECT count(*) FROM subscription FACET page_version SINCE 30 MINUTES AGO TIMESERIES"
                timeRange={platformState.timeRange}
                pollInterval={60000}
            >
                {
                    ({ data }) => {
                        return <LineChart data={data} fullWidth />;
                    }
                }
            </NrqlQuery>
        }
    }
</PlatformStateContext.Consumer>
```

Now, `NewsletterSignups` uses `platformState.timeRange` instead of what's defined in your query's `SINCE` clause.

</Step>

<Step>

Navigate to the root of your Nerdpack at `nru-programmability-course/persist-selected-version/ab-test`.

</Step>

<Step>

Serve your application locally:

```sh
nr1 nerdpack:serve
```

</Step>

<Step>

[View your application](https://one.newrelic.com?nerdpacks=local):

![Your New Relic One application using platform state](../../../images/ab-test/platform-state.png)

Your `NrqlQuery` is now using the account ID, which it got from platform state. It's also using the platform state's time range, but your chart probably still shows the last 30 minutes. Why? Where does the `timeRange` in platform state come from?

The time picker sits on the right side of your application's navigation bar:

![Your New Relic One application's time picker](../../../images/ab-test/time-picker.png)

Change this value and see your chart update:

![Your New Relic One application showing the last 6 hours of data](../../../images/ab-test/time-picked.png)

</Step>

<Step>

Update `VersionAPageViews` and `VersionBPageViews`:

```js
<PlatformStateContext.Consumer>
    {
        (platformState) => {
            return <NrqlQuery
                accountId={platformState.accountId}
                query="SELECT count(*) FROM pageView WHERE page_version = 'a' SINCE 30 MINUTES AGO TIMESERIES"
                timeRange={platformState.timeRange}
                pollInterval={60000}
            >
                {
                    ({ data }) => {
                        return <LineChart data={data} fullWidth />;
                    }
                }
            </NrqlQuery>
        }
    }
</PlatformStateContext.Consumer>

<PlatformStateContext.Consumer>
    {
        (platformState) => {
            return <NrqlQuery
                accountId={platformState.accountId}
                query="SELECT count(*) FROM pageView WHERE page_version = 'b' SINCE 30 MINUTES AGO TIMESERIES"
                timeRange={platformState.timeRange}
                pollInterval={60000}
            >
                {
                    ({ data }) => {
                        return <LineChart data={data} fullWidth />;
                    }
                }
            </NrqlQuery>
        }
    }
</PlatformStateContext.Consumer>
```

Of all the charts in your New Relic One application, these three charts are the ones that should update with the time picker. The others, **Total subscriptions per version**, **Total cancellations per version**, **Version A - Page views vs. subscriptions**, **Version B - Page views vs. subscriptions**, show total values over time. So, hardcoding their `SINCE` clauses to `7 DAYS AGO` makes sense, as this is a reasonable time period for the purposes of this course.

</Step>

<Step>

While still serving your nerdpack locally, view your NR1 app to see your charts updating with the time range you choose:

![Your charts showing your selected time period](../../../images/ab-test/page-views-time-range.png)

When you're finished, stop serving your New Relic One application by pressing `CTRL+C` in the terminal window where you're serving your application.

</Step>

</Steps>

Now that you're basing your queries off the platform state, some of your charts are dynamic in their time ranges. This is a great improvement because it allows you to adjust your charts to show data from any particular point in time, which is useful for tying data to business outcomes.

The Platform API components offer a lot more functionality, too, including the ability to navigate the user to another place in New Relic. You'll learn how to do this in the next lesson.